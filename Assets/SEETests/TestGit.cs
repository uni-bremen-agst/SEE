using LibGit2Sharp;
using NUnit.Framework;
using SEE.Utils;
using System.IO;
using System.Linq;
using UnityEngine;

namespace SEE.VCS
{
    /// <summary>
    /// Exploration tests for <see cref="LibGit2Sharp"/>.
    /// </summary>
    /// <remarks>These are not really tests, but rather a playground to
    /// explore the API of <see cref="LibGit2Sharp"/>.</remarks>
    [Category("SkipOnCI")]
    internal class TestGit : TestGitRepository
    {
        // For more examples of using LibGit2Sharp, see:
        //   https://github.com/libgit2/libgit2sharp/blob/master/LibGit2Sharp.Tests/

        /// <summary>
        /// Represents information to access a Git repository, including its URL and access token.
        /// </summary>
        /// <remarks>This type is used to encapsulate the essential details required to interact with a
        /// Git repository. The <see cref="Url"/> property specifies the repository's location, while the <see
        /// cref="AccessToken"/>  provides the access token necessary for authentication.
        /// The latter should be should be a token generated by GitHub's
        /// "settings->developer settings"</remarks>
        private record RepositoryInfo(string Url, string AccessToken)
        {
            /// <summary>
            /// Returns the <cref name="Url"/> with the added <cref ="AccessToken"/>.
            ///
            /// For instance, AddToken("https://github.com/koschke/TestProjectForSEE.git", "mytoken")
            /// yields "https://mytoken@github.com/koschke/TestProjectForSEE.git".
            /// </summary>
            /// <returns><paramref name="repositoryUrl"/> where <paramref name="accessToken"/> has
            /// been added</returns>
            public string AddToken => Url.Replace("https://", $"https://{AccessToken}@");
        }

        /// <summary>
        /// A private repository on GitHub used for testing purposes.
        /// </summary>
        private static readonly RepositoryInfo TestRepo =
            new(testRepositoryUrl, testRepositoryAccessToken);

        /// <summary>
        /// Make sure that an access token for <see cref="TestRepo"/> has been provided.
        /// </summary>
        [SetUp]
        public static void Setup()
        {
            if (string.IsNullOrWhiteSpace(TestRepo.AccessToken))
            {
                Assert.Inconclusive($"No access token provided. Please add your GitHub access token to the {nameof(TestRepo)} definition in {nameof(TestGit)} to run the tests.");
            }
        }

        /// <summary>
        /// This test shows how to set up a credential provider for LibGit2Sharp.
        /// </summary>
        [Test]
        public void TestCredentialProvider()
        {
            string localRepoPath = LocalPath(TestRepo.Url);
            DeleteDirectoryIfItExists(localRepoPath);

            try
            {
                CloneOptions options = new();

                options.FetchOptions.CredentialsProvider = (_url, _user, _types) =>
                        new UsernamePasswordCredentials
                        {
                            Username = TestRepo.AccessToken,
                            Password = string.Empty
                        };

                Repository.Clone(TestRepo.Url, localRepoPath, options);
                // Exists and is not empty.
                Assert.IsTrue(Directory.Exists(localRepoPath)
                    && Directory.EnumerateFileSystemEntries(localRepoPath).Any());
            }
            catch (LibGit2SharpException)
            {
                throw;
            }
            finally
            {
                DeleteDirectoryIfItExists(localRepoPath);
            }
        }

        [Test]
        public void TestCloneTestRepo()
        {
            TestCloneRepo(TestRepo);
        }

        /// <summary>
        /// Clones a repository described by <paramref name="repositoryInfo"/>.
        /// </summary>
        /// <param name="repositoryInfo"></param>
        private static void TestCloneRepo(RepositoryInfo repositoryInfo)
        {
            string localRepoPath = LocalPath(repositoryInfo.Url);
            try
            {
                Repository.Clone(repositoryInfo.AddToken, localRepoPath, new CloneOptions());
            }
            catch (LibGit2SharpException)
            {
                throw;
            }
            finally
            {
                DeleteDirectoryIfItExists(localRepoPath);
            }
        }

        [Test]
        public void TestCloneAndFetchTestRepo()
        {
            TestCloneAndFetchRepo(TestRepo, true);
        }

        /// <summary>
        /// Clones and fetches a GitHub repository described by <paramref name="repositoryInfo"/>.
        /// </summary>
        /// <param name="repositoryInfo">information about the repository to be cloned and fetched</param>
        /// <param name="cloneFirst">if true, the repository will be cloned first and deleted
        /// after the test; if false, it is assumed that the repository has already been cloned
        /// and the repository will not be deleted</param>
        private static void TestCloneAndFetchRepo(RepositoryInfo repositoryInfo, bool cloneFirst)
        {
            string localRepoPath = LocalPath(repositoryInfo.Url);
            if (cloneFirst)
            {
                DeleteDirectoryIfItExists(localRepoPath);
            }

            try
            {
                // First clone the repository, then fetch.
                if (cloneFirst)
                {
                    Repository.Clone(repositoryInfo.AddToken, localRepoPath, new CloneOptions());
                }

                using Repository repo = new(localRepoPath);

                // Find the remote named "origin".
                Remote remote = repo.Network.Remotes["origin"];

                // Fetch the changes from the remote.
                // A refspec specifies the mapping between remote and local reference names when
                // fetching or pushing. Passing null or an empty array means to use the base refspecs.
                // Passing null as the log message means to use the default message "fetch".
                Commands.Fetch(repo, remote.Name, new string[] { }, new FetchOptions(), null);
                // Fetch downloads new commits from the remote repository. These commits are stored
                // locally but are not integrated into the working directory or local branches.
                // They reside on remote-tracking branches (remotes/origin/main).

                foreach (Branch currentBranch in repo.Branches.Where(b => !b.IsRemote))
                {
                    if (HasChangesToPull(repo, currentBranch))
                    {
                        Debug.Log($"Your branch {currentBranch.FriendlyName} has new changes to pull!\n");
                    }
                    else
                    {
                        Debug.Log($"Your branch {currentBranch.FriendlyName} is up to date with the remote.");
                    }
                }
            }
            catch (LibGit2SharpException)
            {
                throw;
            }
            finally
            {
                if (cloneFirst)
                {
                    DeleteDirectoryIfItExists(localRepoPath);
                }
            }
        }

        private static bool HasChangesToPull(Repository repo, Branch localBranch)
        {
            // Get the remote-tracking branch for localBranch.
            Branch remoteBranch = repo.Branches[localBranch.TrackedBranch.FriendlyName];

            if (remoteBranch == null)
            {
                // The local branch is not configured to track a remote branch.
                return false;
            }

            // Determine the commits on the remote branch that are not in the local branch.
            ICommitLog commitLog = repo.Commits.QueryBy(new CommitFilter
            {
                IncludeReachableFrom = remoteBranch.Tip,
                ExcludeReachableFrom = localBranch.Tip
            });

            int aheadBy = commitLog.Count();

            // If the count is greater than zero, there are changes to pull.
            return aheadBy > 0;
        }
    }
}
