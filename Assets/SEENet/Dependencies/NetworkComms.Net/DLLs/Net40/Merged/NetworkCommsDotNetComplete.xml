<?xml version="1.0"?>
<doc>
  <assembly>
    <name>NetworkCommsDotNetComplete</name>
  </assembly>
  <members>
    <member name="T:NetworkCommsDotNet.ConnectionState">
      <summary>
            Describes the current state of the connection
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.ConnectionState.Undefined">
      <summary>
            The state of this connection is undefined. This is the starting state of new connections.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.ConnectionState.Establishing">
      <summary>
            The connection is in the process of being established/initialised.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.ConnectionState.Established">
      <summary>
            The connection has been successfully established.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.ConnectionState.Shutdown">
      <summary>
            The connection has been shutdown.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.DPSBase.IExplicitlySerialize">
      <summary>
            Interface defining serialize/deserialize methods 
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.IExplicitlySerialize.Serialize(System.IO.Stream)">
      <summary>
            Serializes the current <see cref="T:NetworkCommsDotNet.DPSBase.IExplicitlySerialize" /> object to the provided <see cref="T:System.IO.Stream" /></summary>
      <param name="outputStream">The stream to serialize to</param>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.IExplicitlySerialize.Deserialize(System.IO.Stream)">
      <summary>
            Deserializes from a <see cref="T:System.IO.Stream" /> to the current <see cref="T:NetworkCommsDotNet.DPSBase.IExplicitlySerialize" /> object
            </summary>
      <param name="inputStream">The <see cref="T:System.IO.Stream" /> to deserialize from</param>
    </member>
    <member name="T:NetworkCommsDotNet.ConnectionInfo">
      <summary>
            Contains any information related to the configuration of a <see cref="T:NetworkCommsDotNet.Connections.Connection" /> object.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.ConnectionInfo.NetworkIdentifierStr">
      <summary>
            We store our unique peer identifier as a string so that it can be easily serialised.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.#ctor">
      <summary>
            Private constructor required for deserialisation.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.#ctor(System.Net.EndPoint)">
      <summary>
            Create a new ConnectionInfo object pointing at the provided remote <see cref="T:System.Net.IPEndPoint" />.
            Uses the custom NetworkComms.Net application layer protocol.
            </summary>
      <param name="remoteEndPoint">The end point corresponding with the remote target</param>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.#ctor(System.Net.EndPoint,NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus)">
      <summary>
            Create a new ConnectionInfo object pointing at the provided remote <see cref="T:System.Net.IPEndPoint" /></summary>
      <param name="remoteEndPoint">The end point corresponding with the remote target</param>
      <param name="applicationLayerProtocol">If enabled NetworkComms.Net uses a custom 
            application layer protocol to provide useful features such as inline serialisation, 
            transparent packet transmission, remote peer handshake and information etc. We strongly 
            recommend you enable the NetworkComms.Net application layer protocol.</param>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.#ctor(System.String,System.Int32)">
      <summary>
            Create a new ConnectionInfo object pointing at the provided remote ipAddress and port. 
            Provided ipAddress and port are parsed in to <see cref="P:NetworkCommsDotNet.ConnectionInfo.RemoteEndPoint" />. Uses the 
            custom NetworkComms.Net application layer protocol.
            </summary>
      <param name="remoteIPAddress">IP address of the remote target in string format, e.g. "192.168.0.1"</param>
      <param name="remotePort">The available port of the remote target. 
            Valid ports are 1 through 65535. Port numbers less than 256 are reserved for well-known services (like HTTP on port 80) and port numbers less than 1024 generally require admin access</param>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.#ctor(System.String,System.Int32,NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus)">
      <summary>
            Create a new ConnectionInfo object pointing at the provided remote ipAddress and port. 
            Provided ipAddress and port are parsed in to <see cref="P:NetworkCommsDotNet.ConnectionInfo.RemoteEndPoint" />.
            </summary>
      <param name="remoteIPAddress">IP address of the remote target in string format, e.g. "192.168.0.1"</param>
      <param name="remotePort">The available port of the remote target. 
            Valid ports are 1 through 65535. Port numbers less than 256 are reserved for well-known services (like HTTP on port 80) and port numbers less than 1024 generally require admin access</param>
      <param name="applicationLayerProtocol">If enabled NetworkComms.Net uses a custom 
            application layer protocol to provide useful features such as inline serialisation, 
            transparent packet transmission, remote peer handshake and information etc. We strongly 
            recommend you enable the NetworkComms.Net application layer protocol.</param>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.#ctor(NetworkCommsDotNet.Connections.ConnectionType,NetworkCommsDotNet.Tools.ShortGuid,System.Net.EndPoint,System.Boolean)">
      <summary>
            Create a connectionInfo object which can be used to inform a remote peer of local connectivity.
            Uses the custom NetworkComms.Net application layer protocol.
            </summary>
      <param name="connectionType">The type of connection</param>
      <param name="localNetworkIdentifier">The local network identifier</param>
      <param name="localEndPoint">The localEndPoint which should be referenced remotely</param>
      <param name="isConnectable">True if connectable on provided localEndPoint</param>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.#ctor(NetworkCommsDotNet.Connections.ConnectionType,NetworkCommsDotNet.Tools.ShortGuid,System.Net.EndPoint,System.Boolean,NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus)">
      <summary>
            Create a connectionInfo object which can be used to inform a remote peer of local connectivity
            </summary>
      <param name="connectionType">The type of connection</param>
      <param name="localNetworkIdentifier">The local network identifier</param>
      <param name="localEndPoint">The localEndPoint which should be referenced remotely</param>
      <param name="isConnectable">True if connectable on provided localEndPoint</param>
      <param name="applicationLayerProtocol">If enabled NetworkComms.Net uses a custom 
            application layer protocol to provide useful features such as inline serialisation, 
            transparent packet transmission, remote peer handshake and information etc. We strongly 
            recommend you enable the NetworkComms.Net application layer protocol.</param>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.#ctor(NetworkCommsDotNet.Connections.ConnectionType,System.Net.EndPoint,System.Net.EndPoint,NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus,NetworkCommsDotNet.Connections.ConnectionListenerBase)">
      <summary>
            Create a connectionInfo object for a new connection.
            </summary>
      <param name="connectionType">The type of connection</param>
      <param name="remoteEndPoint">The remoteEndPoint of this connection</param>
      <param name="localEndPoint">The localEndpoint of this connection</param>
      <param name="applicationLayerProtocol">If enabled NetworkComms.Net uses a custom 
            application layer protocol to provide useful features such as inline serialisation, 
            transparent packet transmission, remote peer handshake and information etc. We strongly 
            recommend you enable the NetworkComms.Net application layer protocol.</param>
      <param name="connectionListener">The listener associated with this connection if server side</param>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.NoteStartConnectionEstablish">
      <summary>
            Marks the connection as establishing
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.NoteCompleteConnectionEstablish">
      <summary>
            Set this connectionInfo as established.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.NoteConnectionShutdown">
      <summary>
            Note this connection as shutdown
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.UpdateLocalEndPointInfo(System.Net.EndPoint)">
      <summary>
            Update the localEndPoint information for this connection
            </summary>
      <param name="localEndPoint">
      </param>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.UpdateInfoAfterRemoteHandshake(NetworkCommsDotNet.ConnectionInfo,System.Net.EndPoint)">
      <summary>
            During a connection handShake we might be provided with more update information regarding endPoints, connectability and identifiers
            </summary>
      <param name="handshakeInfo">
        <see cref="T:NetworkCommsDotNet.ConnectionInfo" /> provided by remoteEndPoint during connection handshake.</param>
      <param name="remoteEndPoint">The correct remoteEndPoint of this connection.</param>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.UpdateLastTrafficTime">
      <summary>
            Updates the last traffic time for this connection
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.ResetNetworkIdentifer(NetworkCommsDotNet.Tools.ShortGuid)">
      <summary>
            Replaces the current networkIdentifier with that provided
            </summary>
      <param name="networkIdentifier">The new networkIdentifier for this connectionInfo</param>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.ResetConnectionInfo">
      <summary>
            A connectionInfo object may be used across multiple connection sessions, i.e. due to a possible timeout. 
            This method resets the state of the connectionInfo object so that it may be reused.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.Equals(System.Object)">
      <summary>
            Compares this <see cref="T:NetworkCommsDotNet.ConnectionInfo" /> object with obj and returns true if obj is ConnectionInfo and both 
            the <see cref="P:NetworkCommsDotNet.ConnectionInfo.NetworkIdentifier" /> and <see cref="P:NetworkCommsDotNet.ConnectionInfo.RemoteEndPoint" /> match.
            </summary>
      <param name="obj">The object to test of equality</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.Equals(NetworkCommsDotNet.ConnectionInfo)">
      <summary>
            Compares this <see cref="T:NetworkCommsDotNet.ConnectionInfo" /> object with other and returns true if both the <see cref="P:NetworkCommsDotNet.ConnectionInfo.NetworkIdentifier" /> 
            and <see cref="P:NetworkCommsDotNet.ConnectionInfo.RemoteEndPoint" /> match.
            </summary>
      <param name="other">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.op_Equality(NetworkCommsDotNet.ConnectionInfo,NetworkCommsDotNet.ConnectionInfo)">
      <summary>
            Returns left.Equals(right)
            </summary>
      <param name="left">Left connectionInfo</param>
      <param name="right">Right connectionInfo</param>
      <returns>True if both are equal, otherwise false</returns>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.op_Inequality(NetworkCommsDotNet.ConnectionInfo,NetworkCommsDotNet.ConnectionInfo)">
      <summary>
            Returns !left.Equals(right)
            </summary>
      <param name="left">Left connectionInfo</param>
      <param name="right">Right connectionInfo</param>
      <returns>True if both are different, otherwise false</returns>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.GetHashCode">
      <summary>
            Returns NetworkIdentifier.GetHashCode() ^ RemoteEndPoint.GetHashCode();
            </summary>
      <returns>The hashcode for this connection info</returns>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.ToString">
      <summary>
            Returns a string containing suitable information about this connection
            </summary>
      <returns>A string containing suitable information about this connection</returns>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.Serialize(System.IO.Stream)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.Deserialize(System.IO.Stream)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionInfo.Deserialize(System.IO.MemoryStream,NetworkCommsDotNet.ConnectionInfo@)">
      <summary>
            Deserializes from a memory stream to a <see cref="T:NetworkCommsDotNet.ConnectionInfo" /> object
            </summary>
      <param name="ms">The memory stream containing the serialized <see cref="T:NetworkCommsDotNet.ConnectionInfo" /></param>
      <param name="result">The deserialized <see cref="T:NetworkCommsDotNet.ConnectionInfo" /></param>
    </member>
    <member name="P:NetworkCommsDotNet.ConnectionInfo.ConnectionType">
      <summary>
            The type of this connection
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.ConnectionInfo.IsConnectable">
      <summary>
            True if the <see cref="P:NetworkCommsDotNet.ConnectionInfo.RemoteEndPoint" /> is connectable.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.ConnectionInfo.ConnectionCreationTime">
      <summary>
            The DateTime corresponding to the creation time of this connection object
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.ConnectionInfo.ServerSide">
      <summary>
            True if connection was originally established by remote
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.ConnectionInfo.ConnectionListener">
      <summary>
            If this connection is <see cref="P:NetworkCommsDotNet.ConnectionInfo.ServerSide" /> references the listener that was used.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.ConnectionInfo.ConnectionEstablishedTime">
      <summary>
            The DateTime corresponding to the creation time of this connection object
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.ConnectionInfo.LocalEndPoint">
      <summary>
            The <see cref="T:System.Net.EndPoint" /> corresponding to the local end of this connection.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.ConnectionInfo.RemoteEndPoint">
      <summary>
            The <see cref="T:System.Net.EndPoint" /> corresponding to the local end of this connection.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.ConnectionInfo.ConnectionState">
      <summary>
            Describes the current state of the connection
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.ConnectionInfo.NetworkIdentifier">
      <summary>
            Returns the networkIdentifier of this peer as a ShortGuid. If the NetworkIdentifier has not yet been set returns ShortGuid.Empty.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.ConnectionInfo.LastTrafficTime">
      <summary>
            The DateTime corresponding to the time data was sent or received
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.ConnectionInfo.ApplicationLayerProtocol">
      <summary>
            If enabled NetworkComms.Net uses a custom application layer protocol to provide 
            useful features such as inline serialisation, transparent packet transmission, 
            remote peer information etc. Default: ApplicationLayerProtocolStatus.Enabled
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.ConnectionInfo.LocalIPEndPoint">
      <summary>
            The localEndPoint cast as <see cref="T:System.Net.IPEndPoint" />.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.ConnectionInfo.RemoteIPEndPoint">
      <summary>
            The remoteEndPoint cast as <see cref="T:System.Net.IPEndPoint" />.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.ConnectionInfo.LocalBTEndPoint">
      <summary>
            The localEndPoint cast as <see cref="T:System.Net.IPEndPoint" />.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.ConnectionInfo.RemoteBTEndPoint">
      <summary>
            The remoteEndPoint cast as <see cref="T:System.Net.IPEndPoint" />.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Connections.Connection">
      <summary>
            Global connection base class for NetworkComms.Net. Most user interactions happen using a connection object. 
            Extended by <see cref="T:NetworkCommsDotNet.Connections.TCP.TCPConnection" />, <see cref="T:NetworkCommsDotNet.Connections.UDP.UDPConnection" /> and <see cref="T:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection" />.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.Connection.connectionSetupWait">
      <summary>
            A manual reset event which can be used to handle connection setup and establish.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.Connection.connectionEstablishWait">
      <summary>
            A manual reset event which can be used to handle connection setup and establish.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.Connection.connectionSetupException">
      <summary>
            A boolean used to signal a connection setup exception.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.Connection.connectionSetupExceptionStr">
      <summary>
            If <see cref="F:NetworkCommsDotNet.Connections.Connection.connectionSetupException" /> is true provides additional exception information.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.Connection._syncRoot">
      <summary>
            Thread safety locker which is used when accessing <see cref="F:NetworkCommsDotNet.Connections.Connection.incomingPacketHandlers" />, 
            <see cref="F:NetworkCommsDotNet.Connections.Connection.incomingPacketUnwrappers" /> and <see cref="P:NetworkCommsDotNet.Connections.Connection.ConnectionSpecificShutdownDelegate" />.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.Connection.incomingPacketUnwrappers">
      <summary>
            By default all incoming objects are handled using ConnectionDefaultSendReceiveOptions. Should the user want something else
            those settings are stored here
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.Connection.incomingPacketHandlers">
      <summary>
            A connection specific incoming packet handler dictionary. These are called before any global handlers
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.Connection.packetBuilder">
      <summary>
            The <see cref="T:NetworkCommsDotNet.Tools.PacketBuilder" /> for this connection
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.Connection.totalBytesRead">
      <summary>
            The total bytes read so far within dataBuffer
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.Connection.incomingDataListenThread">
      <summary>
            The thread listening for incoming data should we be using synchronous methods.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.Connection.asyncListenStarted">
      <summary>
            True if async listen has started
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.Connection.asyncListenerInRead">
      <summary>
            True if the async listen method is in a beginRead
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.Connection.listenersDict">
      <summary>
            All connection listeners are recorded in the static connection base.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.Connection.sendLocker">
      <summary>
            Lockers for maintaining thread safe operation
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.Connection.SendTimesMSPerKBCache">
      <summary>
            A NetworkComms.Net math object for tracking send times. Used to prevent send deadlocks.
            Initialised at 1000 milliseconds per KB write speed, corresponding with 1KB / second.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.Connection.packetSequenceCounter">
      <summary>
            A counter which is incremented during every a send. The current value is included in the header of all sent packets.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.Connection.sentPacketsLocker">
      <summary>
            Maintains a list of sent packets for the purpose of confirmation and possible resends.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.#ctor(NetworkCommsDotNet.ConnectionInfo,NetworkCommsDotNet.SendReceiveOptions)">
      <summary>
            Create a new connection object
            </summary>
      <param name="connectionInfo">ConnectionInfo corresponding to the new connection</param>
      <param name="defaultSendReceiveOptions">The SendReceiveOptions which should be used as connection defaults</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.EstablishConnection">
      <summary>
            Establish this connection
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.EstablishConnectionSpecific">
      <summary>
            Any connection type specific establish tasks. Should call at least ConnectionHandshake() or TriggerConnectionEstablishDelegates();
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.ConnectionHandshake">
      <summary>
            Performs a connection handshake with the remote end of the connection.
            Exchanges network identifier and any listener whose IPAddress matches the connection localEndPoint IPAddress.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.TriggerConnectionEstablishDelegates">
      <summary>
            Trigger connection establish delegates.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.WaitForConnectionEstablish(System.Int32)">
      <summary>
            Return true if the connection is established within the provided timeout, otherwise false
            </summary>
      <param name="waitTimeoutMS">Wait time in milliseconds before returning</param>
      <returns>True if the wait was triggered, false otherwise after the provided timeout.</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.ConnectionSetupHandler(System.IO.MemoryStream)">
      <summary>
            Handle an incoming ConnectionSetup packet type
            </summary>
      <param name="packetDataSection">Serialised handshake data</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.ConnectionSetupHandlerFinal(NetworkCommsDotNet.ConnectionInfo,System.Boolean@,NetworkCommsDotNet.Connections.Connection@)">
      <summary>
            Attempts to complete the connection establish with a minimum of locking to avoid possible deadlocking
            </summary>
      <param name="remoteConnectionInfo">
        <see cref="P:NetworkCommsDotNet.Connections.Connection.ConnectionInfo" /> corresponding with remoteEndPoint</param>
      <param name="possibleClashWithExistingConnection">True if a connection already exists with provided remoteEndPoint</param>
      <param name="existingConnection">A reference to an existing connection if it exists</param>
      <returns>True if connection is successfully setup, otherwise false</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.ToString">
      <summary>
            Returns ConnectionInfo.ToString
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.IncomingPacketSendReceiveOptions(NetworkCommsDotNet.PacketHeader)">
      <summary>
            Returns the <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> to be used for the provided <see cref="T:NetworkCommsDotNet.PacketHeader" />. Ensures there 
            will not be a serializer or data processor clash for different delegate levels.
            </summary>
      <param name="header">The <see cref="T:NetworkCommsDotNet.PacketHeader" /> options are desired.</param>
      <returns>The requested <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /></returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.GetPacketHandlerWrappers(System.String)">
      <summary>
            Gets packet handler wrappers for a given packet type
            </summary>
      <param name="packetTypeStr">The packet type to get handler wrappers for</param>
      <returns>The packet handler wrappers associated with the packet type supplied</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.TriggerSpecificPacketHandlers(NetworkCommsDotNet.PacketHeader,System.Object)">
      <summary>
            Trigger connection specific packet delegates with the provided parameters. Returns true if connection specific handlers were executed.
            </summary>
      <param name="packetHeader">The packetHeader for which all delegates should be triggered with</param>
      <param name="returnObject">The deserialised payload object</param>
      <returns>Returns true if connection specific handlers were executed.</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.PacketTypeUnwrapperOptions(System.String)">
      <summary>
            Returns the packet type sendReceiveOptions possibly used to unwrap incoming data. If no specific options are registered returns null
            </summary>
      <param name="packetTypeStr">The packet type for which the <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> are required.</param>
      <returns>The requested <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> otherwise null</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.AppendIncomingPacketHandler``1(System.String,NetworkCommsDotNet.NetworkComms.PacketHandlerCallBackDelegate{``0})">
      <summary>
            Append a connection specific packet handler using the connection default SendReceiveOptions
            </summary>
      <typeparam name="incomingObjectType">The type of incoming object</typeparam>
      <param name="packetTypeStr">The packet type for which this handler will be executed</param>
      <param name="packetHandlerDelgatePointer">The delegate to be executed when a packet of packetTypeStr is received</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.AppendIncomingPacketHandler``1(System.String,NetworkCommsDotNet.NetworkComms.PacketHandlerCallBackDelegate{``0},NetworkCommsDotNet.SendReceiveOptions)">
      <summary>
            Append a connection specific packet handler
            </summary>
      <typeparam name="incomingObjectType">The type of incoming object</typeparam>
      <param name="packetTypeStr">The packet type for which this handler will be executed</param>
      <param name="packetHandlerDelgatePointer">The delegate to be executed when a packet of packetTypeStr is received</param>
      <param name="options">The <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> to be used for the provided packet type</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.AppendIncomingPacketHandler(System.String,NetworkCommsDotNet.Tools.IPacketTypeHandlerDelegateWrapper,NetworkCommsDotNet.SendReceiveOptions)">
      <summary>
            Append a connection specific packet handler which has already been wrapped by IPacketTypeHandlerDelegateWrapper
            </summary>
      <param name="packetTypeStr">The packet type for which this handler will be executed</param>
      <param name="packetHandlerDelgateWrapper">The IPacketTypeHandlerDelegateWrapper to be executed when a packet of packetTypeStr is received</param>
      <param name="options">The <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> to be used for the provided packet type</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.AppendIncomingUnmanagedPacketHandler(NetworkCommsDotNet.NetworkComms.PacketHandlerCallBackDelegate{System.Byte[]})">
      <summary>
            Append a connection specific unmanaged packet handler
            </summary>
      <param name="packetHandlerDelgatePointer">The delegate to be executed when an unmanaged packet is received</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.IncomingPacketHandlerExists(System.String)">
      <summary>
            Returns true if an unmanaged packet handler exists on this connection
            </summary>
      <param name="packetTypeStr">The packet type for which to check incoming packet handlers</param>
      <returns>True if a packet handler exists</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.IncomingUnmanagedPacketHandlerExists">
      <summary>
            Returns true if a connection specific unmanaged packet handler exists, on this connection.
            </summary>
      <returns>True if an unmanaged packet handler exists</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.IncomingPacketHandlerExists(System.String,System.Delegate)">
      <summary>
            Returns true if the provided connection specific packet handler has been added for the provided packet type, on this connection.
            </summary>
      <param name="packetTypeStr">The packet type within which to check packet handlers</param>
      <param name="packetHandlerDelgatePointer">The packet handler to look for</param>
      <returns>True if a connection specific packet handler exists for the provided packetType</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.IncomingUnmanagedPacketHandlerExists(System.Delegate)">
      <summary>
            Returns true if the provided connection specific unmanaged packet handler has been added, on this connection.
            </summary>
      <param name="packetHandlerDelgatePointer">The packet handler to look for</param>
      <returns>True if a connection specific unmanaged packet handler exists</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.RemoveIncomingPacketHandler(System.String,System.Delegate)">
      <summary>
            Remove the provided connection specific packet handler for the specified packet type, on this connection.
            </summary>
      <param name="packetTypeStr">Packet type for which this delegate should be removed</param>
      <param name="packetHandlerDelgatePointer">The delegate to remove</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.RemoveIncomingUnmanagedPacketHandler(System.Delegate)">
      <summary>
            Remove the provided connection specific unmanaged packet handler, on this connection.
            </summary>
      <param name="packetHandlerDelgatePointer">The delegate to remove</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.RemoveIncomingPacketHandler(System.String)">
      <summary>
            Removes all connection specific packet handlers for the provided packet type, on this connection.
            </summary>
      <param name="packetTypeStr">Packet type for which all delegates should be removed</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.RemoveIncomingUnmanagedPacketHandler">
      <summary>
            Removes all unmanaged packet handlers, on this connection.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.RemoveIncomingPacketHandler">
      <summary>
            Removes all packet handlers for all packet types, on this connection.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.AppendShutdownHandler(NetworkCommsDotNet.NetworkComms.ConnectionEstablishShutdownDelegate)">
      <summary>
            Add a connection specific shutdown delegate
            </summary>
      <param name="handlerToAppend">The delegate to call when a connection is shutdown</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.RemoveShutdownHandler(NetworkCommsDotNet.NetworkComms.ConnectionEstablishShutdownDelegate)">
      <summary>
            Remove a connection specific shutdown delegate.
            </summary>
      <param name="handlerToRemove">The delegate to remove for shutdown events</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.StartIncomingDataListen">
      <summary>
            A connection specific method which triggers any requisites for accepting incoming data
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.IncomingPacketHandleHandOff(NetworkCommsDotNet.Tools.PacketBuilder)">
      <summary>
            Attempts to use the data provided in packetBuilder to recreate something useful. If we don't have enough data 
            yet that value is set in packetBuilder.
            </summary>
      <param name="packetBuilder">The <see cref="T:NetworkCommsDotNet.Tools.PacketBuilder" /> containing incoming cached data</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.CheckSumFailResendHandler(System.IO.MemoryStream)">
      <summary>
            Handle an incoming CheckSumFailResend packet type
            </summary>
      <param name="packetDataSection">
      </param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.StartListening``1(NetworkCommsDotNet.Connections.ConnectionType,``0,System.Boolean)">
      <summary>
            Start listening for incoming connections of the provided <see cref="T:NetworkCommsDotNet.Connections.ConnectionType" />. 
            If the desired localEndPoint is not available will throw a CommsSetupShutdownException.
            </summary>
      <param name="connectionType">The <see cref="T:NetworkCommsDotNet.Connections.ConnectionType" /> to start listening for.</param>
      <param name="desiredLocalEndPoint">The desired localEndPoint. For IPEndPoints use IPAddress.Any 
            to listen on all <see cref="M:NetworkCommsDotNet.Tools.HostInfo.IP.FilteredLocalAddresses" /> and port 0 to randomly select an available port.</param>
      <param name="allowDiscoverable">Determines if the listeners created will be discoverable if <see cref="T:NetworkCommsDotNet.Tools.PeerDiscovery" /> is enabled.</param>
      <returns>A list of all listeners used.</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.StartListening``1(NetworkCommsDotNet.Connections.ConnectionListenerBase,``0,System.Boolean)">
      <summary>
            Start listening for new incoming connections on specified <see cref="T:System.Net.IPEndPoint" />. Inspect listener.LocalListenIPEndPoint 
            when method returns to determine the <see cref="T:System.Net.IPEndPoint" /> used.
            </summary>
      <param name="listener">The listener to use.</param>
      <param name="desiredLocalEndPoint">The desired local <see cref="T:System.Net.IPEndPoint" /> to use for listening. IPAddress.Any corresponds with listening on
            0.0.0.0. Use a port number of 0 to dynamically select a port.</param>
      <param name="useRandomPortFailOver">If true and the requested local port is not available will select one at random. 
            If false and provided port is unavailable will throw <see cref="T:NetworkCommsDotNet.CommsSetupShutdownException" /></param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.StartListening``1(System.Collections.Generic.List{NetworkCommsDotNet.Connections.ConnectionListenerBase},System.Collections.Generic.List{``0},System.Boolean)">
      <summary>
            Start listening for new incoming connections on specified <see cref="T:System.Net.IPEndPoint" />s. Listener is matched
            with desired localIPEndPoint based on List index. Inspect listener.LocalListenIPEndPoint 
            when method returns to determine the <see cref="T:System.Net.IPEndPoint" />s used.
            </summary>
      <param name="listeners">The listeners to use.</param>
      <param name="desiredLocalEndPoints">The desired local <see cref="T:System.Net.IPEndPoint" />s to use for listening. IPAddress.Any corresponds with listening on
            0.0.0.0. Use a port number of 0 to dynamically select a port.</param>
      <param name="useRandomPortFailOver">If true and the requested local port is not available will select one at random. 
            If false and provided port is unavailable will throw <see cref="T:NetworkCommsDotNet.CommsSetupShutdownException" /></param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.StopListening">
      <summary>
            Stops all local listeners
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.StopListening(NetworkCommsDotNet.Connections.ConnectionType)">
      <summary>
            Stops all local listeners of the provided <see cref="T:NetworkCommsDotNet.Connections.ConnectionType" />.
            </summary>
      <param name="connectionType">The <see cref="T:NetworkCommsDotNet.Connections.ConnectionType" /> to close.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.StopListening(NetworkCommsDotNet.Connections.ConnectionListenerBase)">
      <summary>
            Stop listening for new incoming connections on specified <see cref="T:NetworkCommsDotNet.Connections.ConnectionListenerBase" /> and remove it from the local listeners dictionary.
            </summary>
      <param name="listener">The listener which should stop listening.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.StopListening(System.Collections.Generic.List{NetworkCommsDotNet.Connections.ConnectionListenerBase})">
      <summary>
            Stop listening for new incoming connections on specified list of <see cref="T:NetworkCommsDotNet.Connections.ConnectionListenerBase" /> and remove them from the local listeners dictionary.
            </summary>
      <param name="listeners">The listeners which should stop listening</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.StopListening(NetworkCommsDotNet.Connections.ConnectionType,System.Net.EndPoint)">
      <summary>
            Stop listening for new incoming connections on specified <see cref="T:System.Net.EndPoint" /> and remove it from the local listeners dictionary.
            </summary>
      <param name="connectionType">The connection type to stop listening on.</param>
      <param name="localEndPointToClose">The local <see cref="T:System.Net.EndPoint" /> to stop listening for connections on.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.Listening(NetworkCommsDotNet.Connections.ConnectionType)">
      <summary>
            Returns true if at least one local listener of the provided <see cref="T:NetworkCommsDotNet.Connections.ConnectionType" /> exists.
            </summary>
      <param name="connectionType">The <see cref="T:NetworkCommsDotNet.Connections.ConnectionType" /> to check.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.AllExistingLocalListenEndPoints">
      <summary>
            Returns a dictionary corresponding to all current local listeners. Key is connection type, value is local EndPoint of listener.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.ExistingLocalListenEndPoints(NetworkCommsDotNet.Connections.ConnectionType)">
      <summary>
            Returns a list of <see cref="T:System.Net.EndPoint" />s corresponding to possible local listeners of the provided 
            <see cref="T:NetworkCommsDotNet.Connections.ConnectionType" />. If no listeners exist returns empty list.
            </summary>
      <param name="connectionType">The connection type to match. Use ConnectionType.Undefined to match all.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.ExistingLocalListenEndPoints(NetworkCommsDotNet.Connections.ConnectionType,System.Net.EndPoint)">
      <summary>
            Returns a list of <see cref="T:System.Net.EndPoint" /> corresponding to possible local listeners of the provided 
            <see cref="T:NetworkCommsDotNet.Connections.ConnectionType" /> with a local EndPoint with matching <see cref="T:System.Net.IPAddress" />. 
            If no matching listeners exist returns empty list.
            </summary>
      <param name="connectionType">Connection type to match. Use ConnectionType.Undefined to match all.</param>
      <param name="localEndPointToMatch">The <see cref="T:System.Net.IPEndPoint" /> to match to local listeners. Use IPAddress.Any 
            to match all addresses. Use port 0 to match all ports.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.ExistingLocalListeners``1(System.Net.EndPoint)">
      <summary>
            Returns a list of requested existing local listeners.
            </summary>
      <typeparam name="listenerType">Type of listener to return.</typeparam>
      <param name="endPointToMatch">The <see cref="T:System.Net.EndPoint" /> to match to local listeners. Use IPAddress.Any to match all 
            addresses. Use port 0 to match all ports.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.AllExistingLocalListeners">
      <summary>
            Returns a list of all local listeners
            </summary>
      <returns>A list of all local listeners</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.SendUnmanagedBytes(System.Byte[])">
      <summary>
            Send bytes on an unmanaged connection
            </summary>
      <param name="bytesToSend">The bytes to send</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.SendObject``1(System.String,``0)">
      <summary>
            Send an object using the connection default <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /></summary>
      <param name="sendingPacketType">The sending packet type</param>
      <param name="objectToSend">The object to send</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.SendObject``1(System.String,``0,System.Int64@)">
      <summary>
            Send an object using the connection default <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /></summary>
      <param name="sendingPacketType">The sending packet type</param>
      <param name="objectToSend">The object to send</param>
      <param name="packetSequenceNumber">The sequence number of the packet sent</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.SendObject``1(System.String,``0,NetworkCommsDotNet.SendReceiveOptions)">
      <summary>
            Send an object using the provided SendReceiveOptions
            </summary>
      <param name="sendingPacketType">The packet type to use for send</param>
      <param name="objectToSend">The object to send</param>
      <param name="options">Send specific <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /></param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.SendObject``1(System.String,``0,NetworkCommsDotNet.SendReceiveOptions,System.Int64@)">
      <summary>
            Send an object using the provided SendReceiveOptions
            </summary>
      <param name="sendingPacketType">The packet type to use for send</param>
      <param name="objectToSend">The object to send</param>
      <param name="options">Send specific <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /></param>
      <param name="packetSequenceNumber">The sequence number of the packet sent</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.SendObject(System.String)">
      <summary>
            Send an empty packet using the provided packetType. Useful for signalling.
            </summary>
      <param name="sendingPacketType">The sending packet type</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.SendObject(System.String,System.Int64@)">
      <summary>
            Send an empty packet using the provided packetType. Useful for signalling.
            </summary>
      <param name="sendingPacketType">The sending packet type</param>
      <param name="packetSequenceNumber">The sequence number of the packet sent</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.SendReceiveObject``2(System.String,System.String,System.Int32,``0)">
      <summary>
            Send an object using the connection default <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> and wait for a returned object 
            again using default <see cref="T:NetworkCommsDotNet.SendReceiveOptions" />.
            </summary>
      <typeparam name="sendObjectType">The sending object type, i.e. string, int[], etc</typeparam>
      <typeparam name="returnObjectType">The type of return object</typeparam>
      <param name="sendingPacketTypeStr">The sending packet type</param>
      <param name="expectedReturnPacketTypeStr">The packet type which will be used for the reply</param>
      <param name="returnPacketTimeOutMilliSeconds">A timeout in milliseconds after which if not reply is received 
            will throw an ExpectedReturnTimeoutException.</param>
      <param name="sendObject">The object to send</param>
      <returns>The requested return object</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.SendReceiveObject``2(System.String,System.String,System.Int32,``0,System.Int64@)">
      <summary>
            Send an object using the connection default <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> and wait for a returned object again
            using default <see cref="T:NetworkCommsDotNet.SendReceiveOptions" />.
            </summary>
      <typeparam name="sendObjectType">The sending object type, i.e. string, int[], etc</typeparam>
      <typeparam name="returnObjectType">The type of return object</typeparam>
      <param name="sendingPacketTypeStr">The sending packet type</param>
      <param name="expectedReturnPacketTypeStr">The packet type which will be used for the reply</param>
      <param name="returnPacketTimeOutMilliSeconds">A timeout in milliseconds after which if not reply is received will 
            throw an ExpectedReturnTimeoutException.</param>
      <param name="sendObject">The object to send</param>
      <param name="sentPacketSequenceNumber">The sequence number of the packet sent</param>
      <returns>The requested return object</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.SendReceiveObject``2(System.String,System.String,System.Int32,``0,NetworkCommsDotNet.SendReceiveOptions,NetworkCommsDotNet.SendReceiveOptions)">
      <summary>
            Send an object using the provided <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> and wait for a returned object using provided 
            <see cref="T:NetworkCommsDotNet.SendReceiveOptions" />.
            </summary>
      <typeparam name="sendObjectType">The sending object type, i.e. string, int[], etc</typeparam>
      <typeparam name="returnObjectType">The type of return object</typeparam>
      <param name="sendingPacketTypeStr">The sending packet type</param>
      <param name="expectedReturnPacketTypeStr">The packet type which will be used for the reply</param>
      <param name="returnPacketTimeOutMilliSeconds">A timeout in milliseconds after which if not reply is received will 
            throw an ExpectedReturnTimeoutException.</param>
      <param name="sendObject">The object to send</param>
      <param name="sendOptions">SendReceiveOptions to use when sending</param>
      <param name="receiveOptions">SendReceiveOptions used when receiving the return object</param>
      <returns>The requested return object</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.SendReceiveObject``2(System.String,System.String,System.Int32,``0,NetworkCommsDotNet.SendReceiveOptions,NetworkCommsDotNet.SendReceiveOptions,System.Int64@)">
      <summary>
            Send an object using the provided <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> and wait for a returned object using provided 
            <see cref="T:NetworkCommsDotNet.SendReceiveOptions" />.
            </summary>
      <typeparam name="sendObjectType">The sending object type, i.e. string, int[], etc</typeparam>
      <typeparam name="returnObjectType">The type of return object</typeparam>
      <param name="sendingPacketTypeStr">The sending packet type</param>
      <param name="expectedReturnPacketTypeStr">The packet type which will be used for the reply</param>
      <param name="returnPacketTimeOutMilliSeconds">A timeout in milliseconds after which if not reply is received will 
            throw an ExpectedReturnTimeoutException.</param>
      <param name="sendObject">The object to send</param>
      <param name="sendOptions">SendReceiveOptions to use when sending</param>
      <param name="receiveOptions">SendReceiveOptions used when receiving the return object</param>
      <param name="sentPacketSequenceNumber">The sequence number of the packet sent</param>
      <returns>The requested return object</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.SendReceiveObject``1(System.String,System.String,System.Int32)">
      <summary>
            Send an empty packet using the connection default <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> and wait for a returned object again 
            using default <see cref="T:NetworkCommsDotNet.SendReceiveOptions" />. Useful to request an object when there is no need to send anything.
            </summary>
      <typeparam name="returnObjectType">The type of return object</typeparam>
      <param name="sendingPacketTypeStr">The sending packet type</param>
      <param name="expectedReturnPacketTypeStr">The packet type which will be used for the reply</param>
      <param name="returnPacketTimeOutMilliSeconds">A timeout in milliseconds after which if not reply is received will throw 
            an ExpectedReturnTimeoutException.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.SendReceiveObject``1(System.String,System.String,System.Int32,System.Int64@)">
      <summary>
            Send an empty packet using the connection default <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> and wait for a returned object again using default <see cref="T:NetworkCommsDotNet.SendReceiveOptions" />. Usefull to request an object when there is no need to send anything.
            </summary>
      <typeparam name="returnObjectType">The type of return object</typeparam>
      <param name="sendingPacketTypeStr">The sending packet type</param>
      <param name="expectedReturnPacketTypeStr">The packet type which will be used for the reply</param>
      <param name="returnPacketTimeOutMilliSeconds">A timeout in milliseconds after which if not reply is received will throw an ExpectedReturnTimeoutException.</param>
      <param name="sentPacketSequenceNumber">The sequence number of the packet sent</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.CloseConnection(System.Boolean,System.Int32)">
      <summary>
            Closes the connection and trigger any associated shutdown delegates.
            </summary>
      <param name="closeDueToError">Closing a connection due an error possibly requires a few extra steps.</param>
      <param name="logLocation">Optional debug parameter.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.CloseConnectionSpecific(System.Boolean,System.Int32)">
      <summary>
            Every connection will probably have to perform connection specific shutdown tasks. This is called before the global 
            connection close tasks.
            </summary>
      <param name="closeDueToError">Closing a connection due an error possibly requires a few extra steps.</param>
      <param name="logLocation">Optional debug parameter for determining the location of the close.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.ConnectionAlive">
      <summary>
            Uses the current connection and returns a bool dependant on the remote end responding to a SendReceiveObject call 
            within the default <see cref="P:NetworkCommsDotNet.NetworkComms.ConnectionAliveTestTimeoutMS" /></summary>
      <returns>True if the remote end responds within <see cref="P:NetworkCommsDotNet.NetworkComms.ConnectionAliveTestTimeoutMS" /> otherwise false</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.ConnectionAlive(System.Int32)">
      <summary>
            Uses the current connection and returns a bool dependant on the remote end responding to a SendReceiveObject call 
            within the provided aliveRespondTimeoutMS.
            </summary>
      <param name="aliveRespondTimeoutMS">The time to wait in milliseconds before returning false</param>
      <returns>True if the remote end responds within the provided aliveRespondTimeoutMS</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.ConnectionAlive(System.Int32,System.Int64@)">
      <summary>
            Uses the current connection and returns a bool dependant on the remote end responding to a SendReceiveObject call 
            within the provided aliveRespondTimeoutMS
            </summary>
      <param name="aliveRespondTimeoutMS">The time to wait in milliseconds before returning false</param>
      <param name="responseTimeMS">The number of milliseconds taken for a successful response to be received</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.SendPacket``1(NetworkCommsDotNet.IPacket)">
      <summary>
            Send the provided packet to the remoteEndPoint. Waits for receive confirmation if required.
            </summary>
      <typeparam name="packetPayloadObjectType">The type of object encapsulated by the provided packet</typeparam>
      <param name="packet">The packet to send</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.SendPacket``1(NetworkCommsDotNet.IPacket,System.Int64@)">
      <summary>
            Send the provided packet to the remoteEndPoint. Waits for receive confirmation if required.
            </summary>
      <typeparam name="packetPayloadObjectType">The type of object encapsulated by the provided packet</typeparam>
      <param name="packet">The packet to send</param>
      <param name="packetSequenceNumber">The sequence number of the packet sent</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.SendNullPacket">
      <summary>
            Implementation for sending a null packets on this connection type. Used for ensuring a connection
            is not terminated by an intermediary switch/router due to inactivity.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.SendPacketSpecific(NetworkCommsDotNet.IPacket)">
      <summary>
            Send the provided packet 
            </summary>
      <param name="packet">
      </param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.SendStreams(NetworkCommsDotNet.Tools.StreamTools.StreamSendWrapper[],System.Double,System.Int64)">
      <summary>
            Connection specific implementation for sending data on this connection type.
            Each StreamSendWrapper[] represents a single expected packet.
            </summary>
      <param name="streamsToSend">The streams which need to be sent</param>
      <param name="maxSendTimePerKB">The maximum time to allow per KB before a write timeout exception.</param>
      <param name="totalBytesToSend">A precalculated sum of streams.Length</param>
      <returns>Should return double[] which represents the milliseconds per byte written for each StreamSendWrapper</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.Dispose">
      <summary>
            Dispose of the connection. Recommended usage is to call CloseConnection instead.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.TriggerConnectionKeepAliveThread">
      <summary>
            Starts the connectionKeepAliveWorker thread if it is not already started
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.ConnectionKeepAliveWorker">
      <summary>
            A single static worker thread which keeps connections alive
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.AllConnectionsSendNullPacketKeepAlive(System.Boolean)">
      <summary>
            Polls all existing connections based on ConnectionKeepAlivePollIntervalSecs value. Server side connections are polled 
            slightly earlier than client side to help reduce potential congestion.
            </summary>
      <param name="returnImmediately">If true runs as task and returns immediately.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Connection.Shutdown(System.Int32)">
      <summary>
            Shutdown any static connection components
            </summary>
      <param name="threadShutdownTimeoutMS">
      </param>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.Connection.ConnectionInfo">
      <summary>
            Connection information related to this connection.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.Connection.SyncRoot">
      <summary>
            Connection level SyncRoot which can be used to perform multiple thread safe operations on this connection
            external to NetworkComms.Net
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.Connection.ConnectionDefaultSendReceiveOptions">
      <summary>
            The default <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> used for this connection
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.Connection.ConnectionSpecificShutdownDelegate">
      <summary>
            A multicast function delegate for maintaining connection specific shutdown delegates
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.Connection.MinimumMSPerKBSendTimeout">
      <summary>
            The minimum number of milliseconds to allow per KB before a write timeout may occur. Default is 20.0.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.Connection.MaxNumSendTimes">
      <summary>
            The maximum number of writes intervals to maintain. Default is 100.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.Connection.MinNumSendsBeforeConnectionSpecificSendTimeout">
      <summary>
            The minimum number of writes before the connection specific write timeouts will be used. Default is 4.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.Connection.DefaultMSPerKBSendTimeout">
      <summary>
            The default milliseconds per KB write timeout before connection specific values become available. Default is 1000. See <see cref="P:NetworkCommsDotNet.Connections.Connection.MinNumSendsBeforeConnectionSpecificSendTimeout" />.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.Connection.MinSendTimeoutMS">
      <summary>
            The minimum timeout for any sized send in milliseconds. Prevents timeouts when sending less than 1KB. Default is 2000.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.Connection.ConnectionKeepAlivePollIntervalSecs">
      <summary>
            The interval between keep alive polls of all connections. Set to int.MaxValue to disable keep alive poll
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.Connection.NumberOfStDeviationsForWriteTimeout">
      <summary>
            The number of standard deviations from the mean to use for write timeouts. Default is 3.0.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection">
      <summary>
            A connection type that uses Bluetooth RFCOMM to communicate 
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection.btClient">
      <summary>
            The Bluetooth equivalent of TCPClient
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection.btClientNetworkStream">
      <summary>
            The network stream associated with btClient
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection.dataBuffer">
      <summary>
            The current incoming data buffer
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection.#ctor(NetworkCommsDotNet.ConnectionInfo,NetworkCommsDotNet.SendReceiveOptions,InTheHand.Net.Sockets.BluetoothClient)">
      <summary>
            Bluetooth connection constructor
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection.EstablishConnectionSpecific">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection.ConnectSocket">
      <summary>
            If we were not provided with a btClient on creation we need to create one
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection.StartIncomingDataListen">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection.IncomingBluetoothPacketHandler(System.IAsyncResult)">
      <summary>
            Asynchronous incoming connection data delegate
            </summary>
      <param name="ar">The call back state object</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection.IncomingBluetoothDataSyncWorker">
      <summary>
            Synchronous incoming connection data worker
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection.CloseConnectionSpecific(System.Boolean,System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection.SendStreams(NetworkCommsDotNet.Tools.StreamTools.StreamSendWrapper[],System.Double,System.Int64)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection.GetConnection(NetworkCommsDotNet.ConnectionInfo,System.Boolean)">
      <summary>
            Create a <see cref="T:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection" /> with the provided connectionInfo. If there is an existing connection that will be returned instead. 
            If a new connection is created it will be registered with NetworkComms and can be retrieved using <see cref="M:NetworkCommsDotNet.NetworkComms.GetExistingConnection(NetworkCommsDotNet.ConnectionInfo)" /> and overrides.
            </summary>
      <param name="connectionInfo">ConnectionInfo to be used to create connection</param>
      <param name="establishIfRequired">If true will establish the TCP connection with the remote end point before returning</param>
      <returns>Returns a <see cref="T:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection" /></returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection.GetConnection(NetworkCommsDotNet.ConnectionInfo,NetworkCommsDotNet.SendReceiveOptions,System.Boolean)">
      <summary>
            Create a TCP connection with the provided connectionInfo and sets the connection default SendReceiveOptions. If there is an existing connection that is returned instead.
            If a new connection is created it will be registered with NetworkComms and can be retrieved using <see cref="M:NetworkCommsDotNet.NetworkComms.GetExistingConnection(NetworkCommsDotNet.ConnectionInfo)" /> and overrides.
            </summary>
      <param name="connectionInfo">ConnectionInfo to be used to create connection</param>
      <param name="defaultSendReceiveOptions">The SendReceiveOptions which will be set as this connections defaults</param>
      <param name="establishIfRequired">If true will establish the TCP connection with the remote end point before returning</param>
      <returns>Returns a <see cref="T:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection" /></returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection.GetConnection(NetworkCommsDotNet.ConnectionInfo,NetworkCommsDotNet.SendReceiveOptions,InTheHand.Net.Sockets.BluetoothClient,System.Boolean)">
      <summary>
            Internal <see cref="T:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection" /> creation which hides the necessary internal calls
            </summary>
      <param name="connectionInfo">ConnectionInfo to be used to create connection</param>
      <param name="defaultSendReceiveOptions">Connection default SendReceiveOptions</param>
      <param name="btClient">If this is an incoming connection we will already have access to the btClient, otherwise use null</param>
      <param name="establishIfRequired">Establish during create if true</param>
      <returns>An existing connection or a new one</returns>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection.EnableNagleAlgorithmForNewConnections">
      <summary>
            By default usage of <see href="http://en.wikipedia.org/wiki/Nagle's_algorithm">Nagle's algorithm</see> during connection exchanges is disabled for performance reasons. If you wish it to be used for newly established connections set this property to true.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Connections.ConnectionListenerBase">
      <summary>
            A base class that the listener of each connection type inherits from.
            This allows NetworkComms.Net to manage listeners at the general connection level.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.ConnectionListenerBase.delegateLocker">
      <summary>
            Thread safety locker which is used when accessing <see cref="F:NetworkCommsDotNet.Connections.ConnectionListenerBase.incomingPacketHandlers" />
            and <see cref="F:NetworkCommsDotNet.Connections.ConnectionListenerBase.incomingPacketUnwrappers" /></summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.ConnectionListenerBase.incomingPacketUnwrappers">
      <summary>
            By default all incoming objects are handled using ListenerDefaultSendReceiveOptions. Should the user want something else
            those settings are stored here
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.ConnectionListenerBase.incomingPacketHandlers">
      <summary>
            A listener specific incoming packet handler dictionary. These are called before any global handlers
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.ConnectionListenerBase.#ctor(NetworkCommsDotNet.Connections.ConnectionType,NetworkCommsDotNet.SendReceiveOptions,NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus,System.Boolean)">
      <summary>
            Create a new listener instance
            </summary>
      <param name="connectionType">The connection type to listen for.</param>
      <param name="sendReceiveOptions">The send receive options to use for this listener</param>
      <param name="applicationLayerProtocol">If enabled NetworkComms.Net uses a custom 
            application layer protocol to provide useful features such as inline serialisation, 
            transparent packet transmission, remote peer handshake and information etc. We strongly 
            recommend you enable the NetworkComms.Net application layer protocol.</param>
      <param name="allowDiscoverable">Determines if the newly created <see cref="T:NetworkCommsDotNet.Connections.ConnectionListenerBase" /> will be discoverable if <see cref="T:NetworkCommsDotNet.Tools.PeerDiscovery" /> is enabled.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.ConnectionListenerBase.ToString">
      <summary>
            Returns a clean string containing the current listener state
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.ConnectionListenerBase.StartListening(System.Net.EndPoint,System.Boolean)">
      <summary>
            Start listening for incoming connections.
            </summary>
      <param name="desiredLocalListenEndPoint">Try to start listening on this EndPoint.</param>
      <param name="useRandomPortFailOver">If the request EndPoint is unavailable fail over to a random port.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.ConnectionListenerBase.StopListening">
      <summary>
            Stop listening for incoming connections.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.ConnectionListenerBase.AppendIncomingPacketHandler``1(System.String,NetworkCommsDotNet.NetworkComms.PacketHandlerCallBackDelegate{``0})">
      <summary>
            Append a listener specific packet handler using the listener default SendReceiveOptions
            </summary>
      <typeparam name="incomingObjectType">The type of incoming object</typeparam>
      <param name="packetTypeStr">The packet type for which this handler will be executed</param>
      <param name="packetHandlerDelgatePointer">The delegate to be executed when a packet of packetTypeStr is received</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.ConnectionListenerBase.AppendIncomingPacketHandler``1(System.String,NetworkCommsDotNet.NetworkComms.PacketHandlerCallBackDelegate{``0},NetworkCommsDotNet.SendReceiveOptions)">
      <summary>
            Append a listener specific packet handler
            </summary>
      <typeparam name="incomingObjectType">The type of incoming object</typeparam>
      <param name="packetTypeStr">The packet type for which this handler will be executed</param>
      <param name="packetHandlerDelgatePointer">The delegate to be executed when a packet of packetTypeStr is received</param>
      <param name="options">The <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> to be used for the provided packet type</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.ConnectionListenerBase.AppendIncomingUnmanagedPacketHandler(NetworkCommsDotNet.NetworkComms.PacketHandlerCallBackDelegate{System.Byte[]})">
      <summary>
            Append a listener specific unmanaged packet handler
            </summary>
      <param name="packetHandlerDelgatePointer">The delegate to be executed when an unmanaged packet is received</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.ConnectionListenerBase.IncomingPacketHandlerExists(System.String)">
      <summary>
            Returns true if an unmanaged packet handler exists on this listener
            </summary>
      <param name="packetTypeStr">The packet type for which to check incoming packet handlers</param>
      <returns>True if a packet handler exists</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.ConnectionListenerBase.IncomingUnmanagedPacketHandlerExists">
      <summary>
            Returns true if a listener specific unmanaged packet handler exists, on this listener.
            </summary>
      <returns>True if an unmanaged packet handler exists</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.ConnectionListenerBase.IncomingPacketHandlerExists(System.String,System.Delegate)">
      <summary>
            Returns true if the provided listener specific packet handler has been added for the provided packet type, on this listener.
            </summary>
      <param name="packetTypeStr">The packet type within which to check packet handlers</param>
      <param name="packetHandlerDelgatePointer">The packet handler to look for</param>
      <returns>True if a listener specific packet handler exists for the provided packetType</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.ConnectionListenerBase.IncomingUnmanagedPacketHandlerExists(System.Delegate)">
      <summary>
            Returns true if the provided listener specific unmanaged packet handler has been added, on this listener.
            </summary>
      <param name="packetHandlerDelgatePointer">The packet handler to look for</param>
      <returns>True if a listener specific unmanaged packet handler exists</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.ConnectionListenerBase.RemoveIncomingPacketHandler(System.String,System.Delegate)">
      <summary>
            Remove the provided listener specific packet handler for the specified packet type, on this listener.
            </summary>
      <param name="packetTypeStr">Packet type for which this delegate should be removed</param>
      <param name="packetHandlerDelgatePointer">The delegate to remove</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.ConnectionListenerBase.RemoveIncomingUnmanagedPacketHandler(System.Delegate)">
      <summary>
            Remove the provided listener specific unmanaged packet handler, on this listener.
            </summary>
      <param name="packetHandlerDelgatePointer">The delegate to remove</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.ConnectionListenerBase.RemoveIncomingPacketHandler(System.String)">
      <summary>
            Removes all listener specific packet handlers for the provided packet type, on this listener.
            </summary>
      <param name="packetTypeStr">Packet type for which all delegates should be removed</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.ConnectionListenerBase.RemoveIncomingUnmanagedPacketHandler">
      <summary>
            Removes all unmanaged packet handlers, on this listener.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.ConnectionListenerBase.RemoveIncomingPacketHandler">
      <summary>
            Removes all packet handlers for all packet types, on this listener.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.ConnectionListenerBase.AddListenerPacketHandlersToConnection(NetworkCommsDotNet.Connections.Connection)">
      <summary>
            Add all listener specific packet handlers to the provided connection
            </summary>
      <param name="connection">The connection to which packet handlers should be added</param>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.ConnectionListenerBase.ListenerDefaultSendReceiveOptions">
      <summary>
            The send receive options associated with this listener.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.ConnectionListenerBase.ConnectionType">
      <summary>
            The connection type that this listener supports.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.ConnectionListenerBase.ApplicationLayerProtocol">
      <summary>
            The application layer protocol status for this listener.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.ConnectionListenerBase.IsListening">
      <summary>
            True if this listener is listening.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.ConnectionListenerBase.IsDiscoverable">
      <summary>
            True if this listener will be advertised via peer discovery
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.ConnectionListenerBase.LocalListenEndPoint">
      <summary>
            The local IPEndPoint that this listener is associated with.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnectionListener">
      <summary>
            A Bluetooth connection listener
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnectionListener.listenerInstance">
      <summary>
            The local Bluetooth listener
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnectionListener.#ctor(NetworkCommsDotNet.SendReceiveOptions,NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus,System.Boolean)">
      <summary>
            Create a new instance of BluetoothConnectionListener
            </summary>
      <param name="sendReceiveOptions">The send receive options to use for this listener.</param>
      <param name="applicationLayerProtocol">If enabled NetworkComms.Net uses a custom 
            application layer protocol to provide useful features such as inline serialisation, 
            transparent packet transmission, remote peer handshake and information etc. We strongly 
            recommend you enable the NetworkComms.Net application layer protocol.</param>
      <param name="allowDiscoverable">Determines if the newly created <see cref="T:NetworkCommsDotNet.Connections.ConnectionListenerBase" /> will be discoverable if <see cref="T:NetworkCommsDotNet.Tools.PeerDiscovery" /> is enabled.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnectionListener.StartListening(System.Net.EndPoint,System.Boolean)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnectionListener.StopListening">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnectionListener.BluetoothConnectionReceivedAsync(System.IAsyncResult)">
      <summary>
            Handle a new incoming bluetooth connection
            </summary>
      <param name="ar">
      </param>
    </member>
    <member name="T:NetworkCommsDotNet.Connections.ConnectionType">
      <summary>
            The type of <see cref="T:NetworkCommsDotNet.Connections.Connection" />.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.ConnectionType.Undefined">
      <summary>
            An undefined connection type. This is used as the default value.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.ConnectionType.TCP">
      <summary>
            A TCP connection type. Used by <see cref="T:NetworkCommsDotNet.Connections.TCP.TCPConnection" />.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.ConnectionType.UDP">
      <summary>
            A UDP connection type. Used by <see cref="T:NetworkCommsDotNet.Connections.UDP.UDPConnection" />.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.ConnectionType.Bluetooth">
      <summary>
            A Bluetooth RFCOMM connection. Used by <see cref="T:NetworkCommsDotNet.Connections.Bluetooth.BluetoothConnection" /></summary>
    </member>
    <member name="T:NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus">
      <summary>
            The connections application layer protocol status.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus.Undefined">
      <summary>
            Useful for selecting or searching connections when the ApplicationLayerProtocolStatus
            is unimportant.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus.Enabled">
      <summary>
            Default value. NetworkComms.Net will use a custom application layer protocol to provide 
            useful features such as inline serialisation, transparent packet send and receive, 
            connection handshakes and remote information etc. We strongly recommend you enable the 
            NetworkComms.Net application layer protocol.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus.Disabled">
      <summary>
            No application layer protocol will be used. TCP packets may fragment or be concatenated 
            with other packets. A large number of library features will be unavailable.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Connections.IPConnection">
      <summary>
            IP Connection base class for NetworkComms.Net. This contains the functionality and tools shared by any connections
            that use IP related endPoints such as <see cref="T:NetworkCommsDotNet.Connections.TCP.TCPConnection" /> and <see cref="T:NetworkCommsDotNet.Connections.UDP.UDPConnection" />.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.IPConnection.#ctor(NetworkCommsDotNet.ConnectionInfo,NetworkCommsDotNet.SendReceiveOptions)">
      <summary>
            Create a new IP connection object
            </summary>
      <param name="connectionInfo">ConnectionInfo corresponding to the new connection</param>
      <param name="defaultSendReceiveOptions">The SendReceiveOptions which should be used as connection defaults</param>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.IPConnection.DOSProtection">
      <summary>
            The NetworkComms.Net DOS protection class. By default DOSProtection is disabled.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.IPConnection.AllowedIncomingIPRanges">
      <summary>
            If set NetworkComms.Net will only accept incoming connections from the provided IP ranges. 
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Connections.SentPacket">
      <summary>
            A wrapper object for keeping track of sent packets. These are used if a resend is requested due to a checksum validation failure.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Connections.TCP.SSLOptions">
      <summary>
            Contains SSL configuration options
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.SSLOptions.#ctor">
      <summary>
            Initialise a new empty instance of SSLOptions, which disables SSL.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.SSLOptions.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean)">
      <summary>
            Initialise a new instance of SSLOptions which enables SSL. If this SSLOptions is used server side any client
            requires either a copy of the provided certificate or the certificate name to successfully connect.
            </summary>
      <param name="certificate">The certificate</param>
      <param name="allowSelfSignedCertificates">If true self signed certificates may be used successfully. CAUTION: Allowing self signed certificates makes it 
            significantly easier for a remote peer to impersonate someone.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.SSLOptions.#ctor(System.Security.Cryptography.X509Certificates.X509Certificate,System.Boolean,System.Boolean)">
      <summary>
            Initialise a new instance of SSLOptions which enables SSL. If requireMutualAuthentication is true, and 
            this SSLOptions is used server side, any client must have a copy of the certificate to successfully connect.
            </summary>
      <param name="certificate">The certificate</param>
      <param name="allowSelfSignedCertificates">If true self signed certificates may be used successfully. CAUTION: Allowing self signed certificates makes it 
            significantly easier for a remote peer to impersonate someone.</param>
      <param name="requireMutualAuthentication">True if any client must also have a copy of the server certificate</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.SSLOptions.#ctor(System.String,System.Boolean)">
      <summary>
            Initialise a new instance of SSLOptions which enables SSL. Can be successfully used to
            connect to a server with a matching certificateName. Server must not require MutualAuthentication.
            </summary>
      <param name="certificateName">The server certificate name</param>
      <param name="allowSelfSignedCertificates">If true self signed certificates may be used successfully. CAUTION: Allowing self signed certificates makes it 
            significantly easier for a remote peer to impersonate someone.</param>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.TCP.SSLOptions.SSLEnabled">
      <summary>
            True if SSL has been enabled
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.TCP.SSLOptions.CertificateName">
      <summary>
            The certificate name
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.TCP.SSLOptions.Certificate">
      <summary>
            A suitable certificate
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.TCP.SSLOptions.AllowSelfSignedCertificate">
      <summary>
            If true self signed certificates may be used successfully. CAUTION: Allowing self signed certificates makes it 
            significantly easier for a remote peer to impersonate someone.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.TCP.SSLOptions.RequireMutualAuthentication">
      <summary>
            If true the client must set the correct certificate in its SSLOptions. If false
            all the client requires to successfully connect is the certificate name.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.TCP.SSLOptions.Authenticated">
      <summary>
            True once the SSL handshake has been authenticated
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Connections.TCP.TCPConnection">
      <summary>
            A connection object which utilises <see href="http://en.wikipedia.org/wiki/Transmission_Control_Protocol">TCP</see> to communicate between peers.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.TCP.TCPConnection.tcpClient">
      <summary>
            The TcpClient corresponding to this connection.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.TCP.TCPConnection.connectionStream">
      <summary>
            The networkstream associated with the tcpClient.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.TCP.TCPConnection.dataBuffer">
      <summary>
            The current incoming data buffer
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnection.#ctor(NetworkCommsDotNet.ConnectionInfo,NetworkCommsDotNet.SendReceiveOptions,System.Net.Sockets.TcpClient,NetworkCommsDotNet.Connections.TCP.SSLOptions)">
      <summary>
            TCP connection constructor
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnection.EstablishConnectionSpecific">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnection.ConnectSocket">
      <summary>
            If we were not provided with a tcpClient on creation we need to create one
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnection.StartIncomingDataListen">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnection.IncomingTCPPacketHandler(System.IAsyncResult)">
      <summary>
            Asynchronous incoming connection data delegate
            </summary>
      <param name="ar">The call back state object</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnection.IncomingTCPDataSyncWorker">
      <summary>
            Synchronous incoming connection data worker
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnection.ConfigureSSLStream">
      <summary>
            Configure the SSL stream from this connection
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnection.CertificateValidationCallback(System.Object,System.Security.Cryptography.X509Certificates.X509Certificate,System.Security.Cryptography.X509Certificates.X509Chain,System.Net.Security.SslPolicyErrors)">
      <summary>
            Callback used to determine if the provided certificate should be accepted
            </summary>
      <param name="sender">
      </param>
      <param name="certificate">
      </param>
      <param name="chain">
      </param>
      <param name="sslPolicyErrors">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnection.CertificateSelectionCallback(System.Object,System.String,System.Security.Cryptography.X509Certificates.X509CertificateCollection,System.Security.Cryptography.X509Certificates.X509Certificate,System.String[])">
      <summary>
            Certificate selection callback
            </summary>
      <param name="sender">
      </param>
      <param name="targetHost">
      </param>
      <param name="localCertificates">
      </param>
      <param name="remoteCertificate">
      </param>
      <param name="acceptableIssuers">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnection.CloseConnectionSpecific(System.Boolean,System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnection.SendStreams(NetworkCommsDotNet.Tools.StreamTools.StreamSendWrapper[],System.Double,System.Int64)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnection.GetConnection(NetworkCommsDotNet.ConnectionInfo,System.Boolean)">
      <summary>
            Create a <see cref="T:NetworkCommsDotNet.Connections.TCP.TCPConnection" /> with the provided connectionInfo. If there is an existing connection that will be returned instead. 
            If a new connection is created it will be registered with NetworkComms and can be retrieved using <see cref="M:NetworkCommsDotNet.NetworkComms.GetExistingConnection(NetworkCommsDotNet.ConnectionInfo)" /> and overrides.
            </summary>
      <param name="connectionInfo">ConnectionInfo to be used to create connection</param>
      <param name="establishIfRequired">If true will establish the TCP connection with the remote end point before returning</param>
      <returns>Returns a <see cref="T:NetworkCommsDotNet.Connections.TCP.TCPConnection" /></returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnection.GetConnection(NetworkCommsDotNet.ConnectionInfo,NetworkCommsDotNet.SendReceiveOptions,System.Boolean)">
      <summary>
            Create a TCP connection with the provided connectionInfo and sets the connection default SendReceiveOptions. If there is an existing connection that is returned instead.
            If a new connection is created it will be registered with NetworkComms and can be retrieved using <see cref="M:NetworkCommsDotNet.NetworkComms.GetExistingConnection(NetworkCommsDotNet.ConnectionInfo)" /> and overrides.
            </summary>
      <param name="connectionInfo">ConnectionInfo to be used to create connection</param>
      <param name="defaultSendReceiveOptions">The SendReceiveOptions which will be set as this connections defaults</param>
      <param name="establishIfRequired">If true will establish the TCP connection with the remote end point before returning</param>
      <returns>Returns a <see cref="T:NetworkCommsDotNet.Connections.TCP.TCPConnection" /></returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnection.GetConnection(NetworkCommsDotNet.ConnectionInfo,NetworkCommsDotNet.SendReceiveOptions,NetworkCommsDotNet.Connections.TCP.SSLOptions,System.Boolean)">
      <summary>
            Create a TCP connection with the provided connectionInfo and sets the connection default SendReceiveOptions. If there is an existing connection that is returned instead.
            If a new connection is created it will be registered with NetworkComms and can be retrieved using <see cref="M:NetworkCommsDotNet.NetworkComms.GetExistingConnection(NetworkCommsDotNet.ConnectionInfo)" /> and overrides.
            </summary>
      <param name="connectionInfo">ConnectionInfo to be used to create connection</param>
      <param name="defaultSendReceiveOptions">The SendReceiveOptions which will be set as this connections defaults</param>
      <param name="sslOptions">SSLOptions to use with this connection</param>
      <param name="establishIfRequired">If true will establish the TCP connection with the remote end point before returning</param>
      <returns>Returns a <see cref="T:NetworkCommsDotNet.Connections.TCP.TCPConnection" /></returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnection.GetConnection(NetworkCommsDotNet.ConnectionInfo,NetworkCommsDotNet.SendReceiveOptions,System.Net.Sockets.TcpClient,System.Boolean,NetworkCommsDotNet.Connections.TCP.SSLOptions)">
      <summary>
            Internal <see cref="T:NetworkCommsDotNet.Connections.TCP.TCPConnection" /> creation which hides the necessary internal calls
            </summary>
      <param name="connectionInfo">ConnectionInfo to be used to create connection</param>
      <param name="defaultSendReceiveOptions">Connection default SendReceiveOptions</param>
      <param name="tcpClient">If this is an incoming connection we will already have access to the tcpClient, otherwise use null</param>
      <param name="establishIfRequired">Establish during create if true</param>
      <param name="sslOptions">SSL options that will be used with this connection.</param>
      <returns>An existing connection or a new one</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnection.StartListening(System.Boolean)">
      <summary>
            Accept new incoming TCP connections on all allowed IP's and Port's
            </summary>
      <param name="useRandomPortFailOver">If true and the default local port is not available will select one at random. If false and a port is unavailable listening will not be enabled on that adaptor</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnection.StartListening(System.Collections.Generic.List{System.Net.IPEndPoint},System.Boolean)">
      <summary>
            Accept new TCP connections on specified list of <see cref="T:System.Net.IPEndPoint" /></summary>
      <param name="localEndPoints">The localEndPoints to listen for connections on</param>
      <param name="useRandomPortFailOver">If true and the requested local port is not available on a given IPEndPoint will select one at random. If false and a port is unavailable will throw <see cref="T:NetworkCommsDotNet.CommsSetupShutdownException" /></param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnection.StartListening(System.Net.IPEndPoint,System.Boolean,System.Boolean)">
      <summary>
            Accept new incoming TCP connections on specified <see cref="T:System.Net.IPEndPoint" /></summary>
      <param name="newLocalEndPoint">The localEndPoint to listen for connections on.</param>
      <param name="useRandomPortFailOver">If true and the requested local port is not available will select one at random. If false and a port is unavailable will throw <see cref="T:NetworkCommsDotNet.CommsSetupShutdownException" /></param>
      <param name="allowDiscoverable">Determines if the newly created <see cref="T:NetworkCommsDotNet.Connections.ConnectionListenerBase" /> will be discoverable if <see cref="T:NetworkCommsDotNet.Tools.PeerDiscovery" /> is enabled.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnection.ExistingLocalListenEndPoints">
      <summary>
            Returns a list of <see cref="T:System.Net.IPEndPoint" /> corresponding to all current TCP local listeners
            </summary>
      <returns>List of <see cref="T:System.Net.IPEndPoint" /> corresponding to all current TCP local listeners</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnection.ExistingLocalListenEndPoints(System.Net.IPAddress)">
      <summary>
            Returns a list of <see cref="T:System.Net.IPEndPoint" /> corresponding to a possible local listeners on the provided <see cref="T:System.Net.IPAddress" />. If not listening on provided <see cref="T:System.Net.IPAddress" /> returns empty list.
            </summary>
      <param name="ipAddress">The <see cref="T:System.Net.IPAddress" /> to match to a possible local listener</param>
      <returns>If listener exists returns <see cref="T:System.Net.IPAddress" /> otherwise null</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnection.Listening">
      <summary>
            Returns true if listening for new TCP connections.
            </summary>
      <returns>True if listening for new TCP connections.</returns>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.TCP.TCPConnection.SSLOptions">
      <summary>
            The SSL options associated with this connection.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.TCP.TCPConnection.EnableNagleAlgorithmForNewConnections">
      <summary>
            By default usage of <see href="http://en.wikipedia.org/wiki/Nagle's_algorithm">Nagle's algorithm</see> during TCP exchanges is disabled for performance reasons. If you wish it to be used for newly established connections set this property to true.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Connections.TCP.TCPConnectionListener">
      <summary>
            A TCP connection listener
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.TCP.TCPConnectionListener.listenerInstance">
      <summary>
            The .net TCPListener class.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnectionListener.#ctor(NetworkCommsDotNet.SendReceiveOptions,NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus,System.Boolean)">
      <summary>
            Create a new instance of a TCP listener
            </summary>
      <param name="sendReceiveOptions">The SendReceiveOptions to use with incoming data on this listener</param>
      <param name="applicationLayerProtocol">If enabled NetworkComms.Net uses a custom 
            application layer protocol to provide useful features such as inline serialisation, 
            transparent packet transmission, remote peer handshake and information etc. We strongly 
            recommend you enable the NetworkComms.Net application layer protocol.</param>
      <param name="allowDiscoverable">Determines if the newly created <see cref="T:NetworkCommsDotNet.Connections.ConnectionListenerBase" /> will be discoverable if <see cref="T:NetworkCommsDotNet.Tools.PeerDiscovery" /> is enabled.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnectionListener.#ctor(NetworkCommsDotNet.SendReceiveOptions,NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus,NetworkCommsDotNet.Connections.TCP.SSLOptions,System.Boolean)">
      <summary>
            Create a new instance of a TCP listener
            </summary>
      <param name="sendReceiveOptions">The SendReceiveOptions to use with incoming data on this listener</param>
      <param name="applicationLayerProtocol">If enabled NetworkComms.Net uses a custom 
            application layer protocol to provide useful features such as inline serialisation, 
            transparent packet transmission, remote peer handshake and information etc. We strongly 
            recommend you enable the NetworkComms.Net application layer protocol.</param>
      <param name="sslOptions">The SSLOptions to use with this listener</param>
      <param name="allowDiscoverable">Determines if the newly created <see cref="T:NetworkCommsDotNet.Connections.ConnectionListenerBase" /> will be discoverable if <see cref="T:NetworkCommsDotNet.Tools.PeerDiscovery" /> is enabled.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnectionListener.StartListening(System.Net.EndPoint,System.Boolean)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnectionListener.StopListening">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Connections.TCP.TCPConnectionListener.TCPConnectionReceivedAsync(System.IAsyncResult)">
      <summary>
            Async method for handling up new incoming TCP connections
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.TCP.TCPConnectionListener.SSLOptions">
      <summary>
            SSL options that are associated with this listener
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Connections.UDP.UdpClientWrapper">
      <summary>
            Internal wrapper around a udpClient object so that we can easily manage usage.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.UDP.UdpClientWrapper.SIO_UDP_CONNRESET">
      <summary>
            IOControl value used to ignore ICMP destination unreachable packets which result in the socket closing
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Connections.UDP.UDPConnection">
      <summary>
            A connection object which utilises <see href="http://en.wikipedia.org/wiki/User_Datagram_Protocol">UDP</see> to communicate between peers.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.UDP.UDPConnection.maximumSingleDatagramSizeBytes">
      <summary>
            The maximum datagram size limit for UDP
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.UDP.UDPConnection.isIsolatedUDPConnection">
      <summary>
            An isolated UDP connection will only accept incoming packets coming from a specific RemoteEndPoint.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.UDP.UDPConnection.udpRogueSenders">
      <summary>
            The rogue UDP connection is used for sending ONLY if no available locally bound client is available.
            First key is address family of rogue sender, second key is value of ApplicationLayerProtocolEnabled.
            Third key is local IPEndPoint of the rouge sender
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.#ctor(NetworkCommsDotNet.ConnectionInfo,NetworkCommsDotNet.SendReceiveOptions,NetworkCommsDotNet.Connections.UDP.UDPOptions,System.Boolean,NetworkCommsDotNet.Connections.UDP.UDPConnection)">
      <summary>
            Internal constructor for UDP connections
            </summary>
      <param name="connectionInfo">
      </param>
      <param name="defaultSendReceiveOptions">
      </param>
      <param name="level">
      </param>
      <param name="listenForIncomingPackets">
      </param>
      <param name="existingConnection">
      </param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.EstablishConnectionSpecific">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.CloseConnectionSpecific(System.Boolean,System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.SendPacketSpecific``1(NetworkCommsDotNet.IPacket,System.Net.IPEndPoint)">
      <summary>
            Send a packet to the specified ipEndPoint. This feature is unique to UDP because of its connectionless structure.
            </summary>
      <param name="packet">Packet to send</param>
      <param name="ipEndPoint">The target ipEndPoint</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.SendStreams(NetworkCommsDotNet.Tools.StreamTools.StreamSendWrapper[],System.Double,System.Int64)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.StartIncomingDataListen">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.IncomingUDPPacketHandler(System.IAsyncResult)">
      <summary>
            Incoming data listen async method
            </summary>
      <param name="ar">Call back state data</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.IncomingUDPPacketWorker">
      <summary>
            Incoming data listen sync method
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.GetConnection(NetworkCommsDotNet.ConnectionInfo,NetworkCommsDotNet.Connections.UDP.UDPOptions,System.Boolean,System.Boolean)">
      <summary>
            Create a UDP connection with the provided connectionInfo. If there is an existing connection that is returned instead.
            If a new connection is created it will be registered with NetworkComms and can be retrieved using 
            <see cref="M:NetworkCommsDotNet.NetworkComms.GetExistingConnection(NetworkCommsDotNet.ConnectionInfo)" /> and overrides.
            </summary>
      <param name="connectionInfo">ConnectionInfo to be used to create connection</param>
      <param name="level">The UDP level to use for this connection</param>
      <param name="listenForReturnPackets">If set to true will ensure that reply packets are handled</param>
      <param name="establishIfRequired">Will establish the connection, triggering connection establish delegates if a 
            new connection is returned</param>
      <returns>Returns a <see cref="T:NetworkCommsDotNet.Connections.UDP.UDPConnection" /></returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.GetConnection(NetworkCommsDotNet.ConnectionInfo,NetworkCommsDotNet.Connections.UDP.UDPOptions,NetworkCommsDotNet.SendReceiveOptions,System.Boolean,System.Boolean)">
      <summary>
            Create a UDP connection with the provided connectionInfo and and sets the connection default SendReceiveOptions. 
            If there is an existing connection that is returned instead. If a new connection is created it will be registered 
            with NetworkComms and can be retrieved using <see cref="M:NetworkCommsDotNet.NetworkComms.GetExistingConnection(NetworkCommsDotNet.ConnectionInfo)" />.
            </summary>
      <param name="connectionInfo">ConnectionInfo to be used to create connection</param>
      <param name="defaultSendReceiveOptions">The SendReceiveOptions to use as defaults for this connection</param>
      <param name="level">The UDP options to use for this connection</param>
      <param name="listenForReturnPackets">If set to true will ensure that reply packets can be received</param>
      <param name="establishIfRequired">Will establish the connection, triggering connection establish delegates if a 
            new connection is returned</param>
      <returns>Returns a <see cref="T:NetworkCommsDotNet.Connections.UDP.UDPConnection" /></returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.GetConnection(NetworkCommsDotNet.ConnectionInfo,NetworkCommsDotNet.Connections.UDP.UDPOptions,NetworkCommsDotNet.SendReceiveOptions,System.Boolean,NetworkCommsDotNet.Connections.UDP.UDPConnection,NetworkCommsDotNet.Connections.UDP.HandshakeUDPDatagram,System.Boolean)">
      <summary>
            Internal UDP creation method that performs the necessary tasks
            </summary>
      <param name="connectionInfo">
      </param>
      <param name="defaultSendReceiveOptions">
      </param>
      <param name="level">
      </param>
      <param name="listenForReturnPackets">
      </param>
      <param name="existingListenerConnection">
      </param>
      <param name="possibleHandshakeUDPDatagram">
      </param>
      <param name="establishIfRequired">Will establish the connection, triggering connection establish delegates if a new 
            connection is returned</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.SendObject(System.String,System.Object,System.String,System.Int32)">
      <summary>
            Sends a single object to the provided IPAddress and Port. NOTE: Any possible reply will be ignored unless listening 
            for incoming UDP packets. 
            </summary>
      <param name="sendingPacketType">The sending packet type</param>
      <param name="objectToSend">The object to send.</param>
      <param name="ipAddress">The destination IP address. Supports multicast addresses such as 192.168.0.255 etc.</param>
      <param name="port">The destination port.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.SendObject(System.String,System.Object,System.Net.IPEndPoint)">
      <summary>
            Sends a single object to the provided endPoint. NOTE: Any possible reply will be ignored unless listening for incoming UDP packets. 
            </summary>
      <param name="sendingPacketType">The sending packet type</param>
      <param name="objectToSend">The object to send</param>
      <param name="ipEndPoint">The destination IPEndPoint. Supports multicast endpoints.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.SendObject(System.String,System.Object,System.Net.IPEndPoint,NetworkCommsDotNet.SendReceiveOptions)">
      <summary>
            Sends a single object to the provided endPoint. NOTE: Any possible reply will be ignored unless listening for incoming UDP packets. 
            </summary>
      <param name="sendingPacketType">The sending packet type</param>
      <param name="objectToSend">The object to send</param>
      <param name="ipEndPoint">The destination IPEndPoint. Supports multicast endpoints.</param>
      <param name="sendReceiveOptions">The sendReceiveOptions to use for this send</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.SendObject``1(System.String,``0,System.Net.IPEndPoint,NetworkCommsDotNet.SendReceiveOptions,NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus)">
      <summary>
            Sends a single object to the provided endPoint. NOTE: Any possible reply will be ignored unless listening for incoming UDP packets. 
            </summary>
      <param name="sendingPacketType">The sending packet type</param>
      <param name="objectToSend">The object to send</param>
      <param name="ipEndPoint">The destination IPEndPoint. Supports multicast endpoints.</param>
      <param name="sendReceiveOptions">The sendReceiveOptions to use for this send</param>
      <param name="applicationLayerProtocol">If enabled NetworkComms.Net uses a custom 
            application layer protocol to provide useful features such as inline serialisation, 
            transparent packet transmission, remote peer handshake and information etc. We strongly 
            recommend you use the NetworkComms.Net application layer protocol.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.SendObject``1(NetworkCommsDotNet.IPacket,System.Net.IPEndPoint,NetworkCommsDotNet.SendReceiveOptions,NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus)">
      <summary>
            Sends a <see cref="T:NetworkCommsDotNet.Packet" /> to the provided endPoint. Offers more performance if an identical packet is being sent to multiple peers. 
            NOTE: Any possible reply will be ignored unless listening for incoming UDP packets. 
            </summary>
      <typeparam name="packetPayloadObjectType">The type of object encapsulated by the provided packet</typeparam>
      <param name="packetToSend">The packet to send</param>
      <param name="ipEndPoint">The destination IPEndPoint. Supports multicast endpoints.</param>
      <param name="sendReceiveOptions">The sendReceiveOptions to use for this send</param>
      <param name="applicationLayerProtocol">If enabled NetworkComms.Net uses a custom 
            application layer protocol to provide useful features such as inline serialisation, 
            transparent packet transmission, remote peer handshake and information etc. We strongly 
            recommend you use the NetworkComms.Net application layer protocol.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.AnyRemoteIPAddress(System.Net.Sockets.AddressFamily)">
      <summary>
            Provides an IP address that matches all IPAddresses of the provided targetAddressFamily
            </summary>
      <param name="targetAddressFamily">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.StartListening(System.Boolean)">
      <summary>
            Listen for incoming UDP packets on all allowed local IP's on default port.
            </summary>
      <param name="useRandomPortFailOver">If true and the default local port is not available will select one at random. If false 
            and a port is unavailable listening will not be enabled on that adaptor unless NetworkComms.ListenOnAllAllowedInterfaces is 
            false in which case a <see cref="T:NetworkCommsDotNet.CommsSetupShutdownException" /> will be thrown instead.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.StartListening(System.Collections.Generic.List{System.Net.IPEndPoint},System.Boolean)">
      <summary>
            Listen for incoming UDP packets on provided list of <see cref="T:System.Net.IPEndPoint" />. 
            </summary>
      <param name="localEndPoints">The localEndPoints to listen for packets on.</param>
      <param name="useRandomPortFailOver">If true and the requested local port is not available will select one at random. If false 
            and a port is unavailable will throw <see cref="T:NetworkCommsDotNet.CommsSetupShutdownException" /></param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.StartListening(System.Net.IPEndPoint,System.Boolean,System.Boolean)">
      <summary>
            Listen for incoming UDP packets on specified <see cref="T:System.Net.IPEndPoint" />. 
            </summary>
      <param name="newLocalEndPoint">The localEndPoint to listen for packets on</param>
      <param name="useRandomPortFailOver">If true and the requested local port is not available will select one at random. 
            If false and a port is unavailable will throw <see cref="T:NetworkCommsDotNet.CommsSetupShutdownException" /></param>
      <param name="allowDiscoverable">Determines if the newly created <see cref="T:NetworkCommsDotNet.Connections.ConnectionListenerBase" /> will be discoverable if <see cref="T:NetworkCommsDotNet.Tools.PeerDiscovery" /> is enabled.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.ExistingLocalListenEndPoints">
      <summary>
            Returns a list of <see cref="T:System.Net.IPEndPoint" /> corresponding with all UDP local listeners
            </summary>
      <returns>List of <see cref="T:System.Net.IPEndPoint" /> corresponding with all UDP local listeners</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.ExistingLocalListenEndPoints(System.Net.IPAddress)">
      <summary>
            Returns an <see cref="T:System.Net.IPEndPoint" /> corresponding to a possible local listener on the provided <see cref="T:System.Net.IPAddress" />. 
            If not listening on provided <see cref="T:System.Net.IPAddress" /> returns null.
            </summary>
      <param name="ipAddress">The <see cref="T:System.Net.IPAddress" /> to match to a possible local listener</param>
      <returns>If listener exists returns <see cref="T:System.Net.IPAddress" /> otherwise null</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnection.Listening">
      <summary>
            Returns true if listening for new UDP connections.
            </summary>
      <returns>True if listening for new UDP connections.</returns>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.UDP.UDPConnection.ConnectionUDPOptions">
      <summary>
            Options associated with this UDPConnection
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.UDP.UDPConnection.IgnoreICMPDestinationUnreachable">
      <summary>
            By default a UDP datagram sent to an unreachable destination will result in an ICMP Destination Unreachable 
            packet. This can result in a SocketException on the local end. To avoid this behaviour these ICMP packets 
            are ignored by default, i.e. this value is set to true. Setting this value to false could cause new UDP 
            connections to close, possibly unexpectedly.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.UDP.UDPConnection.DefaultUDPOptions">
      <summary>
            The default UDPOptions to use where none are otherwise specified.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Connections.UDP.UDPConnectionListener">
      <summary>
            A UDP connection listener
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnectionListener.#ctor(NetworkCommsDotNet.SendReceiveOptions,NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus,NetworkCommsDotNet.Connections.UDP.UDPOptions,System.Boolean)">
      <summary>
            Create a new instance of a UDP listener
            </summary>
      <param name="sendReceiveOptions">The SendReceiveOptions to use with incoming data on this listener</param>
      <param name="applicationLayerProtocol">If enabled NetworkComms.Net uses a custom 
            application layer protocol to provide useful features such as inline serialisation, 
            transparent packet transmission, remote peer handshake and information etc. We strongly 
            recommend you enable the NetworkComms.Net application layer protocol.</param>
      <param name="udpOptions">The UDPOptions to use with this listener</param>
      <param name="allowDiscoverable">Determines if the newly created <see cref="T:NetworkCommsDotNet.Connections.ConnectionListenerBase" /> will be discoverable if <see cref="T:NetworkCommsDotNet.Tools.PeerDiscovery" /> is enabled.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnectionListener.StartListening(System.Net.EndPoint,System.Boolean)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Connections.UDP.UDPConnectionListener.StopListening">
      <inheritdoc />
    </member>
    <member name="P:NetworkCommsDotNet.Connections.UDP.UDPConnectionListener.UDPOptions">
      <summary>
            The UDPOptions to be used for this listener
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Connections.UDP.UDPConnectionListener.UDPConnection">
      <summary>
            The UDP listener is a UDP connection
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Connections.UDP.UDPOptions">
      <summary>
            A <see cref="T:NetworkCommsDotNet.Connections.UDP.UDPConnection" /> could support different combinations of features. i.e. From the most basic (None) which 
            sends connectionless UDP packets up to an emulated TCP. Future versions of NetworkCommsDotNet will support an ever 
            increasing number of UDP features. This flag enum is used to specify which of the available features should be used.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.UDP.UDPOptions.None">
      <summary>
            The most basic UDP option. All UDP packets are sent connectionless with no error handling, sequencing or duplication prevention.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Connections.UDP.UDPOptions.Handshake">
      <summary>
            Performs a connection handshake, which ensures the remote end is alive at the time of the connection
            establish. Also exchanges network identifier and possible remote listening port.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Connections.UDP.HandshakeUDPDatagram">
      <summary>
            A small wrapper class which allows an initialising UDP datagram
            to be handled within a connection instantiation if required.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.DPSBase.DataSerializer">
      <summary>
            Provides methods that convert an <see cref="T:System.Object" /> into a <see cref="T:System.Byte" />[]
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DataSerializer.GetInstance``1">
      <summary>
            Helper function to allow a <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> to be implemented as a singleton.  Returns the singleton instance generated by the <see cref="T:NetworkCommsDotNet.DPSBase.DPSManager" /></summary>
      <typeparam name="T">The <see cref="T:System.Type" /> of the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> to retrieve from the <see cref="T:NetworkCommsDotNet.DPSBase.DPSManager" /></typeparam>
      <returns>The singleton instance generated by the <see cref="T:NetworkCommsDotNet.DPSBase.DPSManager" /></returns>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DataSerializer.SerialiseDataObject``1(``0)">
      <summary>
            Converts objectToSerialize to an array of bytes. Uses no data processors.
            </summary>
      <typeparam name="T">Type of object to serialize</typeparam>
      <param name="objectToSerialise">Object to serialize</param>
      <returns>Serialized array of bytes</returns>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DataSerializer.SerialiseDataObject``1(``0,System.Collections.Generic.List{NetworkCommsDotNet.DPSBase.DataProcessor},System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Converts objectToSerialize to an array of bytes using the data processors and options provided.
            </summary>
      <typeparam name="T">Type of object to serialize</typeparam>
      <param name="objectToSerialise">Object to serialize</param>
      <param name="dataProcessors">Data processors to apply to serialised data.  These will be run in index order i.e. low index to high</param>
      <param name="options">Options dictionary for serialisation/data processing</param>
      <returns>Serialized array of bytes</returns>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DataSerializer.DeserialiseDataObject``1(System.Byte[])">
      <summary>
            Converts array of bytes previously serialized to an object of provided type. Assumes no data processors.
            </summary>
      <typeparam name="T">Type of object to deserialize to</typeparam>
      <param name="receivedObjectBytes">Byte array containing serialized and compressed object</param>
      <returns>The deserialized object</returns>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DataSerializer.DeserialiseDataObject``1(System.IO.MemoryStream)">
      <summary>
            Converts a memory stream containing bytes previously serialized to an object of provided type. Assumes no data processors.
            </summary>
      <typeparam name="T">Type of object to deserialize to</typeparam>
      <param name="receivedObjectStream">Byte array containing serialized and compressed object</param>
      <returns>The deserialized object</returns>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DataSerializer.DeserialiseDataObject``1(System.Byte[],System.Collections.Generic.List{NetworkCommsDotNet.DPSBase.DataProcessor},System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Converts bytes previously serialized and processed using data processors to an object of provided type
            </summary>
      <typeparam name="T">Type of object to deserialize to</typeparam>
      <param name="receivedObjectBytes">Byte array containing serialized and compressed object</param>
      <param name="dataProcessors">Data processors to apply to serialised data.  These will be run in reverse order i.e. high index to low</param>
      <param name="options">Options dictionary for serialisation/data processing</param>
      <returns>The deserialized object</returns>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DataSerializer.DeserialiseDataObject``1(System.IO.MemoryStream,System.Collections.Generic.List{NetworkCommsDotNet.DPSBase.DataProcessor},System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Converts a memory stream containing bytes previously serialized and processed using data processors to an object of provided type
            </summary>
      <typeparam name="T">Type of object to deserialize to</typeparam>
      <param name="receivedObjectStream">Byte array containing serialized and compressed object</param>
      <param name="dataProcessors">Data processors to apply to serialised data.  These will be run in reverse order i.e. high index to low</param>
      <param name="options">Options dictionary for serialisation/data processing</param>
      <returns>The deserialized object</returns>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DataSerializer.SerialiseDataObjectInt(System.IO.Stream,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Serialises an object to a stream using any relevant options provided
            </summary>
      <param name="ouputStream">The stream to serialise to</param>
      <param name="objectToSerialise">The object to serialise</param>
      <param name="options">Options dictionary for serialisation/data processing</param>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DataSerializer.DeserialiseDataObjectInt(System.IO.Stream,System.Type,System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Deserialises the data in a stream to an object of the specified type using any relevant provided options 
            </summary>
      <param name="inputStream">The stream containing the serialised object</param>
      <param name="resultType">The return object Type</param>
      <param name="options">Options dictionary for serialisation/data processing</param>
      <returns>The deserialised object</returns>
    </member>
    <member name="P:NetworkCommsDotNet.DPSBase.DataSerializer.Identifier">
      <summary>
            Returns a unique identifier for the serializer type.  Used in automatic serialization/compression detection
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.DPSBase.BinaryFormaterSerializer">
      <summary>
            DataSerializer that uses .Net <see cref="T:System.Runtime.Serialization.Formatters.Binary.BinaryFormatter" /> to perform <see cref="T:System.Object" /> serialization
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.BinaryFormaterSerializer.SerialiseDataObjectInt(System.IO.Stream,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.BinaryFormaterSerializer.DeserialiseDataObjectInt(System.IO.Stream,System.Type,System.Collections.Generic.Dictionary{System.String,System.String})">
      <inheritdoc />
    </member>
    <member name="P:NetworkCommsDotNet.DPSBase.BinaryFormaterSerializer.Instance">
      <summary>
            Instance singleton used to access serializer instance.  Use instead <see cref="M:NetworkCommsDotNet.DPSBase.DPSManager.GetDataSerializer``1" /></summary>
    </member>
    <member name="T:NetworkCommsDotNet.DPSBase.DataProcessor">
      <summary>
            Provides methods that process data in a <see cref="T:System.IO.Stream" /> into another <see cref="T:System.IO.Stream" />.  Can be used to provide features such as data compression or encryption
            </summary>
      <example>
        <code source="..\NetworkCommsDotNet\DPSBase\RijndaelPSKEncrypter.cs" lang="cs" title="Implementation Example" />
      </example>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DataProcessor.GetInstance``1">
      <summary>
            Helper function to allow a <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to be implemented as a singleton.  Returns the singleton instance generated by the <see cref="T:NetworkCommsDotNet.DPSBase.DPSManager" /></summary>
      <typeparam name="T">The <see cref="T:System.Type" /> of the <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to retrieve from the <see cref="T:NetworkCommsDotNet.DPSBase.DPSManager" /></typeparam>
      <returns>The singleton instance generated by the <see cref="T:NetworkCommsDotNet.DPSBase.DPSManager" /></returns>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DataProcessor.ForwardProcessDataStream(System.IO.Stream,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String},System.Int64@)">
      <summary>
            Processes data held in a stream and outputs it to another stream
            </summary>
      <param name="inStream">An input stream containing data to be processed</param>
      <param name="outStream">An output stream to which the processed data is written</param>
      <param name="options">Options dictionary for serialisation/data processing</param>
      <param name="writtenBytes">The size of the data written to the output stream</param>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DataProcessor.ReverseProcessDataStream(System.IO.Stream,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String},System.Int64@)">
      <summary>
            Processes data, in reverse, that is held in a stream and outputs it to another stream
            </summary>
      <param name="inStream">An input stream containing data to be processed</param>
      <param name="outStream">An output stream to which the processed data is written</param>
      <param name="options">Options dictionary for serialisation/data processing</param>
      <param name="writtenBytes">The size of the data written to the output stream</param>
    </member>
    <member name="P:NetworkCommsDotNet.DPSBase.DataProcessor.Identifier">
      <summary>
            Returns a unique identifier for the compressor type. Used in automatic serialization/compression detection
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.DPSBase.DataProcessor.IsSecurityCritical">
      <summary>
            Returns a boolian stating whether this data processor is security critical
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.DPSBase.DataPadder">
      <summary>
        <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> which pads data section of a packet using to a fixed size
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.DPSBase.DataPadder.DataPaddingType">
      <summary>
            The type of data padding to use
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DataPadder.ForwardProcessDataStream(System.IO.Stream,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String},System.Int64@)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DataPadder.ReverseProcessDataStream(System.IO.Stream,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String},System.Int64@)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DataPadder.AddPaddingOptions(System.Collections.Generic.Dictionary{System.String,System.String},System.Int32,NetworkCommsDotNet.DPSBase.DataPadder.DataPaddingType,System.Boolean)">
      <summary>
            Adds the necessary options for padding 
            </summary>
      <param name="options">The Dictionary to add the options to</param>
      <param name="paddedSize">The size that the data section of the packet should be padded to. If throwExceptionOnNotEnoughPadding is true this must be at least the original data packet size plus four bytes</param>
      <param name="paddingType">Determines whether the data is padded with zeros or random data</param>
      <param name="throwExceptionOnNotEnoughPadding">If true an <see cref="T:System.ArgumentException" /> is thrown if paddingSize is smaller than the original data packet size plus four bytes</param>
    </member>
    <member name="T:NetworkCommsDotNet.DPSBase.ArraySerializer">
      <summary>
            Class that provides optimised method for serializing arrays of primitive data types.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.ArraySerializer.SerialiseArrayObject(System.Object,System.Collections.Generic.List{NetworkCommsDotNet.DPSBase.DataProcessor},System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Serializes objectToSerialize to a byte array using compression provided by compressor if T is an array of primitives.  Otherwise returns default value for T.  Override 
            to serialize other types
            </summary>
      <param name="objectToSerialise">Object to serialize</param>
      <param name="dataProcessors">The compression provider to use</param>
      <param name="options">Options to be used during serialization and processing of data</param>
      <returns>The serialized and compressed bytes of objectToSerialize</returns>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.ArraySerializer.DeserialiseArrayObject(System.IO.MemoryStream,System.Type,System.Collections.Generic.List{NetworkCommsDotNet.DPSBase.DataProcessor},System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Deserializes data object held as compressed bytes in receivedObjectBytes using compressor if desired type is an array of primitives
            </summary>
      <param name="inputStream">Byte array containing serialized and compressed object</param>
      <param name="dataProcessors">Compression provider to use</param>
      <param name="objType">The <see cref="T:System.Type" /> of the <see cref="T:System.Object" /> to be returned</param>
      <param name="options">Options to be used during deserialization and processing of data</param>
      <returns>The deserialized object if it is an array, otherwise null</returns>
    </member>
    <member name="T:NetworkCommsDotNet.DPSBase.StreamSendWrapperSerializer">
      <summary>
            Class that provides optimised method for serializing arrays of primitive data types.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.StreamSendWrapperSerializer.SerialiseStreamSendWrapper(NetworkCommsDotNet.Tools.StreamTools.StreamSendWrapper,System.Collections.Generic.List{NetworkCommsDotNet.DPSBase.DataProcessor},System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Serializes StreamSendWrapper to a StreamSendWrapper possibly using provided data processors.  If there are no data processor streamSendWrapperToSerialize will be returned.
            </summary>
      <param name="streamSendWrapperToSerialize">StreamSendWrapper to serialize</param>
      <param name="dataProcessors">The compression provider to use</param>
      <param name="options">Options to be used during serialization and processing of data</param>
      <returns>The serialized and compressed bytes of objectToSerialize</returns>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.StreamSendWrapperSerializer.DeserialiseStreamSendWrapper(System.Byte[],System.Type,System.Collections.Generic.List{NetworkCommsDotNet.DPSBase.DataProcessor},System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Deserializes data object held as compressed bytes in receivedObjectBytes using compressor if desired type is a <see cref="T:NetworkCommsDotNet.Tools.StreamTools.StreamSendWrapper" /></summary>
      <param name="receivedObjectBytes">Byte array containing serialized and compressed object</param>
      <param name="dataProcessors">Compression provider to use</param>
      <param name="objType">The <see cref="T:System.Type" /> of the <see cref="T:System.Object" /> to be returned</param>
      <param name="options">Options to be used during deserialization and processing of data</param>
      <returns>The deserialized object if it is an array, otherwise null</returns>
    </member>
    <member name="T:NetworkCommsDotNet.DPSBase.DataSerializerProcessorAttribute">
      <summary>
            Custom attribute used to keep track of serializers and processors
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DataSerializerProcessorAttribute.#ctor(System.Byte)">
      <summary>
            Create a new instance of this attribute
            </summary>
      <param name="identifier">
      </param>
    </member>
    <member name="P:NetworkCommsDotNet.DPSBase.DataSerializerProcessorAttribute.Identifier">
      <summary>
            A byte identifier, unique amongst all serialisers and data processors.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.DPSBase.SecurityCriticalDataProcessorAttribute">
      <summary>
            Custom attribute used to label data processors as security critical or not
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.SecurityCriticalDataProcessorAttribute.#ctor(System.Boolean)">
      <summary>
            Create a new instance of this attribute
            </summary>
      <param name="isSecurityCritical">
      </param>
    </member>
    <member name="P:NetworkCommsDotNet.DPSBase.SecurityCriticalDataProcessorAttribute.IsSecurityCritical">
      <summary>
            A booling defining if this data processor is security critical
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.DPSBase.DPSManager">
      <summary>
            Automatically detects and manages the use of <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s.  
            Any <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> or <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> in an assembly located in the working 
            directory (including subdirectories) will be automatically detected.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DPSManager.GetDataSerializer``1">
      <summary>
            Retrieves the singleton instance of the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> with <see cref="T:System.Type" /> T
            </summary>
      <typeparam name="T">The <see cref="T:System.Type" /> of the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> to retrieve </typeparam>
      <returns>The retrieved singleton instance of the desired <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /></returns>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DPSManager.GetDataSerializer(System.Byte)">
      <summary>
            Retrieves the singleton instance of the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> corresponding to a given id
            </summary>
      <param name="Id">The identifier corresponding to the desired <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /></param>
      <returns>The retrieved singleton instance of the desired <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /></returns>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DPSManager.GetDataProcessor``1">
      <summary>
            Retrieves the singleton instance of the <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> with <see cref="T:System.Type" /> T
            </summary>
      <typeparam name="T">The <see cref="T:System.Type" /> of the <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to retrieve </typeparam>
      <returns>The retrieved singleton instance of the desired <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /></returns>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DPSManager.GetDataProcessor(System.Byte)">
      <summary>
            Retrieves the singleton instance of the <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> corresponding to a given id
            </summary>
      <param name="Id">The identifier corresponding to the desired <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /></param>
      <returns>The retrieved singleton instance of the desired <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /></returns>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DPSManager.AddDataProcessor(NetworkCommsDotNet.DPSBase.DataProcessor)">
      <summary>
            Allows the addition of <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s which are not auto detected.  Use only if the assembly 
            in which the <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> is defined is not in the working directory (including subfolders) 
            or if automatic detection is not supported on your platform.
            </summary>
      <param name="dataProcessor">The <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to make the <see cref="T:NetworkCommsDotNet.DPSBase.DPSManager" /> aware of</param>
      <exception cref="T:System.ArgumentException">Thrown if A different <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> of the same 
            <see cref="T:System.Type" /> or Id has already been added to the <see cref="T:NetworkCommsDotNet.DPSBase.DPSManager" /></exception>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DPSManager.AddDataSerializer(NetworkCommsDotNet.DPSBase.DataSerializer)">
      <summary>
            Allows the addition of <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" />s which are not auto detected.  Use only if the assembly 
            in which the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> is defined is not in the working directory (including subfolders) 
            or if automatic detection is not supported on your platform
            </summary>
      <param name="dataSerializer">The <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> to make the see <see cref="T:NetworkCommsDotNet.DPSBase.DPSManager" /> aware of</param>
      <exception cref="T:System.ArgumentException">Thrown if A different <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> of the same 
            <see cref="T:System.Type" /> or Id has already been added to the <see cref="T:NetworkCommsDotNet.DPSBase.DPSManager" /></exception>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DPSManager.CreateSerializerDataProcessorIdentifier(NetworkCommsDotNet.DPSBase.DataSerializer,System.Collections.Generic.List{NetworkCommsDotNet.DPSBase.DataProcessor})">
      <summary>
            Generates an <see cref="T:System.Int64" /> describing a <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and a set of <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s
            </summary>
      <param name="serializer">The <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> to be used</param>
      <param name="dataProcessors">A <see cref="M:System.Collections.Generic.List`1.#ctor" /> to be used.  The order of this </param>
      <returns>A <see cref="T:System.Int64" /> describing the arguments</returns>
      <exception cref="T:System.ArgumentException">Thrown is more than 7 <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" />s are used</exception>
      <remarks>This method is used to specify succinctly the serialization method and any data processing that will be 
            used when transmitting data using NetworkCommsDotNet</remarks>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.DPSManager.GetSerializerDataProcessorsFromIdentifier(System.Int64,NetworkCommsDotNet.DPSBase.DataSerializer@,System.Collections.Generic.List{NetworkCommsDotNet.DPSBase.DataProcessor}@)">
      <summary>
            Takes an identifier generated using <see cref="M:NetworkCommsDotNet.DPSBase.DPSManager.CreateSerializerDataProcessorIdentifier(NetworkCommsDotNet.DPSBase.DataSerializer,System.Collections.Generic.List{NetworkCommsDotNet.DPSBase.DataProcessor})" /> and returns 
            the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and set of <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s used to generate the identifier
            </summary>
      <param name="id">The <see cref="T:System.Int64" /> describing the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and a set of <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s</param>
      <param name="serializer">The resultant <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /></param>
      <param name="dataProcessors">A List of the resultant <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s</param>
      <remarks>This method is used to extract the serialization method and any data processing that needs to 
            be used when transmitting data using NetworkCommsDotNet</remarks>
    </member>
    <member name="T:NetworkCommsDotNet.DPSBase.ExplicitSerializer">
      <summary>
            Serializer that will only serialize objects implementing the <see cref="T:NetworkCommsDotNet.DPSBase.IExplicitlySerialize" /> interface
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.ExplicitSerializer.SerialiseDataObjectInt(System.IO.Stream,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.ExplicitSerializer.DeserialiseDataObjectInt(System.IO.Stream,System.Type,System.Collections.Generic.Dictionary{System.String,System.String})">
      <inheritdoc />
    </member>
    <member name="T:NetworkCommsDotNet.DPSBase.NullSerializer">
      <summary>
            Use only when serializing only primitive arrays. Will throw an exception otherwise
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.NullSerializer.SerialiseDataObjectInt(System.IO.Stream,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.NullSerializer.DeserialiseDataObjectInt(System.IO.Stream,System.Type,System.Collections.Generic.Dictionary{System.String,System.String})">
      <inheritdoc />
    </member>
    <member name="P:NetworkCommsDotNet.DPSBase.NullSerializer.Instance">
      <summary>
            Instance singleton used to access serializer instance.  Use instead <see cref="M:NetworkCommsDotNet.DPSBase.DPSManager.GetDataSerializer``1" /></summary>
    </member>
    <member name="T:NetworkCommsDotNet.DPSBase.RijndaelPSKEncrypter">
      <summary>
        <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> which encrypts/decrypts data using the Rijndael algorithm and a pre-shared password
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.RijndaelPSKEncrypter.ForwardProcessDataStream(System.IO.Stream,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String},System.Int64@)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.RijndaelPSKEncrypter.ReverseProcessDataStream(System.IO.Stream,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String},System.Int64@)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.RijndaelPSKEncrypter.AddPasswordToOptions(System.Collections.Generic.Dictionary{System.String,System.String},System.String)">
      <summary>
            Adds a password, using the correct key, to a Dictionary
            </summary>
      <param name="options">The Dictionary to add the option to</param>
      <param name="password">The password</param>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.RijndaelPSKEncrypter.Dispose">
      <summary>
            Dispose of all resources.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.DPSBase.SevenZipLZMACompressor.LZMACompressor">
      <summary>
            Compressor utilizing LZMA algorithm from <see href="http://www.7-zip.org/">7zip</see></summary>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.SevenZipLZMACompressor.LZMACompressor.ForwardProcessDataStream(System.IO.Stream,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String},System.Int64@)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.SevenZipLZMACompressor.LZMACompressor.ReverseProcessDataStream(System.IO.Stream,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String},System.Int64@)">
      <inheritdoc />
    </member>
    <member name="P:NetworkCommsDotNet.DPSBase.SevenZipLZMACompressor.LZMACompressor.Instance">
      <summary>
            Instance singleton used to access <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> instance.  Obsolete, use instead <see cref="M:NetworkCommsDotNet.DPSBase.DPSManager.GetDataProcessor``1" /></summary>
    </member>
    <member name="T:LZMA.InvalidParamException">
      <summary>
            The exception that is thrown when the value of an argument is outside the allowable range.
            </summary>
    </member>
    <member name="T:LZMA.CoderPropID">
      <summary>
            Provides the fields that represent properties idenitifiers for compressing.
            </summary>
    </member>
    <member name="F:LZMA.CoderPropID.DictionarySize">
      <summary>
            Specifies size of dictionary.
            </summary>
    </member>
    <member name="F:LZMA.CoderPropID.UsedMemorySize">
      <summary>
            Specifies size of memory for PPM*.
            </summary>
    </member>
    <member name="F:LZMA.CoderPropID.Order">
      <summary>
            Specifies order for PPM methods.
            </summary>
    </member>
    <member name="F:LZMA.CoderPropID.PosStateBits">
      <summary>
            Specifies number of postion state bits for LZMA 
            </summary>
    </member>
    <member name="F:LZMA.CoderPropID.LitContextBits">
      <summary>
            Specifies number of literal context bits for LZMA 
            </summary>
    </member>
    <member name="F:LZMA.CoderPropID.LitPosBits">
      <summary>
            Specifies number of literal position bits for LZMA
            </summary>
    </member>
    <member name="F:LZMA.CoderPropID.NumFastBytes">
      <summary>
            Specifies number of fast bytes for LZ*.
            </summary>
    </member>
    <member name="F:LZMA.CoderPropID.MatchFinder">
      <summary>
            Specifies match finder. LZMA: "BT2", "BT4" or "BT4B".
            </summary>
    </member>
    <member name="F:LZMA.CoderPropID.NumPasses">
      <summary>
            Specifies number of passes.
            </summary>
    </member>
    <member name="F:LZMA.CoderPropID.Algorithm">
      <summary>
            Specifies number of algorithm.
            </summary>
    </member>
    <member name="F:LZMA.CoderPropID.MultiThread">
      <summary>
            Specifies multithread mode.
            </summary>
    </member>
    <member name="F:LZMA.CoderPropID.EndMarker">
      <summary>
            Specifies mode with end marker.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.CommsException">
      <summary>
            Base exception. All connection related exceptions can be caught in a single catch block by using catch(<see cref="T:NetworkCommsDotNet.CommsException" />)
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.CommsException.#ctor">
      <summary>
            Create a new instance of CommsException
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.CommsException.#ctor(System.String)">
      <summary>
            Create a new instance of CommsException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
    </member>
    <member name="M:NetworkCommsDotNet.CommsException.#ctor(System.String,System.Exception)">
      <summary>
            Create a new instance of CommsException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
      <param name="innerException">An associated inner exception</param>
    </member>
    <member name="M:NetworkCommsDotNet.CommsException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor required by the runtime and by .NET programming conventions
            </summary>
      <param name="info">
      </param>
      <param name="context">
      </param>
    </member>
    <member name="T:NetworkCommsDotNet.CheckSumException">
      <summary>
            A checksum error has occurred. NetworkComms.EnablePacketCheckSumValidation must be set to true for this exception to be thrown.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.CheckSumException.#ctor">
      <summary>
            Create a new instance of CheckSumException
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.CheckSumException.#ctor(System.String)">
      <summary>
            Create a new instance of CheckSumException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
    </member>
    <member name="M:NetworkCommsDotNet.CheckSumException.#ctor(System.String,System.Exception)">
      <summary>
            Create a new instance of CheckSumException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
      <param name="innerException">An associated inner exception</param>
    </member>
    <member name="M:NetworkCommsDotNet.CheckSumException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor required by the runtime and by .NET programming conventions
            </summary>
      <param name="info">
      </param>
      <param name="context">
      </param>
    </member>
    <member name="T:NetworkCommsDotNet.ConfirmationTimeoutException">
      <summary>
            A timeout has occurred while waiting for a confirmation packet to be received. Check for errors and or consider increasing NetworkComms.PacketConfirmationTimeoutMS
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.ConfirmationTimeoutException.#ctor">
      <summary>
            Create a new instance of ConfirmationTimeoutException
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.ConfirmationTimeoutException.#ctor(System.String)">
      <summary>
            Create a new instance of ConfirmationTimeoutException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
    </member>
    <member name="M:NetworkCommsDotNet.ConfirmationTimeoutException.#ctor(System.String,System.Exception)">
      <summary>
            Create a new instance of ConfirmationTimeoutException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
      <param name="innerException">An associated inner exception</param>
    </member>
    <member name="M:NetworkCommsDotNet.ConfirmationTimeoutException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor required by the runtime and by .NET programming conventions
            </summary>
      <param name="info">
      </param>
      <param name="context">
      </param>
    </member>
    <member name="T:NetworkCommsDotNet.ExpectedReturnTimeoutException">
      <summary>
            A timeout has occurred while waiting for an expected return object. Check for errors and or consider increasing the provided return timeout value.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.ExpectedReturnTimeoutException.#ctor">
      <summary>
            Create a new instance of ExpectedReturnTimeoutException
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.ExpectedReturnTimeoutException.#ctor(System.String)">
      <summary>
            Create a new instance of ExpectedReturnTimeoutException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
    </member>
    <member name="M:NetworkCommsDotNet.ExpectedReturnTimeoutException.#ctor(System.String,System.Exception)">
      <summary>
            Create a new instance of ExpectedReturnTimeoutException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
      <param name="innerException">An associated inner exception</param>
    </member>
    <member name="M:NetworkCommsDotNet.ExpectedReturnTimeoutException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor required by the runtime and by .NET programming conventions
            </summary>
      <param name="info">
      </param>
      <param name="context">
      </param>
    </member>
    <member name="T:NetworkCommsDotNet.SerialisationException">
      <summary>
            An error occurred while trying to serialise/compress or deserialise/uncompress an object.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.SerialisationException.#ctor">
      <summary>
            Create a new instance of SerialisationException
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.SerialisationException.#ctor(System.String)">
      <summary>
            Create a new instance of SerialisationException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
    </member>
    <member name="M:NetworkCommsDotNet.SerialisationException.#ctor(System.String,System.Exception)">
      <summary>
            Create a new instance of SerialisationException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
      <param name="innerException">An associated inner exception</param>
    </member>
    <member name="M:NetworkCommsDotNet.SerialisationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor required by the runtime and by .NET programming conventions
            </summary>
      <param name="info">
      </param>
      <param name="context">
      </param>
    </member>
    <member name="T:NetworkCommsDotNet.ConnectionSetupException">
      <summary>
            An error occurred while trying to establish a Connection
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionSetupException.#ctor">
      <summary>
            Create a new instance of ConnectionSetupException
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionSetupException.#ctor(System.String)">
      <summary>
            Create a new instance of ConnectionSetupException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionSetupException.#ctor(System.String,System.Exception)">
      <summary>
            Create a new instance of ConnectionSetupException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
      <param name="innerException">An associated inner exception</param>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionSetupException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor required by the runtime and by .NET programming conventions
            </summary>
      <param name="info">
      </param>
      <param name="context">
      </param>
    </member>
    <member name="T:NetworkCommsDotNet.ConnectionShutdownException">
      <summary>
            An error occurred while trying to establish a Connection
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionShutdownException.#ctor">
      <summary>
            Create a new instance of ConnectionShutdownException
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionShutdownException.#ctor(System.String)">
      <summary>
            Create a new instance of ConnectionShutdownException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionShutdownException.#ctor(System.String,System.Exception)">
      <summary>
            Create a new instance of ConnectionShutdownException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
      <param name="innerException">An associated inner exception</param>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionShutdownException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor required by the runtime and by .NET programming conventions
            </summary>
      <param name="info">
      </param>
      <param name="context">
      </param>
    </member>
    <member name="T:NetworkCommsDotNet.CommsSetupShutdownException">
      <summary>
            An error occurred while trying to setup or shutdown NetworkComms.Net
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.CommsSetupShutdownException.#ctor">
      <summary>
            Create a new instance of CommsSetupShutdownException
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.CommsSetupShutdownException.#ctor(System.String)">
      <summary>
            Create a new instance of CommsSetupShutdownException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
    </member>
    <member name="M:NetworkCommsDotNet.CommsSetupShutdownException.#ctor(System.String,System.Exception)">
      <summary>
            Create a new instance of CommsSetupShutdownException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
      <param name="innerException">An associated inner exception</param>
    </member>
    <member name="M:NetworkCommsDotNet.CommsSetupShutdownException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor required by the runtime and by .NET programming conventions
            </summary>
      <param name="info">
      </param>
      <param name="context">
      </param>
    </member>
    <member name="T:NetworkCommsDotNet.CommunicationException">
      <summary>
            An error occurred while during communication which does not fall under other exception cases.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.CommunicationException.#ctor">
      <summary>
            Create a new instance of CommunicationException
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.CommunicationException.#ctor(System.String)">
      <summary>
            Create a new instance of CommunicationException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
    </member>
    <member name="M:NetworkCommsDotNet.CommunicationException.#ctor(System.String,System.Exception)">
      <summary>
            Create a new instance of CommunicationException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
      <param name="innerException">An associated inner exception</param>
    </member>
    <member name="M:NetworkCommsDotNet.CommunicationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor required by the runtime and by .NET programming conventions
            </summary>
      <param name="info">
      </param>
      <param name="context">
      </param>
    </member>
    <member name="T:NetworkCommsDotNet.UnexpectedPacketTypeException">
      <summary>
            An unexpected incoming packetType has been received. Consider setting NetworkComms.IgnoreUnknownPacketTypes to true to prevent this exception.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.UnexpectedPacketTypeException.#ctor">
      <summary>
            Create a new instance of UnexpectedPacketTypeException
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.UnexpectedPacketTypeException.#ctor(System.String)">
      <summary>
            Create a new instance of UnexpectedPacketTypeException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
    </member>
    <member name="M:NetworkCommsDotNet.UnexpectedPacketTypeException.#ctor(System.String,System.Exception)">
      <summary>
            Create a new instance of UnexpectedPacketTypeException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
      <param name="innerException">An associated inner exception</param>
    </member>
    <member name="M:NetworkCommsDotNet.UnexpectedPacketTypeException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor required by the runtime and by .NET programming conventions
            </summary>
      <param name="info">
      </param>
      <param name="context">
      </param>
    </member>
    <member name="T:NetworkCommsDotNet.InvalidNetworkIdentifierException">
      <summary>
            An invalid network identifier has been provided.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.InvalidNetworkIdentifierException.#ctor">
      <summary>
            Create a new instance of InvalidNetworkIdentifierException
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.InvalidNetworkIdentifierException.#ctor(System.String)">
      <summary>
            Create a new instance of InvalidNetworkIdentifierException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
    </member>
    <member name="M:NetworkCommsDotNet.InvalidNetworkIdentifierException.#ctor(System.String,System.Exception)">
      <summary>
            Create a new instance of InvalidNetworkIdentifierException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
      <param name="innerException">An associated inner exception</param>
    </member>
    <member name="M:NetworkCommsDotNet.InvalidNetworkIdentifierException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor required by the runtime and by .NET programming conventions
            </summary>
      <param name="info">
      </param>
      <param name="context">
      </param>
    </member>
    <member name="T:NetworkCommsDotNet.DuplicateConnectionException">
      <summary>
            A possible duplicate connection has been detected.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.DuplicateConnectionException.#ctor">
      <summary>
            Create a new instance of DuplicateConnectionException
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.DuplicateConnectionException.#ctor(System.String)">
      <summary>
            Create a new instance of DuplicateConnectionException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
    </member>
    <member name="M:NetworkCommsDotNet.DuplicateConnectionException.#ctor(System.String,System.Exception)">
      <summary>
            Create a new instance of DuplicateConnectionException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
      <param name="innerException">An associated inner exception</param>
    </member>
    <member name="M:NetworkCommsDotNet.DuplicateConnectionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor required by the runtime and by .NET programming conventions
            </summary>
      <param name="info">
      </param>
      <param name="context">
      </param>
    </member>
    <member name="T:NetworkCommsDotNet.ConnectionSendTimeoutException">
      <summary>
            A connection send has timed out.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionSendTimeoutException.#ctor">
      <summary>
            Create a new instance of ConnectionSendTimeoutException
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionSendTimeoutException.#ctor(System.String)">
      <summary>
            Create a new instance of ConnectionSendTimeoutException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionSendTimeoutException.#ctor(System.String,System.Exception)">
      <summary>
            Create a new instance of ConnectionSendTimeoutException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
      <param name="innerException">An associated inner exception</param>
    </member>
    <member name="M:NetworkCommsDotNet.ConnectionSendTimeoutException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor required by the runtime and by .NET programming conventions
            </summary>
      <param name="info">
      </param>
      <param name="context">
      </param>
    </member>
    <member name="T:NetworkCommsDotNet.PacketHandlerException">
      <summary>
            An error occurred during a packetType data handler execution.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.PacketHandlerException.#ctor">
      <summary>
            Create a new instance of PacketHandlerException
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.PacketHandlerException.#ctor(System.String)">
      <summary>
            Create a new instance of PacketHandlerException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
    </member>
    <member name="M:NetworkCommsDotNet.PacketHandlerException.#ctor(System.String,System.Exception)">
      <summary>
            Create a new instance of PacketHandlerException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
      <param name="innerException">An associated inner exception</param>
    </member>
    <member name="M:NetworkCommsDotNet.PacketHandlerException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Constructor required by the runtime and by .NET programming conventions
            </summary>
      <param name="info">
      </param>
      <param name="context">
      </param>
    </member>
    <member name="T:NetworkCommsDotNet.NetworkComms">
      <summary>
            Top level interface for NetworkComms.Net library. Anything which is not connection specific generally happens 
            within the NetworkComms class. e.g. Keeping track of all connections, global defaults and settings, serialisers 
            and data processors etc.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.NetworkComms.PacketHandlerCallBackDelegate`1">
      <summary>
            Delegate for handling incoming packets. See AppendGlobalIncomingPacketHandler members.
            </summary>
      <typeparam name="incomingObjectType">The type of object which is expected for this handler</typeparam>
      <param name="packetHeader">The <see cref="T:NetworkCommsDotNet.PacketHeader" /> of the incoming packet</param>
      <param name="connection">The connection with which this packet was received</param>
      <param name="incomingObject">The incoming object of specified type T</param>
    </member>
    <member name="T:NetworkCommsDotNet.NetworkComms.ConnectionEstablishShutdownDelegate">
      <summary>
            Delegate which is executed when a connection is established or shutdown. See <see cref="M:NetworkCommsDotNet.NetworkComms.AppendGlobalConnectionEstablishHandler(NetworkCommsDotNet.NetworkComms.ConnectionEstablishShutdownDelegate,System.Boolean)" /> and <see cref="M:NetworkCommsDotNet.NetworkComms.AppendGlobalConnectionCloseHandler(NetworkCommsDotNet.NetworkComms.ConnectionEstablishShutdownDelegate)" />.
            </summary>
      <param name="connection">The connection which has been established or shutdown.</param>
    </member>
    <member name="F:NetworkCommsDotNet.NetworkComms.randomGen">
      <summary>
            An internal random object
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.NetworkComms.commsShutdown">
      <summary>
            A single boolean used to control a NetworkCommsDotNet shutdown
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.NetworkComms.totalPacketSendCount">
      <summary>
            A running total of the number of packets sent on all connections. Used to initialise packet sequence counters to ensure 
            duplicates can not occur.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.NetworkComms.globalDictAndDelegateLocker">
      <summary>
            Locker for connection dictionaries
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.NetworkComms.allConnectionsByIdentifier">
      <summary>
            Primary connection dictionary stored by network identifier
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.NetworkComms.allConnectionsByEndPoint">
      <summary>
            Secondary connection dictionary stored by end point. First key is connection type, second key is remote IPEndPoint, third 
            key is local IPEndPoint
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.NetworkComms.oldNetworkIdentifierToConnectionInfo">
      <summary>
            Old connection cache so that requests for connectionInfo can be returned even after a connection has been closed.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.NetworkComms.timeCriticalThreadPriority">
      <summary>
            In times of high CPU usage we need to ensure that certain time critical functions, like connection handshaking do not timeout.
            This sets the thread priority for those processes.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.NetworkComms.ReservedPacketTypeNames">
      <summary>
            An internal reference copy of all reservedPacketTypeNames, key is packet type name
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.NetworkComms.globalIncomingPacketHandlers">
      <summary>
            Dictionary of all custom packetHandlers. Key is packetType.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.NetworkComms.globalIncomingPacketUnwrappers">
      <summary>
            Dictionary of any non default custom packet unwrappers. Key is packetType.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.NetworkComms.globalConnectionShutdownDelegates">
      <summary>
            Multicast delegate pointer for connection shutdowns.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.NetworkComms.globalConnectionShutdownDelegateCount">
      <summary>
            Delegate counter for debugging.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.NetworkComms.globalConnectionEstablishDelegatesAsync">
      <summary>
            Multicast delegate pointer for connection establishments, run asynchronously.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.NetworkComms.globalConnectionEstablishDelegatesSync">
      <summary>
            Multicast delegate pointer for connection establishments, run synchronously.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.NetworkComms.globalConnectionEstablishDelegateCount">
      <summary>
            Delegate counter for debugging.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.CompleteIncomingItemTask(System.Object)">
      <summary>
            Once we have received all incoming data we handle it further. This is performed at the global level to help support different 
            priorities.
            </summary>
      <param name="priorityQueueItemObj">Possible PriorityQueueItem. If null is provided an item will be removed from the global item queue</param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.AppendGlobalIncomingPacketHandler``1(System.String,NetworkCommsDotNet.NetworkComms.PacketHandlerCallBackDelegate{``0})">
      <summary>
            Add an incoming packet handler using default SendReceiveOptions. Multiple handlers for the same packet type will be 
            executed in the order they are added.
            </summary>
      <typeparam name="incomingObjectType">The type of incoming object</typeparam>
      <param name="packetTypeStr">The packet type for which this handler will be executed</param>
      <param name="packetHandlerDelgatePointer">The delegate to be executed when a packet of packetTypeStr is received</param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.AppendGlobalIncomingPacketHandler``1(System.String,NetworkCommsDotNet.NetworkComms.PacketHandlerCallBackDelegate{``0},NetworkCommsDotNet.SendReceiveOptions)">
      <summary>
            Add an incoming packet handler using the provided SendReceiveOptions. Multiple handlers for the same packet type will be executed in the order they are added.
            </summary>
      <typeparam name="incomingObjectType">The type of incoming object</typeparam>
      <param name="packetTypeStr">The packet type for which this handler will be executed</param>
      <param name="packetHandlerDelgatePointer">The delegate to be executed when a packet of packetTypeStr is received</param>
      <param name="sendReceiveOptions">The SendReceiveOptions to be used for the provided packet type</param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.AppendGlobalIncomingUnmanagedPacketHandler(NetworkCommsDotNet.NetworkComms.PacketHandlerCallBackDelegate{System.Byte[]})">
      <summary>
            Add an incoming packet handler for unmanaged packets. Multiple handlers will be executed in the order they are added.
            </summary>
      <param name="packetHandlerDelgatePointer">The delegate to be executed when an unmanaged packet is received</param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.RemoveGlobalIncomingUnmanagedPacketHandler``1(NetworkCommsDotNet.NetworkComms.PacketHandlerCallBackDelegate{``0})">
      <summary>
            Removes the provided delegate for unmanaged packet types. If the provided delegate does not exist for this packet type just returns.
            </summary>
      <param name="packetHandlerDelgatePointer">The delegate to be removed</param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.RemoveGlobalIncomingPacketHandler``1(System.String,NetworkCommsDotNet.NetworkComms.PacketHandlerCallBackDelegate{``0})">
      <summary>
            Removes the provided delegate for the specified packet type. If the provided delegate does not exist for this packet type just returns.
            </summary>
      <param name="packetTypeStr">The packet type for which the delegate will be removed</param>
      <param name="packetHandlerDelgatePointer">The delegate to be removed</param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.RemoveGlobalIncomingPacketHandler(System.String)">
      <summary>
            Removes all delegates for the provided packet type.
            </summary>
      <param name="packetTypeStr">Packet type for which all delegates should be removed</param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.RemoveGlobalIncomingUnmanagedPacketHandler">
      <summary>
            Removes all unmanaged packet handlers.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.RemoveGlobalIncomingPacketHandler">
      <summary>
            Removes all delegates for all packet types
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.TriggerGlobalPacketHandlers(NetworkCommsDotNet.PacketHeader,NetworkCommsDotNet.Connections.Connection,System.IO.MemoryStream,NetworkCommsDotNet.SendReceiveOptions)">
      <summary>
            Trigger incoming packet delegates for the provided parameters.
            </summary>
      <param name="packetHeader">The packet header</param>
      <param name="connection">The incoming connection</param>
      <param name="incomingDataStream">The bytes corresponding to the incoming object</param>
      <param name="options">The SendReceiveOptions to be used to convert incomingObjectBytes back to the desired object</param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.TriggerGlobalPacketHandlers(NetworkCommsDotNet.PacketHeader,NetworkCommsDotNet.Connections.Connection,System.IO.MemoryStream,NetworkCommsDotNet.SendReceiveOptions,System.Boolean)">
      <summary>
            Trigger incoming packet delegates for the provided parameters.
            </summary>
      <param name="packetHeader">The packet header</param>
      <param name="connection">The incoming connection</param>
      <param name="incomingDataStream">The bytes corresponding to the incoming object</param>
      <param name="options">The SendReceiveOptions to be used to convert incomingObjectBytes back to the desired object</param>
      <param name="ignoreUnknownPacketTypeOverride">Used to potentially override NetworkComms.IgnoreUnknownPacketTypes property</param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.TriggerGlobalPacketHandlers(NetworkCommsDotNet.PacketHeader,NetworkCommsDotNet.Connections.Connection,System.Object)">
      <summary>
            Trigger incoming packet delegates for the provided parameters.
            </summary>
      <param name="packetHeader">The packet header</param>
      <param name="connection">The incoming connection</param>
      <param name="returnObject">The deserialised payload object</param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.TriggerGlobalPacketHandlers(NetworkCommsDotNet.PacketHeader,NetworkCommsDotNet.Connections.Connection,System.Object,System.Boolean)">
      <summary>
            Trigger incoming packet delegates for the provided parameters.
            </summary>
      <param name="packetHeader">The packet header</param>
      <param name="connection">The incoming connection</param>
      <param name="returnObject">The deserialised payload object</param>
      <param name="ignoreUnknownPacketTypeOverride">Used to potentially override NetworkComms.IgnoreUnknownPacketTypes property</param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.TriggerAllPacketHandlers(NetworkCommsDotNet.PacketHeader,NetworkCommsDotNet.Connections.Connection,System.IO.MemoryStream,NetworkCommsDotNet.SendReceiveOptions)">
      <summary>
            Trigger both globally defined and connection specific handlers for a packet type
            </summary>
      <param name="packetHeader">The header of the packet</param>
      <param name="connection">The connection on which the packet was recieved</param>
      <param name="dataStream">The <see cref="T:System.IO.Stream" /> containing the payload data of the packet</param>
      <param name="options">Options containing deserialisation parameters</param>
      <remarks>This method is likely to be marked for removal at some point in the future</remarks>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.TriggerAllPacketHandlers(NetworkCommsDotNet.PacketHeader,NetworkCommsDotNet.Connections.Connection,System.IO.MemoryStream,NetworkCommsDotNet.SendReceiveOptions,System.Boolean)">
      <summary>
            Trigger both globally defined and connection specific handlers for a packet type
            </summary>
      <param name="packetHeader">The header of the packet</param>
      <param name="connection">The connection on which the packet was recieved</param>
      <param name="dataStream">The <see cref="T:System.IO.Stream" /> containing the payload data of the packet</param>
      <param name="options">Options containing deserialisation parameters</param>
      <param name="ignoreUnknownPacketTypeOverride">Used to potentially override NetworkComms.IgnoreUnknownPacketTypes property</param>
      <remarks>This method is likely to be marked for removal at some point in the future</remarks>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.GlobalPacketTypeUnwrapperOptions(System.String)">
      <summary>
            Returns the unwrapper <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> for the provided packet type. If no specific options are registered returns null.
            </summary>
      <param name="packetTypeStr">The packet type for which the <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> are required</param>
      <returns>The requested <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> otherwise null</returns>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.GlobalIncomingPacketHandlerExists(System.String)">
      <summary>
            Returns true if a global packet handler exists for the provided packet type.
            </summary>
      <param name="packetTypeStr">The packet type for which to check incoming packet handlers</param>
      <returns>True if a global packet handler exists</returns>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.GlobalIncomingUnmanagedPacketHandlerExists">
      <summary>
            Returns true if a global unmanaged packet handler exists
            </summary>
      <returns>True if a global unmanaged packet handler exists</returns>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.GlobalIncomingPacketHandlerExists``1(System.String,NetworkCommsDotNet.NetworkComms.PacketHandlerCallBackDelegate{``0})">
      <summary>
            Returns true if the provided global packet handler has been added for the provided packet type.
            </summary>
      <param name="packetTypeStr">The packet type within which to check packet handlers</param>
      <param name="packetHandlerDelgatePointer">The packet handler to look for</param>
      <returns>True if a global packet handler exists for the provided packetType</returns>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.GlobalIncomingUnmanagedPacketHandlerExists``1(NetworkCommsDotNet.NetworkComms.PacketHandlerCallBackDelegate{``0})">
      <summary>
            Returns true if the provided global unmanaged packet handler has been added.
            </summary>
      <param name="packetHandlerDelgatePointer">The packet handler to look for.</param>
      <returns>True if a global unmanaged packet handler exists.</returns>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.AppendGlobalConnectionCloseHandler(NetworkCommsDotNet.NetworkComms.ConnectionEstablishShutdownDelegate)">
      <summary>
            Add a new connection shutdown delegate which will be called for every connection as it is closes.
            </summary>
      <param name="connectionShutdownDelegate">The delegate to call on all connection shutdowns</param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.RemoveGlobalConnectionCloseHandler(NetworkCommsDotNet.NetworkComms.ConnectionEstablishShutdownDelegate)">
      <summary>
            Remove a connection shutdown delegate.
            </summary>
      <param name="connectionShutdownDelegate">The delegate to remove from connection shutdown events</param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.AppendGlobalConnectionEstablishHandler(NetworkCommsDotNet.NetworkComms.ConnectionEstablishShutdownDelegate,System.Boolean)">
      <summary>
            Add a new connection establish delegate which will be called for every connection once it has been successfully established.
            </summary>
      <param name="connectionEstablishDelegate">The delegate to call after all connection establishments.</param>
      <param name="runSynchronously">If true this ConnectionEstablishShutdownDelegate will be called synchronously during the 
            connection establish. The connection will not be considered established until the ConnectionEstablishShutdownDelegate has completed.</param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.RemoveGlobalConnectionEstablishHandler(NetworkCommsDotNet.NetworkComms.ConnectionEstablishShutdownDelegate)">
      <summary>
            Remove a connection establish delegate.
            </summary>
      <param name="connectionEstablishDelegate">The delegate to remove from connection establish events</param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.Shutdown(System.Int32)">
      <summary>
            Shutdown all connections, threads and execute OnCommsShutdown event. Any packet handlers are left unchanged. If any network
            activity has taken place this should be called on application close.
            </summary>
      <param name="threadShutdownTimeoutMS">The time to wait for worker threads to close before attempting a thread abort.</param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.EnableLogging">
      <summary>
            Enable logging using a default config. All log output is written directly to the local console.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.EnableLogging(NetworkCommsDotNet.Tools.ILogger)">
      <summary>
            Enable logging using the provided config. See examples for usage.
            </summary>
      <param name="logger">The logger to use for logging</param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.DisableLogging">
      <summary>
            Disable all logging in NetworkCommsDotNet
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.SendObject``1(System.String,System.String,System.Int32,``0)">
      <summary>
            Send the provided object to the specified destination using TCP. Uses default sendReceiveOptions. For more control over 
            options see connection specific methods.
            </summary>
      <param name="packetTypeStr">Packet type to use for send</param>
      <param name="destinationIPAddress">The destination IP address</param>
      <param name="destinationPort">The destination listen port</param>
      <param name="sendObject">The object to send</param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.SendReceiveObject``2(System.String,System.String,System.Int32,System.String,System.Int32,``0)">
      <summary>
            Send the provided object to the specified destination and wait for a return object using TCP. Uses default sendReceiveOptions. 
            For more control over options see connection specific methods.
            </summary>
      <typeparam name="sendObjectType">The sending object type, i.e. string, int[], etc</typeparam>
      <typeparam name="returnObjectType">The expected return object type, i.e. string, int[], etc</typeparam>
      <param name="sendingPacketTypeStr">Packet type to use during send</param>
      <param name="destinationIPAddress">The destination IP address</param>
      <param name="destinationPort">The destination listen port</param>
      <param name="expectedReturnPacketTypeStr">Expected packet type used for return object</param>
      <param name="returnPacketTimeOutMilliSeconds">Time to wait in milliseconds for return object</param>
      <param name="sendObject">Object to send</param>
      <returns>The expected return object</returns>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.AllConnectionInfo(System.Boolean)">
      <summary>
            Returns a ConnectionInfo array containing information for all connections
            </summary>
      <param name="includeClosedConnections">If true information for closed connections will also be included</param>
      <returns>List of ConnectionInfo containing information for all requested connections</returns>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.AllConnectionInfo(NetworkCommsDotNet.Tools.ShortGuid,System.Boolean)">
      <summary>
            Returns a ConnectionInfo array containing information for all connections which have the provided networkIdentifier. 
            It is also possible to include information for closed connections.
            </summary>
      <param name="networkIdentifier">The networkIdentifier corresponding to the desired connectionInfo information</param>
      <param name="includeClosedConnections">If true will include information for connections which are closed. Otherwise only 
            active connections will be included.</param>
      <returns>List of ConnectionInfo containing information for matching connections</returns>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.TotalNumConnections">
      <summary>
            Returns the total number of connections
            </summary>
      <returns>Total number of connections</returns>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.TotalNumConnections(NetworkCommsDotNet.Connections.ConnectionType)">
      <summary>
            Returns the total number of connections of the provided type
            </summary>
      <param name="connectionType">The type of connections to count</param>
      <returns>Total number of connections</returns>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.TotalNumConnections(System.Net.IPAddress)">
      <summary>
            Returns the total number of connections where the <see cref="P:NetworkCommsDotNet.ConnectionInfo.RemoteEndPoint" /> matches the provided 
            <see cref="T:System.Net.IPAddress" /></summary>
      <param name="matchRemoteEndPointIP">The <see cref="T:System.Net.IPAddress" /> to match</param>
      <returns>Total number of connections where the <see cref="P:NetworkCommsDotNet.ConnectionInfo.RemoteEndPoint" /> matches the provided 
            <see cref="T:System.Net.IPAddress" /></returns>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.CloseAllConnections">
      <summary>
            Close all connections
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.CloseAllConnections(NetworkCommsDotNet.Connections.ConnectionType)">
      <summary>
            Close all connections of the provided <see cref="T:NetworkCommsDotNet.Connections.ConnectionType" /></summary>
      <param name="connectionType">The type of connections to be closed</param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.CloseAllConnections(NetworkCommsDotNet.Connections.ConnectionType,System.Net.EndPoint[])">
      <summary>
            Close all connections of the provided <see cref="T:NetworkCommsDotNet.Connections.ConnectionType" /> except to provided <see cref="T:System.Net.EndPoint" /> array.
            </summary>
      <param name="connectionTypeToClose">The type of connections to be closed. ConnectionType.<see cref="F:NetworkCommsDotNet.Connections.ConnectionType.Undefined" /> matches all types.</param>
      <param name="closeAllExceptTheseRemoteEndPoints">Close all except those with remote EndPoint that is provided in <see cref="T:System.Net.EndPoint" /> array</param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.GetExistingConnection(NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus)">
      <summary>
            Returns a list of all connections which match the provided parameters. If no parameter are provided returns all connections.
            </summary>
      <param name="applicationLayerProtocol">Connections with matching ApplicationLayerProtocolStatus.
            Use ApplicationLayerProtocolStatus.<see cref="F:NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus.Undefined" /> to match all status types.</param>
      <returns>A list of requested connections. If no matching connections exist returns empty list.</returns>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.GetExistingConnection(NetworkCommsDotNet.Connections.ConnectionType,NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus)">
      <summary>
            Returns a list of all connections matching the provided parameters.
            </summary>
      <param name="connectionType">The type of connections to return. ConnectionType.<see cref="F:NetworkCommsDotNet.Connections.ConnectionType.Undefined" /> matches 
            all types.</param>
      <param name="applicationLayerProtocol">Connections with matching ApplicationLayerProtocolStatus.
            Use ApplicationLayerProtocolStatus.<see cref="F:NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus.Undefined" /> to match all status types.</param>
      <returns>A list of requested connections. If no matching connections exist returns empty list.</returns>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.GetExistingConnection(NetworkCommsDotNet.Tools.ShortGuid,NetworkCommsDotNet.Connections.ConnectionType,NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus)">
      <summary>
            Returns a list of all connections matching the provided parameters.
            </summary>
      <param name="networkIdentifier">The <see cref="T:NetworkCommsDotNet.Tools.ShortGuid" /> corresponding with the desired peer networkIdentifier</param>
      <param name="connectionType">The <see cref="T:NetworkCommsDotNet.Connections.ConnectionType" /> desired. ConnectionType.<see cref="F:NetworkCommsDotNet.Connections.ConnectionType.Undefined" /> 
            matches all types.</param>
      <param name="applicationLayerProtocol">Connections with matching ApplicationLayerProtocolStatus.
            Use ApplicationLayerProtocolStatus.<see cref="F:NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus.Undefined" /> to match all status types.</param>
      <returns>A list of connections to the desired peer. If no matching connections exist returns empty list.</returns>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.GetExistingConnection(System.Net.EndPoint,System.Net.EndPoint,NetworkCommsDotNet.Connections.ConnectionType,NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus)">
      <summary>
            Returns a list of all connections matching the provided parameters.
            </summary>
      <param name="remoteEndPoint">Remote EndPoint corresponding with the desired connection. Use IPAddress.Any to match all 
            IPAddresses. Use port number 0 to match all port numbers.</param>
      <param name="localEndPoint">Local EndPoint corresponding with the desired connection. Use IPAddress.Any to match all 
            IPAddresses. Use port number 0 to match all port numbers.</param>
      <param name="connectionType">The <see cref="T:NetworkCommsDotNet.Connections.ConnectionType" /> desired. ConnectionType.<see cref="F:NetworkCommsDotNet.Connections.ConnectionType.Undefined" /> 
            matches all types.</param>
      <param name="applicationLayerProtocol">Connections with matching ApplicationLayerProtocolStatus.
            Use ApplicationLayerProtocolStatus.<see cref="F:NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus.Undefined" /> to match all status types.</param>
      <returns>A list of connections to the desired peer. If no matching connections exists returns empty list.</returns>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.GetExistingConnection(NetworkCommsDotNet.ConnectionInfo)">
      <summary>
            Retrieve an existing connection with the provided ConnectionInfo. Internally matches connection based on IPEndPoint, ConnectionType,
            NetworkIdentifier and ApplicationLayerProtocol status.
            </summary>
      <param name="connectionInfo">ConnectionInfo corresponding with the desired connection.</param>
      <returns>The desired connection. If no matching connection exists returns null.</returns>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.ConnectionExists(NetworkCommsDotNet.ConnectionInfo)">
      <summary>
            Check if a connection with the provided ConnectionInfo exists. Internally matches connection based on IPEndPoint, ConnectionType,
            NetworkIdentifier and ApplicationLayerProtocol status.
            </summary>
      <param name="connectionInfo">ConnectionInfo corresponding with the desired connection</param>
      <returns>True if a matching connection exists, otherwise false</returns>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.ConnectionExists(NetworkCommsDotNet.Tools.ShortGuid,NetworkCommsDotNet.Connections.ConnectionType,NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus)">
      <summary>
            Check if a connection exists with the provided parameters.
            </summary>
      <param name="networkIdentifier">The <see cref="T:NetworkCommsDotNet.Tools.ShortGuid" /> corresponding with the desired peer networkIdentifier</param>
      <param name="connectionType">The <see cref="T:NetworkCommsDotNet.Connections.ConnectionType" /> desired. ConnectionType.<see cref="F:NetworkCommsDotNet.Connections.ConnectionType.Undefined" /> 
            matches all types.</param>
      <param name="applicationLayerProtocol">Connections with matching ApplicationLayerProtocolStatus.
            Use ApplicationLayerProtocolStatus.<see cref="F:NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus.Undefined" /> to match all status types.</param>
      <returns>True if a matching connection exists, otherwise false</returns>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.ConnectionExists(System.Net.EndPoint,System.Net.EndPoint,NetworkCommsDotNet.Connections.ConnectionType,NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus)">
      <summary>
            Check if a connection exists with the provided parameters.
            </summary>
      <param name="remoteEndPoint">Remote EndPoint corresponding with the desired connection. Use IPAddress.Any to match all 
            IPAddresses. Use port number 0 to match all port numbers.</param>
      <param name="localEndPoint">Local EndPoint corresponding with the desired connection. Use IPAddress.Any to match all 
            IPAddresses. Use port number 0 to match all port numbers.</param>
      <param name="connectionType">The <see cref="T:NetworkCommsDotNet.Connections.ConnectionType" /> desired. ConnectionType.<see cref="F:NetworkCommsDotNet.Connections.ConnectionType.Undefined" />
            matches all types.</param>
      <param name="applicationLayerProtocol">Connections with matching ApplicationLayerProtocolStatus.
            Use ApplicationLayerProtocolStatus.<see cref="F:NetworkCommsDotNet.Connections.ApplicationLayerProtocolStatus.Undefined" /> to match all status types.</param>
      <returns>True if a matching connection exists, otherwise false</returns>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.RemoveConnectionReference(NetworkCommsDotNet.Connections.Connection,System.Boolean)">
      <summary>
            Removes the reference to the provided connection from within networkComms. DOES NOT CLOSE THE CONNECTION. Returns true if 
            the provided connection reference existed and was removed, false otherwise.
            </summary>
      <param name="connection">
      </param>
      <param name="maintainConnectionInfoHistory">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.AddConnectionReferenceByRemoteEndPoint(NetworkCommsDotNet.Connections.Connection,System.Net.EndPoint,System.Net.EndPoint)">
      <summary>
            Adds a reference by EndPoint to the provided connection within networkComms.
            </summary>
      <param name="connection">
      </param>
      <param name="remoteEndPointToUse">An optional override which forces a specific remote EndPoint</param>
      <param name="localEndPointToUse">An optional override which forces a specific local EndPoint</param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.UpdateConnectionReferenceByEndPoint(NetworkCommsDotNet.Connections.Connection,System.Net.EndPoint,System.Net.EndPoint)">
      <summary>
            Update the endPoint reference for the provided connection with the newEndPoint. If there is no change just returns
            </summary>
      <param name="connection">
      </param>
      <param name="newRemoteEndPoint">
      </param>
      <param name="newLocalEndPoint">
      </param>
    </member>
    <member name="M:NetworkCommsDotNet.NetworkComms.AddConnectionReferenceByIdentifier(NetworkCommsDotNet.Connections.Connection)">
      <summary>
            Add a reference by networkIdentifier to the provided connection within NetworkComms.Net. Requires a reference by 
            EndPoint to already exist.
            </summary>
      <param name="connection">
      </param>
    </member>
    <member name="P:NetworkCommsDotNet.NetworkComms.NetworkIdentifier">
      <summary>
            The local identifier for this instance of NetworkCommsDotNet. This is an application unique identifier.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.NetworkComms.CurrentRuntimeEnvironment">
      <summary>
            The current runtime environment. Detected automatically on start up. Performance may be adversely affected if this is changed.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.NetworkComms.ConnectionListenModeUseSync">
      <summary>
            Used for switching between async and sync connectionListen modes. Default is false. No noticeable performance difference 
            between the two modes when used with a small number of connections. For use cases with a high turnover of connections, i.e. 100/sec, performance is
            considerably better when ConnectionListenModeUseSync is set to true.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.NetworkComms.MaxReceiveBufferSizeBytes">
      <summary>
            Maximum data buffer size that will be allocated for reading. Default is 80KB. CAUTION: Changing the default value can lead to performance degradation.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.NetworkComms.InitialReceiveBufferSizeBytes">
      <summary>
            Initial receive data buffer size for reading data. Keeping this small reduces the static size of connection objects which each have an internal buffer. Default is 512 bytes. CAUTION: Changing the default value can lead to performance degradation.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.NetworkComms.SendBufferSizeBytes">
      <summary>
            Send data buffer size. Default is 80KB. CAUTION: Changing the default value can lead to performance degradation.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.NetworkComms.CommsThreadPool">
      <summary>
            The thread pool used by NetworkComms.Net to execute incoming packet handlers.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.NetworkComms.IncomingConnectionEstablishThreadPool">
      <summary>
            The thread pool used by NetworkComms.Net to handle all incoming connection establishes.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.NetworkComms.EnablePacketCheckSumValidation">
      <summary>
            When enabled uses an MD5 checksum to validate all received packets. Default is false, relying on any possible connection 
            checksum alone. Also when enabled any packets sent less than CheckSumMismatchSentPacketCacheMaxByteLimit will be cached 
            for a duration to ensure successful delivery. Default false.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.NetworkComms.CheckSumMismatchSentPacketCacheMaxByteLimit">
      <summary>
            When checksum validation is enabled sets the limit below which sent packets are cached to ensure successful delivery. Default 75KB.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.NetworkComms.MinimumSentPacketCacheTimeMinutes">
      <summary>
            When a sent packet has been cached for a possible resend this is the minimum length of time it will be retained. 
            Default is 1.0 minutes.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.NetworkComms.LastSentPacketCacheCleanup">
      <summary>
            Records the last sent packet cache clean up time. Prevents the sent packet cache from being checked too frequently.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.NetworkComms.IgnoreUnknownPacketTypes">
      <summary>
            If true any unknown incoming packet types are ignored. Default is false and will result in an error file being created if 
            an unknown packet type is received.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.NetworkComms.ConnectionEstablishTimeoutMS">
      <summary>
            Time to wait in milliseconds before throwing an exception when waiting for a connection to be established. Default is 10000.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.NetworkComms.PacketConfirmationTimeoutMS">
      <summary>
            Time to wait in milliseconds before throwing an exception when waiting for confirmation of packet receipt. Default is 5000.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.NetworkComms.ConnectionAliveTestTimeoutMS">
      <summary>
            Time to wait in milliseconds before assuming a remote connection is dead when doing a connection test. Default is 1000.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.NetworkComms.DisableConnectionSendTimeouts">
      <summary>
            By default NetworkComms.Net closes connections for which sends take a long time. The timeout is calculated based on previous connection send performances. Set this to true to disable this feature.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.NetworkComms.LoggingEnabled">
      <summary>
            Returns true if NetworkComms.Net logging has been enabled.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.NetworkComms.Logger">
      <summary>
            Access the NetworkCommsDotNet logger externally.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.NetworkComms.InternalFixedSendReceiveOptions">
      <summary>
            The following are used for internal NetworkComms.Net objects, packet headers, connection establishment etc. 
            We generally seem to increase the size of our data if compressing small objects (~50 bytes)
            Given the typical header size is 40 bytes we might as well not compress these objects.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.NetworkComms.DefaultSendReceiveOptions">
      <summary>
            Default options for sending and receiving in the absence of specific values
            </summary>
    </member>
    <member name="E:NetworkCommsDotNet.NetworkComms.OnCommsShutdown">
      <summary>
            Comms shutdown event. This will be triggered when calling NetworkComms.Shutdown
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.IPacket">
      <summary>
            Interface for defining Application Layer Protocol packets
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.IPacket.SerialiseHeader(NetworkCommsDotNet.SendReceiveOptions)">
      <summary>
            Returns the serialised bytes of the packet header appended by the serialised header size. This is required to 
            rebuild the header on receive.
            </summary>
      <returns>The serialised header as byte[]</returns>
    </member>
    <member name="M:NetworkCommsDotNet.IPacket.Dispose">
      <summary>
            Dispose of internal packet resources
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.IPacket.PacketHeader">
      <summary>
            The packet header for this packet
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.IPacket.PacketData">
      <summary>
            The payload data stream
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Packet">
      <summary>
            Wrapper for <see cref="P:NetworkCommsDotNet.Packet.PacketHeader" /> and packetData.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Packet._packetHeader">
      <summary>
            If we serialise a whole packet we include the packet header
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Packet._payloadObjectBytes">
      <summary>
            And the payload object as byte[]. We cannot use type T here because we do not know the type of T
            on deserialisation until we have the nested packet header.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Packet.#ctor">
      <summary>
            Parameterless constructor for deserialisation
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Packet.#ctor(System.String,System.Object,NetworkCommsDotNet.SendReceiveOptions)">
      <summary>
            Create a new packet
            </summary>
      <param name="sendingPacketTypeStr">The sending packet type</param>
      <param name="payloadObject">The object to be sent</param>
      <param name="options">The <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> to be used to create this packet</param>
    </member>
    <member name="M:NetworkCommsDotNet.Packet.#ctor(System.String,System.String,System.Object,NetworkCommsDotNet.SendReceiveOptions)">
      <summary>
            Create a new packet
            </summary>
      <param name="sendingPacketTypeStr">The sending packet type</param>
      <param name="requestReturnPacketTypeStr">The expected return packet type</param>
      <param name="payloadObject">The object to be sent</param>
      <param name="options">The <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> to be used to create this packet</param>
    </member>
    <member name="M:NetworkCommsDotNet.Packet.#ctor(System.String,System.String,System.Object,NetworkCommsDotNet.SendReceiveOptions,System.Boolean)">
      <summary>
            Private constructor used for nesting packets
            </summary>
      <param name="sendingPacketTypeStr">
      </param>
      <param name="requestReturnPacketTypeStr">
      </param>
      <param name="payloadObject">
      </param>
      <param name="options">
      </param>
      <param name="isNested">
      </param>
    </member>
    <member name="M:NetworkCommsDotNet.Packet.SerialiseHeader(NetworkCommsDotNet.SendReceiveOptions)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Packet.Dispose">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Packet.Serialize(System.IO.Stream)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Packet.Deserialize(System.IO.Stream)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Packet.Deserialize(System.IO.Stream,NetworkCommsDotNet.Packet@)">
      <summary>
            Deserializes from a memory stream to a <see cref="T:NetworkCommsDotNet.Packet" /> object
            </summary>
      <param name="inputStream">The memory stream containing the serialized <see cref="T:NetworkCommsDotNet.Packet" /></param>
      <param name="result">The deserialized <see cref="T:NetworkCommsDotNet.Packet" /></param>
    </member>
    <member name="P:NetworkCommsDotNet.Packet.PacketHeader">
      <inheritdoc />
    </member>
    <member name="P:NetworkCommsDotNet.Packet.PacketData">
      <inheritdoc />
    </member>
    <member name="T:NetworkCommsDotNet.PacketHeaderLongItems">
      <summary>
            Any <see cref="T:NetworkCommsDotNet.PacketHeader" /> options which are stored as a long.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.PacketHeaderLongItems.TotalPayloadSize">
      <summary>
            The total size of the packet data payload in bytes. This is a compulsory option.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.PacketHeaderLongItems.SerializerProcessors">
      <summary>
            The data serialiser and data processor used to unwrap the payload. Used as flags.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.PacketHeaderLongItems.PacketSequenceNumber">
      <summary>
            The sequence number for this packet. Each connection maintains a unique counter which is increments on each sent packet. This is a compulsory option.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.PacketHeaderLongItems.PacketCreationTime">
      <summary>
            The creation time of the packet header.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.PacketHeaderStringItems">
      <summary>
            Any <see cref="T:NetworkCommsDotNet.PacketHeader" /> options which are stored as a string.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.PacketHeaderStringItems.PacketType">
      <summary>
            The type of the packet. This is a compulsory option which determines how the incoming packet is handled.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.PacketHeaderStringItems.ReceiveConfirmationRequired">
      <summary>
            Specifies if a receive confirmation is required for this packet. String option as takes up less space for a boolean option.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.PacketHeaderStringItems.RequestedReturnPacketType">
      <summary>
            The packet type which should be used for any return packet type.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.PacketHeaderStringItems.CheckSumHash">
      <summary>
            A checksum corresponding to the payload data.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.PacketHeaderStringItems.SourceNetworkIdentifier">
      <summary>
            The network identifier of the packet source
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.PacketHeaderStringItems.PacketIdentifier">
      <summary>
            Optional packet identifier.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.PacketHeaderStringItems.NullDataSection">
      <summary>
            The data section should be interpreted as a null 
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.PacketHeader">
      <summary>
            Contains information required to send, receive and correctly rebuild any objects sent via NetworkComms.Net.
            Any data sent via NetworkCommsDotNet is always preceded by a packetHeader.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.PacketHeader.#ctor">
      <summary>
            Blank constructor required for deserialisation
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.PacketHeader.#ctor(System.String,System.Int64,NetworkCommsDotNet.SendReceiveOptions,System.String,System.String)">
      <summary>
            Creates a new packetHeader
            </summary>
      <param name="packetTypeStr">The packet type to be used.</param>
      <param name="payloadPacketSize">The size on bytes of the payload</param>
      <param name="sendReceiveOptions">Send receive options which may contain header relevant options.</param>
      <param name="requestedReturnPacketTypeStr">An optional field representing the expected return packet type</param>
      <param name="checkSumHash">An optional field representing the payload checksum</param>
    </member>
    <member name="M:NetworkCommsDotNet.PacketHeader.#ctor(System.IO.MemoryStream,NetworkCommsDotNet.SendReceiveOptions)">
      <summary>
            Constructor used for deserialisation
            </summary>
      <param name="packetHeaderStream">
      </param>
      <param name="headerSendReceiveOptions">
      </param>
    </member>
    <member name="M:NetworkCommsDotNet.PacketHeader.ContainsOption(NetworkCommsDotNet.PacketHeaderStringItems)">
      <summary>
            Check if a string option has been set.
            </summary>
      <param name="option">The string option to be checked.</param>
      <returns>Returns true if the provided string option has been set.</returns>
    </member>
    <member name="M:NetworkCommsDotNet.PacketHeader.ContainsOption(NetworkCommsDotNet.PacketHeaderLongItems)">
      <summary>
            Check if a long option has been set.
            </summary>
      <param name="option">The long option to be checked.</param>
      <returns>Returns true if the provided long option has been set.</returns>
    </member>
    <member name="M:NetworkCommsDotNet.PacketHeader.GetOption(NetworkCommsDotNet.PacketHeaderLongItems)">
      <summary>
            Get a long option.
            </summary>
      <param name="option">The option to get</param>
      <returns>The requested long option</returns>
    </member>
    <member name="M:NetworkCommsDotNet.PacketHeader.GetOption(NetworkCommsDotNet.PacketHeaderStringItems)">
      <summary>
            Get a string option
            </summary>
      <param name="options">The option to get</param>
      <returns>The requested string option</returns>
    </member>
    <member name="M:NetworkCommsDotNet.PacketHeader.SetOption(NetworkCommsDotNet.PacketHeaderLongItems,System.Int64)">
      <summary>
            Set a long option with the provided value.
            </summary>
      <param name="option">The option to set</param>
      <param name="Value">The option value</param>
    </member>
    <member name="M:NetworkCommsDotNet.PacketHeader.SetOption(NetworkCommsDotNet.PacketHeaderStringItems,System.String)">
      <summary>
            Set a string option with the provided value.
            </summary>
      <param name="option">The option to set</param>
      <param name="Value">The option value</param>
    </member>
    <member name="M:NetworkCommsDotNet.PacketHeader.Serialize(System.IO.Stream)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.PacketHeader.Deserialize(System.IO.Stream)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.PacketHeader.Deserialize(System.IO.Stream,NetworkCommsDotNet.PacketHeader@)">
      <summary>
            Deserializes from a memory stream to a <see cref="T:NetworkCommsDotNet.PacketHeader" /> object
            </summary>
      <param name="inputStream">The memory stream containing the serialized <see cref="T:NetworkCommsDotNet.PacketHeader" /></param>
      <param name="result">The deserialized <see cref="T:NetworkCommsDotNet.PacketHeader" /></param>
    </member>
    <member name="P:NetworkCommsDotNet.PacketHeader.TotalPayloadSize">
      <summary>
            The total size in bytes of the payload.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.PacketHeader.PacketType">
      <summary>
            The packet type.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.PacketHeader.PacketSequenceNumber">
      <summary>
            The sequence number for this packet
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.PacketHeader.RequestedReturnPacketType">
      <summary>
            The packet type which should be used for any return packet type. If no return packet type is set returns null.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.PacketHeader.PacketIdentifier">
      <summary>
            Optional packet identifier. If no packet identifier is set returns null.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.PacketHeader.SourceNetworkIdentifier">
      <summary>
            The network identifier of the packets source peer. If no source network identifier is set returns null. 
            Also see <see cref="P:NetworkCommsDotNet.ConnectionInfo.NetworkIdentifier" />.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.PacketHeader.CheckSumHash">
      <summary>
            A checksum corresponding to the payload data. If no checksum is set returns null.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.ReservedPacketType">
      <summary>
            Reserved packetTypeStrs. Removing or modifying these will prevent NetworkComms.Net from working
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.RuntimeEnvironment">
      <summary>
            Specifies the current runtime environment. Used for changing minor settings based on environment.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.RuntimeEnvironment.Native_Net4">
      <summary>
            Native .Net 4.0 - Default
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.RuntimeEnvironment.Mono_Net4">
      <summary>
            Mono .Net 4.0
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.RuntimeEnvironment.Native_Net35">
      <summary>
            Native .Net3.5
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.RuntimeEnvironment.Mono_Net35">
      <summary>
            Mono .Net 3.5
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.RuntimeEnvironment.Native_Net2">
      <summary>
            Native .Net 2
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.RuntimeEnvironment.Mono_Net2">
      <summary>
            Mono .Net 2
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.RuntimeEnvironment.WindowsPhone_Silverlight">
      <summary>
            Windows Phone 7.1 (8) or Silverlight
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.RuntimeEnvironment.Xamarin_Android">
      <summary>
            Xamarin.Android
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.RuntimeEnvironment.Xamarin_iOS">
      <summary>
            Xamarin.iOS
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.RuntimeEnvironment.Windows_RT">
      <summary>
            Windows RT or Windows Store 
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.SendReceiveOptions">
      <summary>
            Contains options and flags for sending and receiving data such as serialisation method, data processors, encryption etc.
            Several static constructors are provided to help create SendReceiveOptions in the most common formats.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.SendReceiveOptions.#ctor(NetworkCommsDotNet.DPSBase.DataSerializer,System.Collections.Generic.List{NetworkCommsDotNet.DPSBase.DataProcessor},System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Initializes a new instance of the <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> class with a specified <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" />, set of <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s and and other options
            </summary>
      <param name="serializer">The <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> to use</param>
      <param name="dataProcessors">The set of <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s to use.  The order in the list determines the order the <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s will be applied</param>
      <param name="options">Allows additional options to be passed to the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s</param>
    </member>
    <member name="M:NetworkCommsDotNet.SendReceiveOptions.#ctor(System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Initializes a new instance of the <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> class providing only options for the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s.  This constructor should only be used when adding packet handlers for incoming connections
            </summary>
      <param name="options">Allows additional options to be passed to the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s</param>
    </member>
    <member name="M:NetworkCommsDotNet.SendReceiveOptions.#ctor">
      <summary>
            Initializes an empty instance of the <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> class.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.SendReceiveOptions.OptionsCompatible(NetworkCommsDotNet.SendReceiveOptions)">
      <summary>
            Determines whether the supplied <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> is compatible, from a serialization point of view, with this instance
            </summary>
      <param name="options">The <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> to compare against</param>
      <returns>True if the options are compatible, false otherwise</returns>
      <remarks>Two <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> instances will be compatible if they use the same <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and the same set of <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s</remarks>
    </member>
    <member name="M:NetworkCommsDotNet.SendReceiveOptions.Clone">
      <summary>
            Create a deep clone of this <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> object. 
            </summary>
      <returns>The cloned object</returns>
    </member>
    <member name="P:NetworkCommsDotNet.SendReceiveOptions.ReceiveConfirmationRequired">
      <summary>
            If true any packets sent with this <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> will be forced to trigger a receive confirmation.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.SendReceiveOptions.IncludePacketConstructionTime">
      <summary>
            If true any packets sent with this <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> will include the packet creation time in the header.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.SendReceiveOptions.UseNestedPacket">
      <summary>
            If true any packets sent with this <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> will be nested which can be used to obscure the actual
            packet type.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.SendReceiveOptions.ReceiveHandlePriority">
      <summary>
             Incoming packets are handled using a flexible QueueItemPriority (Default - QueueItemPriority.Normal). Reserved internal 
             packet types and packets marked with QueueItemPriority.Highest are not enqueued but handled in real time by the thread 
             handling the incoming data. You are free to specify the queue item priority for packet handlers using this 
             SendReceiveOptions by setting this value as desired. CAUTION: Only use QueueItemPriority.Highest sparingly.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.SendReceiveOptions.DataSerializer">
      <summary>
            Gets the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> that should be used when sending information
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.SendReceiveOptions.DataProcessors">
      <summary>
            Gets the <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s that should be used when sending information. <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s are applied in index order
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.SendReceiveOptions.Options">
      <summary>
            Gets the options that should be passed to the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s on object serialization and deserialization
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.SendReceiveOptions`1">
      <inheritdoc />
      <typeparam name="T_DS">The type of <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> to use</typeparam>
    </member>
    <member name="M:NetworkCommsDotNet.SendReceiveOptions`1.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> class. The <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> is passed as a generic parameter and no <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s are used. To provide additional options see other overrides. 
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.SendReceiveOptions`1.#ctor(System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Initializes a new instance of the <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> class. The <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> is passed as a generic parameter and no <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s are used.  
            Further options can be passed to the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> as an argument which may be null
            </summary>
      <param name="options">Additional options to be passed to the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /></param>
    </member>
    <member name="T:NetworkCommsDotNet.SendReceiveOptions`2">
      <inheritdoc />
      <typeparam name="T_DS">The type of <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> to use</typeparam>
      <typeparam name="T_DP1">The type of <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
    </member>
    <member name="M:NetworkCommsDotNet.SendReceiveOptions`2.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> class. The <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and a single <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> while will be used are passed as generic parameters. To provide additional options see other overrides. 
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.SendReceiveOptions`2.#ctor(System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Initializes a new instance of the <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> class. The <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and a single <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> while will be used are passed as generic parameters
            Further options can be passed to the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> as an argument which may be null
            </summary>
      <param name="options">Additional options to be passed to the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /></param>
    </member>
    <member name="T:NetworkCommsDotNet.SendReceiveOptions`3">
      <inheritdoc />
      <typeparam name="T_DS">The type of <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> to use</typeparam>
      <typeparam name="T_DP1">The type of the first <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
      <typeparam name="T_DP2">The type of the second <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
    </member>
    <member name="M:NetworkCommsDotNet.SendReceiveOptions`3.#ctor(System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Initializes a new instance of the <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> class. The <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and 2 <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s while will be used are passed as generic parameters
            Further options can be passed to the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s as an argument which may be null
            </summary>
      <param name="options">Additional options to be passed to the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s</param>
    </member>
    <member name="T:NetworkCommsDotNet.SendReceiveOptions`4">
      <inheritdoc />
      <typeparam name="T_DS">The type of <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> to use</typeparam>
      <typeparam name="T_DP1">The type of the first <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
      <typeparam name="T_DP2">The type of the second <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
      <typeparam name="T_DP3">The type of the third <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
    </member>
    <member name="M:NetworkCommsDotNet.SendReceiveOptions`4.#ctor(System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Initializes a new instance of the <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> class. The <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and 3 <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s while will be used are passed as generic parameters
            Further options can be passed to the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s as an argument which may be null
            </summary>
      <param name="options">Additional options to be passed to the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s</param>
    </member>
    <member name="T:NetworkCommsDotNet.SendReceiveOptions`5">
      <inheritdoc />
      <typeparam name="T_DS">The type of <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> to use</typeparam>
      <typeparam name="T_DP1">The type of the first <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
      <typeparam name="T_DP2">The type of the second <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
      <typeparam name="T_DP3">The type of the third <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
      <typeparam name="T_DP4">The type of the fourth <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
    </member>
    <member name="M:NetworkCommsDotNet.SendReceiveOptions`5.#ctor(System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Initializes a new instance of the <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> class. The <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and 4 <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s while will be used are passed as generic parameters
            Further options can be passed to the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s as an argument which may be null
            </summary>
      <param name="options">Additional options to be passed to the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s</param>
    </member>
    <member name="T:NetworkCommsDotNet.SendReceiveOptions`6">
      <inheritdoc />
      <typeparam name="T_DS">The type of <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> to use</typeparam>
      <typeparam name="T_DP1">The type of the first <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
      <typeparam name="T_DP2">The type of the second <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
      <typeparam name="T_DP3">The type of the third <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
      <typeparam name="T_DP4">The type of the fourth <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
      <typeparam name="T_DP5">The type of the fifth <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
    </member>
    <member name="M:NetworkCommsDotNet.SendReceiveOptions`6.#ctor(System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Initializes a new instance of the <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> class. The <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and 5 <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s while will be used are passed as generic parameters
            Further options can be passed to the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s as an argument which may be null
            </summary>
      <param name="options">Additional options to be passed to the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s</param>
    </member>
    <member name="T:NetworkCommsDotNet.SendReceiveOptions`7">
      <inheritdoc />
      <typeparam name="T_DS">The type of <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> to use</typeparam>
      <typeparam name="T_DP1">The type of the first <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
      <typeparam name="T_DP2">The type of the second <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
      <typeparam name="T_DP3">The type of the third <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
      <typeparam name="T_DP4">The type of the fourth <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
      <typeparam name="T_DP5">The type of the fifth <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
      <typeparam name="T_DP6">The type of the sixth <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
    </member>
    <member name="M:NetworkCommsDotNet.SendReceiveOptions`7.#ctor(System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Initializes a new instance of the <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> class. The <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and 6 <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s while will be used are passed as generic parameters
            Further options can be passed to the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s as an argument which may be null
            </summary>
      <param name="options">Additional options to be passed to the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s</param>
    </member>
    <member name="T:NetworkCommsDotNet.SendReceiveOptions`8">
      <inheritdoc />
      <typeparam name="T_DS">The type of <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> to use</typeparam>
      <typeparam name="T_DP1">The type of the first <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
      <typeparam name="T_DP2">The type of the second <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
      <typeparam name="T_DP3">The type of the third <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
      <typeparam name="T_DP4">The type of the fourth <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
      <typeparam name="T_DP5">The type of the fifth <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
      <typeparam name="T_DP6">The type of the sixth <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
      <typeparam name="T_DP7">The type of the seventh <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> to use</typeparam>
    </member>
    <member name="M:NetworkCommsDotNet.SendReceiveOptions`8.#ctor(System.Collections.Generic.Dictionary{System.String,System.String})">
      <summary>
            Initializes a new instance of the <see cref="T:NetworkCommsDotNet.SendReceiveOptions" /> class. The <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and 7 <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s while will be used are passed as generic parameters
            Further options can be passed to the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s as an argument which may be null
            </summary>
      <param name="options">Additional options to be passed to the <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> and <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" />s</param>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.Adler32Checksum">
      <summary>
            Implementation of the <see href="http://en.wikipedia.org/wiki/Adler-32">Adler32</see> checksum algorithm. 
            It is not a particularly reliable checksum compared with <see href="http://en.wikipedia.org/wiki/MD5">MD5</see> but it is about 10 times faster.
            NetworkComms.Net uses <see href="http://en.wikipedia.org/wiki/MD5">MD5</see> as its default but this class is provided should speed be the more important factor.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.Adler32Checksum.GenerateCheckSum(System.Byte[])">
      <summary>
            Generate an Adler32 checksum value based on the provided byte array.
            </summary>
      <param name="buffer">Buffer for which the checksum should be calculated.</param>
      <returns>The checksum value</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.Adler32Checksum.GenerateCheckSumSplitBuffer(System.Byte[][])">
      <summary>
            Generate a single Adler32 checksum value based on the provided byte arrays. Checksum calculated from splitBuffer[0] onwards.
            </summary>
      <param name="splitBuffer">Buffers for which the checksum should be calculated.</param>
      <returns>The checksum value</returns>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.CommsMath">
      <summary>
            A class used for math operations in NetworkComms.Net. Primarily used for load analysis.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CommsMath.#ctor">
      <summary>
            Create a new empty instance of CommsMath
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CommsMath.#ctor(System.Collections.Generic.List{System.Double},System.Collections.Generic.List{System.Double})">
      <summary>
            Create a new empty instance of CommsMath
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CommsMath.AddValue(System.Double)">
      <summary>
            Add a new value to the internal list
            </summary>
      <param name="value">The value to add</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CommsMath.AddValue(System.Double,System.Double)">
      <summary>
            Add a new value to the internal list
            </summary>
      <param name="value">The value to add</param>
      <param name="weight">The weight to apply to the provided value</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CommsMath.TrimList(System.Int32)">
      <summary>
            Trims the list to the provided maxCount. The most recently added items are preserved.
            </summary>
      <param name="maxCount">The maximum size of the list after being trimmed</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CommsMath.ClearList">
      <summary>
            Reset the value list
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CommsMath.CalculateMean">
      <summary>
            Return the mean of the current list.
            </summary>
      <returns>The mean of all values currently in the list.</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CommsMath.CalculateStdDeviation">
      <summary>
            Return the standard deviation of the current list.
            </summary>
      <returns>The standard deviation of all values currently in the list.</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CommsMath.CalculateMean(System.Int32)">
      <summary>
            Return the mean of the current list.
            </summary>
      <param name="lastNValues">If less than the number of items in the value list returns the mean of the lastNValues</param>
      <returns>The mean of relevant values</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CommsMath.CalculateStdDeviation(System.Int32)">
      <summary>
            Return the standard deviation of the current list.
            </summary>
      <param name="lastNValues">If less than the number of items in the value list returns the mean of the lastNValues</param>
      <returns>The mean of relevant values</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CommsMath.CalculateMean(System.Collections.Generic.List{System.Double})">
      <summary>
            Return the mean of the provided list of values
            </summary>
      <param name="localValues">Values for which a mean should be calculated</param>
      <returns>The mean of provided values</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CommsMath.CalculateMean(System.Collections.Generic.List{System.Double},System.Collections.Generic.List{System.Double})">
      <summary>
            Return the mean of the provided list of values
            </summary>
      <param name="localValues">Values for which a mean should be calculated</param>
      <param name="weights">The weights to apply to the corresponding values</param>
      <returns>The mean of provided values</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CommsMath.CalculateStdDeviation(System.Collections.Generic.List{System.Double})">
      <summary>
            Return the standard deviation of the provided list of values
            </summary>
      <param name="localValues">Values for which a standard deviation should be calculated</param>
      <returns>The standard deviation of provided values</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CommsMath.CalculateStdDeviation(System.Collections.Generic.List{System.Double},System.Collections.Generic.List{System.Double})">
      <summary>
            Return the standard deviation of the provided list of values
            </summary>
      <param name="localValues">Values for which a standard deviation should be calculated</param>
      <param name="weights">The weights to apply to the corresponding values</param>
      <returns>The standard deviation of provided values</returns>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.CommsMath.Count">
      <summary>
            Returns the number of values in this object
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.CommsThreadPool">
      <summary>
            A compact priority based thread pool used by NetworkComms.Net to run packet handlers
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.CommsThreadPool.SyncRoot">
      <summary>
            A sync object to make things thread safe
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.CommsThreadPool.threadDict">
      <summary>
            Dictionary of threads, index is ThreadId
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.CommsThreadPool.workerInfoDict">
      <summary>
            Dictionary of thread worker info, index is ThreadId
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.CommsThreadPool.ThreadWaitSleepJoinCountUpdateInterval">
      <summary>
            The minimum timespan between thread wait sleep join updates
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.CommsThreadPool.requireJobThreadsCount">
      <summary>
            A quick lookup of the number of current threads which are idle and require jobs
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.CommsThreadPool.jobQueue">
      <summary>
            Priority queue used to order call backs 
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.CommsThreadPool.shutdown">
      <summary>
            Set to true to ensure correct shutdown of worker threads.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CommsThreadPool.#ctor(System.Int32,System.Int32,System.Int32,System.TimeSpan)">
      <summary>
            Create a new NetworkComms.Net thread pool
            </summary>
      <param name="minThreadsCount">Minimum number of idle threads to maintain in the pool</param>
      <param name="maxActiveThreadsCount">The maximum number of active (i.e. not waiting for IO) threads</param>
      <param name="maxTotalThreadsCount">Maximum number of threads to create in the pool</param>
      <param name="threadIdleTimeoutClose">Timespan after which an idle thread will close</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CommsThreadPool.BeginShutdown">
      <summary>
            Prevent any additional threads from starting. Returns immediately.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CommsThreadPool.EndShutdown(System.Int32)">
      <summary>
            Prevent any additional threads from starting and return once all existing workers have completed.
            </summary>
      <param name="threadShutdownTimeoutMS">
      </param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CommsThreadPool.EnqueueItem(NetworkCommsDotNet.Tools.QueueItemPriority,System.Threading.WaitCallback,System.Object)">
      <summary>
             Enqueue a callback to the thread pool.
            </summary>
      <param name="priority">The priority with which to enqueue the provided callback</param>
      <param name="callback">The callback to execute</param>
      <param name="state">The state parameter to pass to the callback when executed</param>
      <returns>Returns the managed threadId running the callback if one was available, otherwise -1</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CommsThreadPool.ThreadWorker(System.Object)">
      <summary>
            The worker object for the thread pool
            </summary>
      <param name="state">
      </param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CommsThreadPool.UpdateThreadWaitSleepJoinCountCache">
      <summary>
            Returns the total number of threads in the pool which are waiting for IO
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CommsThreadPool.ToString">
      <summary>
            Provides a brief string summarisation the state of the thread pool
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.CommsThreadPool.ThreadIdleTimeoutClose">
      <summary>
            The timespan after which an idle thread will close
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.CommsThreadPool.MaxTotalThreadsCount">
      <summary>
            The maximum number of threads to create in the pool
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.CommsThreadPool.MaxActiveThreadsCount">
      <summary>
            The maximum number of active threads in the pool. This can be less than MaxTotalThreadsCount, taking account of waiting threads.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.CommsThreadPool.MinThreadsCount">
      <summary>
            The minimum number of idle threads to maintain in the pool
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.CommsThreadPool.CurrentNumWaitSleepJoinThreadsCache">
      <summary>
            The most recent count of pool threads which are waiting for IO
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.CommsThreadPool.LastThreadWaitSleepJoinCountCacheUpdate">
      <summary>
            The dateTime associated with the most recent count of pool threads which are waiting for IO
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.CommsThreadPool.CurrentNumTotalThreads">
      <summary>
            The total number of threads currently in the thread pool
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.CommsThreadPool.CurrentNumIdleThreads">
      <summary>
            The total number of idle threads currently in the thread pool
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.CommsThreadPool.QueueCount">
      <summary>
            The total number of items currently waiting to be collected by a thread
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.WorkerInfo">
      <summary>
            A private wrapper used by CommsThreadPool
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.WorkerInfo.SetInsideCallBack">
      <summary>
            Set InsideCallBack to true
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.WorkerInfo.ClearInsideCallBack">
      <summary>
            Set InsideCallBack to false
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.WorkerInfo.SetThreadIdle">
      <summary>
            Set threadIdle to true
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.WorkerInfo.ClearThreadIdle">
      <summary>
            Set threadIdle to false
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.WaitCallBackWrapper">
      <summary>
            A private wrapper used by CommsThreadPool
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.DOSProtection">
      <summary>
            NetworkComms.Net class used for providing Denial Of Service (DOS) protection features. 
            If enabled, malformed data events and connection initialises are tracked. If above
            set thresholds IPAddresses are banned.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.DOSProtection._syncRoot">
      <summary>
            A local thread safety locker
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.DOSProtection._bannedAddresses">
      <summary>
            Addresses that are currently banned. Key is remote IPAddress, value is time banned.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.DOSProtection._malformedCountDict">
      <summary>
            First key is remote IPAddress, second key is DateTime.Ticks, value is the malformed count for that DateTime.ticks
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.DOSProtection._connectionInitialiseCountDict">
      <summary>
            First key is remote IPAddress, second key is DateTime.Ticks, value is the connection initialisation count for that DateTime.ticks
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.DOSProtection.#ctor">
      <summary>
            Initialise a new instance of DOS protection.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.DOSProtection.LogMalformedData(System.Net.IPAddress)">
      <summary>
            Log a malformed data event for the provided remote IPAddress.
            </summary>
      <param name="remoteIPAddress">
      </param>
      <returns>True if the remote IPAddress is now banned, otherwise false.</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.DOSProtection.LogConnectionInitialise(System.Net.IPAddress)">
      <summary>
            Log a connection initialisation for the provided remote IPAddress. 
            </summary>
      <param name="remoteIPAddress">
      </param>
      <returns>True if the remote IPAddress is now banned, otherwise false.</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.DOSProtection.RemoteIPAddressBanned(System.Net.IPAddress)">
      <summary>
            Returns true if the provided IPAddress has been banned due to DOSProtection.
            </summary>
      <param name="remoteIPAddress">The IPAddress to check</param>
      <returns>
      </returns>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.DOSProtection.Enabled">
      <summary>
            The current state of DOS protection
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.DOSProtection.BanTimeout">
      <summary>
            The timeout after which time a banned IPAddress may have access again. Default is 10 minutes.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.DOSProtection.LogInterval">
      <summary>
            The time within which if MalformedCountInIntervalBeforeBan or ConnectionInitialiseCountInIntervalBeforeBan
            is reached a peer will be banned. Default is 5 minutes. 
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.DOSProtection.MalformedCountInIntervalBeforeBan">
      <summary>
            The number of malformed data counts to log within LogInterval before an IPAddress is banned. Default is 2.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.DOSProtection.ConnectionInitialiseCountInIntervalBeforeBan">
      <summary>
            The number of connection initialises to log within LogInterval before an IPAddress is banned. Default is 100
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.HostInfo">
      <summary>
            A static class which provides information about the local host.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.HostInfo.IP">
      <summary>
            Host IP information
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.HostInfo.IP.FilteredLocalAddresses">
      <summary>
            Returns all allowed local IP addresses. Caches results for up to 5 second since the previous refresh.
            If <see cref="P:NetworkCommsDotNet.Tools.HostInfo.RestrictLocalAdaptorNames" /> has been set only returns IP addresses corresponding with specified adaptors.
            If <see cref="P:NetworkCommsDotNet.Tools.HostInfo.IP.RestrictLocalAddressRanges" /> has been set only returns matching addresses ordered in descending 
            preference. i.e. Most preferred at [0].
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.HostInfo.IP.FilteredLocalAddresses(System.Boolean)">
      <summary>
            Returns all allowed local IP addresses. Caches results for up to 5 second since the previous refresh unless forceCacheUpdate is true.
            If <see cref="P:NetworkCommsDotNet.Tools.HostInfo.RestrictLocalAdaptorNames" /> has been set only returns IP addresses corresponding with specified adaptors.
            If <see cref="P:NetworkCommsDotNet.Tools.HostInfo.IP.RestrictLocalAddressRanges" /> has been set only returns matching addresses ordered in descending 
            preference. i.e. Most preferred at [0].
            </summary>
      <param name="forceCacheUpdate">If true will refresh the cache and return latest result</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.HostInfo.IP.AverageNetworkLoadIncoming(System.Byte)">
      <summary>
            Returns the averaged value of CurrentNetworkLoadIncoming, as a value between 0 and 1, for a time window of up to 254 seconds. 
            Triggers load analysis upon first call.
            </summary>
      <param name="secondsToAverage">Number of seconds over which historical data should be used to arrive at an average</param>
      <returns>Average network load as a double between 0 and 1</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.HostInfo.IP.AverageNetworkLoadOutgoing(System.Byte)">
      <summary>
            Returns the averaged value of CurrentNetworkLoadIncoming, as a value between 0 and 1, for a time window of up to 254 seconds.
            Triggers load analysis upon first call.
            </summary>
      <param name="secondsToAverage">Number of seconds over which historical data should be used to arrive at an average</param>
      <returns>Average network load as a double between 0 and 1</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.HostInfo.IP.ShutdownThreads(System.Int32)">
      <summary>
            Shutdown any background threads in the host tools
            </summary>
      <param name="threadShutdownTimeoutMS">
      </param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.HostInfo.IP.NetworkLoadWorker">
      <summary>
            Takes a network load snapshot (CurrentNetworkLoad) every NetworkLoadUpdateWindowMS
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.HostInfo.IP.RestrictLocalAddressRanges">
      <summary>
            Restricts the IPAdddresses that are returned by <see cref="M:NetworkCommsDotNet.Tools.HostInfo.IP.FilteredLocalAddresses" />.
            If using StartListening overrides that do not take IPEndPoints NetworkComms.Net 
            will only listen on IP Addresses within provided ranges. Also see <see cref="P:NetworkCommsDotNet.Tools.HostInfo.RestrictLocalAdaptorNames" />.
            The order of provided ranges determines the order of IPAddresses returned by <see cref="M:NetworkCommsDotNet.Tools.HostInfo.IP.FilteredLocalAddresses" />.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.HostInfo.IP.NetworkLoadUpdateWindowMS">
      <summary>
            The number of milliseconds over which to take an instance load (CurrentNetworkLoad) to be used in averaged 
            values (AverageNetworkLoad). Default is 2000ms. Shorter values can be used but less than 200ms may cause significant 
            errors in the value of returned value, especially in mono environments.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.HostInfo.IP.InterfaceLinkSpeed">
      <summary>
            The interface link speed in bits/sec used for network load calculations. Default is 100Mb/sec
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.HostInfo.IP.CurrentNetworkLoadIncoming">
      <summary>
            Returns the current instance network usage, as a value between 0 and 1. Returns the largest value for any available 
            network adaptor. Triggers load analysis upon first call.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.HostInfo.IP.CurrentNetworkLoadOutgoing">
      <summary>
            Returns the current instance network usage, as a value between 0 and 1. Returns the largest value for any available network 
            adaptor. Triggers load analysis upon first call.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.HostInfo.BT">
      <summary>
            Host bluetooth information
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.HostInfo.BT.FilteredLocalAddresses">
      <summary>
            Returns all allowed local Bluetooth addresses. 
            If <see cref="P:NetworkCommsDotNet.Tools.HostInfo.RestrictLocalAdaptorNames" /> has been set only returns bBluetooth addresses corresponding with specified adaptors.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.HostInfo.AllLocalAdaptorNames">
      <summary>
            Returns all local adaptor names. Can be used to determine which adaptor names to use with <see cref="P:NetworkCommsDotNet.Tools.HostInfo.RestrictLocalAdaptorNames" />.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.HostInfo.HostName">
      <summary>
            Returns the current machine hostname
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.HostInfo.RestrictLocalAdaptorNames">
      <summary>
            Restricts the addresses that may be used when listening.
            If set <see cref="M:NetworkCommsDotNet.Tools.HostInfo.IP.FilteredLocalAddresses" /> will only return addresses corresponding with specified adaptors names. 
            Please see <see cref="M:NetworkCommsDotNet.Tools.HostInfo.AllLocalAdaptorNames" /> for a list of local adaptor names.
            Correct format is string[] { "Local Area Connection", "eth0", "en0", "wlan0" }.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.ILogger">
      <summary>
            The logging interface using by NetworkComms.Net. Implement an instance of this interface to enable your own
            customised logging.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ILogger.Trace(System.String)">
      <summary>
            Log a trace message
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ILogger.Debug(System.String)">
      <summary>
            Log a debug message
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ILogger.Fatal(System.String)">
      <summary>
            Log a fatal message
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ILogger.Fatal(System.String,System.Exception)">
      <summary>
            Log a fatal message including an exception
            </summary>
      <param name="message">The message to log</param>
      <param name="ex">The exception to log</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ILogger.Info(System.String)">
      <summary>
            Log a info message
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ILogger.Warn(System.String)">
      <summary>
            Log a warn message
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ILogger.Error(System.String)">
      <summary>
            Log a error message
            </summary>
      <param name="message">The message to log</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ILogger.Shutdown">
      <summary>
            Shutdown the logger and release all resources.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.LiteLogger">
      <summary>
            A core logger that can be used to write log messages to the console and or a log file.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.LiteLogger.LogMode">
      <summary>
            The different log modes available in the lite logger
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.LiteLogger.#ctor(NetworkCommsDotNet.Tools.LiteLogger.LogMode)">
      <summary>
            Initialise an instance of the core logger. If logging to a file also set LogFileLocationName.
            </summary>
      <param name="logMode">The log mode to use</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.LiteLogger.#ctor(NetworkCommsDotNet.Tools.LiteLogger.LogMode,System.String)">
      <summary>
            Initialise an instance of the core logger
            </summary>
      <param name="logMode">The log mode to use</param>
      <param name="logFileLocationName">The log file location and name, i.e. logs/logFile.txt</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.LiteLogger.Trace(System.String)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Tools.LiteLogger.Debug(System.String)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Tools.LiteLogger.Fatal(System.String)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Tools.LiteLogger.Fatal(System.String,System.Exception)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Tools.LiteLogger.Info(System.String)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Tools.LiteLogger.Warn(System.String)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Tools.LiteLogger.Error(System.String)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Tools.LiteLogger.Shutdown">
      <inheritdoc />
    </member>
    <member name="P:NetworkCommsDotNet.Tools.LiteLogger.LogFileLocationName">
      <summary>
            The location and filename of the log file. Must be set to successfully log to a file
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.IPTools">
      <summary>
            A collection of tools for dealing with <see href="http://en.wikipedia.org/wiki/IP_address">IP addresses</see>.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.IPTools.GetIPv4NetworkBroadcastAddress(System.Net.IPAddress)">
      <summary>
            Returns the network broadcast address for the provided local IP address
            </summary>
      <param name="localIPAddress">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.IPTools.ParseEndPointFromString(System.String)">
      <summary>
            Converts an IPAddress in string form (IPv4 or IPv6) with an appended port number, e.g. 192.168.0.10:10000 or ::1:10000, into an <see cref="T:System.Net.IPEndPoint" />.
            </summary>
      <param name="ipAddressAndPort">The IP and Port to be parsed</param>
      <returns>The equivalent <see cref="T:System.Net.IPEndPoint" /></returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.IPTools.BestLocalEndPoint(System.Net.IPEndPoint)">
      <summary>
            Determines the most appropriate local end point to contact the provided remote end point. 
            Testing shows this method takes on average 1.6ms to return.
            </summary>
      <param name="remoteIPEndPoint">The remote end point</param>
      <returns>The selected local end point</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.IPTools.AttemptBestIPAddressGuess(System.Net.IPAddress)">
      <summary>
            Depreciated - . Attempts to guess the best local <see cref="T:System.Net.IPAddress" /> of this machine for accessing 
            the provided target <see cref="T:System.Net.IPAddress" />. using the Windows API, to provided targets. 
            This method is only supported in a Windows environment.
            </summary>
      <param name="targetIPAddress">The target IP which should be used to determine the best 
            local address. e.g. Either a local network or public IP address.</param>
      <returns>Local <see cref="T:System.Net.IPAddress" /> which is best used to contact that provided target.</returns>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.IPRange">
      <summary>
            A class that encapsulates an IPv4 or IPv6 range. 
            Used for checking if an IPAddress is within an IPRange.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.IPRange.numAddressBits">
      <summary>
            Number of most significant bits used for network-identifying portion of address. 
            The remaining bits specify the host identifier.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.IPRange.addressBytes">
      <summary>
            IPAddress as bytes
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.IPRange.#ctor(System.String)">
      <summary>
            Initialise an IPRange using the provided CIDR notation.
            </summary>
      <param name="rangeCIDR">IP range using CIDR notation, e.g. "192.168.1.0/24" contains 192.168.1.0 to 192.168.1.255</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.IPRange.#ctor(System.Net.IPAddress,System.Net.IPAddress)">
      <summary>
            Initialise an IPRange using the provided address and subnet mask.
            </summary>
      <param name="address">The address range to create</param>
      <param name="subnetmask">The subnet mask that specifies the network-identifying portion of the address</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.IPRange.Contains(System.Net.IPAddress)">
      <summary>
            Returns true if this IPRange contains the provided IPAddress
            </summary>
      <param name="ipAddress">The IPAddress to check</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.IPRange.Contains(System.String)">
      <summary>
            Returns true if this IPRange contains the provided IPAddress
            </summary>
      <param name="ipAddressStr">The IPAddress to check</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.IPRange.Contains(System.Byte[])">
      <summary>
            Returns true if this IPRange contains the provided IPAddress bytes
            </summary>
      <param name="ipAddressBytes">The IPAddress bytes to check</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.IPRange.AllAddressesInRange">
      <summary>
            Returns a list of all IPAddresses in the specified range
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.IPRange.AllAddressesBetween(System.Net.IPAddress,System.Net.IPAddress)">
      <summary>
            Returns all IPAddresses that are between the provided addresses
            </summary>
      <param name="firstAddress">
      </param>
      <param name="lastAddress">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.IPRange.RecursivePopulate(System.Byte[],System.Byte[],System.Byte[],System.Collections.Generic.List{System.Net.IPAddress})">
      <summary>
            Recursively populates the result list by looping over all address byte levels
            </summary>
      <param name="firstAddressBytes">
      </param>
      <param name="lastAddressBytes">
      </param>
      <param name="knownBytes">
      </param>
      <param name="result">
      </param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.IPRange.Contains(System.Collections.Generic.IEnumerable{NetworkCommsDotNet.Tools.IPRange},System.Net.IPAddress)">
      <summary>
            Returns true if the provided IPAddress is within one of the provided IPRanges, otherwise false
            </summary>
      <param name="ranges">The ranges to search</param>
      <param name="ipAddress">The IPAddress to find in ranges</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.IPRange.IsAutoAssignedAddress(System.Net.IPAddress)">
      <summary>
            Returns true if the provided IPAddress is within one of the autoassigned ip ranges, otherwise false
            </summary>
      <param name="ipAddress">The IPAddress to find in ranges</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.IPRange.ToString">
      <summary>
            Returns a clean ToString of the IPRange
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.IPRange.AutoAssignRanges">
      <summary>
            IPRanges associated with auto assigned addresses
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.LogTools">
      <summary>
            Quickly log exceptions and information to a file.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.LogTools.errorLocker">
      <summary>
            Locker for log methods which ensures threadSafe save outs.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.LogTools.AppendStringToLogFile(System.String,System.String)">
      <summary>
            Appends the provided logString to end of fileName.txt. If the file does not exist it will be created.
            </summary>
      <param name="fileName">The filename to use. The extension .txt will be appended automatically</param>
      <param name="logString">The string to append.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.LogTools.LogException(System.Exception,System.String,System.String)">
      <summary>
            Logs the provided exception to a file to assist troubleshooting.
            </summary>
      <param name="ex">The exception to be logged</param>
      <param name="fileName">The filename to use. A time stamp and extension .txt will be appended automatically</param>
      <param name="optionalCommentStr">An optional string which will appear at the top of the error file</param>
      <returns>The entire fileName used.</returns>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.MD5Core">
      <summary>
            Part of the managed MD5 calculator
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.MD5Core.GetHash(System.String,System.Text.Encoding)">
      <summary>
            Return an MD5 hash for the provided parameters
            </summary>
      <param name="input">
      </param>
      <param name="encoding">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.MD5Core.GetHash(System.String)">
      <summary>
            Return an MD5 hash for the provided parameters
            </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.MD5Core.GetHashString(System.Byte[])">
      <summary>
            Return an MD5 hash for the provided parameters
            </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.MD5Core.GetHashString(System.String,System.Text.Encoding)">
      <summary>
            Return an MD5 hash for the provided parameters
            </summary>
      <param name="input">
      </param>
      <param name="encoding">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.MD5Core.GetHashString(System.String)">
      <summary>
            Return an MD5 hash for the provided parameters
            </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.MD5Core.GetHash(System.Byte[])">
      <summary>
            Return an MD5 hash for the provided parameters
            </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.MD5Managed">
      <summary>
            Create a managed MD5 hash calculator
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.MD5Managed.#ctor">
      <summary>
            Create a new instance of the MD5 hash calculator
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.MD5Managed.Initialize">
      <summary>
            Initialise the MD5 hash calculator
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.MD5Managed.HashCore(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Calculate the core hash
            </summary>
      <param name="array">
      </param>
      <param name="ibStart">
      </param>
      <param name="cbSize">
      </param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.MD5Managed.HashFinal">
      <summary>
            Get the final hash
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.PacketBuilder">
      <summary>
            Packet data is generally broken into multiple variable sized byte chunks or 'partial packets'. 
            This class provides features to effortlessly rebuild whole packets.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PacketBuilder.#ctor">
      <summary>
            Create a new instance of the ConnectionPacketBuilder class
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PacketBuilder.ClearNTopBytes(System.Int32)">
      <summary>
            Clear N bytes from cache, starting with oldest bytes first.
            </summary>
      <param name="numBytesToRemove">The total number of bytes to be removed.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PacketBuilder.AddPartialPacket(System.Int32,System.Byte[])">
      <summary>
            Add a partial packet to the end of the cache by reference.
            </summary>
      <param name="packetBytes">The number of valid bytes in the provided partial packet</param>
      <param name="partialPacket">A buffer which may or may not be full with valid bytes</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PacketBuilder.RemoveMostRecentPartialPacket(System.Int32@)">
      <summary>
            Returns the most recently cached partial packet and removes it from the cache.
            Used to more efficiently utilise allocated memory space.
            </summary>
      <param name="lastPacketBytesRead">The number of valid bytes in the last partial packet added</param>
      <returns>A byte[] corresponding with the last added partial packet</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PacketBuilder.NumUnusedBytesMostRecentPartialPacket">
      <summary>
            Returns the number of unused bytes in the most recently cached partial packet.
            </summary>
      <returns>The number of unused bytes in the most recently cached partial packet.</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PacketBuilder.FirstByte">
      <summary>
            Returns the value of the first cached byte.
            </summary>
      <returns>The value of the first cached byte.</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PacketBuilder.GetAllData">
      <summary>
            Copies all cached bytes into a single array and returns. Original data is left unchanged.
            </summary>
      <returns>All cached data as a single byte[]</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PacketBuilder.ReadDataSection(System.Int32,System.Int32)">
      <summary>
            Copies the requested cached bytes into a single array and returns. Original data is left unchanged.
            </summary>
      <param name="startIndex">The inclusive byte index to use as the starting position.</param>
      <param name="length">The total number of desired bytes.</param>
      <returns>The requested bytes as a single array.</returns>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.PacketBuilder.Locker">
      <summary>
            Locker object used for performing thread safe operations over this packet builder
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.PacketBuilder.TotalBytesCached">
      <summary>
            The total number of cached bytes. This is the sum of all bytes across all cached partial packets. See <see cref="P:NetworkCommsDotNet.Tools.PacketBuilder.TotalPartialPacketCount" />.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.PacketBuilder.TotalPartialPacketCount">
      <summary>
            The total number of cached partial packets. This is different from <see cref="P:NetworkCommsDotNet.Tools.PacketBuilder.TotalBytesCached" /> because each partial packet may contain a variable number of bytes.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.PacketBuilder.TotalBytesExpected">
      <summary>
            The total number of bytes required to rebuild the next whole packet.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.PacketTypeUnwrapper">
      <summary>
            Wrapper used to track the SendReceiveOptions for different packet types.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PacketTypeUnwrapper.#ctor(System.String,NetworkCommsDotNet.SendReceiveOptions)">
      <summary>
            Initialise a new PacketTypeUnwrapper
            </summary>
      <param name="packetTypeStr">The packet type of this unwrapper</param>
      <param name="options">The SendReceiveOptions to use with this unwrapper</param>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.PacketTypeUnwrapper.Options">
      <summary>
            The SendReceiveOptions associated with this unwrapper.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.IPacketTypeHandlerDelegateWrapper">
      <summary>
            The following packetTypeHandlerDelegateWrappers are required so that we can do the totally general and awesome object cast on deserialise.
            If there is a way of achieving the same without these wrappers please let us know.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.PeerDiscovery">
      <summary>
            Provides the ability to discover 'discoverable' peers on the local network.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.PeerDiscovery.LocalListenMode">
      <summary>
            Encapsulates the different local listen modes. If the default mode does
            not work please try the others.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.PeerDiscovery.DiscoveryMethod">
      <summary>
            Encapsulates the different peer discovery methods available.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.PeerDiscovery.PeerListenerEndPoint">
      <summary>
            Used to communicate discoverable listeners between peers
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.PeerDiscovery.PeerDiscoveredHandler">
      <summary>
            The event delegate which can optionally be used when a peer is successfully discovered.
            </summary>
      <param name="peerIdentifier">The ShortGuid corresponding with the discovered peers network identifier</param>
      <param name="discoveredListenerEndPoints">The discovered listener endPoints for the discovered peer</param>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.PeerDiscovery._defaultIPDiscoveryMethod">
      <summary>
            Backing field for DefaultIPDiscoveryMethod
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.PeerDiscovery._syncRoot">
      <summary>
            A private object to ensure thread safety
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.PeerDiscovery._discoverSyncRoot">
      <summary>
            A private object used to prevent parallel discovery requests being made
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.PeerDiscovery.discoveryPacketType">
      <summary>
            The packet type string used for peer discovery
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.PeerDiscovery._discoveryListeners">
      <summary>
            Local listeners specifically associated with this peers discover feature
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.PeerDiscovery._discoveredPeers">
      <summary>
            Dictionary which records discovered peers
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.PeerDiscovery._tcpPortScanThreadPool">
      <summary>
            A custom thread pool for performing a TCPPortScan
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PeerDiscovery.EnableDiscoverable(NetworkCommsDotNet.Tools.PeerDiscovery.DiscoveryMethod)">
      <summary>
            Make this peer discoverable using the provided <see cref="T:NetworkCommsDotNet.Tools.PeerDiscovery.DiscoveryMethod" />. 
            Uses all suitable and allowed adaptors, e.g. for IP networks uses <see cref="M:NetworkCommsDotNet.Tools.HostInfo.IP.FilteredLocalAddresses" />.
            IMPORTANT NOTE: For IP networks we strongly recommend using the UDP broadcast discovery method.
            </summary>
      <param name="discoveryMethod">
      </param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PeerDiscovery.EnableDiscoverable(NetworkCommsDotNet.Tools.PeerDiscovery.DiscoveryMethod,System.Net.EndPoint)">
      <summary>
            Make this peer discoverable using the provided <see cref="T:NetworkCommsDotNet.Tools.PeerDiscovery.DiscoveryMethod" />. 
            IMPORTANT NOTE: For IP networks we strongly recommend using the UDP broadcast discovery method.
            </summary>
      <param name="discoveryMethod">The discovery method for which this peer should be discoverable</param>
      <param name="localDiscoveryEndPoint">The local endpoint with which to make this peer discoverable</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PeerDiscovery.DisableDiscoverable(NetworkCommsDotNet.Tools.PeerDiscovery.DiscoveryMethod)">
      <summary>
            Disable this peers discoverable status for the provided <see cref="T:NetworkCommsDotNet.Tools.PeerDiscovery.DiscoveryMethod" />. 
            </summary>
      <param name="discoveryMethod">The <see cref="T:NetworkCommsDotNet.Tools.PeerDiscovery.DiscoveryMethod" /> to disable discovery for.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PeerDiscovery.DisableDiscoverable">
      <summary>
            Disable this peers discoverable status for all discovery methods.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PeerDiscovery.IsDiscoverable(NetworkCommsDotNet.Tools.PeerDiscovery.DiscoveryMethod)">
      <summary>
            Returns true if local discovery endPoints exist for the provided <see cref="T:NetworkCommsDotNet.Tools.PeerDiscovery.DiscoveryMethod" />.
            </summary>
      <param name="discoveryMethod">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PeerDiscovery.LocalDiscoveryEndPoints(NetworkCommsDotNet.Tools.PeerDiscovery.DiscoveryMethod)">
      <summary>
            Returns the local endpoints that are currently used to make this peer discoverable using
            the provided <see cref="T:NetworkCommsDotNet.Tools.PeerDiscovery.DiscoveryMethod" />.
            </summary>
      <param name="discoveryMethod">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PeerDiscovery.LocalDiscoveryEndPoints">
      <summary>
            Returns the local endpoints that are currently used to make this peer discoverable.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PeerDiscovery.DiscoverPeers(NetworkCommsDotNet.Tools.PeerDiscovery.DiscoveryMethod)">
      <summary>
            Discover local peers using the provided <see cref="T:NetworkCommsDotNet.Tools.PeerDiscovery.DiscoveryMethod" /> and default discover time. Returns
            dictionary keyed on peer network identifier. IMPORTANT NOTE: For IP networks we strongly recommend using the UDP 
            broadcast discovery method.
            </summary>
      <param name="discoveryMethod">The <see cref="T:NetworkCommsDotNet.Tools.PeerDiscovery.DiscoveryMethod" /> to use for discovering peers.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PeerDiscovery.DiscoverPeers(NetworkCommsDotNet.Tools.PeerDiscovery.DiscoveryMethod,System.Int32)">
      <summary>
            Discover local peers using the provided <see cref="T:NetworkCommsDotNet.Tools.PeerDiscovery.DiscoveryMethod" />. Returns
            dictionary keyed on peer network identifier. IMPORTANT NOTE: For IP networks we strongly recommend using the UDP 
            broadcast discovery method.
            </summary>
      <param name="discoveryMethod">The <see cref="T:NetworkCommsDotNet.Tools.PeerDiscovery.DiscoveryMethod" /> to use for discovering peers.</param>
      <param name="discoverTimeMS">The wait time, after all requests have been made, in milliseconds before all discovered peers are returned.</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PeerDiscovery.DiscoverPeersAsync(NetworkCommsDotNet.Tools.PeerDiscovery.DiscoveryMethod)">
      <summary>
            Discover local peers using the provided <see cref="T:NetworkCommsDotNet.Tools.PeerDiscovery.DiscoveryMethod" /> asynchronously. Makes a single async request 
            for peers to announce. Ensure that you append to the OnPeerDiscovered event to handle discovered peers. 
            IMPORTANT NOTE: For IP networks we strongly recommend using the UDP broadcast discovery method.
            </summary>
      <param name="discoveryMethod">
      </param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PeerDiscovery.DiscoverPeersUDP(System.Int32)">
      <summary>
            Discover peers using UDP broadcast
            </summary>
      <param name="discoverTimeMS">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PeerDiscovery.DiscoverPeersTCP(System.Int32)">
      <summary>
            Discover peers using TCP port scan
            </summary>
      <param name="discoverTimeMS">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PeerDiscovery.DiscoverPeersBT(System.Int32)">
      <summary>
            Discover peers using BT SDP
            </summary>
      <param name="discoverTimeout">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PeerDiscovery.PeerDiscoveryHandler(NetworkCommsDotNet.PacketHeader,NetworkCommsDotNet.Connections.Connection,System.Byte[])">
      <summary>
            Handle the incoming peer discovery packet
            </summary>
      <param name="header">
      </param>
      <param name="connection">
      </param>
      <param name="data">
      </param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PeerDiscovery.SerializeLocalListenerList">
      <summary>
            Serializes the local listeners that are discoverable
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PeerDiscovery.DeserializeRemoteListenerList(System.Byte[],NetworkCommsDotNet.Tools.ShortGuid@)">
      <summary>
            Deserializes remote listeners that are discoverable
            </summary>
      <param name="data">
      </param>
      <param name="networkIdentifier">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.PeerDiscovery.DefaultDiscoverTimeMS">
      <summary>
            The wait time in milliseconds before all peers discovered are returned for synchronous discovery methods. Default 2000ms.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.PeerDiscovery.MinTargetLocalIPPort">
      <summary>
            The minimum port number that will be used when making this peer discoverable. Default 10000.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.PeerDiscovery.MaxTargetLocalIPPort">
      <summary>
            The maximum port number that will be used when making this peer discoverable. Default 10020.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.PeerDiscovery.ListenMode">
      <summary>
            The mode to use when listening for incoming peer discovery packets. Some systems require
            one mode whilst on others this will throw exceptions. If you have problems please
            use a different mode. Default is LocalListenMode.EachAdaptorIndependently
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.PeerDiscovery.DefaultIPDiscoveryMethod">
      <summary>
            The default discovery method to use for IP type connections (UDP and TCP). By default this is DiscoveryMethod.UDPBroadcast.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.PeerDiscovery.BluetoothDiscoveryService">
      <summary>
            The service on which discovery will run for bluetooth. Default is '3a768eea-cbda-4926-a82d-831cb89092ac'.
            </summary>
    </member>
    <member name="E:NetworkCommsDotNet.Tools.PeerDiscovery.OnPeerDiscovered">
      <summary>
            Event triggered when a peer is discovered.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.PriorityQueue`1">
      <summary>
            Queue which contains features to add and remove items using a simple priority model.
            </summary>
      <typeparam name="TValue">The type of this queue</typeparam>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.PriorityQueue`1.internalQueues">
      <summary>
            Each internal queue in the array represents a priority level.  
            We keep the priority associated with each item so that when eventually returned the 
            priority can be easily included.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.PriorityQueue`1.QueueItemPriorityVals">
      <summary>
            The list of priorities used to handle incoming packets.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.PriorityQueue`1.numDistinctPriorities">
      <summary>
            The number of queues we store internally. 
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.PriorityQueue`1.totalNumberQueuedItems">
      <summary>
            The total number of items currently in all queues
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PriorityQueue`1.#ctor">
      <summary>
            Create a new instance of the priority queue.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PriorityQueue`1.TryAdd(System.Collections.Generic.KeyValuePair{NetworkCommsDotNet.Tools.QueueItemPriority,`0})">
      <summary>
            Try adding an item to the priority queue.
            </summary>
      <param name="item">Key is priority, lower number is lower priority, and value is TValue</param>
      <returns>True if an item was successfully added to the queue</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PriorityQueue`1.TryTake(System.Collections.Generic.KeyValuePair{NetworkCommsDotNet.Tools.QueueItemPriority,`0}@)">
      <summary>
            Try removing an item from the priority queue
            </summary>
      <param name="item">Key is priority, lower number is lower priority, and value is TValue</param>
      <returns>True if an item was successfully removed from the queue</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PriorityQueue`1.TryTake(NetworkCommsDotNet.Tools.QueueItemPriority,System.Collections.Generic.KeyValuePair{NetworkCommsDotNet.Tools.QueueItemPriority,`0}@)">
      <summary>
            Try removing an item from the priority queue which has a priority of at least that provided.
            </summary>
      <param name="minimumPriority">The minimum priority to consider</param>
      <param name="item">Key is priority, lower number is lower priority, and value is TValue</param>
      <returns>True if an item was successfully removed from the queue</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PriorityQueue`1.CopyTo(System.Collections.Generic.KeyValuePair{NetworkCommsDotNet.Tools.QueueItemPriority,`0}[],System.Int32)">
      <summary>
            Copies queued items into the provided destination array. Highest priority items first descending until 
            destination is full or there are no remaining items.
            </summary>
      <param name="destination">The destination array</param>
      <param name="destStartingIndex">The position within destination to start copying to</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PriorityQueue`1.ToArray">
      <summary>
            Returns all queued items as a 1D array. Highest priority items first descending.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PriorityQueue`1.Clear">
      <summary>
            Clear the content of all queues
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.PriorityQueue`1.Count">
      <summary>
            The total number of items currently queued.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.PriorityQueue`1.IsSynchronized">
      <summary>
            Gets a value indicating whether access to the PriorityQueue is synchronized (thread safe). Always returns true.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.PriorityQueue`1.SyncRoot">
      <summary>
            Gets an object that can be used to synchronize access to the PriorityQueue. Throws an exception as all access is explicitly thread safe.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.PriorityQueueItem">
      <summary>
            Private wrapper class used for passing data to the incoming packet item worker
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.PriorityQueueItem.#ctor(NetworkCommsDotNet.Tools.QueueItemPriority,NetworkCommsDotNet.Connections.Connection,NetworkCommsDotNet.PacketHeader,System.IO.MemoryStream,NetworkCommsDotNet.SendReceiveOptions)">
      <summary>
            Initialise a new PriorityQueueItem
            </summary>
      <param name="priority">
      </param>
      <param name="connection">
      </param>
      <param name="packetHeader">
      </param>
      <param name="dataStream">
      </param>
      <param name="sendReceiveOptions">
      </param>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.QueueItemPriority">
      <summary>
            A list of priorities used to handle incoming packets
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.QueueItemPriority.Lowest">
      <summary>
            The System.Threading.Thread can be scheduled after threads with any other priority.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.QueueItemPriority.BelowNormal">
      <summary>
             The System.Threading.Thread can be scheduled after threads with Normal priority and before those with Lowest priority.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.QueueItemPriority.Normal">
      <summary>
            The System.Threading.Thread can be scheduled after threads with AboveNormal priority and before those with BelowNormal priority. Threads have Normal priority by default.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.QueueItemPriority.AboveNormal">
      <summary>
            The System.Threading.Thread can be scheduled after threads with Highest priority and before those with Normal priority.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.QueueItemPriority.Highest">
      <summary>
            The System.Threading.Thread can be scheduled before threads with any other priority.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.ShortGuid">
      <summary>
            Represents a shortform globally unique identifier (<see href="http://en.wikipedia.org/wiki/Globally_unique_identifier">GUID</see>) which is easier to handle than Guid.NewGuid(). 
            This class is used to uniquely identify a peer/application using NetworkComms.Net.
            See <see href="http://www.singular.co.nz/blog/archive/2007/12/20/shortguid-a-shorter-and-url-friendly-guid-in-c-sharp.aspx">here</see> for original source.
            </summary>
    </member>
    <member name="F:NetworkCommsDotNet.Tools.ShortGuid.Empty">
      <summary>
            A read-only instance of the ShortGuid class whose value
            is guaranteed to be all zeroes.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ShortGuid.#ctor(System.String)">
      <summary>
            Creates a ShortGuid from a base64 encoded string
            </summary>
      <param name="value">The encoded guid as a
            base64 string</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ShortGuid.#ctor(System.Guid)">
      <summary>
            Creates a ShortGuid from a Guid
            </summary>
      <param name="guid">The Guid to encode</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ShortGuid.ToString">
      <summary>
            Returns the base64 encoded guid as a string
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ShortGuid.Equals(System.Object)">
      <summary>
            Returns a value indicating whether this instance and a
            specified Object represent the same type and value.
            </summary>
      <param name="obj">The object to compare</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ShortGuid.GetHashCode">
      <summary>
            Returns the HashCode for underlying Guid.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ShortGuid.NewGuid">
      <summary>
            Initialises a new instance of the ShortGuid class
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ShortGuid.Encode(System.String)">
      <summary>
            Creates a new instance of a Guid using the string value,
            then returns the base64 encoded version of the Guid.
            </summary>
      <param name="value">An actual Guid string (i.e. not a ShortGuid)</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ShortGuid.Encode(System.Guid)">
      <summary>
            Encodes the given Guid as a base64 string that is 22
            characters long.
            </summary>
      <param name="guid">The Guid to encode</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ShortGuid.Decode(System.String)">
      <summary>
            Decodes the given base64 string
            </summary>
      <param name="value">The base64 encoded string of a Guid</param>
      <returns>A new Guid</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ShortGuid.op_Equality(NetworkCommsDotNet.Tools.ShortGuid,NetworkCommsDotNet.Tools.ShortGuid)">
      <summary>
            Determines if both ShortGuids have the same underlying
            Guid value.
            </summary>
      <param name="x">
      </param>
      <param name="y">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ShortGuid.op_Inequality(NetworkCommsDotNet.Tools.ShortGuid,NetworkCommsDotNet.Tools.ShortGuid)">
      <summary>
            Determines if both ShortGuids do not have the
            same underlying Guid value.
            </summary>
      <param name="x">
      </param>
      <param name="y">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ShortGuid.op_Implicit(NetworkCommsDotNet.Tools.ShortGuid)~System.String">
      <summary>
            Implicitly converts the ShortGuid to it's string equivilent
            </summary>
      <param name="shortGuid">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ShortGuid.op_Implicit(NetworkCommsDotNet.Tools.ShortGuid)~System.Guid">
      <summary>
            Implicitly converts the ShortGuid to it's Guid equivilent
            </summary>
      <param name="shortGuid">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ShortGuid.op_Implicit(System.String)~NetworkCommsDotNet.Tools.ShortGuid">
      <summary>
            Implicitly converts the string to a ShortGuid
            </summary>
      <param name="shortGuid">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.ShortGuid.op_Implicit(System.Guid)~NetworkCommsDotNet.Tools.ShortGuid">
      <summary>
            Implicitly converts the Guid to a ShortGuid
            </summary>
      <param name="guid">
      </param>
      <returns>
      </returns>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.ShortGuid.Guid">
      <summary>
            Gets/sets the underlying Guid
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.ShortGuid.Value">
      <summary>
            Gets/sets the underlying base64 encoded string
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.CertificateDetails">
      <summary>
            Contains the information required to create self signed certificates
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CertificateDetails.#ctor(System.String,System.DateTime,System.DateTime,System.Security.SecureString)">
      <summary>
            Initialise certificate details.
            </summary>
      <param name="x500">Certificates "distinguished name". An example is "CN='My Certificate'; C='USA'". 
            Please see http://msdn.microsoft.com/en-us/library/aa377160 and http://en.wikipedia.org/wiki/X.509 for more information.</param>
      <param name="startTime">Certificate validity start DateTime</param>
      <param name="endTime">Certificate validity end DateTime</param>
      <param name="password">Password for encrypting the key data</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CertificateDetails.#ctor(System.String,System.DateTime,System.DateTime,System.String)">
      <summary>
            Initialise certificate details.
            </summary>
      <param name="x500">Certificates "distinguished name". An example is "CN='My Certificate'; C='USA'". 
            Please see http://msdn.microsoft.com/en-us/library/aa377160 and http://en.wikipedia.org/wiki/X.509 for more information.</param>
      <param name="startTime">Certificate validity start DateTime</param>
      <param name="endTime">Certificate validity end DateTime</param>
      <param name="insecurePassword">Password for encrypting the key data</param>
      <returns>PFX file data</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CertificateDetails.#ctor(System.String,System.DateTime,System.DateTime)">
      <summary>
            Initialise certificate details.
            </summary>
      <param name="x500">Certificates "distinguished name". An example is "CN='My Certificate'; C='USA'". 
            Please see http://msdn.microsoft.com/en-us/library/aa377160 and http://en.wikipedia.org/wiki/X.509 for more information.</param>
      <param name="startTime">Certificate validity start DateTime</param>
      <param name="endTime">Certificate validity end DateTime</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.CertificateDetails.Dispose">
      <summary>
            Dispose of the secure string password
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.CertificateDetails.X500">
      <summary>
            Certificate "distinguished name". An example is "CN='My Certificate'; C='USA'". 
            Please see http://msdn.microsoft.com/en-us/library/aa377160 and http://en.wikipedia.org/wiki/X.509 for more information.
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.CertificateDetails.StartTime">
      <summary>
            Certificate validity start DateTime
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.CertificateDetails.EndTime">
      <summary>
            Certificate validity end DateTime
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.CertificateDetails.Password">
      <summary>
            Password for encrypting the key data
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.CertificateDetails.KeyLength">
      <summary>
            The key length to be generated. Default is 1024. Minimum is 384. maximum is 16384.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.SSLTools">
      <summary>
            Tools used in conjunction with SSL encrypted connections.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.SSLTools.NativeMethods.CryptGenKey(System.IntPtr,System.Int32,System.Int32,System.IntPtr@)">
      <summary>
            See http://msdn.microsoft.com/en-us/library/windows/desktop/aa379941(v=vs.85).aspx for more information.
            </summary>
      <param name="providerContext">
      </param>
      <param name="algorithmId">
      </param>
      <param name="flags">
      </param>
      <param name="cryptKeyHandle">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.SSLTools.CreateSelfSignedCertificatePFX(NetworkCommsDotNet.Tools.CertificateDetails,System.String)">
      <summary>
            Creates a self signed certificate which can be used for peer to peer authentication and 
            saves it to disk using provided certificateFileName. Initial implementation used with permission from http://blogs.msdn.com/b/dcook/archive/2008/11/25/creating-a-self-signed-certificate-in-c.aspx
            </summary>
      <param name="certificateDetails">The certificate details to use.</param>
      <param name="certificateFileName">The certificate file name, e.g. certFile.PFX</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.SSLTools.CreateSelfSignedCertificatePFX(NetworkCommsDotNet.Tools.CertificateDetails)">
      <summary>
            Creates a self signed certificate which can be used for peer to peer authentication. 
            Initial implementation used with permission from http://blogs.msdn.com/b/dcook/archive/2008/11/25/creating-a-self-signed-certificate-in-c.aspx
            </summary>
      <param name="certificateDetails">The certificate details to use.</param>
      <returns>PFX file data</returns>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.StreamTools">
      <summary>
            Wrapper class for writing to streams with time-outs. Used primarily to prevent stream write deadlocks.
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.StreamTools.StreamSendWrapper">
      <summary>
            Used to send all or parts of a stream. Particularly useful for sending files directly from disk etc.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.StreamSendWrapper.#ctor(NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream)">
      <summary>
            Create a new stream wrapper and set Start and Length to encompass the entire Stream
            </summary>
      <param name="stream">The underlying stream</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.StreamSendWrapper.#ctor(NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream,System.Int64,System.Int64)">
      <summary>
            Create a new stream wrapper
            </summary>
      <param name="stream">The underlying stream</param>
      <param name="start">The start position from where to read data</param>
      <param name="length">The length to read</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.StreamSendWrapper.MD5CheckSum">
      <summary>
            Return the MD5 for the specific part of the stream only.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.StreamSendWrapper.Dispose">
      <summary>
            Dispose the internal ThreadSafeStream
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.StreamTools.StreamSendWrapper.ThreadSafeStream">
      <summary>
            The wrapped stream
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.StreamTools.StreamSendWrapper.Start">
      <summary>
            The start position to read from Stream
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.StreamTools.StreamSendWrapper.Length">
      <summary>
            The number of bytes to read from Stream
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream">
      <summary>
            A wrapper around a stream to ensure it can be accessed in a thread safe way. The .net implementation of Stream.Synchronized is not suitable on its own.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.#ctor(System.IO.Stream)">
      <summary>
            Create a thread safe stream. Once any actions are complete the stream must be correctly disposed by the user.
            </summary>
      <param name="stream">The stream to make thread safe</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.#ctor(System.IO.Stream,System.Boolean)">
      <summary>
            Create a thread safe stream.
            </summary>
      <param name="stream">The stream to make thread safe.</param>
      <param name="closeStreamAfterSend">If true the provided stream will be disposed once data has been written to the network. If false the stream must be disposed of correctly by the user</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.SetLength(System.Int64)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.Seek(System.Int64,System.IO.SeekOrigin)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.ToArray(System.Int32)">
      <summary>
            Returns data from entire Stream
            </summary>
      <param name="numberZeroBytesPrefex">If non zero will append N 0 value bytes to the start of the returned array</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.ToArray(System.Int64,System.Int64,System.Int32,System.Int32)">
      <summary>
            Returns data from the specified portion of Stream
            </summary>
      <param name="start">The start position of the desired bytes</param>
      <param name="length">The total number of desired bytes, not including the zero byte prefix and append parameters</param>
      <param name="numberZeroBytesPrefix">If non zero will append N 0 value bytes to the start of the returned array</param>
      <param name="numberZeroBytesAppend">If non zero will append N 0 value bytes to the end of the returned array</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.MD5">
      <summary>
            Return the MD5 hash of the current <see cref="T:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream" /> as a string
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.MD5(System.Int64,System.Int32)">
      <summary>
            Return the MD5 hash of part of the current <see cref="T:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream" /> as a string
            </summary>
      <param name="start">The start position in the stream</param>
      <param name="length">The length of stream to MD5</param>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.Write(System.Byte[],System.Int64)">
      <summary>
            Writes the provided buffer to the internal stream starting at the provided position within the internal stream
            </summary>
      <param name="buffer">
      </param>
      <param name="startPosition">
      </param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.Write(System.Byte[],System.Int32,System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.CopyTo(System.IO.Stream,System.Int64,System.Int64,System.Int32,System.Double,System.Int32)">
      <summary>
            Copies data specified by start and length properties from internal stream to the provided stream.
            </summary>
      <param name="destinationStream">The destination stream to write to</param>
      <param name="startPosition">
      </param>
      <param name="length">
      </param>
      <param name="writeBufferSize">The buffer size to use for copying stream contents</param>
      <param name="minTimeoutMS">The minimum time allowed for any sized copy</param>
      <param name="timeoutMSPerKBWrite">The timouts in milliseconds per KB to write</param>
      <returns>The average time in milliseconds per byte written</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.GetBuffer">
      <summary>
            Attempts to return the buffer associated with the internal stream. In certain circumstances this is more efficient
            than copying the stream contents into a new buffer using ToArray. If the internal stream is not a memory stream 
            will throw InvalidCastException. If access to the buffer is not allowed will throw an UnauthorizedAccessException.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.Read(System.Byte[],System.Int32,System.Int32)">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.Dispose">
      <summary>
            Disposes the internal stream if <see cref="P:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.DiposeInnerStreamOnDispose" /> is true. 
            Use Close() to close the inner stream regardless of <see cref="P:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.DiposeInnerStreamOnDispose" />.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.Dispose(System.Boolean)">
      <summary>
            Disposes the internal stream. If <see cref="P:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.DiposeInnerStreamOnDispose" /> is false, forceDispose
            must be true to dispose of the internal stream.
            </summary>
      <param name="forceDispose">If true the internal stream will be disposed regardless of <see cref="P:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.DiposeInnerStreamOnDispose" /> value.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.Flush">
      <inheritdoc />
    </member>
    <member name="P:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.DiposeInnerStreamOnDispose">
      <summary>
            If true the internal stream will be disposed once the data has been written to the network
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.Length">
      <summary>
            The total length of the internal stream
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.Position">
      <summary>
            The current position of the internal stream
            </summary>
    </member>
    <member name="P:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.CanRead">
      <inheritdoc />
    </member>
    <member name="P:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.CanSeek">
      <inheritdoc />
    </member>
    <member name="P:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.CanWrite">
      <inheritdoc />
    </member>
    <member name="F:NetworkCommsDotNet.Tools.StreamTools.errorLocker">
      <summary>
            Locker for LogError() which ensures thread safe saves.
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.Write(System.Byte[],System.Int32,System.Int32,System.IO.Stream,System.Int32,System.Double,System.Int32)">
      <summary>
            Write the provided sendbuffer to the destination stream in chunks of writeBufferSize. Throws exception if any write takes longer than timeoutPerByteWriteMS.
            </summary>
      <param name="sendBuffer">Buffer containing data to write</param>
      <param name="inputStart">The start position in sendBuffer</param>
      <param name="bufferLength">The number of bytes to write</param>
      <param name="destinationStream">The destination stream</param>
      <param name="writeBufferSize">The size in bytes of each successive write</param>
      <param name="timeoutMSPerKBWrite">The maximum time to allow for write to complete per KB</param>
      <param name="minTimeoutMS">The minimum time to allow for any sized write</param>
      <returns>The average time in milliseconds per KB written</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.Write(System.IO.Stream,System.Int64,System.Int64,System.IO.Stream,System.Int32,System.Double,System.Int32)">
      <summary>
            Write the provided input stream to the destination stream in chunks of writeBufferSize. Throws exception if any write takes longer than timeoutPerByteWriteMS.
            </summary>
      <param name="inputStream">Input stream containing data to send</param>
      <param name="inputStart">The start position in inputStream</param>
      <param name="inputLength">The number of bytes to write</param>
      <param name="destinationStream">The destination stream</param>
      <param name="writeBufferSize">The size in bytes of each successive write, recommended 8K</param>
      <param name="timeoutMSPerKBWrite">The maximum time to allow for write to complete per KB</param>
      <param name="minTimeoutMS">The minimum time to wait per write, this takes priority over other values.</param>
      <returns>The average time in milliseconds per KB written</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.Write(System.IO.Stream,System.IO.Stream)">
      <summary>
            Write the provided input stream to the destination stream
            </summary>
      <param name="inputStream">Input stream containing data to send</param>
      <param name="destinationStream">The destination stream</param>
      <returns>The average time in milliseconds per KB written</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.AppendStringToLogFile(System.String,System.String)">
      <summary>
            Appends the provided logString to end of fileName.txt. If the file does not exist it will be created.
            </summary>
      <param name="fileName">The filename to use. The extension .txt will be appended automatically</param>
      <param name="logString">The string to append.</param>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.MD5(System.IO.Stream,System.Int64,System.Int32)">
      <summary>
            Return the MD5 hash of the provided memory stream as a string. Stream position will be equal to the length of stream on 
            return, this ensures the MD5 is consistent.
            </summary>
      <param name="streamToMD5">The bytes which will be checksummed</param>
      <param name="start">The start position in the stream</param>
      <param name="length">The length in the stream to MD5</param>
      <returns>The MD5 checksum as a string</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.MD5(System.Byte[])">
      <summary>
            Return the MD5 hash of the provided byte array as a string
            </summary>
      <param name="bytesToMd5">The bytes which will be checksummed</param>
      <returns>The MD5 checksum as a string</returns>
    </member>
    <member name="M:NetworkCommsDotNet.Tools.StreamTools.MD5(System.IO.Stream)">
      <summary>
            Return the MD5 hash of the provided memory stream as a string. Stream position will be equal to the length of stream on 
            return, this ensures the MD5 is consistent.
            </summary>
      <param name="streamToMD5">The bytes which will be checksummed</param>
      <returns>The MD5 checksum as a string</returns>
    </member>
    <member name="T:ProtoBuf.BclHelpers">
      <summary>
            Provides support for common .NET types that do not have a direct representation
            in protobuf, using the definitions from bcl.proto
            </summary>
    </member>
    <member name="T:ProtoBuf.BclHelpers.NetObjectOptions">
      <summary>
            Optional behaviours that introduce .NET-specific functionality
            </summary>
    </member>
    <member name="M:ProtoBuf.BclHelpers.GetUninitializedObject(System.Type)">
      <summary>
            Creates a new instance of the specified type, bypassing the constructor.
            </summary>
      <param name="type">The type to create</param>
      <returns>The new instance</returns>
      <exception cref="T:System.NotSupportedException">If the platform does not support constructor-skipping</exception>
    </member>
    <member name="M:ProtoBuf.BclHelpers.WriteTimeSpan(System.TimeSpan,ProtoBuf.ProtoWriter)">
      <summary>
            Writes a TimeSpan to a protobuf stream
            </summary>
    </member>
    <member name="M:ProtoBuf.BclHelpers.ReadTimeSpan(ProtoBuf.ProtoReader)">
      <summary>
            Parses a TimeSpan from a protobuf stream
            </summary>
    </member>
    <member name="M:ProtoBuf.BclHelpers.ReadDateTime(ProtoBuf.ProtoReader)">
      <summary>
            Parses a DateTime from a protobuf stream
            </summary>
    </member>
    <member name="M:ProtoBuf.BclHelpers.WriteDateTime(System.DateTime,ProtoBuf.ProtoWriter)">
      <summary>
            Writes a DateTime to a protobuf stream
            </summary>
    </member>
    <member name="M:ProtoBuf.BclHelpers.ReadDecimal(ProtoBuf.ProtoReader)">
      <summary>
            Parses a decimal from a protobuf stream
            </summary>
    </member>
    <member name="M:ProtoBuf.BclHelpers.WriteDecimal(System.Decimal,ProtoBuf.ProtoWriter)">
      <summary>
            Writes a decimal to a protobuf stream
            </summary>
    </member>
    <member name="M:ProtoBuf.BclHelpers.WriteGuid(System.Guid,ProtoBuf.ProtoWriter)">
      <summary>
            Writes a Guid to a protobuf stream
            </summary>
    </member>
    <member name="M:ProtoBuf.BclHelpers.ReadGuid(ProtoBuf.ProtoReader)">
      <summary>
            Parses a Guid from a protobuf stream
            </summary>
    </member>
    <member name="M:ProtoBuf.BclHelpers.ReadNetObject(System.Object,ProtoBuf.ProtoReader,System.Int32,System.Type,ProtoBuf.BclHelpers.NetObjectOptions)">
      <summary>
            Reads an *implementation specific* bundled .NET object, including (as options) type-metadata, identity/re-use, etc.
            </summary>
    </member>
    <member name="M:ProtoBuf.BclHelpers.WriteNetObject(System.Object,ProtoBuf.ProtoWriter,System.Int32,ProtoBuf.BclHelpers.NetObjectOptions)">
      <summary>
            Writes an *implementation specific* bundled .NET object, including (as options) type-metadata, identity/re-use, etc.
            </summary>
    </member>
    <member name="T:ProtoBuf.IExtension">
      <summary>
            Provides addition capability for supporting unexpected fields during
            protocol-buffer serialization/deserialization. This allows for loss-less
            round-trip/merge, even when the data is not fully understood.
            </summary>
    </member>
    <member name="M:ProtoBuf.IExtension.BeginAppend">
      <summary>
            Requests a stream into which any unexpected fields can be persisted.
            </summary>
      <returns>A new stream suitable for storing data.</returns>
    </member>
    <member name="M:ProtoBuf.IExtension.EndAppend(System.IO.Stream,System.Boolean)">
      <summary>
            Indicates that all unexpected fields have now been stored. The
            implementing class is responsible for closing the stream. If
            "commit" is not true the data may be discarded.
            </summary>
      <param name="stream">The stream originally obtained by BeginAppend.</param>
      <param name="commit">True if the append operation completed successfully.</param>
    </member>
    <member name="M:ProtoBuf.IExtension.BeginQuery">
      <summary>
            Requests a stream of the unexpected fields previously stored.
            </summary>
      <returns>A prepared stream of the unexpected fields.</returns>
    </member>
    <member name="M:ProtoBuf.IExtension.EndQuery(System.IO.Stream)">
      <summary>
            Indicates that all unexpected fields have now been read. The
            implementing class is responsible for closing the stream.
            </summary>
      <param name="stream">The stream originally obtained by BeginQuery.</param>
    </member>
    <member name="M:ProtoBuf.IExtension.GetLength">
      <summary>
            Requests the length of the raw binary stream; this is used
            when serializing sub-entities to indicate the expected size.
            </summary>
      <returns>The length of the binary stream representing unexpected data.</returns>
    </member>
    <member name="T:ProtoBuf.BufferExtension">
      <summary>
            Provides a simple buffer-based implementation of an <see cref="T:ProtoBuf.IExtension">extension</see> object.
            </summary>
    </member>
    <member name="T:ProtoBuf.ProtoBeforeSerializationAttribute">
      <summary>Specifies a method on the root-contract in an hierarchy to be invoked before serialization.</summary>
    </member>
    <member name="T:ProtoBuf.ProtoAfterSerializationAttribute">
      <summary>Specifies a method on the root-contract in an hierarchy to be invoked after serialization.</summary>
    </member>
    <member name="T:ProtoBuf.ProtoBeforeDeserializationAttribute">
      <summary>Specifies a method on the root-contract in an hierarchy to be invoked before deserialization.</summary>
    </member>
    <member name="T:ProtoBuf.ProtoAfterDeserializationAttribute">
      <summary>Specifies a method on the root-contract in an hierarchy to be invoked after deserialization.</summary>
    </member>
    <member name="M:ProtoBuf.Compiler.CompilerContext.UsingBlock.#ctor(ProtoBuf.Compiler.CompilerContext,ProtoBuf.Compiler.Local)">
      <summary>
            Creates a new "using" block (equivalent) around a variable;
            the variable must exist, and note that (unlike in C#) it is
            the variables *final* value that gets disposed. If you need
            *original* disposal, copy your variable first.
            
            It is the callers responsibility to ensure that the variable's
            scope fully-encapsulates the "using"; if not, the variable
            may be re-used (and thus re-assigned) unexpectedly.
            </summary>
    </member>
    <member name="M:ProtoBuf.Compiler.CompilerContext.LoadNullRef">
      <summary>
            Pushes a null reference onto the stack. Note that this should only
            be used to return a null (or set a variable to null); for null-tests
            use BranchIfTrue / BranchIfFalse.
            </summary>
    </member>
    <member name="T:ProtoBuf.DataFormat">
      <summary>
            Sub-format to use when serializing/deserializing data
            </summary>
    </member>
    <member name="F:ProtoBuf.DataFormat.Default">
      <summary>
            Uses the default encoding for the data-type.
            </summary>
    </member>
    <member name="F:ProtoBuf.DataFormat.ZigZag">
      <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that zigzag variant encoding will be used. This means that values
            with small magnitude (regardless of sign) take a small amount
            of space to encode.
            </summary>
    </member>
    <member name="F:ProtoBuf.DataFormat.TwosComplement">
      <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that two's-complement variant encoding will be used.
            This means that any -ve number will take 10 bytes (even for 32-bit),
            so should only be used for compatibility.
            </summary>
    </member>
    <member name="F:ProtoBuf.DataFormat.FixedSize">
      <summary>
            When applied to signed integer-based data (including Decimal), this
            indicates that a fixed amount of space will be used.
            </summary>
    </member>
    <member name="F:ProtoBuf.DataFormat.Group">
      <summary>
            When applied to a sub-message, indicates that the value should be treated
            as group-delimited.
            </summary>
    </member>
    <member name="T:ProtoBuf.IExtensible">
      <summary>
            Indicates that the implementing type has support for protocol-buffer
            <see cref="T:ProtoBuf.IExtension">extensions</see>.
            </summary>
      <remarks>Can be implemented by deriving from Extensible.</remarks>
    </member>
    <member name="M:ProtoBuf.IExtensible.GetExtensionObject(System.Boolean)">
      <summary>
            Retrieves the <see cref="T:ProtoBuf.IExtension">extension</see> object for the current
            instance, optionally creating it if it does not already exist.
            </summary>
      <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
      <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
      <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
    </member>
    <member name="T:ProtoBuf.Extensible">
      <summary>
            Simple base class for supporting unexpected fields allowing
            for loss-less round-tips/merge, even if the data is not understod.
            The additional fields are (by default) stored in-memory in a buffer.
            </summary>
      <remarks>As an example of an alternative implementation, you might
            choose to use the file system (temporary files) as the back-end, tracking
            only the paths [such an object would ideally be IDisposable and use
            a finalizer to ensure that the files are removed].</remarks>
      <seealso cref="T:ProtoBuf.IExtensible" />
    </member>
    <member name="M:ProtoBuf.Extensible.GetExtensionObject(System.Boolean)">
      <summary>
            Retrieves the <see cref="T:ProtoBuf.IExtension">extension</see> object for the current
            instance, optionally creating it if it does not already exist.
            </summary>
      <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
      <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
      <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
    </member>
    <member name="M:ProtoBuf.Extensible.GetExtensionObject(ProtoBuf.IExtension@,System.Boolean)">
      <summary>
            Provides a simple, default implementation for <see cref="T:ProtoBuf.IExtension">extension</see> support,
            optionally creating it if it does not already exist. Designed to be called by
            classes implementing <see cref="T:ProtoBuf.IExtensible" />.
            </summary>
      <param name="createIfMissing">Should a new extension object be
            created if it does not already exist?</param>
      <param name="extensionObject">The extension field to check (and possibly update).</param>
      <returns>The extension object if it exists (or was created), or null
            if the extension object does not exist or is not available.</returns>
      <remarks>The <c>createIfMissing</c> argument is false during serialization,
            and true during deserialization upon encountering unexpected fields.</remarks>
    </member>
    <member name="M:ProtoBuf.Extensible.AppendValue``1(ProtoBuf.IExtensible,System.Int32,``0)">
      <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
      <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
      <typeparam name="TValue">The type of the value to append.</typeparam>
      <param name="instance">The extensible object to append the value to.</param>
      <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
      <param name="value">The value to append.</param>
    </member>
    <member name="M:ProtoBuf.Extensible.AppendValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,``0)">
      <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
      <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
      <typeparam name="TValue">The data-type of the field.</typeparam>
      <param name="format">The data-format to use when encoding the value.</param>
      <param name="instance">The extensible object to append the value to.</param>
      <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
      <param name="value">The value to append.</param>
    </member>
    <member name="M:ProtoBuf.Extensible.GetValue``1(ProtoBuf.IExtensible,System.Int32)">
      <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned is the composed value after merging any duplicated content; if the
            value is "repeated" (a list), then use GetValues instead.
            </summary>
      <typeparam name="TValue">The data-type of the field.</typeparam>
      <param name="instance">The extensible object to obtain the value from.</param>
      <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
      <returns>The effective value of the field, or the default value if not found.</returns>
    </member>
    <member name="M:ProtoBuf.Extensible.GetValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat)">
      <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned is the composed value after merging any duplicated content; if the
            value is "repeated" (a list), then use GetValues instead.
            </summary>
      <typeparam name="TValue">The data-type of the field.</typeparam>
      <param name="instance">The extensible object to obtain the value from.</param>
      <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
      <param name="format">The data-format to use when decoding the value.</param>
      <returns>The effective value of the field, or the default value if not found.</returns>
    </member>
    <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.IExtensible,System.Int32,``0@)">
      <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
      <typeparam name="TValue">The data-type of the field.</typeparam>
      <param name="value">The effective value of the field, or the default value if not found.</param>
      <param name="instance">The extensible object to obtain the value from.</param>
      <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
      <returns>True if data for the field was present, false otherwise.</returns>
    </member>
    <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,``0@)">
      <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
      <typeparam name="TValue">The data-type of the field.</typeparam>
      <param name="value">The effective value of the field, or the default value if not found.</param>
      <param name="instance">The extensible object to obtain the value from.</param>
      <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
      <param name="format">The data-format to use when decoding the value.</param>
      <returns>True if data for the field was present, false otherwise.</returns>
    </member>
    <member name="M:ProtoBuf.Extensible.TryGetValue``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,``0@)">
      <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
      <typeparam name="TValue">The data-type of the field.</typeparam>
      <param name="value">The effective value of the field, or the default value if not found.</param>
      <param name="instance">The extensible object to obtain the value from.</param>
      <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
      <param name="format">The data-format to use when decoding the value.</param>
      <param name="allowDefinedTag">Allow tags that are present as part of the definition; for example, to query unknown enum values.</param>
      <returns>True if data for the field was present, false otherwise.</returns>
    </member>
    <member name="M:ProtoBuf.Extensible.GetValues``1(ProtoBuf.IExtensible,System.Int32)">
      <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
      <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
      <typeparam name="TValue">The data-type of the field.</typeparam>
      <param name="instance">The extensible object to obtain the value from.</param>
      <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
      <returns>An enumerator that yields each occurrence of the field.</returns>
    </member>
    <member name="M:ProtoBuf.Extensible.GetValues``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat)">
      <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
      <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
      <typeparam name="TValue">The data-type of the field.</typeparam>
      <param name="instance">The extensible object to obtain the value from.</param>
      <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
      <param name="format">The data-format to use when decoding the value.</param>
      <returns>An enumerator that yields each occurrence of the field.</returns>
    </member>
    <member name="M:ProtoBuf.Extensible.TryGetValue(ProtoBuf.Meta.TypeModel,System.Type,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,System.Object@)">
      <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            The value returned (in "value") is the composed value after merging any duplicated content;
            if the value is "repeated" (a list), then use GetValues instead.
            </summary>
      <param name="type">The data-type of the field.</param>
      <param name="model">The model to use for configuration.</param>
      <param name="value">The effective value of the field, or the default value if not found.</param>
      <param name="instance">The extensible object to obtain the value from.</param>
      <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
      <param name="format">The data-format to use when decoding the value.</param>
      <param name="allowDefinedTag">Allow tags that are present as part of the definition; for example, to query unknown enum values.</param>
      <returns>True if data for the field was present, false otherwise.</returns>
    </member>
    <member name="M:ProtoBuf.Extensible.GetValues(ProtoBuf.Meta.TypeModel,System.Type,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat)">
      <summary>
            Queries an extensible object for an additional (unexpected) data-field for the instance.
            Each occurrence of the field is yielded separately, making this usage suitable for "repeated"
            (list) fields.
            </summary>
      <remarks>The extended data is processed lazily as the enumerator is iterated.</remarks>
      <param name="model">The model to use for configuration.</param>
      <param name="type">The data-type of the field.</param>
      <param name="instance">The extensible object to obtain the value from.</param>
      <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
      <param name="format">The data-format to use when decoding the value.</param>
      <returns>An enumerator that yields each occurrence of the field.</returns>
    </member>
    <member name="M:ProtoBuf.Extensible.AppendValue(ProtoBuf.Meta.TypeModel,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Object)">
      <summary>
            Appends the value as an additional (unexpected) data-field for the instance.
            Note that for non-repeated sub-objects, this equates to a merge operation;
            for repeated sub-objects this adds a new instance to the set; for simple
            values the new value supercedes the old value.
            </summary>
      <remarks>Note that appending a value does not remove the old value from
            the stream; avoid repeatedly appending values for the same field.</remarks>
      <param name="model">The model to use for configuration.</param>
      <param name="format">The data-format to use when encoding the value.</param>
      <param name="instance">The extensible object to append the value to.</param>
      <param name="tag">The field identifier; the tag should not be defined as a known data-field for the instance.</param>
      <param name="value">The value to append.</param>
    </member>
    <member name="T:ProtoBuf.ExtensibleUtil">
      <summary>
            This class acts as an internal wrapper allowing us to do a dynamic
            methodinfo invoke; an't put into Serializer as don't want on public
            API; can't put into Serializer&lt;T&gt; since we need to invoke
            accross classes, which isn't allowed in Silverlight)
            </summary>
    </member>
    <member name="M:ProtoBuf.ExtensibleUtil.GetExtendedValues``1(ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,System.Boolean)">
      <summary>
            All this does is call GetExtendedValuesTyped with the correct type for "instance";
            this ensures that we don't get issues with subclasses declaring conflicting types -
            the caller must respect the fields defined for the type they pass in.
            </summary>
    </member>
    <member name="M:ProtoBuf.ExtensibleUtil.GetExtendedValues(ProtoBuf.Meta.TypeModel,System.Type,ProtoBuf.IExtensible,System.Int32,ProtoBuf.DataFormat,System.Boolean,System.Boolean)">
      <summary>
            All this does is call GetExtendedValuesTyped with the correct type for "instance";
            this ensures that we don't get issues with subclasses declaring conflicting types -
            the caller must respect the fields defined for the type they pass in.
            </summary>
    </member>
    <member name="T:ProtoBuf.Helpers">
      <summary>
            Not all frameworks are created equal (fx1.1 vs fx2.0,
            micro-framework, compact-framework,
            silverlight, etc). This class simply wraps up a few things that would
            otherwise make the real code unnecessarily messy, providing fallback
            implementations if necessary.
            </summary>
    </member>
    <member name="T:ProtoBuf.ProtoTypeCode">
      <summary>
            Intended to be a direct map to regular TypeCode, but:
            - with missing types
            - existing on WinRT
            </summary>
    </member>
    <member name="T:ProtoBuf.ImplicitFields">
      <summary>
            Specifies the method used to infer field tags for members of the type
            under consideration. Tags are deduced using the invariant alphabetic
            sequence of the members' names; this makes implicit field tags very brittle,
            and susceptible to changes such as field names (normally an isolated
            change).
            </summary>
    </member>
    <member name="F:ProtoBuf.ImplicitFields.None">
      <summary>
            No members are serialized implicitly; all members require a suitable
            attribute such as [ProtoMember]. This is the recmomended mode for
            most scenarios.
            </summary>
    </member>
    <member name="F:ProtoBuf.ImplicitFields.AllPublic">
      <summary>
            Public properties and fields are eligible for implicit serialization;
            this treats the public API as a contract. Ordering beings from ImplicitFirstTag.
            </summary>
    </member>
    <member name="F:ProtoBuf.ImplicitFields.AllFields">
      <summary>
            Public and non-public fields are eligible for implicit serialization;
            this acts as a state/implementation serializer. Ordering beings from ImplicitFirstTag.
            </summary>
    </member>
    <member name="T:ProtoBuf.Meta.CallbackSet">
      <summary>
            Represents the set of serialization callbacks to be used when serializing/deserializing a type.
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.CallbackSet.BeforeSerialize">
      <summary>Called before serializing an instance</summary>
    </member>
    <member name="P:ProtoBuf.Meta.CallbackSet.BeforeDeserialize">
      <summary>Called before deserializing an instance</summary>
    </member>
    <member name="P:ProtoBuf.Meta.CallbackSet.AfterSerialize">
      <summary>Called after serializing an instance</summary>
    </member>
    <member name="P:ProtoBuf.Meta.CallbackSet.AfterDeserialize">
      <summary>Called after deserializing an instance</summary>
    </member>
    <member name="P:ProtoBuf.Meta.CallbackSet.NonTrivial">
      <summary>
            True if any callback is set, else False
            </summary>
    </member>
    <member name="T:ProtoBuf.Meta.MetaType">
      <summary>
            Represents a type at runtime for use with protobuf, allowing the field mappings (etc) to be defined
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.MetaType.ToString">
      <summary>
            Get the name of the type being represented
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.MetaType.AddSubType(System.Int32,System.Type)">
      <summary>
            Adds a known sub-type to the inheritance model
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.MetaType.AddSubType(System.Int32,System.Type,ProtoBuf.DataFormat)">
      <summary>
            Adds a known sub-type to the inheritance model
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.MetaType.SetCallbacks(System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
      <summary>
            Assigns the callbacks to use during serialiation/deserialization.
            </summary>
      <param name="beforeSerialize">The method (or null) called before serialization begins.</param>
      <param name="afterSerialize">The method (or null) called when serialization is complete.</param>
      <param name="beforeDeserialize">The method (or null) called before deserialization begins (or when a new instance is created during deserialization).</param>
      <param name="afterDeserialize">The method (or null) called when deserialization is complete.</param>
      <returns>The set of callbacks.</returns>
    </member>
    <member name="M:ProtoBuf.Meta.MetaType.SetCallbacks(System.String,System.String,System.String,System.String)">
      <summary>
            Assigns the callbacks to use during serialiation/deserialization.
            </summary>
      <param name="beforeSerialize">The name of the method (or null) called before serialization begins.</param>
      <param name="afterSerialize">The name of the method (or null) called when serialization is complete.</param>
      <param name="beforeDeserialize">The name of the method (or null) called before deserialization begins (or when a new instance is created during deserialization).</param>
      <param name="afterDeserialize">The name of the method (or null) called when deserialization is complete.</param>
      <returns>The set of callbacks.</returns>
    </member>
    <member name="M:ProtoBuf.Meta.MetaType.SetFactory(System.Reflection.MethodInfo)">
      <summary>
            Designate a factory-method to use to create instances of this type
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.MetaType.SetFactory(System.String)">
      <summary>
            Designate a factory-method to use to create instances of this type
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.MetaType.ThrowIfFrozen">
      <summary>
            Throws an exception if the type has been made immutable
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.MetaType.Add(System.Int32,System.String)">
      <summary>
            Adds a member (by name) to the MetaType
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.MetaType.AddField(System.Int32,System.String)">
      <summary>
            Adds a member (by name) to the MetaType, returning the ValueMember rather than the fluent API.
            This is otherwise identical to Add.
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.MetaType.Add(System.String)">
      <summary>
            Adds a member (by name) to the MetaType
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.MetaType.SetSurrogate(System.Type)">
      <summary>
            Performs serialization of this type via a surrogate; all
            other serialization options are ignored and handled
            by the surrogate's configuration.
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.MetaType.Add(System.String[])">
      <summary>
            Adds a set of members (by name) to the MetaType
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.MetaType.Add(System.Int32,System.String,System.Object)">
      <summary>
            Adds a member (by name) to the MetaType
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.MetaType.Add(System.Int32,System.String,System.Type,System.Type)">
      <summary>
            Adds a member (by name) to the MetaType, including an itemType and defaultType for representing lists
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.MetaType.AddField(System.Int32,System.String,System.Type,System.Type)">
      <summary>
            Adds a member (by name) to the MetaType, including an itemType and defaultType for representing lists, returning the ValueMember rather than the fluent API.
            This is otherwise identical to Add.
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.MetaType.GetFields">
      <summary>
            Returns the ValueMember instances associated with this type
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.MetaType.GetSubtypes">
      <summary>
            Returns the SubType instances associated with this type
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.MetaType.CompileInPlace">
      <summary>
            Compiles the serializer for this type; this is *not* a full
            standalone compile, but can significantly boost performance
            while allowing additional types to be added.
            </summary>
      <remarks>An in-place compile can access non-public types / members</remarks>
    </member>
    <member name="P:ProtoBuf.Meta.MetaType.BaseType">
      <summary>
            Gets the base-type for this type
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.MetaType.IncludeSerializerMethod">
      <summary>
            When used to compile a model, should public serialization/deserialzation methods
            be included for this type?
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.MetaType.AsReferenceDefault">
      <summary>
            Should this type be treated as a reference by default?
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.MetaType.HasCallbacks">
      <summary>
            Indicates whether the current type has defined callbacks 
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.MetaType.HasSubtypes">
      <summary>
            Indicates whether the current type has defined subtypes
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.MetaType.Callbacks">
      <summary>
            Returns the set of callbacks defined for this type
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.MetaType.Name">
      <summary>
            Gets or sets the name of this contract.
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.MetaType.Type">
      <summary>
            The runtime type that the meta-type represents
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.MetaType.UseConstructor">
      <summary>
            Gets or sets whether the type should use a parameterless constructor (the default),
            or whether the type should skip the constructor completely. This option is not supported
            on compact-framework.
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.MetaType.ConstructType">
      <summary>
            The concrete type to create when a new instance of this type is needed; this may be useful when dealing
            with dynamic proxies, or with interface-based APIs
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.MetaType.Item(System.Int32)">
      <summary>
            Returns the ValueMember that matchs a given field number, or null if not found
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.MetaType.Item(System.Reflection.MemberInfo)">
      <summary>
            Returns the ValueMember that matchs a given member (property/field), or null if not found
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.MetaType.EnumPassthru">
      <summary>
            Gets or sets a value indicating that an enum should be treated directly as an int/short/etc, rather
            than enforcing .proto enum rules. This is useful *in particul* for [Flags] enums.
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.MetaType.IgnoreListHandling">
      <summary>
            Gets or sets a value indicating that this type should NOT be treated as a list, even if it has
            familiar list-like characteristics (enumerable, add, etc)
            </summary>
    </member>
    <member name="T:ProtoBuf.Meta.TypeModel">
      <summary>
            Provides protobuf serialization support for a number of types
            </summary>
    </member>
    <member name="T:ProtoBuf.Meta.TypeModel.CallbackType">
      <summary>
            Indicates the type of callback to be used
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.MapType(System.Type)">
      <summary>
            Resolve a System.Type to the compiler-specific type
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.MapType(System.Type,System.Boolean)">
      <summary>
            Resolve a System.Type to the compiler-specific type
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.TrySerializeAuxiliaryType(ProtoBuf.ProtoWriter,System.Type,ProtoBuf.DataFormat,System.Int32,System.Object,System.Boolean)">
      <summary>
            This is the more "complete" version of Serialize, which handles single instances of mapped types.
            The value is written as a complete field, including field-header and (for sub-objects) a
            length-prefix
            In addition to that, this provides support for:
             - basic values; individual int / string / Guid / etc
             - IEnumerable sequences of any type handled by TrySerializeAuxiliaryType
             
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.Serialize(System.IO.Stream,System.Object)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
      <param name="value">The existing instance to be serialized (cannot be null).</param>
      <param name="dest">The destination stream to write to.</param>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.Serialize(System.IO.Stream,System.Object,ProtoBuf.SerializationContext)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
      <param name="value">The existing instance to be serialized (cannot be null).</param>
      <param name="dest">The destination stream to write to.</param>
      <param name="context">Additional information about this serialization operation.</param>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.Serialize(ProtoBuf.ProtoWriter,System.Object)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied writer.
            </summary>
      <param name="value">The existing instance to be serialized (cannot be null).</param>
      <param name="dest">The destination writer to write to.</param>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.DeserializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32)">
      <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
      <param name="type">The type being merged.</param>
      <param name="value">The existing instance to be modified (can be null).</param>
      <param name="source">The binary stream to apply to the instance (cannot be null).</param>
      <param name="style">How to encode the length prefix.</param>
      <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
      <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.DeserializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.Serializer.TypeResolver)">
      <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
      <param name="type">The type being merged.</param>
      <param name="value">The existing instance to be modified (can be null).</param>
      <param name="source">The binary stream to apply to the instance (cannot be null).</param>
      <param name="style">How to encode the length prefix.</param>
      <param name="expectedField">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
      <param name="resolver">Used to resolve types on a per-field basis.</param>
      <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.DeserializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.Serializer.TypeResolver,System.Int32@)">
      <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
      <param name="type">The type being merged.</param>
      <param name="value">The existing instance to be modified (can be null).</param>
      <param name="source">The binary stream to apply to the instance (cannot be null).</param>
      <param name="style">How to encode the length prefix.</param>
      <param name="expectedField">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
      <param name="resolver">Used to resolve types on a per-field basis.</param>
      <param name="bytesRead">Returns the number of bytes consumed by this operation (includes length-prefix overheads and any skipped data).</param>
      <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems(System.IO.Stream,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.Serializer.TypeResolver)">
      <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag" /> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
      <param name="source">The binary stream containing the serialized records.</param>
      <param name="style">The prefix style used in the data.</param>
      <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
      <param name="resolver">On a field-by-field basis, the type of object to deserialize (can be null if "type" is specified). </param>
      <param name="type">The type of object to deserialize (can be null if "resolver" is specified).</param>
      <returns>The sequence of deserialized objects.</returns>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems(System.IO.Stream,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.Serializer.TypeResolver,ProtoBuf.SerializationContext)">
      <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag" /> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
      <param name="source">The binary stream containing the serialized records.</param>
      <param name="style">The prefix style used in the data.</param>
      <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
      <param name="resolver">On a field-by-field basis, the type of object to deserialize (can be null if "type" is specified). </param>
      <param name="type">The type of object to deserialize (can be null if "resolver" is specified).</param>
      <returns>The sequence of deserialized objects.</returns>
      <param name="context">Additional information about this serialization operation.</param>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32)">
      <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag" /> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
      <typeparam name="T">The type of object to deserialize.</typeparam>
      <param name="source">The binary stream containing the serialized records.</param>
      <param name="style">The prefix style used in the data.</param>
      <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
      <returns>The sequence of deserialized objects.</returns>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.DeserializeItems``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.SerializationContext)">
      <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag" /> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
      <typeparam name="T">The type of object to deserialize.</typeparam>
      <param name="source">The binary stream containing the serialized records.</param>
      <param name="style">The prefix style used in the data.</param>
      <param name="expectedField">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
      <returns>The sequence of deserialized objects.</returns>
      <param name="context">Additional information about this serialization operation.</param>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.SerializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
      <param name="type">The type being serialized.</param>
      <param name="value">The existing instance to be serialized (cannot be null).</param>
      <param name="style">How to encode the length prefix.</param>
      <param name="dest">The destination stream to write to.</param>
      <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.SerializeWithLengthPrefix(System.IO.Stream,System.Object,System.Type,ProtoBuf.PrefixStyle,System.Int32,ProtoBuf.SerializationContext)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
      <param name="type">The type being serialized.</param>
      <param name="value">The existing instance to be serialized (cannot be null).</param>
      <param name="style">How to encode the length prefix.</param>
      <param name="dest">The destination stream to write to.</param>
      <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
      <param name="context">Additional information about this serialization operation.</param>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type)">
      <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
      <param name="type">The type (including inheritance) to consider.</param>
      <param name="value">The existing instance to be modified (can be null).</param>
      <param name="source">The binary stream to apply to the instance (cannot be null).</param>
      <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,ProtoBuf.SerializationContext)">
      <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
      <param name="type">The type (including inheritance) to consider.</param>
      <param name="value">The existing instance to be modified (can be null).</param>
      <param name="source">The binary stream to apply to the instance (cannot be null).</param>
      <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
      <param name="context">Additional information about this serialization operation.</param>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,System.Int32)">
      <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
      <param name="type">The type (including inheritance) to consider.</param>
      <param name="value">The existing instance to be modified (can be null).</param>
      <param name="source">The binary stream to apply to the instance (cannot be null).</param>
      <param name="length">The number of bytes to consume.</param>
      <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.IO.Stream,System.Object,System.Type,System.Int32,ProtoBuf.SerializationContext)">
      <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
      <param name="type">The type (including inheritance) to consider.</param>
      <param name="value">The existing instance to be modified (can be null).</param>
      <param name="source">The binary stream to apply to the instance (cannot be null).</param>
      <param name="length">The number of bytes to consume (or -1 to read to the end of the stream).</param>
      <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
      <param name="context">Additional information about this serialization operation.</param>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(ProtoBuf.ProtoReader,System.Object,System.Type)">
      <summary>
            Applies a protocol-buffer reader to an existing instance (which may be null).
            </summary>
      <param name="type">The type (including inheritance) to consider.</param>
      <param name="value">The existing instance to be modified (can be null).</param>
      <param name="source">The reader to apply to the instance (cannot be null).</param>
      <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.TryDeserializeAuxiliaryType(ProtoBuf.ProtoReader,ProtoBuf.DataFormat,System.Int32,System.Type,System.Object@,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            This is the more "complete" version of Deserialize, which handles single instances of mapped types.
            The value is read as a complete field, including field-header and (for sub-objects) a
            length-prefix..kmc  
            
            In addition to that, this provides support for:
             - basic values; individual int / string / Guid / etc
             - IList sets of any type handled by TryDeserializeAuxiliaryType
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.Create">
      <summary>
            Creates a new runtime model, to which the caller
            can add support for a range of types. A model
            can be used "as is", or can be compiled for
            optimal performance.
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.ResolveProxies(System.Type)">
      <summary>
            Applies common proxy scenarios, resolving the actual type to consider
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.IsDefined(System.Type)">
      <summary>
            Indicates whether the supplied type is explicitly modelled by the model
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.GetKey(System.Type@)">
      <summary>
            Provides the key that represents a given type in the current model.
            The type is also normalized for proxies at the same time.
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.GetKeyImpl(System.Type)">
      <summary>
            Provides the key that represents a given type in the current model.
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.Serialize(System.Int32,System.Object,ProtoBuf.ProtoWriter)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
      <param name="key">Represents the type (including inheritance) to consider.</param>
      <param name="value">The existing instance to be serialized (cannot be null).</param>
      <param name="dest">The destination stream to write to.</param>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.Deserialize(System.Int32,System.Object,ProtoBuf.ProtoReader)">
      <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
      <param name="key">Represents the type (including inheritance) to consider.</param>
      <param name="value">The existing instance to be modified (can be null).</param>
      <param name="source">The binary stream to apply to the instance (cannot be null).</param>
      <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.DeepClone(System.Object)">
      <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.ThrowUnexpectedSubtype(System.Type,System.Type)">
      <summary>
            Indicates that while an inheritance tree exists, the exact type encountered was not
            specified in that hierarchy and cannot be processed.
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.ThrowUnexpectedType(System.Type)">
      <summary>
            Indicates that the given type was not expected, and cannot be processed.
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.ThrowCannotCreateInstance(System.Type)">
      <summary>
            Indicates that the given type cannot be constructed; it may still be possible to 
            deserialize into existing instances.
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.CanSerializeContractType(System.Type)">
      <summary>
            Returns true if the type supplied is either a recognised contract type,
            or a *list* of a recognised contract type. 
            </summary>
      <remarks>Note that primitives always return false, even though the engine
            will, if forced, try to serialize such</remarks>
      <returns>True if this type is recognised as a serializable entity, else false</returns>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.CanSerialize(System.Type)">
      <summary>
            Returns true if the type supplied is a basic type with inbuilt handling,
            a recognised contract type, or a *list* of a basic / contract type. 
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.CanSerializeBasicType(System.Type)">
      <summary>
            Returns true if the type supplied is a basic type with inbuilt handling,
            or a *list* of a basic type with inbuilt handling
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.GetSchema(System.Type)">
      <summary>
            Suggest a .proto definition for the given type
            </summary>
      <param name="type">The type to generate a .proto definition for, or <c>null</c> to generate a .proto that represents the entire model</param>
      <returns>The .proto definition as a string</returns>
    </member>
    <member name="M:ProtoBuf.Meta.TypeModel.CreateFormatter(System.Type)">
      <summary>
            Creates a new IFormatter that uses protocol-buffer [de]serialization.
            </summary>
      <returns>A new IFormatter to be used during [de]serialization.</returns>
      <param name="type">The type of object to be [de]deserialized by the formatter.</param>
    </member>
    <member name="E:ProtoBuf.Meta.TypeModel.DynamicTypeFormatting">
      <summary>
            Used to provide custom services for writing and parsing type names when using dynamic types. Both parsing and formatting
            are provided on a single API as it is essential that both are mapped identically at all times.
            </summary>
    </member>
    <member name="T:ProtoBuf.Meta.RuntimeTypeModel">
      <summary>
            Provides protobuf serialization support for a number of types that can be defined at runtime
            </summary>
    </member>
    <member name="T:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions">
      <summary>
            Represents configuration options for compiling a model to 
            a standalone assembly.
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.SetFrameworkOptions(ProtoBuf.Meta.MetaType)">
      <summary>
            Import framework options from an existing type
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.TargetFrameworkName">
      <summary>
            The TargetFrameworkAttribute FrameworkName value to burn into the generated assembly
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.TargetFrameworkDisplayName">
      <summary>
            The TargetFrameworkAttribute FrameworkDisplayName value to burn into the generated assembly
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.TypeName">
      <summary>
            The name of the TypeModel class to create
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.OutputPath">
      <summary>
            The path for the new dll
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.ImageRuntimeVersion">
      <summary>
            The runtime version for the generated assembly
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.MetaDataVersion">
      <summary>
            The runtime version for the generated assembly
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions.Accessibility">
      <summary>
            The acecssibility of the generated serializer
            </summary>
    </member>
    <member name="T:ProtoBuf.Meta.RuntimeTypeModel.Accessibility">
      <summary>
            Type accessibility
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.RuntimeTypeModel.GetTypes">
      <summary>
            Returns a sequence of the Type instances that can be
            processed by this model.
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.RuntimeTypeModel.GetSchema(System.Type)">
      <summary>
            Suggest a .proto definition for the given type
            </summary>
      <param name="type">The type to generate a .proto definition for, or <c>null</c> to generate a .proto that represents the entire model</param>
      <returns>The .proto definition as a string</returns>
    </member>
    <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Add(System.Type,System.Boolean)">
      <summary>
            Adds support for an additional type in this model, optionally
            appplying inbuilt patterns. If the type is already known to the
            model, the existing type is returned **without** applying
            any additional behaviour.
            </summary>
      <remarks>Inbuilt patterns include:
            [ProtoContract]/[ProtoMember(n)]
            [DataContract]/[DataMember(Order=n)]
            [XmlType]/[XmlElement(Order=n)]
            [On{Des|S}erializ{ing|ed}]
            ShouldSerialize*/*Specified
            </remarks>
      <param name="type">The type to be supported</param>
      <param name="applyDefaultBehaviour">Whether to apply the inbuilt configuration patterns (via attributes etc), or
            just add the type with no additional configuration (the type must then be manually configured).</param>
      <returns>The MetaType representing this type, allowing
            further configuration.</returns>
    </member>
    <member name="M:ProtoBuf.Meta.RuntimeTypeModel.ThrowIfFrozen">
      <summary>
            Verifies that the model is still open to changes; if not, an exception is thrown
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Freeze">
      <summary>
            Prevents further changes to this model
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.RuntimeTypeModel.GetKeyImpl(System.Type)">
      <summary>
            Provides the key that represents a given type in the current model.
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Serialize(System.Int32,System.Object,ProtoBuf.ProtoWriter)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
      <param name="key">Represents the type (including inheritance) to consider.</param>
      <param name="value">The existing instance to be serialized (cannot be null).</param>
      <param name="dest">The destination stream to write to.</param>
    </member>
    <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Deserialize(System.Int32,System.Object,ProtoBuf.ProtoReader)">
      <summary>
            Applies a protocol-buffer stream to an existing instance (which may be null).
            </summary>
      <param name="key">Represents the type (including inheritance) to consider.</param>
      <param name="value">The existing instance to be modified (can be null).</param>
      <param name="source">The binary stream to apply to the instance (cannot be null).</param>
      <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
    </member>
    <member name="M:ProtoBuf.Meta.RuntimeTypeModel.CompileInPlace">
      <summary>
            Compiles the serializers individually; this is *not* a full
            standalone compile, but can significantly boost performance
            while allowing additional types to be added.
            </summary>
      <remarks>An in-place compile can access non-public types / members</remarks>
    </member>
    <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Compile">
      <summary>
            Fully compiles the current model into a static-compiled model instance
            </summary>
      <remarks>A full compilation is restricted to accessing public types / members</remarks>
      <returns>An instance of the newly created compiled type-model</returns>
    </member>
    <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Compile(System.String,System.String)">
      <summary>
            Fully compiles the current model into a static-compiled serialization dll
            (the serialization dll still requires protobuf-net for support services).
            </summary>
      <remarks>A full compilation is restricted to accessing public types / members</remarks>
      <param name="name">The name of the TypeModel class to create</param>
      <param name="path">The path for the new dll</param>
      <returns>An instance of the newly created compiled type-model</returns>
    </member>
    <member name="M:ProtoBuf.Meta.RuntimeTypeModel.Compile(ProtoBuf.Meta.RuntimeTypeModel.CompilerOptions)">
      <summary>
            Fully compiles the current model into a static-compiled serialization dll
            (the serialization dll still requires protobuf-net for support services).
            </summary>
      <remarks>A full compilation is restricted to accessing public types / members</remarks>
      <returns>An instance of the newly created compiled type-model</returns>
    </member>
    <member name="M:ProtoBuf.Meta.RuntimeTypeModel.SetDefaultFactory(System.Reflection.MethodInfo)">
      <summary>
            Designate a factory-method to use to create instances of any type; note that this only affect types seen by the serializer *after* setting the factory.
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.RuntimeTypeModel.InferTagFromNameDefault">
      <summary>
            Global default that
            enables/disables automatic tag generation based on the existing name / order
            of the defined members. See <seealso cref="P:ProtoBuf.ProtoContractAttribute.InferTagFromName" />
            for usage and <b>important warning</b> / explanation.
            You must set the global default before attempting to serialize/deserialize any
            impacted type.
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AutoAddProtoContractTypesOnly">
      <summary>
            Global default that determines whether types are considered serializable
            if they have [DataContract] / [XmlType]. With this enabled, <b>ONLY</b>
            types marked as [ProtoContract] are added automatically.
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.RuntimeTypeModel.UseImplicitZeroDefaults">
      <summary>
            Global switch that enables or disables the implicit
            handling of "zero defaults"; meanning: if no other default is specified,
            it assumes bools always default to false, integers to zero, etc.
            
            If this is disabled, no such assumptions are made and only *explicit*
            default values are processed. This is enabled by default to 
            preserve similar logic to v1.
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AllowParseableTypes">
      <summary>
            Global switch that determines whether types with a <c>.ToString()</c> and a <c>Parse(string)</c>
            should be serialized as strings.
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.RuntimeTypeModel.Default">
      <summary>
            The default model, used to support ProtoBuf.Serializer
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.RuntimeTypeModel.Item(System.Type)">
      <summary>
            Obtains the MetaType associated with a given Type for the current model,
            allowing additional configuration.
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AutoCompile">
      <summary>
            Should serializers be compiled on demand? It may be useful
            to disable this for debugging purposes.
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.RuntimeTypeModel.AutoAddMissingTypes">
      <summary>
            Should support for unexpected types be added automatically?
            If false, an exception is thrown when unexpected types
            are encountered.
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.RuntimeTypeModel.MetadataTimeoutMilliseconds">
      <summary>
            The amount of time to wait if there are concurrent metadata access operations
            </summary>
    </member>
    <member name="E:ProtoBuf.Meta.RuntimeTypeModel.LockContended">
      <summary>
            If a lock-contention is detected, this event signals the *owner* of the lock responsible for the blockage, indicating
            what caused the problem; this is only raised if the lock-owning code successfully completes.
            </summary>
    </member>
    <member name="T:ProtoBuf.Meta.LockContentedEventArgs">
      <summary>
            Contains the stack-trace of the owning code when a lock-contention scenario is detected
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.LockContentedEventArgs.OwnerStackTrace">
      <summary>
            The stack-trace of the code that owned the lock when a lock-contention scenario occurred
            </summary>
    </member>
    <member name="T:ProtoBuf.Meta.LockContentedEventHandler">
      <summary>
            Event-type that is raised when a lock-contention scenario is detected
            </summary>
    </member>
    <member name="T:ProtoBuf.Meta.SubType">
      <summary>
            Represents an inherited type in a type hierarchy.
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.SubType.#ctor(System.Int32,ProtoBuf.Meta.MetaType,ProtoBuf.DataFormat)">
      <summary>
            Creates a new SubType instance.
            </summary>
      <param name="fieldNumber">The field-number that is used to encapsulate the data (as a nested
            message) for the derived dype.</param>
      <param name="derivedType">The sub-type to be considered.</param>
      <param name="format">Specific encoding style to use; in particular, Grouped can be used to avoid buffering, but is not the default.</param>
    </member>
    <member name="P:ProtoBuf.Meta.SubType.FieldNumber">
      <summary>
            The field-number that is used to encapsulate the data (as a nested
            message) for the derived dype.
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.SubType.DerivedType">
      <summary>
            The sub-type to be considered.
            </summary>
    </member>
    <member name="T:ProtoBuf.Meta.TypeFormatEventArgs">
      <summary>
            Event arguments needed to perform type-formatting functions; this could be resolving a Type to a string suitable for serialization, or could
            be requesting a Type from a string. If no changes are made, a default implementation will be used (from the assembly-qualified names).
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.TypeFormatEventArgs.Type">
      <summary>
            The type involved in this map; if this is initially null, a Type is expected to be provided for the string in FormattedName.
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.TypeFormatEventArgs.FormattedName">
      <summary>
            The formatted-name involved in this map; if this is initially null, a formatted-name is expected from the type in Type.
            </summary>
    </member>
    <member name="T:ProtoBuf.Meta.TypeFormatEventHandler">
      <summary>
            Delegate type used to perform type-formatting functions; the sender originates as the type-model.
            </summary>
    </member>
    <member name="T:ProtoBuf.Meta.ValueMember">
      <summary>
            Represents a member (property/field) that is mapped to a protobuf field
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.ValueMember.#ctor(ProtoBuf.Meta.RuntimeTypeModel,System.Type,System.Int32,System.Reflection.MemberInfo,System.Type,System.Type,System.Type,ProtoBuf.DataFormat,System.Object)">
      <summary>
            Creates a new ValueMember instance
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.ValueMember.#ctor(ProtoBuf.Meta.RuntimeTypeModel,System.Int32,System.Type,System.Type,System.Type,ProtoBuf.DataFormat)">
      <summary>
            Creates a new ValueMember instance
            </summary>
    </member>
    <member name="M:ProtoBuf.Meta.ValueMember.SetSpecified(System.Reflection.MethodInfo,System.Reflection.MethodInfo)">
      <summary>
            Specifies methods for working with optional data members.
            </summary>
      <param name="getSpecified">Provides a method (null for none) to query whether this member should
            be serialized; it must be of the form "bool {Method}()". The member is only serialized if the
            method returns true.</param>
      <param name="setSpecified">Provides a method (null for none) to indicate that a member was
            deserialized; it must be of the form "void {Method}(bool)", and will be called with "true"
            when data is found.</param>
    </member>
    <member name="P:ProtoBuf.Meta.ValueMember.FieldNumber">
      <summary>
            The number that identifies this member in a protobuf stream
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.ValueMember.Member">
      <summary>
            Gets the member (field/property) which this member relates to.
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.ValueMember.ItemType">
      <summary>
            Within a list / array / etc, the type of object for each item in the list (especially useful with ArrayList)
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.ValueMember.MemberType">
      <summary>
            The underlying type of the member
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.ValueMember.DefaultType">
      <summary>
            For abstract types (IList etc), the type of concrete object to create (if required)
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.ValueMember.ParentType">
      <summary>
            The type the defines the member
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.ValueMember.DefaultValue">
      <summary>
            The default value of the item (members with this value will not be serialized)
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.ValueMember.DataFormat">
      <summary>
            Specifies the rules used to process the field; this is used to determine the most appropriate
            wite-type, but also to describe subtypes <i>within</i> that wire-type (such as SignedVariant)
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.ValueMember.IsStrict">
      <summary>
            Indicates whether this field should follow strict encoding rules; this means (for example) that if a "fixed32"
            is encountered when "variant" is defined, then it will fail (throw an exception) when parsing. Note that
            when serializing the defined type is always used.
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.ValueMember.IsPacked">
      <summary>
            Indicates whether this field should use packed encoding (which can save lots of space for repeated primitive values).
            This option only applies to list/array data of primitive types (int, double, etc).
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.ValueMember.OverwriteList">
      <summary>
            Indicates whether this field should *repace* existing values (the default is false, meaning *append*).
            This option only applies to list/array data.
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.ValueMember.IsRequired">
      <summary>
            Indicates whether this field is mandatory.
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.ValueMember.AsReference">
      <summary>
            Enables full object-tracking/full-graph support.
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.ValueMember.DynamicType">
      <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance.
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.ValueMember.Name">
      <summary>
            Gets the logical name for this member in the schema (this is not critical for binary serialization, but may be used
            when inferring a schema).
            </summary>
    </member>
    <member name="P:ProtoBuf.Meta.ValueMember.SupportNull">
      <summary>
            Should lists have extended support for null values? Note this makes the serialization less efficient.
            </summary>
    </member>
    <member name="T:ProtoBuf.PrefixStyle">
      <summary>
            Specifies the type of prefix that should be applied to messages.
            </summary>
    </member>
    <member name="F:ProtoBuf.PrefixStyle.None">
      <summary>
            No length prefix is applied to the data; the data is terminated only be the end of the stream.
            </summary>
    </member>
    <member name="F:ProtoBuf.PrefixStyle.Base128">
      <summary>
            A base-128 length prefix is applied to the data (efficient for short messages).
            </summary>
    </member>
    <member name="F:ProtoBuf.PrefixStyle.Fixed32">
      <summary>
            A fixed-length (little-endian) length prefix is applied to the data (useful for compatibility).
            </summary>
    </member>
    <member name="F:ProtoBuf.PrefixStyle.Fixed32BigEndian">
      <summary>
            A fixed-length (big-endian) length prefix is applied to the data (useful for compatibility).
            </summary>
    </member>
    <member name="T:ProtoBuf.ProtoContractAttribute">
      <summary>
            Indicates that a type is defined for protocol-buffer serialization.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoContractAttribute.Name">
      <summary>
            Gets or sets the defined name of the type.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoContractAttribute.ImplicitFirstTag">
      <summary>
            Gets or sets the fist offset to use with implicit field tags;
            only uesd if ImplicitFields is set.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoContractAttribute.UseProtoMembersOnly">
      <summary>
            If specified, alternative contract markers (such as markers for XmlSerailizer or DataContractSerializer) are ignored.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoContractAttribute.IgnoreListHandling">
      <summary>
            If specified, do NOT treat this type as a list, even if it looks like one.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoContractAttribute.ImplicitFields">
      <summary>
            Gets or sets the mechanism used to automatically infer field tags
            for members. This option should be used in advanced scenarios only.
            Please review the important notes against the ImplicitFields enumeration.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoContractAttribute.InferTagFromName">
      <summary>
            Enables/disables automatic tag generation based on the existing name / order
            of the defined members. This option is not used for members marked
            with ProtoMemberAttribute, as intended to provide compatibility with
            WCF serialization. WARNING: when adding new fields you must take
            care to increase the Order for new elements, otherwise data corruption
            may occur.
            </summary>
      <remarks>If not explicitly specified, the default is assumed from Serializer.GlobalOptions.InferTagFromName.</remarks>
    </member>
    <member name="P:ProtoBuf.ProtoContractAttribute.InferTagFromNameHasValue">
      <summary>
            Has a InferTagFromName value been explicitly set? if not, the default from the type-model is assumed.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoContractAttribute.DataMemberOffset">
      <summary>
            Specifies an offset to apply to [DataMember(Order=...)] markers;
            this is useful when working with mex-generated classes that have
            a different origin (usually 1 vs 0) than the original data-contract.
            
            This value is added to the Order of each member.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoContractAttribute.SkipConstructor">
      <summary>
            If true, the constructor for the type is bypassed during deserialization, meaning any field initializers
            or other initialization code is skipped.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoContractAttribute.AsReferenceDefault">
      <summary>
            Should this type be treated as a reference by default? Please also see the implications of this,
            as recorded on ProtoMemberAttribute.AsReference
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoContractAttribute.EnumPassthru">
      <summary>
            Applies only to enums (not to DTO classes themselves); gets or sets a value indicating that an enum should be treated directly as an int/short/etc, rather
            than enforcing .proto enum rules. This is useful *in particul* for [Flags] enums.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoContractAttribute.EnumPassthruHasValue">
      <summary>
            Has a EnumPassthru value been explicitly set?
            </summary>
    </member>
    <member name="T:ProtoBuf.ProtoEnumAttribute">
      <summary>
            Used to define protocol-buffer specific behavior for
            enumerated values.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoEnumAttribute.HasValue">
      <summary>
            Indicates whether this instance has a customised value mapping
            </summary>
      <returns>true if a specific value is set</returns>
    </member>
    <member name="P:ProtoBuf.ProtoEnumAttribute.Value">
      <summary>
            Gets or sets the specific value to use for this enum during serialization.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoEnumAttribute.Name">
      <summary>
            Gets or sets the defined name of the enum, as used in .proto
            (this name is not used during serialization).
            </summary>
    </member>
    <member name="T:ProtoBuf.ProtoException">
      <summary>
            Indicates an error during serialization/deserialization of a proto stream.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoException.#ctor">
      <summary>Creates a new ProtoException instance.</summary>
    </member>
    <member name="M:ProtoBuf.ProtoException.#ctor(System.String)">
      <summary>Creates a new ProtoException instance.</summary>
    </member>
    <member name="M:ProtoBuf.ProtoException.#ctor(System.String,System.Exception)">
      <summary>Creates a new ProtoException instance.</summary>
    </member>
    <member name="M:ProtoBuf.ProtoException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>Creates a new ProtoException instance.</summary>
    </member>
    <member name="T:ProtoBuf.ProtoIgnoreAttribute">
      <summary>
            Indicates that a member should be excluded from serialization; this
            is only normally used when using implict fields.
            </summary>
    </member>
    <member name="T:ProtoBuf.ProtoPartialIgnoreAttribute">
      <summary>
            Indicates that a member should be excluded from serialization; this
            is only normally used when using implict fields. This allows
            ProtoIgnoreAttribute usage
            even for partial classes where the individual members are not
            under direct control.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoPartialIgnoreAttribute.#ctor(System.String)">
      <summary>
            Creates a new ProtoPartialIgnoreAttribute instance.
            </summary>
      <param name="memberName">Specifies the member to be ignored.</param>
    </member>
    <member name="P:ProtoBuf.ProtoPartialIgnoreAttribute.MemberName">
      <summary>
            The name of the member to be ignored.
            </summary>
    </member>
    <member name="T:ProtoBuf.ProtoIncludeAttribute">
      <summary>
            Indicates the known-types to support for an individual
            message. This serializes each level in the hierarchy as
            a nested message to retain wire-compatibility with
            other protocol-buffer implementations.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoIncludeAttribute.#ctor(System.Int32,System.Type)">
      <summary>
             Creates a new instance of the ProtoIncludeAttribute.
             </summary>
      <param name="tag">The unique index (within the type) that will identify this data.</param>
      <param name="knownType">The additional type to serialize/deserialize.</param>
    </member>
    <member name="M:ProtoBuf.ProtoIncludeAttribute.#ctor(System.Int32,System.String)">
      <summary>
            Creates a new instance of the ProtoIncludeAttribute.
            </summary>
      <param name="tag">The unique index (within the type) that will identify this data.</param>
      <param name="knownTypeName">The additional type to serialize/deserialize.</param>
    </member>
    <member name="P:ProtoBuf.ProtoIncludeAttribute.Tag">
      <summary>
            Gets the unique index (within the type) that will identify this data.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoIncludeAttribute.KnownTypeName">
      <summary>
            Gets the additional type to serialize/deserialize.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoIncludeAttribute.KnownType">
      <summary>
            Gets the additional type to serialize/deserialize.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoIncludeAttribute.DataFormat">
      <summary>
            Specifies whether the inherited sype's sub-message should be
            written with a length-prefix (default), or with group markers.
            </summary>
    </member>
    <member name="T:ProtoBuf.ProtoMemberAttribute">
      <summary>
            Declares a member to be used in protocol-buffer serialization, using
            the given Tag. A DataFormat may be used to optimise the serialization
            format (for instance, using zigzag encoding for negative numbers, or 
            fixed-length encoding for large values.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoMemberAttribute.CompareTo(System.Object)">
      <summary>
            Compare with another ProtoMemberAttribute for sorting purposes
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoMemberAttribute.CompareTo(ProtoBuf.ProtoMemberAttribute)">
      <summary>
            Compare with another ProtoMemberAttribute for sorting purposes
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoMemberAttribute.#ctor(System.Int32)">
      <summary>
            Creates a new ProtoMemberAttribute instance.
            </summary>
      <param name="tag">Specifies the unique tag used to identify this member within the type.</param>
    </member>
    <member name="P:ProtoBuf.ProtoMemberAttribute.Name">
      <summary>
            Gets or sets the original name defined in the .proto; not used
            during serialization.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoMemberAttribute.DataFormat">
      <summary>
            Gets or sets the data-format to be used when encoding this value.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoMemberAttribute.Tag">
      <summary>
            Gets the unique tag used to identify this member within the type.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoMemberAttribute.IsRequired">
      <summary>
            Gets or sets a value indicating whether this member is mandatory.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoMemberAttribute.IsPacked">
      <summary>
            Gets a value indicating whether this member is packed.
            This option only applies to list/array data of primitive types (int, double, etc).
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoMemberAttribute.OverwriteList">
      <summary>
            Indicates whether this field should *repace* existing values (the default is false, meaning *append*).
            This option only applies to list/array data.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoMemberAttribute.AsReference">
      <summary>
            Enables full object-tracking/full-graph support.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoMemberAttribute.DynamicType">
      <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoMemberAttribute.Options">
      <summary>
            Gets or sets a value indicating whether this member is packed (lists/arrays).
            </summary>
    </member>
    <member name="T:ProtoBuf.MemberSerializationOptions">
      <summary>
            Additional (optional) settings that control serialization of members
            </summary>
    </member>
    <member name="F:ProtoBuf.MemberSerializationOptions.None">
      <summary>
            Default; no additional options
            </summary>
    </member>
    <member name="F:ProtoBuf.MemberSerializationOptions.Packed">
      <summary>
            Indicates that repeated elements should use packed (length-prefixed) encoding
            </summary>
    </member>
    <member name="F:ProtoBuf.MemberSerializationOptions.Required">
      <summary>
            Indicates that the given item is required
            </summary>
    </member>
    <member name="F:ProtoBuf.MemberSerializationOptions.AsReference">
      <summary>
            Enables full object-tracking/full-graph support
            </summary>
    </member>
    <member name="F:ProtoBuf.MemberSerializationOptions.DynamicType">
      <summary>
            Embeds the type information into the stream, allowing usage with types not known in advance
            </summary>
    </member>
    <member name="F:ProtoBuf.MemberSerializationOptions.OverwriteList">
      <summary>
            Indicates whether this field should *repace* existing values (the default is false, meaning *append*).
            This option only applies to list/array data.
            </summary>
    </member>
    <member name="F:ProtoBuf.MemberSerializationOptions.AsReferenceHasValue">
      <summary>
            Determines whether the types AsReferenceDefault value is used, or whether this member's AsReference should be used
            </summary>
    </member>
    <member name="T:ProtoBuf.ProtoPartialMemberAttribute">
      <summary>
            Declares a member to be used in protocol-buffer serialization, using
            the given Tag and MemberName. This allows ProtoMemberAttribute usage
            even for partial classes where the individual members are not
            under direct control.
            A DataFormat may be used to optimise the serialization
            format (for instance, using zigzag encoding for negative numbers, or 
            fixed-length encoding for large values.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoPartialMemberAttribute.#ctor(System.Int32,System.String)">
      <summary>
            Creates a new ProtoMemberAttribute instance.
            </summary>
      <param name="tag">Specifies the unique tag used to identify this member within the type.</param>
      <param name="memberName">Specifies the member to be serialized.</param>
    </member>
    <member name="P:ProtoBuf.ProtoPartialMemberAttribute.MemberName">
      <summary>
            The name of the member to be serialized.
            </summary>
    </member>
    <member name="T:ProtoBuf.ProtoReader">
      <summary>
            A stateful reader, used to read a protobuf stream. Typical usage would be (sequentially) to call
            ReadFieldHeader and (after matching the field) an appropriate Read* method.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.#ctor(System.IO.Stream,ProtoBuf.Meta.TypeModel,ProtoBuf.SerializationContext)">
      <summary>
            Creates a new reader against a stream
            </summary>
      <param name="source">The source stream</param>
      <param name="model">The model to use for serialization; this can be null, but this will impair the ability to deserialize sub-objects</param>
      <param name="context">Additional context about this serialization operation</param>
    </member>
    <member name="M:ProtoBuf.ProtoReader.#ctor(System.IO.Stream,ProtoBuf.Meta.TypeModel,ProtoBuf.SerializationContext,System.Int32)">
      <summary>
            Creates a new reader against a stream
            </summary>
      <param name="source">The source stream</param>
      <param name="model">The model to use for serialization; this can be null, but this will impair the ability to deserialize sub-objects</param>
      <param name="context">Additional context about this serialization operation</param>
      <param name="length">The number of bytes to read, or -1 to read until the end of the stream</param>
    </member>
    <member name="M:ProtoBuf.ProtoReader.Dispose">
      <summary>
            Releases resources used by the reader, but importantly <b>does not</b> Dispose the 
            underlying stream; in many typical use-cases the stream is used for different
            processes, so it is assumed that the consumer will Dispose their stream separately.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.ReadUInt32">
      <summary>
            Reads an unsigned 32-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.ReadInt16">
      <summary>
            Reads a signed 16-bit integer from the stream: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.ReadUInt16">
      <summary>
            Reads an unsigned 16-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.ReadByte">
      <summary>
            Reads an unsigned 8-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.ReadSByte">
      <summary>
            Reads a signed 8-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.ReadInt32">
      <summary>
            Reads a signed 32-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.ReadInt64">
      <summary>
            Reads a signed 64-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.ReadString">
      <summary>
            Reads a string from the stream (using UTF8); supported wire-types: String
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.ThrowEnumException(System.Type,System.Int32)">
      <summary>
            Throws an exception indication that the given value cannot be mapped to an enum.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.ReadDouble">
      <summary>
            Reads a double-precision number from the stream; supported wire-types: Fixed32, Fixed64
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.ReadObject(System.Object,System.Int32,ProtoBuf.ProtoReader)">
      <summary>
            Reads (merges) a sub-message from the stream, internally calling StartSubItem and EndSubItem, and (in between)
            parsing the message in accordance with the model associated with the reader
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.EndSubItem(ProtoBuf.SubItemToken,ProtoBuf.ProtoReader)">
      <summary>
            Makes the end of consuming a nested message in the stream; the stream must be either at the correct EndGroup
            marker, or all fields of the sub-message must have been consumed (in either case, this means ReadFieldHeader
            should return zero)
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.StartSubItem(ProtoBuf.ProtoReader)">
      <summary>
            Begins consuming a nested message in the stream; supported wire-types: StartGroup, String
            </summary>
      <remarks>The token returned must be help and used when callining EndSubItem</remarks>
    </member>
    <member name="M:ProtoBuf.ProtoReader.ReadFieldHeader">
      <summary>
            Reads a field header from the stream, setting the wire-type and retuning the field number. If no
            more fields are available, then 0 is returned. This methods respects sub-messages.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.TryReadFieldHeader(System.Int32)">
      <summary>
            Looks ahead to see whether the next field in the stream is what we expect
            (typically; what we've just finished reading - for example ot read successive list items)
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.Hint(ProtoBuf.WireType)">
      <summary>
            Compares the streams current wire-type to the hinted wire-type, updating the reader if necessary; for example,
            a Variant may be updated to SignedVariant. If the hinted wire-type is unrelated then no change is made.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.Assert(ProtoBuf.WireType)">
      <summary>
            Verifies that the stream's current wire-type is as expected, or a specialized sub-type (for example,
            SignedVariant) - in which case the current wire-type is updated. Otherwise an exception is thrown.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.SkipField">
      <summary>
            Discards the data for the current field.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.ReadUInt64">
      <summary>
            Reads an unsigned 64-bit integer from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.ReadSingle">
      <summary>
            Reads a single-precision number from the stream; supported wire-types: Fixed32, Fixed64
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.ReadBoolean">
      <summary>
            Reads a boolean value from the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:ProtoBuf.ProtoReader.AppendBytes(System.Byte[],ProtoBuf.ProtoReader)">
      <summary>
            Reads a byte-sequence from the stream, appending them to an existing byte-sequence (which can be null); supported wire-types: String
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.ReadLengthPrefix(System.IO.Stream,System.Boolean,ProtoBuf.PrefixStyle,System.Int32@)">
      <summary>
            Reads the length-prefix of a message from a stream without buffering additional data, allowing a fixed-length
            reader to be created.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.DirectReadLittleEndianInt32(System.IO.Stream)">
      <summary>
            Reads a little-endian encoded integer. An exception is thrown if the data is not all available.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.DirectReadBigEndianInt32(System.IO.Stream)">
      <summary>
            Reads a big-endian encoded integer. An exception is thrown if the data is not all available.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.DirectReadVarintInt32(System.IO.Stream)">
      <summary>
            Reads a varint encoded integer. An exception is thrown if the data is not all available.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.DirectReadBytes(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
      <summary>
            Reads a string (of a given lenth, in bytes) directly from the source into a pre-existing buffer. An exception is thrown if the data is not all available.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.DirectReadBytes(System.IO.Stream,System.Int32)">
      <summary>
            Reads a given number of bytes directly from the source. An exception is thrown if the data is not all available.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.DirectReadString(System.IO.Stream,System.Int32)">
      <summary>
            Reads a string (of a given lenth, in bytes) directly from the source. An exception is thrown if the data is not all available.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.ReadLengthPrefix(System.IO.Stream,System.Boolean,ProtoBuf.PrefixStyle,System.Int32@,System.Int32@)">
      <summary>
            Reads the length-prefix of a message from a stream without buffering additional data, allowing a fixed-length
            reader to be created.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.TryReadUInt32Variant(System.IO.Stream,System.UInt32@)">
      <returns>The number of bytes consumed; 0 if no data available</returns>
    </member>
    <member name="M:ProtoBuf.ProtoReader.AppendExtensionData(ProtoBuf.IExtensible)">
      <summary>
            Copies the current field into the instance as extension data
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.HasSubValue(ProtoBuf.WireType,ProtoBuf.ProtoReader)">
      <summary>
            Indicates whether the reader still has data remaining in the current sub-item,
            additionally setting the wire-type for the next field if there is more data.
            This is used when decoding packed data.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.NoteObject(System.Object,ProtoBuf.ProtoReader)">
      <summary>
            Utility method, not intended for public use; this helps maintain the root object is complex scenarios
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.ReadType">
      <summary>
            Reads a Type from the stream, using the model's DynamicTypeFormatting if appropriate; supported wire-types: String
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoReader.Merge(ProtoBuf.ProtoReader,System.Object,System.Object)">
      <summary>
            Merge two objects using the details from the current reader; this is used to change the type
            of objects when an inheritance relationship is discovered later than usual during deserilazation.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoReader.FieldNumber">
      <summary>
            Gets the number of the field being processed.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoReader.WireType">
      <summary>
            Indicates the underlying proto serialization format on the wire.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoReader.InternStrings">
      <summary>
            Gets / sets a flag indicating whether strings should be checked for repetition; if
            true, any repeated UTF-8 byte sequence will result in the same String instance, rather
            than a second instance of the same string. Enabled by default. Note that this uses
            a <i>custom</i> interner - the system-wide string interner is not used.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoReader.Context">
      <summary>
            Addition information about this deserialization operation.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoReader.Position">
      <summary>
            Returns the position of the current reader (note that this is not necessarily the same as the position
            in the underlying stream, if multiple readers are used on the same stream)
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoReader.Model">
      <summary>
            Get the TypeModel associated with this reader
            </summary>
    </member>
    <member name="T:ProtoBuf.ProtoWriter">
      <summary>
            Represents an output stream for writing protobuf data.
            
            Why is the API backwards (static methods with writer arguments)?
            See: http://marcgravell.blogspot.com/2010/03/last-will-be-first-and-first-will-be.html
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.WriteObject(System.Object,System.Int32,ProtoBuf.ProtoWriter)">
      <summary>
            Write an encapsulated sub-object, using the supplied unique key (reprasenting a type).
            </summary>
      <param name="value">The object to write.</param>
      <param name="key">The key that uniquely identifies the type within the model.</param>
      <param name="writer">The destination.</param>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.WriteRecursionSafeObject(System.Object,System.Int32,ProtoBuf.ProtoWriter)">
      <summary>
            Write an encapsulated sub-object, using the supplied unique key (reprasenting a type) - but the
            caller is asserting that this relationship is non-recursive; no recursion check will be
            performed.
            </summary>
      <param name="value">The object to write.</param>
      <param name="key">The key that uniquely identifies the type within the model.</param>
      <param name="writer">The destination.</param>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.WriteFieldHeader(System.Int32,ProtoBuf.WireType,ProtoBuf.ProtoWriter)">
      <summary>
            Writes a field-header, indicating the format of the next data we plan to write.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.WriteBytes(System.Byte[],ProtoBuf.ProtoWriter)">
      <summary>
            Writes a byte-array to the stream; supported wire-types: String
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.WriteBytes(System.Byte[],System.Int32,System.Int32,ProtoBuf.ProtoWriter)">
      <summary>
            Writes a byte-array to the stream; supported wire-types: String
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.StartSubItem(System.Object,ProtoBuf.ProtoWriter)">
      <summary>
            Indicates the start of a nested record.
            </summary>
      <param name="instance">The instance to write.</param>
      <param name="writer">The destination.</param>
      <returns>A token representing the state of the stream; this token is given to EndSubItem.</returns>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.EndSubItem(ProtoBuf.SubItemToken,ProtoBuf.ProtoWriter)">
      <summary>
            Indicates the end of a nested record.
            </summary>
      <param name="token">The token obtained from StartubItem.</param>
      <param name="writer">The destination.</param>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.#ctor(System.IO.Stream,ProtoBuf.Meta.TypeModel,ProtoBuf.SerializationContext)">
      <summary>
            Creates a new writer against a stream
            </summary>
      <param name="dest">The destination stream</param>
      <param name="model">The model to use for serialization; this can be null, but this will impair the ability to serialize sub-objects</param>
      <param name="context">Additional context about this serialization operation</param>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.Close">
      <summary>
            Flushes data to the underlying stream, and releases any resources. The underlying stream is *not* disposed
            by this operation.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.Flush(ProtoBuf.ProtoWriter)">
      <summary>
            Writes any buffered data (if possible) to the underlying stream.
            </summary>
      <param name="writer">The writer to flush</param>
      <remarks>It is not always possible to fully flush, since some sequences
            may require values to be back-filled into the byte-stream.</remarks>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.WriteUInt32Variant(System.UInt32,ProtoBuf.ProtoWriter)">
      <summary>
            Writes an unsigned 32-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.WriteString(System.String,ProtoBuf.ProtoWriter)">
      <summary>
            Writes a string to the stream; supported wire-types: String
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.WriteUInt64(System.UInt64,ProtoBuf.ProtoWriter)">
      <summary>
            Writes an unsigned 64-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.WriteInt64(System.Int64,ProtoBuf.ProtoWriter)">
      <summary>
            Writes a signed 64-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.WriteUInt32(System.UInt32,ProtoBuf.ProtoWriter)">
      <summary>
            Writes an unsigned 16-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.WriteInt16(System.Int16,ProtoBuf.ProtoWriter)">
      <summary>
            Writes a signed 16-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.WriteUInt16(System.UInt16,ProtoBuf.ProtoWriter)">
      <summary>
            Writes an unsigned 16-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.WriteByte(System.Byte,ProtoBuf.ProtoWriter)">
      <summary>
            Writes an unsigned 8-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.WriteSByte(System.SByte,ProtoBuf.ProtoWriter)">
      <summary>
            Writes a signed 8-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.WriteInt32(System.Int32,ProtoBuf.ProtoWriter)">
      <summary>
            Writes a signed 32-bit integer to the stream; supported wire-types: Variant, Fixed32, Fixed64, SignedVariant
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.WriteDouble(System.Double,ProtoBuf.ProtoWriter)">
      <summary>
            Writes a double-precision number to the stream; supported wire-types: Fixed32, Fixed64
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.WriteSingle(System.Single,ProtoBuf.ProtoWriter)">
      <summary>
            Writes a single-precision number to the stream; supported wire-types: Fixed32, Fixed64
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.ThrowEnumException(ProtoBuf.ProtoWriter,System.Object)">
      <summary>
            Throws an exception indicating that the given enum cannot be mapped to a serialized value.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.WriteBoolean(System.Boolean,ProtoBuf.ProtoWriter)">
      <summary>
            Writes a boolean to the stream; supported wire-types: Variant, Fixed32, Fixed64
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.AppendExtensionData(ProtoBuf.IExtensible,ProtoBuf.ProtoWriter)">
      <summary>
            Copies any extension data stored for the instance to the underlying stream
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.SetPackedField(System.Int32,ProtoBuf.ProtoWriter)">
      <summary>
            Used for packed encoding; indicates that the next field should be skipped rather than
            a field header written. Note that the field number must match, else an exception is thrown
            when the attempt is made to write the (incorrect) field. The wire-type is taken from the
            subsequent call to WriteFieldHeader. Only primitive types can be packed.
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.SetRootObject(System.Object)">
      <summary>
            Specifies a known root object to use during reference-tracked serialization
            </summary>
    </member>
    <member name="M:ProtoBuf.ProtoWriter.WriteType(System.Type,ProtoBuf.ProtoWriter)">
      <summary>
            Writes a Type to the stream, using the model's DynamicTypeFormatting if appropriate; supported wire-types: String
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoWriter.Context">
      <summary>
            Addition information about this serialization operation.
            </summary>
    </member>
    <member name="P:ProtoBuf.ProtoWriter.Model">
      <summary>
            Get the TypeModel associated with this writer
            </summary>
    </member>
    <member name="T:ProtoBuf.SerializationContext">
      <summary>
            Additional information about a serialization operation
            </summary>
    </member>
    <member name="M:ProtoBuf.SerializationContext.op_Implicit(ProtoBuf.SerializationContext)~System.Runtime.Serialization.StreamingContext">
      <summary>
            Convert a SerializationContext to a StreamingContext
            </summary>
    </member>
    <member name="M:ProtoBuf.SerializationContext.op_Implicit(System.Runtime.Serialization.StreamingContext)~ProtoBuf.SerializationContext">
      <summary>
            Convert a StreamingContext to a SerializationContext
            </summary>
    </member>
    <member name="P:ProtoBuf.SerializationContext.Context">
      <summary>
            Gets or sets a user-defined object containing additional information about this serialization/deserialization operation.
            </summary>
    </member>
    <member name="P:ProtoBuf.SerializationContext.Default">
      <summary>
            A default SerializationContext, with minimal information.
            </summary>
    </member>
    <member name="P:ProtoBuf.SerializationContext.State">
      <summary>
            Gets or sets the source or destination of the transmitted data.
            </summary>
    </member>
    <member name="T:ProtoBuf.Serializer">
      <summary>
            Provides protocol-buffer serialization capability for concrete, attributed types. This
            is a *default* model, but custom serializer models are also supported.
            </summary>
      <remarks>
            Protocol-buffer serialization is a compact binary format, designed to take
            advantage of sparse data and knowledge of specific data types; it is also
            extensible, allowing a type to be deserialized / merged even if some data is
            not recognised.
            </remarks>
    </member>
    <member name="T:ProtoBuf.Serializer.NonGeneric">
      <summary>
            Provides non-generic access to the default serializer.
            </summary>
    </member>
    <member name="M:ProtoBuf.Serializer.NonGeneric.DeepClone(System.Object)">
      <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
    </member>
    <member name="M:ProtoBuf.Serializer.NonGeneric.Serialize(System.IO.Stream,System.Object)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
      <param name="instance">The existing instance to be serialized (cannot be null).</param>
      <param name="dest">The destination stream to write to.</param>
    </member>
    <member name="M:ProtoBuf.Serializer.NonGeneric.Deserialize(System.Type,System.IO.Stream)">
      <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
      <param name="type">The type to be created.</param>
      <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
      <returns>A new, initialized instance.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.NonGeneric.Merge(System.IO.Stream,System.Object)">
      <summary>Applies a protocol-buffer stream to an existing instance.</summary>
      <param name="instance">The existing instance to be modified (cannot be null).</param>
      <param name="source">The binary stream to apply to the instance (cannot be null).</param>
      <returns>The updated instance</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.NonGeneric.SerializeWithLengthPrefix(System.IO.Stream,System.Object,ProtoBuf.PrefixStyle,System.Int32)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
      <param name="instance">The existing instance to be serialized (cannot be null).</param>
      <param name="style">How to encode the length prefix.</param>
      <param name="destination">The destination stream to write to.</param>
      <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
    </member>
    <member name="M:ProtoBuf.Serializer.NonGeneric.TryDeserializeWithLengthPrefix(System.IO.Stream,ProtoBuf.PrefixStyle,ProtoBuf.Serializer.TypeResolver,System.Object@)">
      <summary>
            Applies a protocol-buffer stream to an existing instance (or null), using length-prefixed
            data - useful with network IO.
            </summary>
      <param name="value">The existing instance to be modified (can be null).</param>
      <param name="source">The binary stream to apply to the instance (cannot be null).</param>
      <param name="style">How to encode the length prefix.</param>
      <param name="resolver">Used to resolve types on a per-field basis.</param>
      <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.NonGeneric.CanSerialize(System.Type)">
      <summary>
            Indicates whether the supplied type is explicitly modelled by the model
            </summary>
    </member>
    <member name="T:ProtoBuf.Serializer.GlobalOptions">
      <summary>
            Global switches that change the behavior of protobuf-net
            </summary>
    </member>
    <member name="P:ProtoBuf.Serializer.GlobalOptions.InferTagFromName">
      <summary>
        <see cref="P:ProtoBuf.Meta.RuntimeTypeModel.InferTagFromNameDefault" />
      </summary>
    </member>
    <member name="T:ProtoBuf.Serializer.TypeResolver">
      <summary>
            Maps a field-number to a type
            </summary>
    </member>
    <member name="F:ProtoBuf.Serializer.ListItemTag">
      <summary>
            The field number that is used as a default when serializing/deserializing a list of objects.
            The data is treated as repeated message with field number 1.
            </summary>
    </member>
    <member name="M:ProtoBuf.Serializer.GetProto``1">
      <summary>
            Suggest a .proto definition for the given type
            </summary>
      <typeparam name="T">The type to generate a .proto definition for</typeparam>
      <returns>The .proto definition as a string</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.DeepClone``1(``0)">
      <summary>
            Create a deep clone of the supplied instance; any sub-items are also cloned.
            </summary>
    </member>
    <member name="M:ProtoBuf.Serializer.Merge``1(System.IO.Stream,``0)">
      <summary>
            Applies a protocol-buffer stream to an existing instance.
            </summary>
      <typeparam name="T">The type being merged.</typeparam>
      <param name="instance">The existing instance to be modified (can be null).</param>
      <param name="source">The binary stream to apply to the instance (cannot be null).</param>
      <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.Deserialize``1(System.IO.Stream)">
      <summary>
            Creates a new instance from a protocol-buffer stream
            </summary>
      <typeparam name="T">The type to be created.</typeparam>
      <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
      <returns>A new, initialized instance.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.Serialize``1(System.IO.Stream,``0)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream.
            </summary>
      <param name="instance">The existing instance to be serialized (cannot be null).</param>
      <param name="destination">The destination stream to write to.</param>
    </member>
    <member name="M:ProtoBuf.Serializer.ChangeType``2(``0)">
      <summary>
            Serializes a given instance and deserializes it as a different type;
            this can be used to translate between wire-compatible objects (where
            two .NET types represent the same data), or to promote/demote a type
            through an inheritance hierarchy.
            </summary>
      <remarks>No assumption of compatibility is made between the types.</remarks>
      <typeparam name="TFrom">The type of the object being copied.</typeparam>
      <typeparam name="TTo">The type of the new object to be created.</typeparam>
      <param name="instance">The existing instance to use as a template.</param>
      <returns>A new instane of type TNewType, with the data from TOldType.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.Serialize``1(System.Runtime.Serialization.SerializationInfo,``0)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied SerializationInfo.
            </summary>
      <typeparam name="T">The type being serialized.</typeparam>
      <param name="instance">The existing instance to be serialized (cannot be null).</param>
      <param name="info">The destination SerializationInfo to write to.</param>
    </member>
    <member name="M:ProtoBuf.Serializer.Serialize``1(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,``0)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied SerializationInfo.
            </summary>
      <typeparam name="T">The type being serialized.</typeparam>
      <param name="instance">The existing instance to be serialized (cannot be null).</param>
      <param name="info">The destination SerializationInfo to write to.</param>
      <param name="context">Additional information about this serialization operation.</param>
    </member>
    <member name="M:ProtoBuf.Serializer.Serialize``1(System.Xml.XmlWriter,``0)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied XmlWriter.
            </summary>
      <typeparam name="T">The type being serialized.</typeparam>
      <param name="instance">The existing instance to be serialized (cannot be null).</param>
      <param name="writer">The destination XmlWriter to write to.</param>
    </member>
    <member name="M:ProtoBuf.Serializer.Merge``1(System.Xml.XmlReader,``0)">
      <summary>
            Applies a protocol-buffer from an XmlReader to an existing instance.
            </summary>
      <typeparam name="T">The type being merged.</typeparam>
      <param name="instance">The existing instance to be modified (cannot be null).</param>
      <param name="reader">The XmlReader containing the data to apply to the instance (cannot be null).</param>
    </member>
    <member name="M:ProtoBuf.Serializer.Merge``1(System.Runtime.Serialization.SerializationInfo,``0)">
      <summary>
            Applies a protocol-buffer from a SerializationInfo to an existing instance.
            </summary>
      <typeparam name="T">The type being merged.</typeparam>
      <param name="instance">The existing instance to be modified (cannot be null).</param>
      <param name="info">The SerializationInfo containing the data to apply to the instance (cannot be null).</param>
    </member>
    <member name="M:ProtoBuf.Serializer.Merge``1(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext,``0)">
      <summary>
            Applies a protocol-buffer from a SerializationInfo to an existing instance.
            </summary>
      <typeparam name="T">The type being merged.</typeparam>
      <param name="instance">The existing instance to be modified (cannot be null).</param>
      <param name="info">The SerializationInfo containing the data to apply to the instance (cannot be null).</param>
      <param name="context">Additional information about this serialization operation.</param>
    </member>
    <member name="M:ProtoBuf.Serializer.PrepareSerializer``1">
      <summary>
            Precompiles the serializer for a given type.
            </summary>
    </member>
    <member name="M:ProtoBuf.Serializer.CreateFormatter``1">
      <summary>
            Creates a new IFormatter that uses protocol-buffer [de]serialization.
            </summary>
      <typeparam name="T">The type of object to be [de]deserialized by the formatter.</typeparam>
      <returns>A new IFormatter to be used during [de]serialization.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.DeserializeItems``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32)">
      <summary>
            Reads a sequence of consecutive length-prefixed items from a stream, using
            either base-128 or fixed-length prefixes. Base-128 prefixes with a tag
            are directly comparable to serializing multiple items in succession
            (use the <see cref="F:ProtoBuf.Serializer.ListItemTag" /> tag to emulate the implicit behavior
            when serializing a list/array). When a tag is
            specified, any records with different tags are silently omitted. The
            tag is ignored. The tag is ignores for fixed-length prefixes.
            </summary>
      <typeparam name="T">The type of object to deserialize.</typeparam>
      <param name="source">The binary stream containing the serialized records.</param>
      <param name="style">The prefix style used in the data.</param>
      <param name="fieldNumber">The tag of records to return (if non-positive, then no tag is
            expected and all records are returned).</param>
      <returns>The sequence of deserialized objects.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.DeserializeWithLengthPrefix``1(System.IO.Stream,ProtoBuf.PrefixStyle)">
      <summary>
            Creates a new instance from a protocol-buffer stream that has a length-prefix
            on data (to assist with network IO).
            </summary>
      <typeparam name="T">The type to be created.</typeparam>
      <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
      <param name="style">How to encode the length prefix.</param>
      <returns>A new, initialized instance.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.DeserializeWithLengthPrefix``1(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32)">
      <summary>
            Creates a new instance from a protocol-buffer stream that has a length-prefix
            on data (to assist with network IO).
            </summary>
      <typeparam name="T">The type to be created.</typeparam>
      <param name="source">The binary stream to apply to the new instance (cannot be null).</param>
      <param name="style">How to encode the length prefix.</param>
      <param name="fieldNumber">The expected tag of the item (only used with base-128 prefix style).</param>
      <returns>A new, initialized instance.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.MergeWithLengthPrefix``1(System.IO.Stream,``0,ProtoBuf.PrefixStyle)">
      <summary>
            Applies a protocol-buffer stream to an existing instance, using length-prefixed
            data - useful with network IO.
            </summary>
      <typeparam name="T">The type being merged.</typeparam>
      <param name="instance">The existing instance to be modified (can be null).</param>
      <param name="source">The binary stream to apply to the instance (cannot be null).</param>
      <param name="style">How to encode the length prefix.</param>
      <returns>The updated instance; this may be different to the instance argument if
            either the original instance was null, or the stream defines a known sub-type of the
            original instance.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.SerializeWithLengthPrefix``1(System.IO.Stream,``0,ProtoBuf.PrefixStyle)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
      <typeparam name="T">The type being serialized.</typeparam>
      <param name="instance">The existing instance to be serialized (cannot be null).</param>
      <param name="style">How to encode the length prefix.</param>
      <param name="destination">The destination stream to write to.</param>
    </member>
    <member name="M:ProtoBuf.Serializer.SerializeWithLengthPrefix``1(System.IO.Stream,``0,ProtoBuf.PrefixStyle,System.Int32)">
      <summary>
            Writes a protocol-buffer representation of the given instance to the supplied stream,
            with a length-prefix. This is useful for socket programming,
            as DeserializeWithLengthPrefix/MergeWithLengthPrefix can be used to read the single object back
            from an ongoing stream.
            </summary>
      <typeparam name="T">The type being serialized.</typeparam>
      <param name="instance">The existing instance to be serialized (cannot be null).</param>
      <param name="style">How to encode the length prefix.</param>
      <param name="destination">The destination stream to write to.</param>
      <param name="fieldNumber">The tag used as a prefix to each record (only used with base-128 style prefixes).</param>
    </member>
    <member name="M:ProtoBuf.Serializer.TryReadLengthPrefix(System.IO.Stream,ProtoBuf.PrefixStyle,System.Int32@)">
      <summary>Indicates the number of bytes expected for the next message.</summary>
      <param name="source">The stream containing the data to investigate for a length.</param>
      <param name="style">The algorithm used to encode the length.</param>
      <param name="length">The length of the message, if it could be identified.</param>
      <returns>True if a length could be obtained, false otherwise.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.TryReadLengthPrefix(System.Byte[],System.Int32,System.Int32,ProtoBuf.PrefixStyle,System.Int32@)">
      <summary>Indicates the number of bytes expected for the next message.</summary>
      <param name="buffer">The buffer containing the data to investigate for a length.</param>
      <param name="index">The offset of the first byte to read from the buffer.</param>
      <param name="count">The number of bytes to read from the buffer.</param>
      <param name="style">The algorithm used to encode the length.</param>
      <param name="length">The length of the message, if it could be identified.</param>
      <returns>True if a length could be obtained, false otherwise.</returns>
    </member>
    <member name="M:ProtoBuf.Serializer.FlushPool">
      <summary>
            Releases any internal buffers that have been reserved for efficiency; this does not affect any serialization
            operations; simply: it can be used (optionally) to release the buffers for garbage collection (at the expense
            of having to re-allocate a new buffer for the next operation, rather than re-use prior buffers).
            </summary>
    </member>
    <member name="M:ProtoBuf.Serializers.IProtoSerializer.Write(System.Object,ProtoBuf.ProtoWriter)">
      <summary>
            Perform the steps necessary to serialize this data.
            </summary>
      <param name="value">The value to be serialized.</param>
      <param name="dest">The writer entity that is accumulating the output data.</param>
    </member>
    <member name="M:ProtoBuf.Serializers.IProtoSerializer.Read(System.Object,ProtoBuf.ProtoReader)">
      <summary>
            Perform the steps necessary to deserialize this data.
            </summary>
      <param name="value">The current value, if appropriate.</param>
      <param name="source">The reader providing the input data.</param>
      <returns>The updated / replacement value.</returns>
    </member>
    <member name="M:ProtoBuf.Serializers.IProtoSerializer.EmitWrite(ProtoBuf.Compiler.CompilerContext,ProtoBuf.Compiler.Local)">
      <summary>Emit the IL necessary to perform the given actions
            to serialize this data.
            </summary>
      <param name="ctx">Details and utilities for the method being generated.</param>
      <param name="valueFrom">The source of the data to work against;
            If the value is only needed once, then LoadValue is sufficient. If
            the value is needed multiple times, then note that a "null"
            means "the top of the stack", in which case you should create your
            own copy - GetLocalWithValue.</param>
    </member>
    <member name="M:ProtoBuf.Serializers.IProtoSerializer.EmitRead(ProtoBuf.Compiler.CompilerContext,ProtoBuf.Compiler.Local)">
      <summary>
            Emit the IL necessary to perform the given actions to deserialize this data.
            </summary>
      <param name="ctx">Details and utilities for the method being generated.</param>
      <param name="entity">For nested values, the instance holding the values; note
            that this is not always provided - a null means not supplied. Since this is always
            a variable or argument, it is not necessary to consume this value.</param>
    </member>
    <member name="P:ProtoBuf.Serializers.IProtoSerializer.ExpectedType">
      <summary>
            The type that this serializer is intended to work for.
            </summary>
    </member>
    <member name="P:ProtoBuf.Serializers.IProtoSerializer.RequiresOldValue">
      <summary>
            Indicates whether a Read operation <em>replaces</em> the existing value, or
            <em>extends</em> the value. If false, the "value" parameter to Read is
            discarded, and should be passed in as null.
            </summary>
    </member>
    <member name="P:ProtoBuf.Serializers.IProtoSerializer.ReturnsValue">
      <summary>
            Now all Read operations return a value (although most do); if false no
            value should be expected.
            </summary>
    </member>
    <member name="T:ProtoBuf.ServiceModel.ProtoBehaviorAttribute">
      <summary>
            Uses protocol buffer serialization on the specified operation; note that this
            must be enabled on both the client and server.
            </summary>
    </member>
    <member name="T:ProtoBuf.ServiceModel.ProtoBehaviorExtension">
      <summary>
            Configuration element to swap out DatatContractSerilaizer with the XmlProtoSerializer for a given endpoint.
            </summary>
      <seealso cref="T:ProtoBuf.ServiceModel.ProtoEndpointBehavior" />
    </member>
    <member name="M:ProtoBuf.ServiceModel.ProtoBehaviorExtension.#ctor">
      <summary>
            Creates a new ProtoBehaviorExtension instance.
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.ProtoBehaviorExtension.CreateBehavior">
      <summary>
            Creates a behavior extension based on the current configuration settings.
            </summary>
      <returns>The behavior extension.</returns>
    </member>
    <member name="P:ProtoBuf.ServiceModel.ProtoBehaviorExtension.BehaviorType">
      <summary>
            Gets the type of behavior.
            </summary>
    </member>
    <member name="T:ProtoBuf.ServiceModel.ProtoEndpointBehavior">
      <summary>
            Behavior to swap out DatatContractSerilaizer with the XmlProtoSerializer for a given endpoint.
             <example>
            Add the following to the server and client app.config in the system.serviceModel section:
             <behaviors><endpointBehaviors><behavior name="ProtoBufBehaviorConfig"><ProtoBufSerialization /></behavior></endpointBehaviors></behaviors><extensions><behaviorExtensions><add name="ProtoBufSerialization" type="ProtoBuf.ServiceModel.ProtoBehaviorExtension, protobuf-net, Version=1.0.0.255, Culture=neutral, PublicKeyToken=257b51d87d2e4d67" /></behaviorExtensions></extensions>
            
            Configure your endpoints to have a behaviorConfiguration as follows:
            
             <service name="TK.Framework.Samples.ServiceModel.Contract.SampleService"><endpoint address="http://myhost:9003/SampleService" binding="basicHttpBinding" behaviorConfiguration="ProtoBufBehaviorConfig" bindingConfiguration="basicHttpBindingConfig" name="basicHttpProtoBuf" contract="ISampleServiceContract" /></service><client><endpoint address="http://myhost:9003/SampleService" binding="basicHttpBinding" bindingConfiguration="basicHttpBindingConfig" contract="ISampleServiceContract" name="BasicHttpProtoBufEndpoint" behaviorConfiguration="ProtoBufBehaviorConfig" /></client></example></summary>
    </member>
    <member name="T:ProtoBuf.ServiceModel.ProtoOperationBehavior">
      <summary>
            Describes a WCF operation behaviour that can perform protobuf serialization
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.ProtoOperationBehavior.#ctor(System.ServiceModel.Description.OperationDescription)">
      <summary>
            Create a new ProtoOperationBehavior instance
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.ProtoOperationBehavior.CreateSerializer(System.Type,System.Xml.XmlDictionaryString,System.Xml.XmlDictionaryString,System.Collections.Generic.IList{System.Type})">
      <summary>
            Creates a protobuf serializer if possible (falling back to the default WCF serializer)
            </summary>
    </member>
    <member name="P:ProtoBuf.ServiceModel.ProtoOperationBehavior.Model">
      <summary>
            The type-model that should be used with this behaviour
            </summary>
    </member>
    <member name="T:ProtoBuf.ServiceModel.XmlProtoSerializer">
      <summary>
            An xml object serializer that can embed protobuf data in a base-64 hunk (looking like a byte[])
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.TryCreate(ProtoBuf.Meta.TypeModel,System.Type)">
      <summary>
            Attempt to create a new serializer for the given model and type
            </summary>
      <returns>A new serializer instance if the type is recognised by the model; null otherwise</returns>
    </member>
    <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.#ctor(ProtoBuf.Meta.TypeModel,System.Type)">
      <summary>
            Creates a new serializer for the given model and type
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.WriteEndObject(System.Xml.XmlDictionaryWriter)">
      <summary>
            Ends an object in the output
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.WriteStartObject(System.Xml.XmlDictionaryWriter,System.Object)">
      <summary>
            Begins an object in the output
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.WriteObjectContent(System.Xml.XmlDictionaryWriter,System.Object)">
      <summary>
            Writes the body of an object in the output
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.IsStartObject(System.Xml.XmlDictionaryReader)">
      <summary>
            Indicates whether this is the start of an object we are prepared to handle
            </summary>
    </member>
    <member name="M:ProtoBuf.ServiceModel.XmlProtoSerializer.ReadObject(System.Xml.XmlDictionaryReader,System.Boolean)">
      <summary>
            Reads the body of an object
            </summary>
    </member>
    <member name="T:ProtoBuf.SubItemToken">
      <summary>
            Used to hold particulars relating to nested objects. This is opaque to the caller - simply
            give back the token you are given at the end of an object.
            </summary>
    </member>
    <member name="T:ProtoBuf.WireType">
      <summary>
            Indicates the encoding used to represent an individual value in a protobuf stream
            </summary>
    </member>
    <member name="F:ProtoBuf.WireType.None">
      <summary>
            Represents an error condition
            </summary>
    </member>
    <member name="F:ProtoBuf.WireType.Variant">
      <summary>
            Base-128 variant-length encoding
            </summary>
    </member>
    <member name="F:ProtoBuf.WireType.Fixed64">
      <summary>
            Fixed-length 8-byte encoding
            </summary>
    </member>
    <member name="F:ProtoBuf.WireType.String">
      <summary>
            Length-variant-prefixed encoding
            </summary>
    </member>
    <member name="F:ProtoBuf.WireType.StartGroup">
      <summary>
            Indicates the start of a group
            </summary>
    </member>
    <member name="F:ProtoBuf.WireType.EndGroup">
      <summary>
            Indicates the end of a group
            </summary>
    </member>
    <member name="F:ProtoBuf.WireType.Fixed32">
      <summary>
            Fixed-length 4-byte encoding
            </summary>10
        </member>
    <member name="F:ProtoBuf.WireType.SignedVariant">
      <summary>
            This is not a formal wire-type in the "protocol buffers" spec, but
            denotes a variant integer that should be interpreted using
            zig-zag semantics (so -ve numbers aren't a significant overhead)
            </summary>
    </member>
    <member name="T:NetworkCommsDotNet.DPSBase.ProtobufSerializer">
      <summary>
        <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> using <see href="http://code.google.com/p/protobuf-net/">ProtoBuf-Net</see> to serialize an <see cref="T:System.Object" /> to bytes
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.ProtobufSerializer.SerialiseDataObjectInt(System.IO.Stream,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.ProtobufSerializer.DeserialiseDataObjectInt(System.IO.Stream,System.Type,System.Collections.Generic.Dictionary{System.String,System.String})">
      <inheritdoc />
    </member>
    <member name="P:NetworkCommsDotNet.DPSBase.ProtobufSerializer.Instance">
      <summary>
            Instance singleton used to access <see cref="T:NetworkCommsDotNet.DPSBase.DataSerializer" /> instance.  Use instead <see cref="M:NetworkCommsDotNet.DPSBase.DPSManager.GetDataSerializer``1" /></summary>
    </member>
    <member name="T:SharpZipLibCompressor.SharpZipLibGzipCompressor">
      <summary>
            Compresor using Gzip compression from <see href="http://www.icsharpcode.net/opensource/sharpziplib/">SharpZipLib</see></summary>
    </member>
    <member name="M:SharpZipLibCompressor.SharpZipLibGzipCompressor.ForwardProcessDataStream(System.IO.Stream,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String},System.Int64@)">
      <inheritdoc />
    </member>
    <member name="M:SharpZipLibCompressor.SharpZipLibGzipCompressor.ReverseProcessDataStream(System.IO.Stream,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String},System.Int64@)">
      <inheritdoc />
    </member>
    <member name="P:SharpZipLibCompressor.SharpZipLibGzipCompressor.Instance">
      <summary>
            Instance singleton used to access <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> instance.  Obsolete, use instead <see cref="M:NetworkCommsDotNet.DPSBase.DPSManager.GetDataProcessor``1" /></summary>
    </member>
    <member name="T:QuickLZCompressor.QuickLZ">
      <summary>
            Compressor that utilizes native quicklz compression provided by the <see href="http://www.quicklz.com/">QuickLZ</see> library 
            </summary>
    </member>
    <member name="F:QuickLZCompressor.QuickLZ.compressDecompressLocker">
      <summary>
            Testing confirmed the decompress methods within quickLZ do not appear to be thread safe. No testing done on compress but also locked incase.
            </summary>
    </member>
    <member name="M:QuickLZCompressor.QuickLZ.ForwardProcessDataStream(System.IO.Stream,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String},System.Int64@)">
      <inheritdoc />
    </member>
    <member name="M:QuickLZCompressor.QuickLZ.ReverseProcessDataStream(System.IO.Stream,System.IO.Stream,System.Collections.Generic.Dictionary{System.String,System.String},System.Int64@)">
      <inheritdoc />
    </member>
    <member name="P:QuickLZCompressor.QuickLZ.Instance">
      <summary>
            Instance singleton used to access <see cref="T:NetworkCommsDotNet.DPSBase.DataProcessor" /> instance.  Obsolete, use instead <see cref="M:NetworkCommsDotNet.DPSBase.DPSManager.GetDataProcessor``1" /></summary>
    </member>
    <member name="P:QuickLZCompressor.QuickLZ.Available">
      <summary>
            Returns true if running in windows and the native <see href="http://www.quicklz.com/">QuickLZ</see> library is available for execution.  False otherwise.  All function calls to <see cref="T:QuickLZCompressor.QuickLZ" /> will fail if Available returns false
            </summary>
    </member>
    <member name="M:InTheHand.Net.ExceptionExtension.ToStringNoStackTrace(System.Exception)">
      <summary>
            Get the normal first line of <c>Exception.ToString()</c>,
            that is without the stack trace lines.
            </summary>
            -
            <remarks>
            Get the normal first line of <c>Exception.ToString()</c>,
            that is including details of all inner exceptions,
            but without the stack trace lines.
            e.g. <c>System.IO.IOException: An established connection was aborted by the software in your host machine. ---&gt; System.Net.Sockets.SocketException: An established connection was aborted by the software in your host machine.</c></remarks>
            -
            <param name="this">The exception.
            </param>
            -
            <returns>A string containing the first line of the <c>Exception.ToString()</c>.
            </returns></member>
    <member name="M:InTheHand.Net.ExceptionFactory.ArgumentOutOfRangeException(System.String,System.String)">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.StringUtilities.IsNullOrEmpty(System.String)">
      <exclude />
    </member>
    <member name="T:InTheHand.Net.Bluetooth.ServiceRecordParser">
      <summary>
            Parses an array of bytes into the contained SDP 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />.
            </summary>
            -
            <remarks>
            See the
            <see cref="M:InTheHand.Net.Bluetooth.ServiceRecordParser.Parse(System.Byte[],System.Int32,System.Int32)" />
            methods for more information.
            </remarks>
            -
            <seealso cref="M:InTheHand.Net.Bluetooth.ServiceRecordParser.Parse(System.Byte[],System.Int32,System.Int32)" /></member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceRecordParser.ElementTypeDescriptorOffset">
      <summary>
            Bit offset of the ElementTypeDescriptor field in a header byte.
            </summary>
      <remarks>
            The header byte has two parts: five bits of ElementTypeDescriptor and
            three bits of Size Index.
            </remarks>
      <seealso cref="F:InTheHand.Net.Bluetooth.ServiceRecordParser.SizeIndexMask" />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceRecordParser.SizeIndexMask">
      <summary>
            Mask for the SizeIndex field in a header byte.
            </summary>
      <remarks>
            The header byte has two parts: five bits of ElementTypeDescriptor and
            three bits of Size Index, upper and lower respectively.
            </remarks>
      <seealso cref="F:InTheHand.Net.Bluetooth.ServiceRecordParser.ElementTypeDescriptorOffset" />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceRecordParser.ErrorMsgFormatUnknownType">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceRecordParser.ErrorMsgFormatTypeNotTypeDSubtype">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceRecordParser.ErrorMsgSizeIndexNotSuitTypeD">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceRecordParser.ErrorMsgServiceRecordBytesZeroLength">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceRecordParser.ErrorMsgFormatInvalidHeaderBytes">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceRecordParser.ErrorMsgFormatTruncated">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceRecordParser.ErrorMsgFormatNotSupportFull32bitSized">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceRecordParser.ErrorMsgTypeNotAsExpected">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceRecordParser.ErrorMsgTopElementNotSequence">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceRecordParser.ErrorMsgMultiSeqChildElementNotSequence">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceRecordParser.ErrorMsgSequenceOverruns">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceRecordParser.ErrorMsgElementOverrunsBuffer_WithLengths">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceRecordParser.ErrorMsgElementOverrunsBuffer">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceRecordParser.ErrorMsgElementOverrunsBufferPrefix">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceRecordParser.ErrorMsgAttributePairFirstMustUint16">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordParser.Parse(System.Byte[])">
      <summary>
            Parses an array of bytes into its contained 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />.
            </summary>
            -
            <remarks>
            See <see cref="M:InTheHand.Net.Bluetooth.ServiceRecordParser.Parse(System.Byte[],System.Int32,System.Int32)" />
            for more information.
            </remarks>
            -
            <param name="buffer">A byte array containing the encoded Service Record.
            </param><returns>The new <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> parsed from the byte array.
            </returns>
            -
            <seealso cref="M:InTheHand.Net.Bluetooth.ServiceRecordParser.Parse(System.Byte[],System.Int32,System.Int32)" /><seealso cref="M:InTheHand.Net.Bluetooth.ServiceRecord.CreateServiceRecordFromBytes(System.Byte[])" /></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordParser.Parse(System.Byte[],System.Int32,System.Int32)">
      <summary>
            Parses an array of bytes into its contained 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />.
            </summary>
            -
            <remarks><para>If the record contains any element type not supported by the parser
            it will throw <see cref="T:System.NotImplementedException" />. The
            only element types defined by SDP in v2.0 that are not currently implemented 
            are 64- and 128-bit integers.  Of course any types defined in a later 
            version will also throw this.  This behaviour can be changed with the
            <see cref="P:InTheHand.Net.Bluetooth.ServiceRecordParser.SkipUnhandledElementTypes" /> 
            property.
            </para></remarks>
            -
            <param name="buffer">A byte array containing a Service Record.
            </param><param name="offset">The position in the data buffer at which to
            begin parsing the Service Record.
            </param><param name="length">The length of the Service Record in the byte array.
            </param><returns>The Service Record parse from the byte array.
            </returns>
            -
            <exception cref="T:System.Net.ProtocolViolationException">
            The record contains invalid content.
            </exception><exception cref="T:System.NotImplementedException">
            The record contains an element type not supported by the parser.
            </exception>
            -
            <seealso cref="M:InTheHand.Net.Bluetooth.ServiceRecordParser.Parse(System.Byte[])" /><seealso cref="M:InTheHand.Net.Bluetooth.ServiceRecord.CreateServiceRecordFromBytes(System.Byte[])" /></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordParser.SplitSearchAttributeResult(System.Byte[])">
      <summary>
            Split a sequence of records into the component records.
            </summary>
            -
            <remarks><para>The Bluetooth SDP operation ServiceSearchAttribute returns its 
            result as a data element sequence where each element in turn is 
            a data element sequence representing an attribute list.  This
            method split that sequence into the individual attribute lists.
            </para><para>On CE/Windows Mobile the result of a record lookup is in this form
            so <see cref="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.GetServiceRecords(System.Guid)" />
            etc use this method to split the result into is constituent records.
            </para></remarks>
            -
            <param name="multiRecord">A byte array holding the 
            data element sequence where each element in turn is 
            a data element sequence representing an attribute list.
            </param>
            -
            <returns>An array of byte arrays where each holds a SDP record
            (a data element sequence representing an attribute list.).
            If the input was zero length or empty then a zero length array is returned.
            </returns>
            -
            <exception cref="T:System.ArgumentNullException"><paramref name="multiRecord" /> is <see langword="null" />.
            </exception></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordParser.ParseContent(System.Boolean,System.Boolean,System.Byte[],System.Int32,System.Int32,System.Int32@,InTheHand.Net.Bluetooth.ElementTypeDescriptor,InTheHand.Net.Bluetooth.SizeIndex,System.Int32,System.Int32)">
      <summary>
            For use when the content of the element is in an array
            i.e. the stack parses the element structure and returns the values in byte arrays.
            </summary>
            -
            <param name="networkOrderInteger">Whether the stack uses network order
            for UnsignedInteger and TwosComplementInteger elements (as used in the SDP format)
            or instead that the numerical values are in host order
            in the byte array.
            </param><param name="networkOrderUuid">Whether the stack uses network order
            for Uuid elements (as used in the SDP format) 
            or instead that the numerical values are in host order
            in the byte array.
            </param><param name="buffer">The byte array containing the SDP value.
            </param><param name="offset">(?Always zero).
            </param><param name="length">The length of the byte array.
            (Always equals <paramref name="contentLength" />).
            </param><param name="_readLength"></param><param name="etd">The Element Type.
            </param><param name="dbgSizeIndex">(Not used).
            </param><param name="contentLength">The size of the value.
            </param><param name="contentOffset">(?Always zero).
            </param>
            -
            <returns></returns></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordParser.GetElementLength(System.Byte[],System.Int32,System.Int32,System.Int32@,System.Int32@)">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordParser.SplitHeaderByte(System.Byte,InTheHand.Net.Bluetooth.ElementTypeDescriptor@,InTheHand.Net.Bluetooth.SizeIndex@)">
      <summary>
            Split a header byte into its <see cref="T:InTheHand.Net.Bluetooth.ElementTypeDescriptor" /> and 
            <see cref="T:InTheHand.Net.Bluetooth.SizeIndex" /> parts.
            </summary>
      <remarks>
            The <see cref="T:InTheHand.Net.Bluetooth.ElementTypeDescriptor" /> returned is not checked to be a 
            known value.
            </remarks>
            -
            <param name="headerByte">The byte from the header.
            </param><param name="etd">The <see cref="T:InTheHand.Net.Bluetooth.ElementTypeDescriptor" />
            value from the header byte.
            </param><param name="sizeIndex">The <see cref="T:InTheHand.Net.Bluetooth.SizeIndex" />
            value from a header byte.
            </param>
            -
            <seealso cref="M:InTheHand.Net.Bluetooth.ServiceRecordParser.GetElementTypeDescriptor(System.Byte)" /><seealso cref="M:InTheHand.Net.Bluetooth.ServiceRecordParser.GetSizeIndex(System.Byte)" /></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordParser.GetElementTypeDescriptor(System.Byte)">
      <summary>
            Extract the <see cref="T:InTheHand.Net.Bluetooth.ElementTypeDescriptor" /> value from a header byte.
            </summary>
      <remarks>
            The <see cref="T:InTheHand.Net.Bluetooth.ElementTypeDescriptor" /> returned is not checked to be a 
            known value.
            </remarks>
            -
            <param name="headerByte">The byte from the header.
            </param>
            -
            <returns>The value as a <see cref="T:InTheHand.Net.Bluetooth.ElementTypeDescriptor" />.</returns>
            -
            <seealso cref="M:InTheHand.Net.Bluetooth.ServiceRecordParser.SplitHeaderByte(System.Byte,InTheHand.Net.Bluetooth.ElementTypeDescriptor@,InTheHand.Net.Bluetooth.SizeIndex@)" /><seealso cref="M:InTheHand.Net.Bluetooth.ServiceRecordParser.GetSizeIndex(System.Byte)" /></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordParser.GetSizeIndex(System.Byte)">
      <summary>
            Extract the <see cref="T:InTheHand.Net.Bluetooth.SizeIndex" /> field from a header byte.
            </summary>
            -
            <param name="headerByte">The byte from the header.
            </param>
            -
            <returns>The value as a <see cref="T:InTheHand.Net.Bluetooth.SizeIndex" />.</returns>
            -
            <seealso cref="M:InTheHand.Net.Bluetooth.ServiceRecordParser.SplitHeaderByte(System.Byte,InTheHand.Net.Bluetooth.ElementTypeDescriptor@,InTheHand.Net.Bluetooth.SizeIndex@)" /><seealso cref="M:InTheHand.Net.Bluetooth.ServiceRecordParser.GetElementTypeDescriptor(System.Byte)" /></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordParser.TypeMatchesEtd(InTheHand.Net.Bluetooth.ElementTypeDescriptor,InTheHand.Net.Bluetooth.ElementType)">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordParser.GetEtdForType(InTheHand.Net.Bluetooth.ElementType)">
      <exclude />
    </member>
    <member name="P:InTheHand.Net.Bluetooth.ServiceRecordParser.SkipUnhandledElementTypes">
      <summary>
            Gets or set whether the parser will attempt to skip any unknown element
            type rather than producing an error.
            </summary>
            -
            <remarks><para>
            An element type is added instead with 
            <c>ElementType.</c><see cref="F:InTheHand.Net.Bluetooth.ElementType.Unknown" /> 
            and <c>ElementTypeDescriptor.</c><see cref="F:InTheHand.Net.Bluetooth.ElementTypeDescriptor.Unknown" />.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.ServiceRecordParser.LazyUrlCreation">
      <summary>
            Gets or sets whether any URL elements will be converted to 
            <see cref="T:System.Uri" /> instances at parse time, or left as raw byte arrays.
            </summary>
            -
            <remarks><para>
            This is useful when the URL element is badly formatted and thus the
            parser will reject the record, setting this property to <c>true</c> will
            allow the parse to complete without attempting to decode the URL value.
            </para><para>When <c>true</c> the value is stored as a array of bytes, when
            <c>false</c> it is stored as a <see cref="T:System.String" />;
            however in earlier versions it was stored as <see cref="T:System.Uri" />,
            and since there was often invalid content on devices (e.g. iPhone)
            this often failed.
            </para></remarks></member>
    <member name="T:InTheHand.Net.Sockets.BluetoothSocketOptionLevel">
      <summary>
            Defines additional Bluetooth socket option levels for the <see cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" /> and <see cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" /> methods.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionLevel.RFComm">
      <summary>
            Bluetooth RFComm protocol (bt-rfcomm)
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionLevel.L2Cap">
      <summary>
            Logical Link Control and Adaptation Protocol (bt-l2cap)
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionLevel.Sdp">
      <summary>
            Service Discovery Protocol (bt-sdp)
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Widcomm.WidcommSocketException">
      <summary>
            Note that this exception will always be internal, just catch SocketException.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Factory.IBluetoothRadio">
      <exclude />
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothRadio.IsPlatformSupported">
      <summary>
            Gets a value that indicates whether the 32feet.NET library can be used with the current device.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.IUsesBluetoothConnectorImplementsServiceLookup.BeginServiceDiscovery(InTheHand.Net.BluetoothAddress,System.Guid,System.AsyncCallback,System.Object)">
      <summary>
            When overidden, initiates 
            lookup the SDP record with the give Service Class Id
            to find the RFCOMM port number (SCN) that the server is listening on.
            The process returns a list of port numbers.
            </summary>
      <param name="address">The remote device.
            </param>
      <param name="serviceGuid">The Service Class Id.
            </param>
      <param name="asyncCallback">callback</param>
      <param name="state">state</param>
      <returns>IAsyncResult</returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.IUsesBluetoothConnectorImplementsServiceLookup.EndServiceDiscovery(System.IAsyncResult)">
      <summary>
            When overidden, 
            completes the SDP Record to port number lookup process
            </summary>
            -
            <param name="ar">IAsyncResult from <see cref="M:InTheHand.Net.Bluetooth.Factory.IUsesBluetoothConnectorImplementsServiceLookup.BeginServiceDiscovery(InTheHand.Net.BluetoothAddress,System.Guid,System.AsyncCallback,System.Object)" />.
            </param>
            -
            <remarks><para>There must be at least one entry in the result list for each
            Service Record found for the specified Service Class Id.  This
            allows us to know if no records were found, or that records were
            found but none of them were for RFCOMM.
            If a particular record does not have a RFCOMM port then -1 (negative
            one should be added to the list for it).
            </para><para>The process may throw an exception if an error occurs, e.g.
            the remote device did not respond.
            </para></remarks>
            -
            <returns>A <see cref="T:System.Collections.Generic.List{System.Int32}" />
            with at least one entry for each Service Record
            found for the specified Service Class Id, the item being -1 if the
            record has no port. is .
            </returns></member>
    <member name="T:InTheHand.Net.Bluetooth.Factory.CommonBluetoothInquiry`1">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.CommonBluetoothInquiry`1.InquiryTimeoutParams.InquiryLengthAsMiliseconds">
      <summary>
            Get timeout value in Int32 milliseconds,
            as NETCF <c>WaitHandle.WaitOne</c> can't use TimeSpan.
            </summary>
            -
            <returns>An Int32 containing the timeout value in milliseconds.
            </returns></member>
    <member name="T:InTheHand.ObexUri">
      <summary>
            Contains <see cref="T:System.Uri" /> helper functionality.
            </summary>
    </member>
    <member name="F:InTheHand.ObexUri.UriSchemeObex">
      <summary>
            Specifies that the URI is accessed through the Object Exchange (OBEX) protocol.
            </summary>
    </member>
    <member name="F:InTheHand.ObexUri.UriSchemeObexPush">
      <summary>
            Specifies that the URI is accessed through the Object Exchange (OBEX) Push protocol.
            </summary>
    </member>
    <member name="F:InTheHand.ObexUri.UriSchemeObexFtp">
      <summary>
            Specifies that the URI is accessed through the Object Exchange (OBEX) FTP protocol.
            </summary>
    </member>
    <member name="F:InTheHand.ObexUri.UriSchemeObexSync">
      <summary>
            Specifies that the URI is accessed through the Object Exchange (OBEX) Sync protocol.
            </summary>
    </member>
    <member name="T:InTheHand.Net.ObexWebResponse">
      <summary>
            Provides an OBEX implementation of the <see cref="T:System.Net.WebResponse" /> class.
            </summary>
    </member>
    <member name="M:InTheHand.Net.ObexWebResponse.GetResponseStream">
      <summary>
            Gets the stream used to read the body of the response from the server.
            </summary>
            -
            <returns>A <see cref="T:System.IO.Stream" /> containing the body of the response.</returns></member>
    <member name="M:InTheHand.Net.ObexWebResponse.Close">
      <summary>
            Frees the resources held by the response.
            </summary>
    </member>
    <member name="M:InTheHand.Net.ObexWebResponse.WriteFile(System.String)">
      <summary>
            Writes the contents of the response to the specified file path.
            </summary>
      <param name="fileName">The filename (including the path) from which to read.</param>
    </member>
    <member name="P:InTheHand.Net.ObexWebResponse.Headers">
      <summary>
            Gets the headers associated with this response from the server.
            </summary>
    </member>
    <member name="P:InTheHand.Net.ObexWebResponse.ContentLength">
      <summary>
            Gets the length of the content returned by the request.
            </summary>
    </member>
    <member name="P:InTheHand.Net.ObexWebResponse.ContentType">
      <summary>
            Gets the content type of the response.
            </summary>
    </member>
    <member name="P:InTheHand.Net.ObexWebResponse.StatusCode">
      <summary>
            Returns a status code to indicate the outcome of the request.
            </summary>
            -
            <remarks><para>Note, if a error occurs locally then the status code
            <see cref="F:InTheHand.Net.ObexStatusCode.InternalServerError" /> is returned.
            Therefore that error code could signal local or remote errors.
            </para></remarks></member>
    <member name="T:InTheHand.Net.Bluetooth.Factory.IBluetoothListener">
      <exclude />
    </member>
    <member name="T:InTheHand.Net.Bluetooth.HciVersion">
      <summary>
            HCI_Version  Assigned Numbers  Host Controller Interface
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.HciVersion.v1_0_b">
      <summary>
            Bluetooth Core Specification 1.0b
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.HciVersion.v1_1">
      <summary>
            Bluetooth Core Specification 1.1
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.HciVersion.v1_2">
      <summary>
            Bluetooth Core Specification 1.2
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.HciVersion.v2_0wEdr">
      <summary>
            Bluetooth Core Specification 2.0 + EDR
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.HciVersion.v2_1wEdr">
      <summary>
            Bluetooth Core Specification 2.1 + EDR
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.HciVersion.v3_0wHS">
      <summary>
            Bluetooth Core Specification 3.0 + HS
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.HciVersion.v4_0">
      <summary>
            Bluetooth Core Specification 4.0
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.HciVersion.Unknown">
      <summary>
            Unknown version  probably the stack API
            does not provide the value.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.LmpVersion">
      <summary>
            LMP VerNr  Assigned Numbers  Link Manager Protocol
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpVersion.v1_0_b">
      <summary>
            Bluetooth Core Specification 1.0b
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpVersion.v1_1">
      <summary>
            Bluetooth Core Specification 1.1
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpVersion.v1_2">
      <summary>
            Bluetooth Core Specification 1.2
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpVersion.v2_0wEdr">
      <summary>
            Bluetooth Core Specification 2.0 + EDR
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpVersion.v2_1wEdr">
      <summary>
            Bluetooth Core Specification 2.1 + EDR
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpVersion.v3_0wHS">
      <summary>
            Bluetooth Core Specification 3.0 + HS
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpVersion.v4_0">
      <summary>
            Bluetooth Core Specification 4.0
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpVersion.Unknown">
      <summary>
            Unknown version  probably the stack API
            does not provide the value.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BluetoothSecurity">
      <summary>
            Handles security between bluetooth devices.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothSecurity.PairRequest(InTheHand.Net.BluetoothAddress,System.String)">
      <summary>
            Intiates pairing for a remote device.
            </summary>
      <param name="device">Remote device with which to pair.</param>
      <param name="pin">Chosen PIN code, must be between 1 and 16 ASCII characters.</param>
      <remarks>
        <para>On Windows CE platforms this calls <c>BthPairRequest</c>,
            its MSDN remarks say:
            </para>
        <para>BthPairRequest passes the parameters to the <c>BthSetPIN</c>
            function and creates an ACL connection. Once the connection is established,
            it calls the <c>BthAuthenticate</c> function to authenticate the device.
            </para>
        <para>On Windows XP/Vista platforms this calls <c>BluetoothAuthenticateDevice</c>,
            if the pin argument is set to null a Wizard is displayed to accept a PIN from the user,
            otherwise the function executes in transparent mode.
            </para>
        <para>See also 
            <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.SetPin(InTheHand.Net.BluetoothAddress,System.String)" /></para>
      </remarks>
      <returns>Whether the operation was successful.</returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothSecurity.RemoveDevice(InTheHand.Net.BluetoothAddress)">
      <summary>
            Remove the pairing with the specified device
            </summary>
            -
            <param name="device">Remote device with which to remove pairing.</param>
            -
            <returns>TRUE if device was successfully removed, else FALSE.</returns></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothSecurity.SetPin(InTheHand.Net.BluetoothAddress,System.String)">
      <summary>
            This function stores the personal identification number (PIN) for the Bluetooth device.
            </summary>
      <param name="device">Address of remote device.</param>
      <param name="pin">Pin, alphanumeric string of between 1 and 16 ASCII characters.</param>
      <remarks>
        <para>On Windows CE platforms this calls <c>BthSetPIN</c>,
            its MSDN remarks say:
            </para>
        <para>Stores the pin for the Bluetooth device identified in pba.
            The active connection to the device is not necessary, nor is the presence
            of the Bluetooth controller. The PIN is persisted in the registry until
            BthRevokePIN is called.
            </para>
        <para>While the PIN is stored, it is supplied automatically
            after the PIN request is issued by the authentication mechanism, so the
            user will not be prompted for it. Typically, for UI-based devices, you
            would set the PIN for the duration of authentication, and then revoke
            it after authentication is complete.
            </para>
        <para>See also 
            <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.RevokePin(InTheHand.Net.BluetoothAddress)" /></para>
      </remarks>
      <returns>True on success, else False.</returns>
      <seealso cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.RevokePin(InTheHand.Net.BluetoothAddress)" />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothSecurity.RevokePin(InTheHand.Net.BluetoothAddress)">
      <summary>
            This function revokes the personal identification number (PIN) for the Bluetooth device.
            </summary>
      <remarks>
        <para>On Windows CE platforms this calls <c>BthRevokePIN</c>,
            its MSDN remarks say:
            </para>
        <para>When the PIN is revoked, it is removed from registry.
            The active connection to the device is not necessary, nor is the presence
            of the Bluetooth controller.
            </para>
        <para>On Windows CE platforms this removes any pending BluetoothWin32Authentication object but does not remove the PIN for an already authenticated device.
            Use RemoveDevice to ensure a pairing is completely removed.</para>
        <para>See also 
            <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.SetPin(InTheHand.Net.BluetoothAddress,System.String)" /></para>
      </remarks>
      <param name="device">The remote device.</param>
      <returns>True on success, else False.</returns>
      <seealso cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.SetPin(InTheHand.Net.BluetoothAddress,System.String)" />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothSecurity.SetLinkKey(InTheHand.Net.BluetoothAddress,System.Guid)">
      <summary>
        <para>
          <b>Not supported on Windows XP</b>
        </para>
      </summary>
            -
            <param name="device">The device whose Link Key to retrieve.</param><param name="linkKey">The 16-byte Link Key to set.</param>
            -
            <returns><c>true</c> if the operation was successful; <c>false</c> otherwise.</returns>
            -
            <remarks><para>On Windows CE platforms this calls <c>BthSetLinkKey</c>,
            its MSDN remarks say:
            </para><para>The link key is persisted in registry until <c>BthRevokeLinkKey</c>
            is called.
            </para><para>Typically, the Bluetooth stack manages link keys automatically,
            for example, it stores them when they are created. This function is useful
            primarily for backup purposes.
            </para><para>While link key is stored, it will be automatically supplied
            once the link key request is issued by the authentication mechanism. If
            the link key is incorrect, the renegotiation that involves the PIN is
            initiated by the Bluetooth adapter, and the PIN code may be requested
            from the user.
            </para><para>The link key length is 16 bytes. You cannot create link
            keys; they are generated by the Bluetooth hardware.
            </para></remarks><returns></returns></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothSecurity.GetPinRequest">
      <summary>
            Retrieves the address of the Bluetooth peer device authentication that requires the PIN code.
            <para><b>Not supported on Windows XP</b></para></summary>
      <remarks>
        <para>On Windows CE platforms this calls <c>BthGetPINRequest</c>,
            its MSDN remarks say:
            </para>
        <para>There can be multiple requests outstanding. After the event
            that is provided by the UI handler is signaled, the UI handler must call
            this function multiple times until the call fails.
            </para>
        <para>See also 
            <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.RefusePinRequest(InTheHand.Net.BluetoothAddress)" />
            and <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.AnswerPinRequest(InTheHand.Net.BluetoothAddress,System.String)" /></para>
      </remarks>
      <returns>
        <see cref="T:InTheHand.Net.BluetoothAddress" /> of the remote device, or null if there is no outstanding PIN request.</returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothSecurity.RefusePinRequest(InTheHand.Net.BluetoothAddress)">
      <summary>
            Refuses an outstanding PIN request.
            <para><b>Not supported on Windows XP</b></para></summary>
            -
            <param name="device">Address of the requesting device.</param>
            -
            <returns><c>true</c> if the operation was successful; <c>false</c> otherwise.</returns>
            -
            <remarks><para>On Windows CE platforms this calls <c>BthRefusePINRequest</c>,
            its MSDN remarks say:
            </para><para>This function refuses an outstanding PIN request that is
            retrieved by <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.GetPinRequest" />
            function.
            </para><para>See also 
            <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.GetPinRequest" />
            and <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.AnswerPinRequest(InTheHand.Net.BluetoothAddress,System.String)" /></para></remarks></member>
    <member name="T:InTheHand.Net.Sockets.AddressFamily32">
      <summary>
            Specifies additional addressing schemes that an instance of the <see cref="T:System.Net.Sockets.Socket" /> class can use.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.AddressFamily32.Bluetooth">
      <summary>
            Bluetooth address.
            </summary>
      <value>32</value>
    </member>
    <member name="F:InTheHand.Net.Sockets.AddressFamily32.Irda">
      <summary>
            IrDA address used on some Windows CE platforms (Has a different value to <see cref="T:System.Net.Sockets.AddressFamily">AddressFamily.IrDA</see>).
            </summary>
      <value>22</value>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.ServiceRecordHelper">
      <summary>
            Some useful methods for working with a SDP <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            including creating and accessing the <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList" />
            for an RFCOMM service.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordHelper.GetRfcommChannelElement(InTheHand.Net.Bluetooth.ServiceRecord)">
      <summary>
            Reads the RFCOMM Channel Number element from the service record.
            </summary>
            -
            <param name="record">The <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            to search for the element.
            </param>
            -
            <returns>The <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" />
            holding the Channel Number.
            or <see langword="null" /> if at the <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList" />
            attribute is missing or contains invalid elements.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordHelper.GetL2CapChannelElement(InTheHand.Net.Bluetooth.ServiceRecord)">
      <summary>
            Reads the L2CAP Channel Number element from the service record.
            </summary>
            -
            <param name="record">The <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            to search for the element.
            </param>
            -
            <returns>The <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" />
            holding the Channel Number.
            or <see langword="null" /> if at the <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList" />
            attribute is missing or contains invalid elements.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordHelper.GetRfcommChannelNumber(InTheHand.Net.Bluetooth.ServiceRecord)">
      <summary>
            Reads the RFCOMM Channel Number value from the service record,
            or returns -1 if the element is not present.
            </summary>
            -
            <param name="record">The <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            to search for the element.
            </param>
            -
            <returns>The Channel Number as an unsigned byte cast to an Int32, 
            or -1 if at the <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList" />
            attribute is missing or contains invalid elements.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordHelper.GetL2CapChannelNumber(InTheHand.Net.Bluetooth.ServiceRecord)">
      <summary>
            Reads the L2CAP Channel Number value from the service record,
            or returns -1 if the element is not present.
            </summary>
            -
            <param name="record">The <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            to search for the element.
            </param>
            -
            <returns>The PSM number as an uint16 cast to an Int32, 
            or -1 if at the <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList" />
            attribute is missing or contains invalid elements.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordHelper.SetRfcommChannelNumber(InTheHand.Net.Bluetooth.ServiceRecord,System.Byte)">
      <summary>
            Sets the RFCOMM Channel Number value in the service record.
            </summary>
            -
            <param name="record">The <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            in which to set the RFCOMM Channel number.
            </param><param name="channelNumber">The Channel number to set in the record.
            </param>
            -
            <exception cref="T:System.InvalidOperationException">The
            <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList" />
            attribute is missing or contains invalid elements.
            </exception></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordHelper.SetL2CapPsmNumber(InTheHand.Net.Bluetooth.ServiceRecord,System.Int32)">
      <summary>
            Sets the RFCOMM Channel Number value in the service record.
            </summary>
            -
            <remarks><para>Note: We use an <see cref="T:System.Int32" /> for the
            <paramref name="psm" /> parameter as its natural type <see cref="T:System.UInt16" /> 
            in not usable in CLS Compliant interfaces.
            </para></remarks>
            -
            <param name="record">The <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            in which to set the L2CAP PSM value.
            </param><param name="psm">The PSM value to set in the record.
            Note that although the parameter is of type <see cref="T:System.Int32" /> 
            the value must actually be in the range of a <see cref="T:System.UInt16" />,
            see the remarks for more information.
            </param>
            -
            <exception cref="T:System.InvalidOperationException">The
            <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList" />
            attribute is missing or contains invalid elements.
            </exception><exception cref="T:System.ArgumentOutOfRangeException">
            The PSM must fit in a 16-bit unsigned integer.
            </exception></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordHelper.CreateL2CapProtocolDescriptorList">
      <summary>
            Creates the data element for the 
            <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList" />
            attribute in an L2CAP service
            </summary>
            -
            <returns>The new <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" />.</returns>
            -
            <remarks>Thus is the following structure:
            <code lang="none">
            ElementSequence
               ElementSequence
                  Uuid16 = L2CAP
                  UInt16 = 0      -- The L2CAP PSM Number.
            </code></remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordHelper.CreateRfcommProtocolDescriptorList">
      <summary>
            Creates the data element for the 
            <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList" />
            attribute in an RFCOMM service
            </summary>
            -
            <returns>The new <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" />.</returns>
            -
            <remarks>Thus is the following structure:
            <code lang="none">
            ElementSequence
               ElementSequence
                  Uuid16 = L2CAP
               ElementSequence
                  Uuid16 = RFCOMM
                  UInt8  = 0      -- The RFCOMM Channel Number.
            </code></remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordHelper.CreateGoepProtocolDescriptorList">
      <summary>
            Creates the data element for the 
            <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList" />
            attribute in an GOEP (i.e. OBEX) service
            </summary>
            -
            <returns>The new <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" />.</returns>
            -
            <remarks>Thus is the following structure:
            <code lang="none">
            ElementSequence
               ElementSequence
                  Uuid16 = L2CAP
               ElementSequence
                  Uuid16 = RFCOMM
                  UInt8  = 0      -- The RFCOMM Channel Number.
               ElementSequence
                  Uuid16 = GOEP
            </code></remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordHelper.CreateL2CapProtocolDescriptorListWithUpperLayers(InTheHand.Net.Bluetooth.ServiceElement[])">
      <summary>
            Creates the data element for the 
            <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList" />
            attribute in an L2CAP service,
            with upper layer entries.
            </summary>
            -
            <returns>The new <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" />.</returns>
            -
            <remarks>Thus is the following structure at the first layer:
            <code lang="none">
            ElementSequence
               ElementSequence
                  Uuid16 = L2CAP
                  UInt16 = 0      -- The L2CAP PSM Number.
            </code>
            One can add layers above that; remember that all layers are formed
            of an ElementSequence.  See the example below.
            </remarks>
            -
            <example><code>
            var netProtoList = new ServiceElement(ElementType.ElementSequence,
                ServiceElement.CreateNumericalServiceElement(ElementType.UInt16, 0x0800),
                ServiceElement.CreateNumericalServiceElement(ElementType.UInt16, 0x0806)
                );
            var layer1 = new ServiceElement(ElementType.ElementSequence,
                new ServiceElement(ElementType.Uuid16, Uuid16_BnepProto),
                ServiceElement.CreateNumericalServiceElement(ElementType.UInt16, 0x0100), //v1.0
                netProtoList
                );
            ServiceElement element = ServiceRecordHelper.CreateL2CapProtocolDescriptorListWithUpperLayers(
                layer1);
            </code></example>
            -
            <param name="upperLayers">The list of upper layer elements, one per layer.
            As an array.
            </param></member>
    <member name="T:InTheHand.Net.Bluetooth.ServiceRecordCreator">
      <summary>
            Creates a Service Record byte array from the given 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> object.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.ServiceRecordCreator.HeaderWriteState">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceRecordCreator.ErrorMsgSupportOnlyLength255">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordCreator.CreateServiceRecord(InTheHand.Net.Bluetooth.ServiceRecord,System.Byte[])">
      <overloads>
            Creates a Service Record byte array from the given 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> object.
            </overloads>
            -
            <summary>
            Creates a Service Record byte array from the given 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> object,
            into the specified byte array.
            </summary>
            -
            <remarks>
            See the other overload <see cref="M:InTheHand.Net.Bluetooth.ServiceRecordCreator.CreateServiceRecord(InTheHand.Net.Bluetooth.ServiceRecord)" /></remarks>
            -
            <param name="record">An instance of <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            containing the record to be created.
            </param><param name="buffer">An array of <see cref="T:System.Byte" /> for the record
            to be written to.
            </param>
            -
            <exception cref="T:System.ArgumentOutOfRangeException">
            The record bytes are longer that the supplied byte array buffer.
            </exception>
            -
            <returns>The length of the record in the array of <see cref="T:System.Byte" />.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordCreator.WriteAttribute(InTheHand.Net.Bluetooth.ServiceAttribute,System.Byte[],System.Int32@)">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordCreator.CreateServiceRecord(InTheHand.Net.Bluetooth.ServiceRecord)">
      <summary>
            Creates a Service Record byte array from the given 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> object.
            </summary>
            -
            <remarks><para>The only oddity (as with parsing) is with the <c>TextString</c>
            type.  The <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" /> can
            either hold the string already encoded to its array of bytes or an 
            <see cref="T:System.String" />.  In the latter case we will always simply 
            encode the string to an array of bytes using encoding 
            <see cref="P:System.Text.Encoding.UTF8" />.
            </para><para>Currently any UUIDs in the record are written out in the form supplied,
            we should probably write a short-form equivalent if its
            a Bluetooth-based UUID e.g. <c>Uuid128</c> as <c>Uuid16</c>.
            </para></remarks>
            -
            <param name="record">An instance of <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            containing the record to be created.
            </param>
            -
            <returns>An array of <see cref="T:System.Byte" /> containing the resultant
            record bytes.  The length of the array is the length of the record bytes.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordCreator.CreateAttrId(InTheHand.Net.Bluetooth.ServiceAttributeId,System.Byte[],System.Int32)">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordCreator.CreateElement(InTheHand.Net.Bluetooth.ServiceElement,System.Byte[],System.Int32)">
      <summary>
            Create the element in the buffer starting at offset, and return its totalLength.
            </summary>
      <param name="element">The element to create.
            </param>
      <param name="buf">The byte array to write the encoded element to.
            </param>
      <param name="offset">The place to start writing in <paramref name="buf" />.
            </param>
      <returns>The total length of the encoded element written to the buffer
            </returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordCreator.WriteVariableLength(InTheHand.Net.Bluetooth.ServiceElement,System.Byte[],System.Byte[],System.Int32@,System.Int32@)">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordCreator.WriteFixedLength(InTheHand.Net.Bluetooth.ServiceElement,System.Byte[],System.Byte[],System.Int32@,System.Int32@)">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordCreator.MakeVariableLengthHeader(System.Byte[],System.Int32,InTheHand.Net.Bluetooth.ElementTypeDescriptor,InTheHand.Net.Bluetooth.ServiceRecordCreator.HeaderWriteState@)">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordCreator.CompleteHeaderWrite(InTheHand.Net.Bluetooth.ServiceRecordCreator.HeaderWriteState,System.Byte[],System.Int32,System.Int32@)">
      <exclude />
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BluetoothWin32Events">
      <summary>
            Provides access to the Bluetooth events from the Microsoft stack on
            desktop Windows.
            </summary>
            -
            <remarks><note>Supported only by the Microsoft stack on desktop Windows.
            </note><para>The Microsoft Bluetooth stack on Window raises events for various
            Bluetooth actions.  We expose that feature via this class.
            </para><para>Currently it raises two types of event: in-range and out-of-range
            using classes: <see cref="T:InTheHand.Net.Bluetooth.BluetoothWin32RadioInRangeEventArgs" />
            and <see cref="T:InTheHand.Net.Bluetooth.BluetoothWin32RadioOutOfRangeEventArgs" />.
            Both have properties <c>Device</c> which return a <c>BluetoothDeviceInfo</c>.
            Then the in-range event also includes a set of flags, which in
            Windows XP are: Address, Cod, Name, Paired, Personal, and Connected;
            more events are available in Windows 7.  These events are provided on
            the <see cref="T:InTheHand.Net.Bluetooth.BluetoothWin32RadioInRangeEventArgs" />
            class via properties:
            <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32RadioInRangeEventArgs.CurrentState" />
            and <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32RadioInRangeEventArgs.PreviousState" />,
            and also <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32RadioInRangeEventArgs.GainedStates" /> etc.
            </para><para>To see the events get an instance of this class via its method
            <see cref="M:InTheHand.Net.Bluetooth.BluetoothWin32Events.GetInstance" />.
            Then one should register for the events on that instance and keep a
            reference to it.
            </para><para>Note that just being in range is not enough for
            devices to know that the other is present.  Without running device
            discovery or a connection attempt the two devices will not see each
            other.  Note however that Windows XP also does not raise events when
            running device discovery (inquiry), this is fixed in Windows 7
            (probably Vista).  See
            <see href="http://32feetnetdev.wordpress.com/2010/11/15/device-discovery-improvements-on-msftwin32/">32feet blog: Device Discovery improvements on MSFT+Win32</see>
            for more information.
            </para><para>For example when connecting and disconnecting on Windows XP to
            another device that is not paired we see:
            </para><example><code lang="none">
            12:23:48.9582648: InRange 000A3A6865BB 'joe',
                now 'Address, Cod, Name, Connected'
                was 'Address, Cod, Name'.
            12:24:16.8009456: InRange 000A3A6865BB 'joe',
                now 'Address, Cod, Name'
                was 'Address, Cod, Name, Connected'.}}
            </code></example><para>For example when connecting and then disconnecting on Windows 7
            to another v2.1 device that is paired with we see:
            </para><example><code lang="none">
            20:53:25.5605469: InRange 00190E02C916 'alanlt2ws',
                now 'Address, Cod, Name, Paired, Personal, Connected, SspSupported, SspPaired, Rssi, Eir'
                was 'Address, Cod, Name, Paired, Personal,            SspSupported, SspPaired, Rssi, Eir'.
            20:53:27.7949219: InRange 00190E02C916 'fred',
                now 'Address, Cod, Name, Paired, Personal,            SspSupported, SspPaired, Rssi, Eir'
                was 'Address, Cod, Name, Paired, Personal, Connected, SspSupported, SspPaired, Rssi, Eir'.}}
            </code></example></remarks></member>
    <member name="T:InTheHand.Net.Bluetooth.BluetoothWin32Events.BTH_L2CAP_EVENT_INFO">
      <summary>
            Buffer associated with GUID_BLUETOOTH_L2CAP_EVENT
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BluetoothWin32Events.BTH_HCI_EVENT_INFO">
      <summary>
            Buffer associated with GUID_BLUETOOTH_HCI_EVENT
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothWin32Events.#ctor">
      <summary>
            Initialise an instance of the class.
            </summary>
            -
            <remarks><para>Consider using the method <see cref="M:InTheHand.Net.Bluetooth.BluetoothWin32Events.GetInstance" />
            instead of calling this constructor.
            </para></remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothWin32Events.#ctor(InTheHand.Net.Bluetooth.BluetoothRadio)">
      <summary>
            Initialise an instance of the class for the specified radio.
            </summary>
            -
            <param name="microsoftWin32BluetoothRadio">
            The radio to listen for events from.
            Must be non-null and a MSFT+Win32 stack radio.
            </param>
            -
            <remarks>Note that since the Microsoft stack supports only one radio
            (controller) there is lilely no benefit in calling this constructor
            as opposed to the other constructor or method
            <see cref="M:InTheHand.Net.Bluetooth.BluetoothWin32Events.GetInstance" />.
            </remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothWin32Events.GetInstance">
      <summary>
            Gets a possible shared instance of this class.
            </summary>
            -
            <remarks><para>If more that one piece of code is using this class then there
            is no need for each to have a private instance.  This method allows
            them to access a shared instance.  When first called it creates a
            new instance and keeps a weak-reference to it.  Subsequent callers
            will then get the same instance.  The instance is kept alive only
            as long as at least one caller keeps a reference to it.  If no
            references are kept then the instance will be deleted and a new
            instance will be created when this method is next called.
            </para></remarks>
            -
            <returns>An instance of this class.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothWin32Events.OnInRange(InTheHand.Net.Bluetooth.BluetoothWin32RadioInRangeEventArgs)">
      <summary>
            Raises the <see cref="E:InTheHand.Net.Bluetooth.BluetoothWin32Events.InRange" /> event.
            </summary>
            -
            <param name="e">A <see cref="T:InTheHand.Net.Bluetooth.BluetoothWin32RadioInRangeEventArgs" />
            that contains the event data.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothWin32Events.OnOutOfRange(InTheHand.Net.Bluetooth.BluetoothWin32RadioOutOfRangeEventArgs)">
      <summary>
            Raises the <see cref="E:InTheHand.Net.Bluetooth.BluetoothWin32Events.OutOfRange" /> event.
            </summary>
            -
            <param name="e">A <see cref="T:InTheHand.Net.Bluetooth.BluetoothWin32RadioOutOfRangeEventArgs" />
            that contains the event data.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothWin32Events.Dispose">
      <summary>
            Releases the resources used by the instance.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothWin32Events.Dispose(System.Boolean)">
      <summary>
            Releases the unmanaged resources used by the instance
            and optionally releases the managed resources.
            </summary>
    </member>
    <member name="E:InTheHand.Net.Bluetooth.BluetoothWin32Events.InRange">
      <summary>
            This message is sent when any of the following attributes
            of a remote Bluetooth device has changed: the device has been
            discovered, the class of device, name, connected state, or device
            remembered state. This message is also sent when these attributes
            are set or cleared.
            </summary>
    </member>
    <member name="E:InTheHand.Net.Bluetooth.BluetoothWin32Events.OutOfRange">
      <summary>
            This message is sent when a previously discovered device
            has not been found after the completion of the last inquiry.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BLUETOOTH_AUTHENTICATION_CALLBACK_PARAMS">
      <summary>
            The BLUETOOTH_AUTHENTICATION_CALLBACK_PARAMS structure contains specific configuration information about the Bluetooth device responding to an authentication request.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BLUETOOTH_AUTHENTICATION_CALLBACK_PARAMS.deviceInfo">
      <summary>
            A BLUETOOTH_DEVICE_INFO structure that contains information about a Bluetooth device.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BLUETOOTH_AUTHENTICATION_CALLBACK_PARAMS.authenticationMethod">
      <summary>
            A BLUETOOTH_AUTHENTICATION_METHOD enumeration that defines the authentication method utilized by the Bluetooth device.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BLUETOOTH_AUTHENTICATION_CALLBACK_PARAMS.ioCapability">
      <summary>
            A BLUETOOTH_IO_CAPABILITY enumeration that defines the input/output capabilities of the Bluetooth device.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BLUETOOTH_AUTHENTICATION_CALLBACK_PARAMS.authenticationRequirements">
      <summary>
            A AUTHENTICATION_REQUIREMENTS specifies the 'Man in the Middle' protection required for authentication.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BLUETOOTH_AUTHENTICATION_CALLBACK_PARAMS.Numeric_Value_Passkey">
      <summary>
            A ULONG value used for Numeric Comparison authentication.
            or
            A ULONG value used as the passkey used for authentication.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BLUETOOTH_PIN_INFO">
      <summary>
            The BLUETOOTH_PIN_INFO structure contains information used for authentication via PIN.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BLUETOOTH_OOB_DATA_INFO">
      <summary>
            The BLUETOOTH_OOB_DATA_INFO structure contains data used to authenticate prior to establishing an Out-of-Band device pairing.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BluetoothIoCapability">
      <summary>
            The BLUETOOTH_IO_CAPABILITY enumeration defines the input/output capabilities of a Bluetooth Device.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothIoCapability.DisplayOnly">
      <summary>
            The Bluetooth device is capable of output via display only.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothIoCapability.DisplayYesNo">
      <summary>
            The Bluetooth device is capable of output via a display, 
            and has the additional capability to presenting a yes/no question to the user.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothIoCapability.KeyboardOnly">
      <summary>
            The Bluetooth device is capable of input via keyboard.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothIoCapability.NoInputNoOutput">
      <summary>
            The Bluetooth device is not capable of input/output.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothIoCapability.Undefined">
      <summary>
            The input/output capabilities for the Bluetooth device are undefined.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BluetoothDeviceInfoProperties">
      <summary>
            Specifies properties of a remote Bluetooth Device.
            </summary>
            -
            -
            <remarks><para>Supported only by the Microsoft stack on desktop Windows.
            </para><para>Originally from Win32 "bthdef.h" and used by struct
            BTH_DEVICE_INFO.flags. The flags are named BDIF_**.
            </para></remarks></member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothDeviceInfoProperties.Address">
      <summary>
            The address member contains valid data.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothDeviceInfoProperties.Cod">
      <summary>
            The classOfDevice member contains valid data.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothDeviceInfoProperties.Name">
      <summary>
            The name member contains valid data.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothDeviceInfoProperties.Paired">
      <summary>
            The device is a remembered and authenticated device.
            The BDIF_PERSONAL flag is always set when this flag is set.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothDeviceInfoProperties.Personal">
      <summary>
            The device is a remembered device. If this flag is set and
            the BDIF_PAIRED flag is not set, the device is not authenticated.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothDeviceInfoProperties.Connected">
      <summary>
            The remote Bluetooth device is currently connected to the local radio.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothDeviceInfoProperties.Eir">
      <summary>
      </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothDeviceInfoProperties.BR">
      <summary>
            Bluetooth Basic Rate  i.e. traditional Bluetooth
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothDeviceInfoProperties.LE">
      <summary>
            Bluetooth Low Energy
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Widcomm.ISdpDiscoveryRecordsBuffer.RecordCount">
      <summary>
            Get the number of records that the buffer contains.
            </summary>
            -
            <value>An integer containing the number of records that the buffer contains,
            may be zero.
            </value>
            -
            <exception cref="T:System.InvalidOperationException">The buffer has 
            not yet been filled with a CSdpDiscoveryRec list.
            </exception>
            -
            <remarks><para>In <see cref="F:InTheHand.Net.Bluetooth.Widcomm.SdpSearchScope.ServiceClassOnly">SdpSearchScope.ServiceClassOnly</see>
            this returns the actual number of records as the filtering is done by
            the stack.  In <see cref="F:InTheHand.Net.Bluetooth.Widcomm.SdpSearchScope.Anywhere">SdpSearchScope.Anywhere</see>
            this returns the pre-filtered number of records.  We do the filtering
            so this will likely be greater that the matching number of records.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.Widcomm.SdpDiscoveryRecordsBuffer.RecordCount">
      <summary>
            Get the number of records that the buffer contains.
            </summary>
            -
            <value>An integer containing the number of records that the buffer contains,
            may be zero.
            </value>
            -
            <exception cref="T:System.InvalidOperationException">The buffer has 
            not yet been filled with a CSdpDiscoveryRec list.
            </exception>
            -
            <remarks><para>In <see cref="F:InTheHand.Net.Bluetooth.Widcomm.SdpSearchScope.ServiceClassOnly">SdpSearchScope.ServiceClassOnly</see>
            this returns the actual number of records as the filtering is done by
            the stack.  In <see cref="F:InTheHand.Net.Bluetooth.Widcomm.SdpSearchScope.Anywhere">SdpSearchScope.Anywhere</see>
            this returns the pre-filtered number of records.  We do the filtering
            so this will likely be greater that the matching number of records.
            </para></remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.Widcomm.IBtIf.SetParent(InTheHand.Net.Bluetooth.Widcomm.WidcommBtInterface)">
      <summary>
            To get to HandleDeviceResponded, HandleInquiryCompleted etc
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Widcomm.IBtIf.StartDiscovery(InTheHand.Net.BluetoothAddress,System.Guid)">
      <summary>
            This function requests a service discovery for a specific device.
            </summary>
            -
            <remarks><para>When the discovery is complete the derived function OnDiscoveryComplete() is called.
            </para></remarks>
            -
            <param name="address"></param><param name="serviceGuid"></param><returns>TRUE, if discovery has started; FALSE, if discovery has not started.</returns></member>
    <member name="M:InTheHand.Net.Bluetooth.Widcomm.IBtIf.GetLastDiscoveryResult(InTheHand.Net.BluetoothAddress@,System.UInt16@)">
      <summary>
            When multiple discovery operations are in progress, the application 
            must call GetLastDiscoveryResult() from within the OnDiscoveryComplete() 
            to determine which remote devices reported services.
            </summary>
      <param name="address">
      </param>
      <param name="p_num_recs">
      </param>
      <returns>DISCOVERY_RESULT_SUCCESS, if the discovery operation was successful.</returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Widcomm.IBtIf.ReadDiscoveryRecords(InTheHand.Net.BluetoothAddress,System.Int32,InTheHand.Net.Bluetooth.Widcomm.ServiceDiscoveryParams)">
      <summary>
            This function is called when discovery is complete to retrieve the records 
            received from the remote device.
            </summary>
            -
            <remarks><para>Discovery results for a device are not removed until the device fails to respond to an inquiry.
            </para></remarks>
            -
            <param name="address"></param><param name="maxRecords"></param><param name="args"></param><returns>The discovery records read, which may have recordCount equals zero.</returns></member>
    <member name="T:InTheHand.Net.Bluetooth.Factory.IBluetoothDeviceInfo">
      <exclude />
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo">
      <summary>
            Provides information about an available device obtained by the client during device discovery.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.#ctor(System.IntPtr)">
      <overloads>
            Initializes an instance of the <see cref="T:BluetoothDeviceInfo" /> class.
            </overloads>
            -
            <summary>
            Initializes an instance of the <see cref="T:BluetoothDeviceInfo" /> class with the given native structure.
            </summary></member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.#ctor(InTheHand.Net.BluetoothAddress)">
      <summary>
            Initializes an instance of the <see cref="T:BluetoothDeviceInfo" /> class 
            for the device with the given address.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.Refresh">
      <summary>
            Forces the system to refresh the device information.
            </summary>
            -
            <remarks>
            See <see cref="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.DeviceName" />
            for one reason why this method is necessary.
            </remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.Update">
      <summary>
            Updates the device name used to display the device, affects the local computer cache.
            </summary>
      <remarks>On Windows CE this only affects devices which are already paired.</remarks>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.SetServiceState(System.Guid,System.Boolean)">
      <summary>
             Enables or disables services for a Bluetooth device.
             </summary>
      <param name="service">The service GUID on the remote device.</param>
      <param name="state">Service state - TRUE to enable the service, FALSE to disable it.</param>
      <remarks>
             When called on Windows CE, the device will require a soft-reset to enabled the settings.
             
            <note><para>The system maintains a mapping of service guids to supported drivers for
             Bluetooth-enabled devices. Enabling a service installs the corresponding
             device driver. Disabling a service removes the corresponding device driver.
             If a non-supported service is enabled, a driver will not be installed.
             </para></note><para>This overload is silent on error; the other overload raises an exception
             if required
             (<see cref="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.SetServiceState(System.Guid,System.Boolean,System.Boolean)" />).
             </para></remarks>
             -
             <exception cref="T:System.PlatformNotSupportedException">
             Thrown if this method is called on Windows CE platforms.</exception></member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.SetServiceState(System.Guid,System.Boolean,System.Boolean)">
      <summary>
             Enables or disables services for a Bluetooth device.
             </summary>
      <param name="service">The service GUID on the remote device.</param>
      <param name="state">Service state - TRUE to enable the service, FALSE to disable it.</param>
      <param name="throwOnError">Whether the method should raise an exception
             when 
             </param>
      <remarks>
             When called on Windows CE, the device will require a soft-reset to enabled the settings.
            <note><para>The system maintains a mapping of service guids to supported drivers for
             Bluetooth-enabled devices. Enabling a service installs the corresponding
             device driver. Disabling a service removes the corresponding device driver.
             If a non-supported service is enabled, a driver will not be installed.
             </para></note></remarks>
             -
             <exception cref="T:System.ComponentModel.Win32Exception">The call failed.
             </exception></member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.GetServiceRecords(System.Guid)">
      <summary>
            Run an SDP query on the devices Service Discovery Database.
            </summary>
            -
            <remarks><para>
            For instance to see whether the device has an an Serial Port services
            search for UUID <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.SerialPort" />,
            or too find all the services that use RFCOMM use 
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.RFCommProtocol" />,
            or all the services use 
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.L2CapProtocol" />.
            </para><para>
            If the device isnt accessible a <see cref="T:System.Net.Sockets.SocketException" />
            with <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />
            10108 (0x277C) occurs.
            </para></remarks>
            -
            <param name="service">The UUID to search for, as a <see cref="T:System.Guid" />.
            </param>
            -
            <returns>The parsed record as an 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />.
            </returns>
            -
            <example><code lang="VB.NET">
            Dim bdi As BluetoothDeviceInfo = ...
            Dim records As ServiceRecord() = bdi.GetServiceRecords(BluetoothService.RFCommProtocol)
            ' Dump each to console
            For Each curRecord As ServiceRecord In records
               ServiceRecordUtilities.Dump(Console.Out, curRecord)
            Next
            </code></example>
            
            -
            <exception cref="T:System.Net.Sockets.SocketException">
            The query failed.
            </exception></member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.GetServiceRecordsUnparsed(System.Guid)">
      <summary>
            Run an SDP query on the devices Service Discovery Database,
            returning the raw byte rather than a parsed record.
            </summary>
            -
            <remarks>
            If the device isnt accessible a <see cref="T:System.Net.Sockets.SocketException" />
            with <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />
            10108 (0x277C) occurs.
            </remarks>
            -
            <param name="service">The UUID to search for, as a <see cref="T:System.Guid" />.
            </param>
            -
            <returns>An array of array of <see cref="T:System.Byte" />.</returns>
            -
            <exception cref="T:System.Net.Sockets.SocketException">
            The query failed.
            </exception></member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.GetServiceRecordsUnparsedWindowsRaw(System.Guid)">
      <summary>
            Returns the raw results from the native call(s); the format is different 
            on Win32 versus WinCE.
            </summary>
      <remarks>
            On CE this is thus a single item which is a ElementSequence of records.
            On Win32 it is an array with each item being a record.
            </remarks>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.ShowDialog">
      <summary>
            Displays information about the device.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.DeviceAddress">
      <summary>
            Gets the device identifier.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.DeviceName">
      <summary>
            Gets a name of a device.
            </summary>
            -
            <remarks><para>Note, that due the way in which Bluetooth device discovery works,
            the existence and address of a device is known first, but a separate
            query has to be carried out to find whether the device also has a name.
            This means that if a device is discovered afresh then this property might
            return only a text version of the devices address and not its
            name, one can also see this in the Windows Bluetooth device dialogs
            where the device appears first with its address and the name is later
            updated.  To see the name, wait for some time and access this property again
            having called <see cref="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.Refresh" />
            in the meantime.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.ClassOfDevice">
      <summary>
            Returns the Class of Device of the remote device.
            </summary>
            -
            <remarks><para>
            Some CE 4.2 devices such as original PPC2003 devices don't have the native 
            API on which this property depends  it was added as part of a hotfix. 
            The property will always return zero in such a case.  On WM/CE we also 
            attempt to get the CoD value as part of the discovery process; this is 
            of course only works for devices in-range.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.Rssi">
      <summary>
            Returns the signal strength for the Bluetooth connection with the peer device.
            <para><b>Requires Windows Mobile 5.0 or Windows Embedded CE 6.0</b></para></summary>
            -
            <value>Valid values for this property are -128 to 128.  It returns
            <see cref="F:System.Int32.MinValue">Int32.MinValue</see> on failure.
            </value>
            -
            <remarks><para>This method requires an open connection to the peer device.
            If there is no active connection, then it will attempt to create one.
            </para><note type="caution">Requires Windows Mobile 5.0 or Windows Embedded CE 6.0</note><para>As well as the no connection issue, the native method
            on which the property depends is only present in later OS versions, so it 
            will fail on earlier devices.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.InstalledServices">
      <summary>
            Returns a list of services which are already installed for use on the calling machine.
            </summary>
      <remarks>
        <para>This property returns the services already configured for use. 
            Those are the ones that are checked in the Services tab
            of the devices property sheet in the Bluetooth Control panel.
            I presume the behaviour is similar on CE.
            </para>
        <para>Will only return available services for paired devices.
            </para>
        <para>It of course will also only returns standard system services which Windows understands.
            (On desktop Windows this method calls the OS function <c>BluetoothEnumerateInstalledServices</c>).
            </para>
        <para>To see all the services that a device advertises use the 
            <see cref="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.GetServiceRecords(System.Guid)" />
            method.
            </para>
      </remarks>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.Connected">
      <summary>
            Specifies whether the device is connected.
            </summary>
      <remarks>Not supported under Windows CE and will always return false.</remarks>
      <seealso cref="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.Remembered" />
      <seealso cref="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.Authenticated" />
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.Remembered">
      <summary>
            Specifies whether the device is a remembered device. Not all remembered devices are authenticated.
            </summary>
            -
            <remarks>Now supported under Windows CE  will return the same as 
            <see cref="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.Authenticated" />.
            </remarks><seealso cref="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.Connected" /><seealso cref="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.Authenticated" /></member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.Authenticated">
      <summary>
            Specifies whether the device is authenticated, paired, or bonded. All authenticated devices are remembered.
            </summary>
      <remarks>Is now supported on both CE and XP.</remarks>
      <seealso cref="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.Connected" />
      <seealso cref="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothDeviceInfo.Remembered" />
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Factory.IBluetoothClient">
      <exclude />
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Factory.DiscoDevsParams">
      <exclude />
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream">
      <exclude />
      <summary>
      </summary>
            -
            <remarks><para>Sub-class must call various methods at the following events:
            <list type="bullet"><item><term>open</term><description><see cref="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.HandleCONNECTED(System.String)" />
            or <see cref="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.HandleCONNECT_ERR(System.String,System.Nullable{System.Int32})" /> on failure</description></item><item><term>close</term><description><see cref="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.HandleCONNECT_ERR(System.String,System.Nullable{System.Int32})" /></description></item><item><term>data arrival</term><description><see cref="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.HandlePortReceive(System.Byte[])" /></description></item><item><term>flow control off</term><description><see cref="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.FreePendingWrites" /></description></item></list></para></remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.EnsureOpenForWrite">
      <summary>
            Fails if state is not Connected.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.EnsureOpenForRead">
      <summary>
            Fails if state is not Connected or PeerDidClose.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.RemovePortRecords">
      <summary>
        <see cref="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.DoPortClose(System.Boolean)" />
      </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.DoOtherPreDestroy(System.Boolean)">
      <summary>
        <see cref="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.DoPortClose(System.Boolean)" />
      </summary>
      <param name="disposing">Disposing</param>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.DoPortClose(System.Boolean)">
      <summary>
            Called from CloseInternal and Dispose;
            RemovePortRecords is called before from both places.
            Dispose then calls DoOtherPreDestroy and DoPortDestroy in that order.
            </summary>
      <param name="disposing">Disposing</param>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.DoPortDestroy(System.Boolean)">
      <summary>
        <see cref="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.DoPortClose(System.Boolean)" />
      </summary>
      <param name="disposing">Disposing</param>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.DoOtherSetup(InTheHand.Net.BluetoothEndPoint,System.Int32)">
      <summary>
            Called before DoOpenClient.
            For instance is empty on BTPS, on Widcomm it calls SetScnForPeerServer and SetSecurityLevelClient.
            </summary>
      <param name="bep">Endpoint</param>
      <param name="scn">Channel number</param>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.DoOpenClient(System.Int32,InTheHand.Net.BluetoothAddress)">
      <summary>
            Starts the connect process.  The async completion should call
            either <see cref="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.HandleCONNECTED(System.String)" /> or <see cref="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.HandleCONNECT_ERR(System.String,System.Nullable{System.Int32})" />.
            </summary>
      <param name="scn">scn</param>
      <param name="addressToConnect">addr</param>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.HandleCONNECTED(System.String)">
      <summary>
            Call when connection is successfully made.
            </summary>
      <param name="eventIdToString">Used for logging etc.  Pass a string
            containing the name of the stack's event/status that occurred.
            </param>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.DoIsConnected(InTheHand.Net.BluetoothAddress@)">
      <summary>
            Get the remote address.
            </summary>
            -
            <param name="p_remote_bdaddr">On return contains the address to which we are connected.
            </param>
            -
            <returns><see langword="true" /> if connected, but we ignore the result.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.HandleCONNECT_ERR(System.String,System.Nullable{System.Int32})">
      <summary>
            Call when connection is un-successfully made (fails),
            and also when the connection closes.
            </summary>
      <param name="eventIdToString">Used for logging etc.  Pass a string
            containing the name of the stack's event/status that occurred.
            </param>
      <param name="socketErrorCode">The socket error code for this failure
            -- known.
            Pass for instance a value from <see cref="T:System.Net.Sockets.SocketError" />
            as an <see cref="T:System.Int32" />;
            or <see langword="null" /> respectively.
            </param>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.CloseInternal(InTheHand.Net.AsyncResult{System.Int32,InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.BeginReadParameters}[]@,InTheHand.Net.AsyncNoResult{InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.BeginReadParameters}[]@)">
      <summary>
            Used: 1. when we get CONNECT_ERR from the stack, and POSSIBLY 2. when we close the 
            stream to do consumer timeout (SO_RCVTIMEO/etc).
            </summary>
      <param name="allRead">Out: to call <see cref="M:InTheHand.Net.Bluetooth.Widcomm.WidcommRfcommStream.AbortIf(System.Collections.Generic.IList{InTheHand.Net.AsyncResult{System.Int32,InTheHand.Net.Bluetooth.Widcomm.WidcommRfcommStream.BeginReadParameters}}, System.Collections.Generic.IList{InTheHand.Net.AsyncNoResult{InTheHand.Net.Bluetooth.Widcomm.WidcommRfcommStream.BeginReadParameters}})" />
            on.</param>
      <param name="allWrite">Out: to call <see cref="M:InTheHand.Net.Bluetooth.Widcomm.WidcommRfcommStream.AbortIf(System.Collections.Generic.IList{InTheHand.Net.AsyncResult{System.Int32,InTheHand.Net.Bluetooth.Widcomm.WidcommRfcommStream.BeginReadParameters}}, System.Collections.Generic.IList{InTheHand.Net.AsyncNoResult{InTheHand.Net.Bluetooth.Widcomm.WidcommRfcommStream.BeginReadParameters}})" />
            on.</param>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.CloseInternalAndAbort_willLock">
      <summary>
            Close the connection from the network/stack side (not from the consumer side).
            </summary>
            -
            <remarks><para>When we call Close the object is disposed and outstanding and
            new operations fail with ObjectDisposedException.  This method
            instead closes the connection from the network/stack side and thus
            operations fail with an IO error etc.
            </para></remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.TryBondingIf_inLock(InTheHand.Net.BluetoothAddress,System.Int32,System.Exception@)">
      <summary>
            DEPRECATED, should return false.
            </summary>
      <returns>Whether Bonding was attempted and thus the connect should be retried.
            </returns>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Factory.CommonRfcommStream.Connected">
      <summary>
            Used by Client, note from MSDN Socket.Connected:
            "Gets a value that indicates whether a Socket is connected to a remote host as of the last Send or Receive operation."
            </summary>
            -
            <remarks><para>From MSDN <see cref="P:System.Net.Sockets.Socket.Connected" />:
            "Gets a value that indicates whether a Socket is connected to a remote host as of the last Send or Receive operation."
            From MSDN <see cref="P:System.Net.Sockets.TcpClient.Connected" />:
            "true if the Client socket was connected to a remote resource as of the most recent operation; otherwise, false."
            </para></remarks></member>
    <member name="T:InTheHand.Net.BluetoothEndPoint">
      <summary>
            Represents a network endpoint as a Bluetooth address and 
            a Service Class Id and/or a port number.
            </summary>
            -
            <remarks><para>The BluetoothEndPoint class contains the host, service class id and port 
            information needed by an application to connect to a service on a host.
            By combining the host's Bluetooth address and class id or port number, 
            the BluetoothEndPoint class forms a connection point to a service.
            </para><para>When used for instance when connecting with <see cref="T:InTheHand.Net.Sockets.BluetoothClient" />, 
            if the port is specified then the connection is made to that port, 
            otherwise a SDP lookup is done for a record with the class specified in 
            the <see cref="P:InTheHand.Net.BluetoothEndPoint.Service" /> property.
            </para></remarks></member>
    <member name="F:InTheHand.Net.BluetoothEndPoint.MinPort">
      <summary>
            Specifies the minimum value that can be assigned to the Port property.
            </summary>
    </member>
    <member name="F:InTheHand.Net.BluetoothEndPoint.MaxPort">
      <summary>
            Specifies the maximum value that can be assigned to the Port property.
            </summary>
    </member>
    <member name="F:InTheHand.Net.BluetoothEndPoint.MinScn">
      <summary>
            The minimum valid Server Channel Number, 1.
            </summary>
      <remarks>
        <para>
            Bluetooth's rfcomm.pdf: Part F:1 -- RFCOMM with TS 07.10 -- Serial Port Emulation
            </para>
        <para>
            Section 5.4:
            </para>
        <list type="table">
               The RFCOMM server channel number is a [five-bit field].
               Server applications registering with an RFCOMM service interface are assigned a
               Server Channel number in the range 130. [0 and 31 should not be used since
               the corresponding DLCIs are reserved in TS 07.10]
            </list>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.BluetoothEndPoint.MaxScn">
      <summary>
            The maximum valid Server Channel Number, 30.
            </summary>
      <remarks>
        <see cref="F:InTheHand.Net.BluetoothEndPoint.MinScn" />
      </remarks>
    </member>
    <member name="M:InTheHand.Net.BluetoothEndPoint.#ctor(InTheHand.Net.BluetoothAddress,System.Guid)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.BluetoothEndPoint" /> class with the specified address and service.
            </summary>
      <param name="address">The Bluetooth address of the device. A six byte array.</param>
      <param name="service">The Bluetooth service to use.</param>
    </member>
    <member name="M:InTheHand.Net.BluetoothEndPoint.#ctor(InTheHand.Net.BluetoothAddress,System.Guid,System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.BluetoothEndPoint" /> class with the specified address, service and port number.
            </summary>
      <param name="address">The Bluetooth address of the device. A six byte array.</param>
      <param name="service">The Bluetooth service to use.</param>
      <param name="port">Radio channel to use, -1 for any.</param>
            -
            <remarks><para>See the <see cref="T:InTheHand.Net.BluetoothEndPoint" /> documentation for 
            how the combination of Service and Port are used when connecting with 
            BluetoothClient.
            </para></remarks></member>
    <member name="M:InTheHand.Net.BluetoothEndPoint.Serialize">
      <summary>
            Serializes endpoint information into a <see cref="T:System.Net.SocketAddress" /> instance.
            </summary>
      <returns>A <see cref="T:System.Net.SocketAddress" /> instance containing the socket address for the endpoint.</returns>
    </member>
    <member name="M:InTheHand.Net.BluetoothEndPoint.Create(System.Net.SocketAddress)">
      <summary>
            Creates an endpoint from a socket address.
            </summary>
      <param name="socketAddress">The <see cref="T:System.Net.SocketAddress" /> to use for the endpoint.</param>
      <returns>An <see cref="T:System.Net.EndPoint" /> instance using the specified socket address.</returns>
    </member>
    <member name="M:InTheHand.Net.BluetoothEndPoint.Equals(System.Object)">
      <summary>
            Compares two <see cref="T:InTheHand.Net.BluetoothEndPoint" /> instances for equality.
            </summary>
            -
            <param name="obj">The <see cref="T:InTheHand.Net.BluetoothEndPoint" />
            to compare with the current instance.
            </param>
            -
            <returns><c>true</c> if <paramref name="obj" />
            is a <see cref="T:InTheHand.Net.BluetoothEndPoint" /> and equal to the current instance;
            otherwise, <c>false</c>.
            </returns></member>
    <member name="M:InTheHand.Net.BluetoothEndPoint.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
      <returns>A hash code for the current object.</returns>
    </member>
    <member name="M:InTheHand.Net.BluetoothEndPoint.ToString">
      <summary>
            Returns the string representation of the BluetoothEndPoint.
            </summary>
      <remarks>
        <para>
            We try to follow existing examples where possible; JSR-82 and similar
            use a URI of the form:</para>
        <code lang="none">bluetooth://xxxxxxxxxxxx:xx</code>
            or:
            <code lang="none">bluetooth://xxxxxxxxxxxx:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx</code>
            or in some serialport only situations:
            <code lang="none">btspp://</code><para>So we follow that pattern here, but of course without the URI prefix.
            If the form with the URI is required then the prefix can simply be appended.</para><para>
            If the port is non default then we use that, otherwise just the full guid.
            </para><para>Some examples are:</para>
            To the ObexObjectPush service:
            <code lang="none">"04E2030405F6:0000110500001000800000805f9b34fb"</code>
            To the SerialPort service:
            <code lang="none">"04E2030405F6:0000110100001000800000805f9b34fb"</code>
            With an Empty service GUID:
            <code lang="none">"04E2030405F6:00000000000000000000000000000000"</code>
            With port 9:
            <code lang="none">"04E2030405F6:9"</code></remarks>
      <returns>The string representation of the BluetoothEndPoint.</returns>
    </member>
    <member name="M:InTheHand.Net.BluetoothEndPoint.Clone">
      <summary>
            Creates a copy of the <see cref="T:InTheHand.Net.BluetoothEndPoint" />.
            </summary>
      <remarks>Creates a copy including of the internal <see cref="T:InTheHand.Net.BluetoothAddress" /></remarks>
      <returns>A copy of the <see cref="T:InTheHand.Net.BluetoothEndPoint" />.
            </returns>
    </member>
    <member name="P:InTheHand.Net.BluetoothEndPoint.AddressFamily">
      <summary>
            Gets the address family of the Bluetooth address. 
            </summary>
    </member>
    <member name="P:InTheHand.Net.BluetoothEndPoint.Address">
      <summary>
            Gets or sets the Bluetooth address of the endpoint.
            </summary>
      <seealso cref="T:InTheHand.Net.BluetoothAddress" />
    </member>
    <member name="P:InTheHand.Net.BluetoothEndPoint.Service">
      <summary>
            Gets or sets the Bluetooth service to use for the connection.
            </summary>
      <seealso cref="T:InTheHand.Net.Bluetooth.BluetoothService" />
    </member>
    <member name="P:InTheHand.Net.BluetoothEndPoint.Port">
      <summary>
            Gets or sets the service channel number of the endpoint.
            </summary>
    </member>
    <member name="P:InTheHand.Net.BluetoothEndPoint.HasPort">
      <summary>
            Gets whether a <see cref="P:InTheHand.Net.BluetoothEndPoint.Port" /> is set.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.ElementTypeDescriptor">
      <summary>
            Represents the type of the element in the SDP record binary format, 
            and is stored as the higher 5 bits of the header byte.
            </summary>
      <remarks>
            There is an identifier for each major type: String vs UUID vs unsigned integer.
            There are various sizes of UUID and integer type for instance, the resultant
            types are listed in enum <see cref="T:InTheHand.Net.Bluetooth.ElementType" />.
            </remarks>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.SizeIndex">
      <summary>
            Represents the size of the SDP element in the record binary format,
            and is stored as the lower 3 bits of the header byte.
            </summary>
      <seealso cref="M:InTheHand.Net.Bluetooth.ServiceRecordParser.SplitHeaderByte(System.Byte,InTheHand.Net.Bluetooth.ElementTypeDescriptor@,InTheHand.Net.Bluetooth.SizeIndex@)" />
      <seealso cref="M:InTheHand.Net.Bluetooth.ServiceRecordParser.GetSizeIndex(System.Byte)" />
    </member>
    <member name="T:InTheHand.Net.Bluetooth.ElementType">
      <summary>
            Represents the types that an SDP element can hold.
            </summary>
      <remarks>
        <para>
            (Is a logical combination of the <see cref="T:InTheHand.Net.Bluetooth.ElementTypeDescriptor" />
            field which defines the major type and the size field in the binary format; and
            the size field being made up of the <see cref="T:InTheHand.Net.Bluetooth.SizeIndex" />
            field and any additional length bytes.
            </para>
        <para>Note, the values here are not the numerical bitwise combination of the 
            <see cref="T:InTheHand.Net.Bluetooth.ElementTypeDescriptor" /> and 
            <see cref="T:InTheHand.Net.Bluetooth.SizeIndex" /> fields as they appear 
            in the encoded protocol.  It was simpler to assign arbitrary values here as 
            firstly we wanted zero to be the 'Unknown' value, which conflicts with Nil's
            bitwise value; but also because the TextString, sequence and Url types can 
            have various SizeIndex values and thus they wouldnt be easily 
            representable by one value here).
            </para>
      </remarks>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Factory.CommonDiscoveryBluetoothClient">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.CommonDiscoveryBluetoothClient.ConvertBthInquiryParams(System.Int32,System.TimeSpan,System.Byte@,System.Byte@)">
      <summary>
            Convert the user Inquiry parameters to the formats used by HCI.
            </summary>
      <param name="maxDevices">The <c>maxDevices</c> parameter from e.g.
            <see cref="M:InTheHand.Net.Sockets.BluetoothClient.DiscoverDevices(System.Int32,System.Bool,System.Bool,System.Bool,System.Bool)" />.
            </param>
      <param name="inquiryLength">The <see cref="P:InTheHand.Net.Sockets.BluetoothClient.InquiryLength" /> property
            <see cref="T:InTheHand.Net.Sockets.BluetoothClient" />.
            </param>
      <param name="hciMaxResponses">On return contains the Num_Responses value to be passed to the HCI Inquiry command.
            If greater that 255 or less than zero, the value 0 will be returned.
            HCI uses zero as "Unlimited".
            </param>
      <param name="hciInquiryLength">On return contains the Inquiry_Length value to be passed to the HCI Inquiry command.
            Is scaled by the divisor 1.28secs
            and if not in range 1 to 0x30 inclusive is set to 10.
            </param>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Factory.CommonBluetoothClient">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.CommonBluetoothClient.BeginServiceDiscovery(InTheHand.Net.BluetoothAddress,System.Guid,System.AsyncCallback,System.Object)">
      <summary>
            When overidden, initiates 
            lookup the SDP record with the give Service Class Id
            to find the RFCOMM port number (SCN) that the server is listening on.
            The process returns a list of port numbers.
            </summary>
      <param name="address">The remote device.
            </param>
      <param name="serviceGuid">The Service Class Id.
            </param>
      <param name="asyncCallback">callback</param>
      <param name="state">state</param>
      <returns>IAsyncResult</returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.CommonBluetoothClient.EndServiceDiscovery(System.IAsyncResult)">
      <summary>
            When overidden, 
            completes the SDP Record to port number lookup process
            </summary>
            -
            <param name="ar">IAsyncResult from <see cref="M:InTheHand.Net.Bluetooth.Factory.CommonBluetoothClient.BeginServiceDiscovery(InTheHand.Net.BluetoothAddress,System.Guid,System.AsyncCallback,System.Object)" />.
            </param>
            -
            <remarks><para>There must be at least one entry in the result list for each
            Service Record found for the specified Service Class Id.  This
            allows us to know if no records were found, or that records were
            found but none of them were for RFCOMM.
            If a particular record does not have a RFCOMM port then -1 (negative
            one should be added to the list for it).
            </para><para>The process may throw an exception if an error occurs, e.g.
            the remote device did not respond.
            </para></remarks>
            -
            <returns>A <see cref="T:System.Collections.Generic.List{System.Int32}" />
            with at least one entry for each Service Record
            found for the specified Service Class Id, the item being -1 if the
            record has no port. is .
            </returns></member>
    <member name="T:InTheHand.Net.Bluetooth.Widcomm.WidcommBluetoothClient">
      <summary>
            Provides client connections for Bluetooth network services with Widcomm stack.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Widcomm.WidcommBluetoothClient.#ctor(InTheHand.Net.Bluetooth.Widcomm.WidcommRfcommStreamBase,InTheHand.Net.Bluetooth.Widcomm.WidcommBluetoothFactoryBase)">
      <summary>
            Used by WidcommBluetoothListener to return the newly accepted connection.
            </summary>
            -
            <param name="strm">The WidcommRfcommStream containing the newly connected 
            RfCommPort.
            </param><param name="factory">Factory to use in GetRemoteMachineName etc.
            </param></member>
    <member name="P:InTheHand.Net.Bluetooth.Widcomm.WidcommBluetoothClient.ReadKnownDeviceFromTheRegistry">
      <summary>
            ... Allow the tests to disable the Registry lookup.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Factory.BluetoothFactory">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.BluetoothFactory.GetTheFactoryOfTypeOrDefault``1">
      <summary>
            PRE-RELEASE
            Get the instance of the given factory type -- if it exists.
            </summary>
            -
            <typeparam name="TFactory">The factory type e.g.
            <see cref="T:InTheHand.Net.Bluetooth.SocketsBluetoothFactory" />
            or <see cref="T:InTheHand.Net.Bluetooth.Widcomm.WidcommBluetoothFactoryBase" />
            etc.
            </typeparam>
            -
            <returns>The instance of the given type or <c>null</c>.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.BluetoothFactory.GetTheFactoryOfTypeOrDefault(System.Type)">
      <summary>
            PRE-RELEASE
            Get the instance of the given factory type -- if it exists.
            </summary>
            -
            <param name="factoryType">The factory type e.g.
            <see cref="T:InTheHand.Net.Bluetooth.SocketsBluetoothFactory" />
            or <see cref="T:InTheHand.Net.Bluetooth.Widcomm.WidcommBluetoothFactoryBase" />
            etc.
            </param>
            -
            <returns>The instance of the given type or <c>null</c>.
            </returns></member>
    <member name="T:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog">
      <summary>
            Provides a form to select an available Bluetooth device.
            </summary>
    </member>
    <member name="M:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog.#ctor">
      <summary>
            Initializes an instance of the <see cref="T:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog" /> class.
            </summary>
    </member>
    <member name="M:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog.Reset">
      <summary>
            Resets the properties of the <see cref="T:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog" /> to their default values.
            </summary>
    </member>
    <member name="M:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog.ShowCustomDialog">
      <summary>
      </summary>
      <returns>
      </returns>
    </member>
    <member name="M:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog.RunDialog(System.IntPtr)">
      <summary>
            Specifies a common dialog box.
            </summary>
      <param name="hwndOwner">A value that represents the window handle of the owner window for the common dialog box.</param>
      <returns>true if the dialog box was successfully run; otherwise, false.</returns>
    </member>
    <member name="M:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog.Dispose(System.Boolean)">
      <exclude />
    </member>
    <member name="P:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog.AddNewDeviceWizard">
      <summary>
            If TRUE, invokes the Add New Device Wizard.
            </summary>
      <remarks>Supported only on Windows XP/Vista with Microsoft stack.</remarks>
    </member>
    <member name="P:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog.SkipServicesPage">
      <summary>
            If TRUE, skips the Services page in the Add New Device Wizard.
            </summary>
      <remarks>Supported only on Windows XP/Vista with Microsoft stack.</remarks>
    </member>
    <member name="P:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog.Info">
      <summary>
            Gets or sets the information text.
            </summary>
      <remarks>
      </remarks>
    </member>
    <member name="P:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog.ClassOfDevices">
      <summary>
            Array of class of devices to find.
            </summary>
      <remarks>Clear the collection to return all devices.</remarks>
    </member>
    <member name="P:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog.SelectedDevice">
      <summary>
            Gets the selected Bluetooth device.
            </summary>
    </member>
    <member name="P:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog.ShowAuthenticated">
      <summary>
            If TRUE, authenticated devices are shown in the picker.
            </summary>
    </member>
    <member name="P:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog.ShowRemembered">
      <summary>
            If TRUE, remembered devices are shown in the picker.
            </summary>
    </member>
    <member name="P:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog.ShowUnknown">
      <summary>
            If TRUE, unknown devices are shown in the picker.
            </summary>
    </member>
    <member name="P:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog.ForceAuthentication">
      <summary>
            If TRUE, forces authentication before returning.
            </summary>
      <remarks>
      </remarks>
    </member>
    <member name="P:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog.ShowDiscoverableOnly">
      <summary>
            If TRUE, only devices which are currently discoverable are shown in the picker.
            </summary>
      <remarks>
        <note>Does <strong>not</strong> work on the Microsoft stack on desktop Windows.
            There, when true the dialog will not open and will return an error to the caller.
            </note>
      </remarks>
    </member>
    <member name="P:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog.DiscoverableOnly">
      <summary>
            Obsolete, use <see cref="P:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog.ShowDiscoverableOnly" />
            instead.
            If TRUE, only devices which are currently discoverable are shown in the picker.
            </summary>
      <remarks>
        <para>Obsolete, use <see cref="P:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog.ShowDiscoverableOnly" />
            instead.
            </para>
      </remarks>
      <seealso cref="P:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog.ShowDiscoverableOnly" />
    </member>
    <member name="P:InTheHand.Windows.Forms.SelectBluetoothDeviceDialog.DeviceFilter">
      <summary>
             Set a function that will be called for each device
             that returns whether to include the device in the list or not.
             </summary>
             -
             <value>The function to call for each device.
             The function should returns <c>true</c> if the device is to be included or <c>false</c> if not.
             Pass <c>null</c> to the property to clear the filter function.
             </value>
             -
             <remarks><para>The callback method is called for each device as it is 
             being added to the dialog box.  If the function returns <c>false</c> it 
             won't be added, otherwise it will be added and displayed. The 
             information about each device is provided as a <see cref="T:InTheHand.Net.Sockets.BluetoothDeviceInfo" />
             instance which will contain all the information about the device 
             that the discovery process knows and will also include any 
             information from the remembered/authenticated/paired devices. 
             Note that prior to Bluetooth v2.1 a separate query has to be 
             carried out to find whether the device also has a name, so unless 
             both devices are v2.1 or later then it's likely that the 
             name won't be included in the first discovery. 
             <see href="http://32feet.codeplex.com/wikipage?title=DeviceName%20and%20Discovery" /></para></remarks>
             -
             <example>
                 '......
                 Dim dlg As New InTheHand.Windows.Forms.SelectBluetoothDeviceDialog()
                 dlg.DeviceFilter = AddressOf FilterDevice
                 Dim rslt As DialogResult = dlg.ShowDialog()
                 '...... 
            
             Shared Function FilterDevice(ByVal dev As BluetoothDeviceInfo) As Boolean
                 Dim rslt As DialogResult = MessageBox.Show("Include this device " &amp; dev.DeviceAddress.ToString &amp; " " &amp; dev.DeviceName, "FilterDevice", MessageBoxButtons.YesNo)
                 Dim ret As Boolean = (DialogResult.Yes = rslt)
                 Return ret
             End Function
             </example></member>
    <member name="T:InTheHand.Net.BluetoothAddress">
      <summary>
            Represents a Bluetooth device address.
            </summary>
      <remarks>The BluetoothAddress class contains the address of a bluetooth device.</remarks>
    </member>
    <member name="F:InTheHand.Net.BluetoothAddress.IacFirst">
      <summary>
      </summary>
    </member>
    <member name="F:InTheHand.Net.BluetoothAddress.IacLast">
      <summary>
      </summary>
    </member>
    <member name="F:InTheHand.Net.BluetoothAddress.Liac">
      <summary>
            Limited Inquiry Access Code.
            </summary>
    </member>
    <member name="F:InTheHand.Net.BluetoothAddress.Giac">
      <summary>
            General Inquire Access Code.
            The default inquiry code which is used to discover all devices in range.
            </summary>
    </member>
    <member name="F:InTheHand.Net.BluetoothAddress.None">
      <summary>
            Provides a null Bluetooth address.
            </summary>
    </member>
    <member name="M:InTheHand.Net.BluetoothAddress.#ctor(System.Int64)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.BluetoothAddress" /> class with the specified address.
            </summary>
      <param name="address">
        <see cref="T:System.Int64" /> representation of the address.</param>
    </member>
    <member name="M:InTheHand.Net.BluetoothAddress.#ctor(System.Byte[])">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.BluetoothAddress" /> class with the specified address.
            </summary>
            -
            <remarks><para>Note: The address should be supplied in little-endian order on the
            current Windows platform (which is little-endian).
            For forward compatibility it would be safer to use the 
            <see cref="M:InTheHand.Net.BluetoothAddress.Parse(System.String)" /> method, 
            which will be correct for all platforms.
            Or consider
            <see cref="M:InTheHand.Net.BluetoothAddress.CreateFromLittleEndian(System.Byte[])" />
            or 
            <see cref="M:InTheHand.Net.BluetoothAddress.CreateFromBigEndian(System.Byte[])" />.
            
            </para></remarks>
            -
            <param name="address">Address as 6 byte array.</param><exception cref="T:System.ArgumentNullException">address passed was <see langword="null" />.</exception><exception cref="T:System.ArgumentException">address passed was not a 6 byte array.</exception></member>
    <member name="M:InTheHand.Net.BluetoothAddress.CreateFromBigEndian(System.Byte[])">
      <summary>
            Create a <see cref="T:InTheHand.Net.BluetoothAddress" /> from an Array of <see cref="T:System.Byte" />
            where the array is in standard order.
            </summary>
            -
            <remarks><para>Different protocol stacks have different ways of storing a
            Bluetooth Address.   Some use an array of bytes e.g. "byte[6]",
            which means that the first byte of the address comes first in
            memory (which well call big-endian format).  Others
            e.g. the Microsoft stack use a long integer (e.g. uint64) which
            means that the *last* byte of the address come comes first in
            memory (which well call little-endian format)
            </para><para>This method creates an address for the first form.
            See <see cref="M:InTheHand.Net.BluetoothAddress.CreateFromLittleEndian(System.Byte[])" /> for the second form.
            </para></remarks>
            -
            <param name="address">An Array of <see cref="T:System.Byte" />
            with the Bluetooth Address ordered as described above.
            </param>
            -
            <returns>The resultant <see cref="T:InTheHand.Net.BluetoothAddress" />.
            </returns>
            -
            <seealso cref="M:InTheHand.Net.BluetoothAddress.CreateFromLittleEndian(System.Byte[])" /></member>
    <member name="M:InTheHand.Net.BluetoothAddress.CreateFromLittleEndian(System.Byte[])">
      <summary>
            Create a <see cref="T:InTheHand.Net.BluetoothAddress" /> from an Array of <see cref="T:System.Byte" />
            where the array is in reverse order.
            </summary>
            -
            <remarks><para>Different protocol stacks have different ways of storing a
            Bluetooth Address.   Some use an array of bytes e.g. "byte[6]",
            which means that the first byte of the address comes first in
            memory (which well call big-endian format).  Others
            e.g. the Microsoft stack use a long integer (e.g. uint64) which
            means that the *last* byte of the address come comes first in
            memory (which well call little-endian format)
            </para><para>This method creates an address for the second form.
            See <see cref="M:InTheHand.Net.BluetoothAddress.CreateFromLittleEndian(System.Byte[])" /> for the first form.
            </para></remarks>
            -
            <param name="address">An Array of <see cref="T:System.Byte" />
            with the Bluetooth Address ordered as described above.
            </param>
            -
            <returns>The resultant <see cref="T:InTheHand.Net.BluetoothAddress" />.
            </returns>
            -
            <seealso cref="M:InTheHand.Net.BluetoothAddress.CreateFromBigEndian(System.Byte[])" /></member>
    <member name="M:InTheHand.Net.BluetoothAddress.TryParse(System.String,InTheHand.Net.BluetoothAddress@)">
      <summary>
            Converts the string representation of an address to it's <see cref="T:InTheHand.Net.BluetoothAddress" /> equivalent.
            A return value indicates whether the operation succeeded.
            </summary>
      <param name="bluetoothString">A string containing an address to convert.</param>
      <param name="result">When this method returns, contains the <see cref="T:InTheHand.Net.BluetoothAddress" /> equivalent to the address contained in s, if the conversion succeeded, or null (Nothing in Visual Basic) if the conversion failed.
            The conversion fails if the s parameter is null or is not of the correct format.</param>
      <returns>true if s is a valid Bluetooth address; otherwise, false.</returns>
    </member>
    <member name="M:InTheHand.Net.BluetoothAddress.Parse(System.String)">
      <summary>
            Converts the string representation of a Bluetooth address to a new <see cref="T:InTheHand.Net.BluetoothAddress" /> instance.
            </summary>
      <param name="bluetoothString">A string containing an address to convert.</param>
      <returns>New <see cref="T:InTheHand.Net.BluetoothAddress" /> instance.</returns>
      <remarks>Address must be specified in hex format optionally separated by the colon or period character e.g. 000000000000, 00:00:00:00:00:00 or 00.00.00.00.00.00.</remarks>
      <exception cref="T:System.ArgumentNullException">bluetoothString is null.</exception>
      <exception cref="T:System.FormatException">bluetoothString is not a valid Bluetooth address.</exception>
    </member>
    <member name="M:InTheHand.Net.BluetoothAddress.ToByteArray">
      <summary>
            Returns the value as a byte array.
            </summary>
            -
            <remarks>In previous versions this returned the internal array, it now
            returns a copy.  Addresses should be immutable, particularly for the
            None const!
            </remarks>
            -
            <returns>An array of byte</returns></member>
    <member name="M:InTheHand.Net.BluetoothAddress.ToByteArrayLittleEndian">
      <summary>
            Returns the value as a byte array,
            where the array is in reverse order.
            </summary>
            -
            <remarks><para>See <see cref="M:InTheHand.Net.BluetoothAddress.CreateFromBigEndian(System.Byte[])" /> for discussion of
            different stack#x2019;s storage formats for Bluetooth Addresses.
            </para><para>In previous versions this returned the internal array, it now
            returns a copy.  Addresses should be immutable, particularly for the
            None const!
            </para></remarks>
            -
            <returns>An array of byte of length six representing the Bluetooth address.</returns></member>
    <member name="M:InTheHand.Net.BluetoothAddress.ToByteArrayBigEndian">
      <summary>
            Returns the value as a byte array,
            where the array is in standard order.
            </summary>
            -
            <remarks><para>See <see cref="M:InTheHand.Net.BluetoothAddress.CreateFromBigEndian(System.Byte[])" /> for discussion of
            different stack#x2019;s storage formats for Bluetooth Addresses.
            </para><para>In previous versions this returned the internal array, it now
            returns a copy.  Addresses should be immutable, particularly for the
            None const!
            </para></remarks>
            -
            <returns>An array of byte of length six representing the Bluetooth address.</returns></member>
    <member name="M:InTheHand.Net.BluetoothAddress.ToInt64">
      <summary>
            Returns the Bluetooth address as a long integer.
            </summary>
            -
            <returns>An <see cref="T:System.Int64" />.</returns></member>
    <member name="M:InTheHand.Net.BluetoothAddress.Equals(System.Object)">
      <summary>
            Compares two <see cref="T:InTheHand.Net.BluetoothAddress" /> instances for equality.
            </summary>
            -
            <param name="obj">The <see cref="T:InTheHand.Net.BluetoothAddress" />
            to compare with the current instance.
            </param>
            -
            <returns><c>true</c> if <paramref name="obj" />
            is a <see cref="T:InTheHand.Net.BluetoothAddress" /> and equal to the current instance;
            otherwise, <c>false</c>.
            </returns></member>
    <member name="M:InTheHand.Net.BluetoothAddress.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
      <returns>A hash code for the current object.</returns>
    </member>
    <member name="M:InTheHand.Net.BluetoothAddress.op_Equality(InTheHand.Net.BluetoothAddress,InTheHand.Net.BluetoothAddress)">
      <summary>
            Returns an indication whether the values of two specified <see cref="T:InTheHand.Net.BluetoothAddress" /> objects are equal.<para><b>New in v1.5</b></para></summary>
            -
            <param name="x">A <see cref="T:InTheHand.Net.BluetoothAddress" /> or <see langword="null" />.</param><param name="y">A <see cref="T:InTheHand.Net.BluetoothAddress" /> or <see langword="null" />.</param>
            -
            <returns><c>true</c> if the values of the two instance are equal;
            otherwise, <c>false</c>.
            </returns></member>
    <member name="M:InTheHand.Net.BluetoothAddress.op_Inequality(InTheHand.Net.BluetoothAddress,InTheHand.Net.BluetoothAddress)">
      <summary>
            Returns an indication whether the values of two specified <see cref="T:InTheHand.Net.BluetoothAddress" /> objects are not equal.
            </summary>
            -
            <param name="x">A <see cref="T:InTheHand.Net.BluetoothAddress" /> or <see langword="null" />.</param><param name="y">A <see cref="T:InTheHand.Net.BluetoothAddress" /> or <see langword="null" />.</param>
            -
            <returns><c>true</c> if the value of the two instance is different;
            otherwise, <c>false</c>.
            </returns></member>
    <member name="M:InTheHand.Net.BluetoothAddress.ToString">
      <summary>
            Converts the address to its equivalent string representation.
            </summary>
      <returns>The string representation of this instance.</returns>
      <remarks>The default return format is without a separator character 
            - use the <see cref="M:InTheHand.Net.BluetoothAddress.ToString(System.String)" />
            overload for more formatting options.</remarks>
    </member>
    <member name="M:InTheHand.Net.BluetoothAddress.ToString(System.String)">
      <summary>
            Returns a <see cref="T:System.String" /> representation of the value of this <see cref="T:InTheHand.Net.BluetoothAddress" /> instance, according to the provided format specifier.
            </summary>
      <param name="format">A single format specifier that indicates how to format the value of this address.
            The format parameter can be "N", "C", or "P".
            If format is null or the empty string (""), "N" is used.</param>
      <returns>A <see cref="T:System.String" /> representation of the value of this <see cref="T:InTheHand.Net.BluetoothAddress" />.</returns>
      <remarks>
        <list type="table">
          <listheader>
            <term>Specifier</term>
            <term>Format of Return Value </term>
          </listheader>
          <item>
            <term>N</term>
            <term>12 digits: <para>XXXXXXXXXXXX</para></term>
          </item>
          <item>
            <term>C</term>
            <term>12 digits separated by colons: <para>XX:XX:XX:XX:XX:XX</para></term>
          </item>
          <item>
            <term>P</term>
            <term>12 digits separated by periods: <para>XX.XX.XX.XX.XX.XX</para></term>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:InTheHand.Net.BluetoothAddress.ToString(System.String,System.IFormatProvider)">
      <summary>
            Returns a <see cref="T:System.String" /> representation of the value of this 
            <see cref="T:InTheHand.Net.BluetoothAddress" /> instance, according to the provided format specifier.
            </summary>
            -
            <param name="format">A single format specifier that indicates how to format the value of this Address.
            See <see cref="M:InTheHand.Net.BluetoothAddress.ToString(System.String)" />
            for the possible format strings and their output.
            </param><param name="formatProvider">Ignored.
            </param>
            -
            <returns>A <see cref="T:System.String" /> representation of the value of this
            <see cref="T:InTheHand.Net.BluetoothAddress" />.
            </returns>
            -
            <remarks>See <see cref="M:InTheHand.Net.BluetoothAddress.ToString(System.String)" />
            for the possible format strings and their output.
            </remarks></member>
    <member name="M:InTheHand.Net.BluetoothAddress.Clone">
      <summary>
            Creates a copy of the <see cref="T:InTheHand.Net.BluetoothAddress" />.
            </summary>
      <remarks>Creates a copy including of the internal byte array.
            </remarks>
      <returns>A copy of the <see cref="T:InTheHand.Net.BluetoothAddress" />.
            </returns>
    </member>
    <member name="P:InTheHand.Net.BluetoothAddress.Sap">
      <summary>
            Significant address part.
            </summary>
    </member>
    <member name="P:InTheHand.Net.BluetoothAddress.Nap">
      <summary>
            Non-significant address part.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BluetoothRadio">
      <summary>
            Represents a Bluetooth Radio device.
            </summary>
      <remarks>Allows you to query properties of the radio hardware and set the mode.</remarks>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothRadio.AllRadios">
      <summary>
             Gets an array of all Bluetooth radios on the system.  
            </summary>
      <remarks>Under Windows CE this will only ever return a single <see cref="T:InTheHand.Net.Bluetooth.BluetoothRadio" /> device.
            <para>If the device has a third-party stack this property will return an empty collection</para></remarks>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothRadio.PrimaryRadio">
      <summary>
            Gets the primary <see cref="T:InTheHand.Net.Bluetooth.BluetoothRadio" />.
            </summary>
      <remarks>For Windows CE based devices this is the only <see cref="T:InTheHand.Net.Bluetooth.BluetoothRadio" />, for Windows XP this is the first available <see cref="T:InTheHand.Net.Bluetooth.BluetoothRadio" /> device.
            <para>If the device has a third-party stack this property will return null</para></remarks>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothRadio.IsSupported">
      <summary>
            Gets a value that indicates whether the 32feet.NET library can be used with the current device.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothRadio.StackFactory">
      <summary>
            Gets a class factory for creating client and listener instances on a particular stack.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothRadio.Remote">
      <summary>
            Gets whether the radio is on a Bluetooth stack on a remote machine.
            </summary>
            -
            <value>Is <see langword="null" /> if the radio is on to the local
            machine, otherwise its the name of the remote machine to which the
            radio is attached.
            </value></member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothRadio.Handle">
      <summary>
            Gets the handle for this radio.
            </summary>
      <remarks>Relevant only on Windows XP.</remarks>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothRadio.HardwareStatus">
      <summary>
            Returns the current status of the Bluetooth radio hardware.
            </summary>
      <value>A member of the <see cref="P:InTheHand.Net.Bluetooth.BluetoothRadio.HardwareStatus" /> enumeration.</value>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothRadio.Mode">
      <summary>
            Gets or Sets the current mode of operation of the Bluetooth radio.
            </summary>
      <remarks>
        <para>
          <strong>Microsoft CE/WM</strong>
        </para>
            This setting will be persisted when the device is reset.
            An Icon will be displayed in the tray on the Home screen and a ?Windows Mobile device will emit a flashing blue LED when Bluetooth is enabled.
            
            <para><strong>Widcomm Win32</strong></para><para>Is supported.
            </para><para><strong>Widcomm CE/WM</strong></para><para>Get and Set both supported.
            </para><list type="table"><listheader><term>Mode</term><term>Get</term><term>Set</term></listheader><item><term>PowerOff</term><term>Disabled or non-connectable</term><term>CONNECT_ALLOW_NONE</term></item><item><term>Connectable</term><term>Connectable</term><term>CONNECT_ALLOW_ALL, note not CONNECT_ALLOW_PAIRED.</term></item><item><term>Discoverable</term><term>Discoverable</term><term>Plus also discoverable.</term></item></list><para>Note also that when the Widcomm stack is disabled/off
            we report <c>PowerOff</c> (not in 2.4 and earlier), but
            we can't turn put it in that mode from the library.
            Neither can we turn it back on, <strong>except</strong> that
            it happens when the application first uses Bluetooth!
            </para><para><strong>Widcomm Win32</strong></para><para>Set is not supported.  There's no Widcomm API support.
            </para></remarks>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothRadio.LocalAddress">
      <summary>
            Get the address of the local Bluetooth radio device.
            </summary>
            -
            <remarks><para>The property can return a <see langword="null" /> value in
            some cases.  For instance on CE when the radio is powered-off the value 
            will be <see>null</see>.</para></remarks>
            -
            <value>The address of the local Bluetooth radio device.
            </value></member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothRadio.Name">
      <summary>
            Returns the friendly name of the local Bluetooth radio.
            </summary>
            -
            <remarks><para>Devices normally cache the remote device name, only reading it the first
            time the remote device is discovered.  It is generally not useful then to change
            the name to provide a status update.  For instance on desktop Windows
            with the Microsoft stack we haven't found a good way for the name to be
            flushed so that it is re-read, even deleting the device didn't flush the
            name if I remember correctly.
            </para><para>Currently read-only on Widcomm stack.  Probably could be supported,
            let us know if you need this function.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothRadio.ClassOfDevice">
      <summary>
            Returns the Class of Device.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothRadio.Manufacturer">
      <summary>
            Returns the manufacturer of the <see cref="T:InTheHand.Net.Bluetooth.BluetoothRadio" /> device.
            </summary>
      <remarks>
            See <see cref="P:InTheHand.Net.Bluetooth.BluetoothRadio.HciVersion" /> for more information.
            </remarks>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothRadio.HciVersion">
      <summary>
            Bluetooth Version supported by the Host Controller Interface implementation.
            </summary>
            -
            <remarks><para>There are five fields returned by the Read Local Version Information
            HCI command: HCI Version, HCI Revision, LMP Version,
            Manufacturer_Name, and LMP Subversion.
            We expose all five, but not all platforms provide access to them all.
            The Microsoft stack on desktop Windows exposes all five,
            except for Windows XP which only exposes the Manufacturer
            and LmpSubversion values.  Bluetopia apparently exposes none of them.
            The Microsoft stack on Windows Mobile, Widcomm on both platforms,
            BlueSoleil, and BlueZ expose all five.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothRadio.HciRevision">
      <summary>
            Manufacture's Revision number of the HCI implementation.
            </summary>
      <remarks>
            See <see cref="P:InTheHand.Net.Bluetooth.BluetoothRadio.HciVersion" /> for more information.
            </remarks>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothRadio.LmpVersion">
      <summary>
            Bluetooth Version supported by the Link Manager Protocol implementation.
            </summary>
      <remarks>
            See <see cref="P:InTheHand.Net.Bluetooth.BluetoothRadio.HciVersion" /> for more information.
            </remarks>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothRadio.LmpSubversion">
      <summary>
            Manufacture's Revision number of the LMP implementation.
            </summary>
      <remarks>
            See <see cref="P:InTheHand.Net.Bluetooth.BluetoothRadio.HciVersion" /> for more information.
            </remarks>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothRadio.SoftwareManufacturer">
      <summary>
            Returns the manufacturer of the Bluetooth software stack running locally.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Factory.DecoratorNetworkStream">
      <exclude />
    </member>
    <member name="T:InTheHand.Net.ObexListener">
      <summary>
            Provides a simple, programmatically controlled OBEX protocol listener.
            </summary>
    </member>
    <member name="M:InTheHand.Net.ObexListener.#ctor">
      <overloads>
            Initializes a new instance of the ObexListener class.
            </overloads>
            -
            <summary>
            Initializes a new instance of the ObexListener class using the Bluetooth transport.
            </summary></member>
    <member name="M:InTheHand.Net.ObexListener.#ctor(InTheHand.Net.ObexTransport)">
      <summary>
            Initializes a new instance of the ObexListener class specifiying the transport to use.
            </summary>
            -
            <param name="transport">Specifies the transport protocol to use.
            </param></member>
    <member name="M:InTheHand.Net.ObexListener.Start">
      <summary>
            Allows this instance to receive incoming requests.
            </summary>
    </member>
    <member name="M:InTheHand.Net.ObexListener.Stop">
      <summary>
            Causes this instance to stop receiving incoming requests.
            </summary>
    </member>
    <member name="M:InTheHand.Net.ObexListener.Close">
      <summary>
            Shuts down the ObexListener.
            </summary>
    </member>
    <member name="M:InTheHand.Net.ObexListener.GetContext">
      <summary>
            Waits for an incoming request and returns when one is received.
            </summary>
            -
            <remarks><para>This method blocks waiting for a new connection.  It will
            return when a new connection completes or 
            <see cref="M:InTheHand.Net.ObexListener.Stop" />/<see cref="M:InTheHand.Net.ObexListener.Close" />
            has been called.
            </para></remarks>
            -
            <returns>Returns a <see cref="T:InTheHand.Net.ObexListenerContext" />
            or <see langword="null" /> if
            <see cref="M:InTheHand.Net.ObexListener.Stop" />/<see cref="M:InTheHand.Net.ObexListener.Close" />
            has been called.
            </returns></member>
    <member name="P:InTheHand.Net.ObexListener.Authenticate">
      <summary>
            Get or set whether the transport connection (e.g. Bluetooth) will
            require Authentication.
            </summary>
            -
            <remarks><para>Only Bluetooth supports this, TCP/IP and IrDA do not.
            On Bluetooth this uses <see cref="P:InTheHand.Net.Sockets.BluetoothListener.Authenticate">BluetoothListener.Authenticate</see>.
            </para></remarks></member>
    <member name="P:InTheHand.Net.ObexListener.Encrypt">
      <summary>
            Get or set whether the transport connection (e.g. Bluetooth) will
            require Encryption.
            </summary>
            -
            <remarks><para>Only Bluetooth supports this, TCP/IP and IrDA do not.
            On Bluetooth this uses <see cref="P:InTheHand.Net.Sockets.BluetoothListener.Encrypt">BluetoothListener.Encrypt</see>.
            </para></remarks></member>
    <member name="P:InTheHand.Net.ObexListener.IsListening">
      <summary>
            Gets a value that indicates whether the <see cref="T:InTheHand.Net.ObexListener" /> has been started.
            </summary>
    </member>
    <member name="M:InTheHand.Net.AsyncResult`1.SetAsCompletedWithResultOf(System.Func{`0},System.Boolean)">
      <summary>
            Get the results of the operation from the specified function
            and set the operation as completed,
            or if getting the results fails then set the corresponding error
            completion.
            </summary>
            -
            <remarks><para>The pattern that comes to mind when calling
            <see cref="M:SetAsCompleted(TResult,AsyncResultCompletion)" /> is
            the incorrect:
            <code>try {
               var result = SomeStatementsAndFunctionCallsToGetTheResult(...);
               ar.SetAsCompleted(result, false);
            } catch (Exception ex) {
               ar.SetAsCompleted(ex, false);
            }
            </code>
            That is wrong because if the user callback fails with an exception
            then we'll catch it and try to call SetAsCompleted a second time!
            </para><para>We need to instead call SetAsCompleted outside of the try
            block.  This method provides that pattern.
            </para></remarks>
            -
            <param name="getResultsOrThrow">A delegate containing the function
            to call to get the result.
            It should throw an exception in error cases.
            </param><param name="completedSynchronously"></param></member>
    <member name="T:InTheHand.Net.Bluetooth.Manufacturer">
      <summary>
            Manufacturer codes.
            </summary>
      <remarks>Defined in Bluetooth Specifications <see href="https://www.bluetooth.org/Technical/AssignedNumbers/identifiers.htm" />.</remarks>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.DiscoverDevicesEventArgs">
      <summary>
            Provides data for the <see cref="E:InTheHand.Net.Bluetooth.BluetoothComponent.DiscoverDevicesComplete" />
            event.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.DiscoverDevicesEventArgs.#ctor(InTheHand.Net.Sockets.BluetoothDeviceInfo[],System.Object)">
      <summary>
            Initialise a new instance.
            </summary>
            -
            <param name="devices">The result, may be empty but not null.
            </param><param name="userState">Any user state object.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.DiscoverDevicesEventArgs.#ctor(System.Exception,System.Object)">
      <summary>
            Initialise a new instance.
            </summary>
            -
            <param name="exception">The resultant error.
            </param><param name="userState">Any user state object.
            </param></member>
    <member name="P:InTheHand.Net.Bluetooth.DiscoverDevicesEventArgs.Devices">
      <summary>
            Gets the list of discovered Bluetooth devices.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BluetoothComponent">
      <summary>
             Provides simple access to asynchronous methods on Bluetooth features, for
             instance to background device discovery.
             </summary>
             -
             <example><code lang="VB.NET">
             Public Sub DiscoDevicesAsync()
                 Dim bco As New BluetoothComponent()
                 AddHandler bco.DiscoverDevicesProgress, AddressOf HandleDiscoDevicesProgress
                 AddHandler bco.DiscoverDevicesComplete, AddressOf HandleDiscoDevicesComplete
                 bco.DiscoverDevicesAsync(255, True, True, True, False, 99)
             End Sub
            
             Private Sub HandleDiscoDevicesProgress(ByVal sender As Object, ByVal e As DiscoverDevicesEventArgs)
                 Console.WriteLine("DiscoDevicesAsync Progress found {0} devices.", e.Devices.Length)
             End Sub
            
             Private Sub HandleDiscoDevicesComplete(ByVal sender As Object, ByVal e As DiscoverDevicesEventArgs)
                 Debug.Assert(CInt(e.UserState) = 99)
                 If e.Cancelled Then
                     Console.WriteLine("DiscoDevicesAsync cancelled.")
                 ElseIf e.Error IsNot Nothing Then
                     Console.WriteLine("DiscoDevicesAsync error: {0}.", e.Error.Message)
                 Else
                     Console.WriteLine("DiscoDevicesAsync complete found {0} devices.", e.Devices.Length)
                 End If
             End Sub
             </code></example></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothComponent.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.BluetoothComponent" /> class.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothComponent.#ctor(InTheHand.Net.Sockets.BluetoothClient)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.BluetoothComponent" /> class.
            </summary>
            -
            <param name="cli">A <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> 
            instance to use to run discovery on.  Must be non-null.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothComponent.Dispose(System.Boolean)">
      <summary>
            Optionally disposes of the managed resources used by the
            <see cref="T:InTheHand.Net.Bluetooth.BluetoothComponent" /> class.
            </summary>
      <param name="disposing">
        <c>true</c> to release both managed and unmanaged
            resources; <c>false</c> to release only unmanaged resources.
            </param>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothComponent.OnDiscoveryComplete(InTheHand.Net.Bluetooth.DiscoverDevicesEventArgs)">
      <summary>
            Raises the <see cref="E:InTheHand.Net.Bluetooth.BluetoothComponent.DiscoverDevicesComplete" /> event.
            </summary>
      <param name="e">A <see cref="T:InTheHand.Net.Bluetooth.DiscoverDevicesEventArgs" />
            object that contains event data.
            </param>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothComponent.OnDiscoveryProgress(InTheHand.Net.Bluetooth.DiscoverDevicesEventArgs)">
      <summary>
            Raises the <see cref="E:InTheHand.Net.Bluetooth.BluetoothComponent.DiscoverDevicesProgress" /> event.
            </summary>
      <param name="e">A <see cref="T:InTheHand.Net.Bluetooth.DiscoverDevicesEventArgs" />
            object that contains event data.
            </param>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothComponent.DiscoverDevicesAsync(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.Object)">
      <summary>
            Discovers accessible Bluetooth devices and returns their names and addresses.
            This method does not block the calling thread.
            </summary>
            -
            <remarks><para>See <see cref="M:InTheHand.Net.Sockets.BluetoothClient.DiscoverDevices(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />
            for more information.
            </para><para>The devices are presented in the <see cref="E:InTheHand.Net.Bluetooth.BluetoothComponent.DiscoverDevicesComplete" />
            and <see cref="E:InTheHand.Net.Bluetooth.BluetoothComponent.DiscoverDevicesProgress" /> events.
            </para></remarks>
            -
            <param name="maxDevices">The maximum number of devices to get information about.
            </param><param name="authenticated">True to return previously authenticated/paired devices.
            </param><param name="remembered">True to return remembered devices.
            </param><param name="unknown">True to return previously unknown devices.
            </param><param name="discoverableOnly">True to return only the devices that 
            are in range, and in    discoverable mode.  See the remarks section.
            </param><param name="state">A user-defined object that is passed to the method
            invoked when the asynchronous operation completes.
            </param>
            -
            <returns>An array of BluetoothDeviceInfo objects describing the devices discovered.</returns></member>
    <member name="E:InTheHand.Net.Bluetooth.BluetoothComponent.DiscoverDevicesComplete">
      <summary>
            Occurs when an device discovery operation completes.
            </summary>
            -
            <remarks><para>This event is raised at the end of the discovery process
            and lists all the discovered devices.
            </para></remarks>
            -
            <seealso cref="E:InTheHand.Net.Bluetooth.BluetoothComponent.DiscoverDevicesProgress" /></member>
    <member name="E:InTheHand.Net.Bluetooth.BluetoothComponent.DiscoverDevicesProgress">
      <summary>
            Occurs during an device discovery operation
            to show one or more new devices.
            </summary>
            -
            <remarks><para>This event is raised for all discovered devices, both the
            known devices which are presented first, if requested,
            as well as newly discovery device found by the inquiry process,
            again if requested.
            </para><para>Note that any event instance may include one or more devices.  Note
            also that a particular device may be presented more than one time;
            including once from the known list, once when a
            device is dicovered, and possibly another time when the discovery
            process retrieves the new devices Device Name.
            </para></remarks>
            -
            <seealso cref="E:InTheHand.Net.Bluetooth.BluetoothComponent.DiscoverDevicesComplete" /></member>
    <member name="T:InTheHand.Net.Bluetooth.Factory.IL2CapClient">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.IL2CapClient.GetMtu">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Widcomm.WidcommRfcommStreamBase.Bond(InTheHand.Net.BluetoothAddress,System.String)">
      <summary>
            Wrapper around CBtIf::Bond().
            </summary>
      <param name="device">
        <see cref="T:InTheHand.Net.BluetoothAddress" />
      </param>
      <param name="passcode">
        <see cref="T:System.String" />
      </param>
      <returns>
        <see langword="true" /> if pairing was completed.
            <see langword="false" /> if were already paired, or pairing failed.
            </returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.NativeMethods.BluetoothAuthenticateDevice(System.IntPtr,System.IntPtr,InTheHand.Net.Bluetooth.Msft.BLUETOOTH_DEVICE_INFO@,System.String,System.Int32)">
      <summary>
            The BluetoothAuthenticateDevice function sends an authentication request to a remote Bluetooth device.
            </summary>
      <param name="hwndParent">The window to parent the authentication wizard.
            If NULL, the wizard will be parented off the desktop.</param>
      <param name="hRadio">A valid local radio handle, or NULL. If NULL, authentication is attempted on all local radios; if any radio succeeds, the function call succeeds.</param>
      <param name="pbtdi">A structure of type BLUETOOTH_DEVICE_INFO that contains the record of the Bluetooth device to be authenticated.</param>
      <param name="pszPasskey">A Personal Identification Number (PIN) to be used for device authentication. If set to NULL, the user interface is displayed and and the user must follow the authentication process provided in the user interface. If pszPasskey is not NULL, no user interface is displayed. If the passkey is not NULL, it must be a NULL-terminated string. For more information, see the Remarks section.</param>
      <param name="ulPasskeyLength">The size, in characters, of pszPasskey.
            The size of pszPasskey must be less than or equal to BLUETOOTH_MAX_PASSKEY_SIZE.</param>
      <returns>
      </returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.NativeMethods.BluetoothAuthenticateDeviceEx(System.IntPtr,System.IntPtr,InTheHand.Net.Bluetooth.Msft.BLUETOOTH_DEVICE_INFO@,System.Byte[],InTheHand.Net.Bluetooth.BluetoothAuthenticationRequirements)">
      <summary>
            The BluetoothAuthenticateDeviceEx function sends an authentication request to a remote Bluetooth device. Additionally, this function allows for out-of-band data to be passed into the function call for the device being authenticated.
            Note  This API is supported in Windows Vista SP2 and Windows 7.
            </summary>
      <param name="hwndParentIn">The window to parent the authentication wizard.
            If NULL, the wizard will be parented off the desktop.</param>
      <param name="hRadioIn">A valid local radio handle or NULL.
            If NULL, then all radios will be tried. If any of the radios succeed, then the call will succeed.</param>
      <param name="pbtdiInout">A pointer to a BLUETOOTH_DEVICE_INFO structure describing the device being authenticated.</param>
      <param name="pbtOobData">Pointer to device specific out-of-band data to be provided with this API call.
            If NULL, then UI is displayed to continue the authentication process.
            If not NULL, no UI is displayed.</param>
      <param name="authenticationRequirement">An AUTHENTICATION_REQUIREMENTS enumeration that specifies the protection required for authentication.</param>
      <returns>
      </returns>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Msft.WSAESETSERVICEOP.RNRSERVICE_REGISTER">
      <summary>
            Register the service. For SAP, this means sending out a periodic broadcast.
            This is an NOP for the DNS namespace.
            For persistent data stores, this means updating the address information. 
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Msft.WSAESETSERVICEOP.RNRSERVICE_DEREGISTER">
      <summary>
             Remove the service from the registry.
             For SAP, this means stop sending out the periodic broadcast.
             This is an NOP for the DNS namespace.
             For persistent data stores this means deleting address information. 
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Msft.WSAESETSERVICEOP.RNRSERVICE_DELETE">
      <summary>
            Delete the service from dynamic name and persistent spaces.
            For services represented by multiple CSADDR_INFO structures (using the SERVICE_MULTIPLE flag), only the specified address will be deleted, and this must match exactly the corresponding CSADDR_INFO structure that was specified when the service was registered 
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Factory.IBluetoothSecurity">
      <summary>
            Handles security between bluetooth devices.
            </summary>
            -
            <remarks><para>Used by <see cref="P:InTheHand.Net.Bluetooth.BluetoothPublicFactory.BluetoothSecurity" />.
            </para></remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.IBluetoothSecurity.PairRequest(InTheHand.Net.BluetoothAddress,System.String)">
      <summary>
            Intiates pairing for a remote device.
            </summary>
            -
            <param name="device">Remote device with which to pair.</param><param name="pin">Chosen PIN code, must be between 1 and 16 ASCII characters.</param>
            -
            <returns>Whether the operation was successful.</returns></member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.IBluetoothSecurity.RemoveDevice(InTheHand.Net.BluetoothAddress)">
      <summary>
            Remove the pairing with the specified device
            </summary>
            -
            <param name="device">Remote device with which to remove pairing.</param>
            -
            <returns>TRUE if device was successfully removed, else FALSE.</returns></member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.IBluetoothSecurity.SetPin(InTheHand.Net.BluetoothAddress,System.String)">
      <summary>
            This function stores the personal identification number (PIN) for the Bluetooth device.
            </summary>
      <param name="device">Address of remote device.</param>
      <param name="pin">Pin, alphanumeric string of between 1 and 16 ASCII characters.</param>
      <remarks>
        <para>On Windows CE platforms this calls <c>BthSetPIN</c>,
            its MSDN remarks say:
            </para>
        <para>Stores the pin for the Bluetooth device identified in pba.
            The active connection to the device is not necessary, nor is the presence
            of the Bluetooth controller. The PIN is persisted in the registry until
            BthRevokePIN is called.
            </para>
        <para>While the PIN is stored, it is supplied automatically
            after the PIN request is issued by the authentication mechanism, so the
            user will not be prompted for it. Typically, for UI-based devices, you
            would set the PIN for the duration of authentication, and then revoke
            it after authentication is complete.
            </para>
        <para>See also 
            <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.RevokePin(InTheHand.Net.BluetoothAddress)" /></para>
      </remarks>
      <returns>True on success, else False.</returns>
      <seealso cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.RevokePin(InTheHand.Net.BluetoothAddress)" />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.IBluetoothSecurity.RevokePin(InTheHand.Net.BluetoothAddress)">
      <summary>
            This function revokes the personal identification number (PIN) for the Bluetooth device.
            </summary>
      <remarks>
        <para>On Windows CE platforms this calls <c>BthRevokePIN</c>,
            its MSDN remarks say:
            </para>
        <para>When the PIN is revoked, it is removed from registry.
            The active connection to the device is not necessary, nor is the presence
            of the Bluetooth controller.
            </para>
        <para>On Windows CE platforms this removes any pending BluetoothWin32Authentication object but does not remove the PIN for an already authenticated device.
            Use RemoveDevice to ensure a pairing is completely removed.</para>
        <para>See also 
            <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.SetPin(InTheHand.Net.BluetoothAddress,System.String)" /></para>
      </remarks>
      <param name="device">The remote device.</param>
      <returns>True on success, else False.</returns>
      <seealso cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.SetPin(InTheHand.Net.BluetoothAddress,System.String)" />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.IBluetoothSecurity.GetPinRequest">
      <summary>
            Retrieves the address of the Bluetooth peer device authentication that requires the PIN code.
            <para><b>Not supported on Windows XP</b></para></summary>
      <remarks>
        <para>On Windows CE platforms this calls <c>BthGetPINRequest</c>,
            its MSDN remarks say:
            </para>
        <para>There can be multiple requests outstanding. After the event
            that is provided by the UI handler is signaled, the UI handler must call
            this function multiple times until the call fails.
            </para>
        <para>See also 
            <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.RefusePinRequest(InTheHand.Net.BluetoothAddress)" />
            and <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.AnswerPinRequest(InTheHand.Net.BluetoothAddress,System.String)" /></para>
      </remarks>
      <returns>
        <see cref="T:InTheHand.Net.BluetoothAddress" /> of the remote device, or null if there is no outstanding PIN request.</returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.IBluetoothSecurity.RefusePinRequest(InTheHand.Net.BluetoothAddress)">
      <summary>
            Refuses an outstanding PIN request.
            <para><b>Not supported on Windows XP</b></para></summary>
            -
            <param name="device">Address of the requesting device.</param>
            -
            <returns><c>true</c> if the operation was successful; <c>false</c> otherwise.</returns>
            -
            <remarks><para>On Windows CE platforms this calls <c>BthRefusePINRequest</c>,
            its MSDN remarks say:
            </para><para>This function refuses an outstanding PIN request that is
            retrieved by <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.GetPinRequest" />
            function.
            </para><para>See also 
            <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.GetPinRequest" />
            and <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.AnswerPinRequest(InTheHand.Net.BluetoothAddress,System.String)" /></para></remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.IBluetoothSecurity.SetLinkKey(InTheHand.Net.BluetoothAddress,System.Guid)">
      <summary>
        <para>
          <b>Not supported on Windows XP</b>
        </para>
      </summary>
            -
            <param name="device">The device whose Link Key to retrieve.</param><param name="linkKey">The 16-byte Link Key to set.</param>
            -
            <returns><c>true</c> if the operation was successful; <c>false</c> otherwise.</returns>
            -
            <remarks><para>On Windows CE platforms this calls <c>BthSetLinkKey</c>,
            its MSDN remarks say:
            </para><para>The link key is persisted in registry until <c>BthRevokeLinkKey</c>
            is called.
            </para><para>Typically, the Bluetooth stack manages link keys automatically,
            for example, it stores them when they are created. This function is useful
            primarily for backup purposes.
            </para><para>While link key is stored, it will be automatically supplied
            once the link key request is issued by the authentication mechanism. If
            the link key is incorrect, the renegotiation that involves the PIN is
            initiated by the Bluetooth adapter, and the PIN code may be requested
            from the user.
            </para><para>The link key length is 16 bytes. You cannot create link
            keys; they are generated by the Bluetooth hardware.
            </para></remarks><returns></returns></member>
    <member name="T:InTheHand.Net.Bluetooth.AttributeIds.DeviceIdProfileAttributeId">
      <summary>
            Service Attribute IDs defined by the Device Identification Profile specification.
            </summary>
            -
            <remarks><para>This document specifies a method by which Bluetooth devices may
            provide information that may be used by peer Bluetooth devices to
            find representative icons or load associated support software. This
            information is published as Bluetooth SDP records, and optionally in
            an Extended Inquiry Response.
            </para><para>Used in records with Service Class ID:
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.PnPInformation" />.
            </para><para>As well as the attributes defined here, use of some of the universal
            attributes is recommended, they are:
            <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ClientExecutableUrl" />,
            <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceDescription" />,
            and <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.DocumentationUrl" />.
            </para></remarks></member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.DeviceIdProfileAttributeId.SpecificationId">
      <summary>
            SpecificationId [0x0200]
            </summary>
      <remarks>The version of the Bluetooth Device ID Profile Specification
            supported by the device.
            e.g. version 1.3 will be value 0x0103. [<c>UInt16</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.DeviceIdProfileAttributeId.VendorId">
      <summary>
            VendorId [0x0201]
            </summary>
      <remarks>
        <para>The id assigned by the organisation in <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.DeviceIdProfileAttributeId.VendorIdSource" />. [<c>UInt16</c>]
            </para>
        <para>The value <c>FFFF</c> is reserved as the default id when
            no Device ID Service Record is present in the device.
            </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.DeviceIdProfileAttributeId.ProductId">
      <summary>
            ProductId [0x0202]
            </summary>
      <remarks>Distinguishes between different products made by the same vendor. [<c>UInt16</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.DeviceIdProfileAttributeId.Version">
      <summary>
            Version [0x0203]
            </summary>
      <remarks>The version of the product. [<c>UInt16</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.DeviceIdProfileAttributeId.PrimaryRecord">
      <summary>
            PrimaryRecord [0x0204]
            </summary>
      <remarks>If multiple Device ID records are present this indicates the one primary record. [<c>Boolean</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.DeviceIdProfileAttributeId.VendorIdSource">
      <summary>
            VendorIdSource [0x0205]
            </summary>
      <remarks>Designates which organisation assigned the Vendor ID value. [<c>UInt16</c>]
            <list type="table"><listheader><term>Value</term><term>Assigning Organisation</term></listheader><item><term>1</term><term>Bluetooth SIG</term></item><item><term>2</term><term>USB Implementors Forum</term></item><item><term>0, 3-FFFF</term><term>reserved</term></item></list></remarks>
    </member>
    <member name="T:InTheHand.Net.Sockets.L2CapListener">
      <summary>
            Listens for connections from L2CAP Bluetooth network clients.
            </summary>
            -
            <remarks><para>The <see cref="T:InTheHand.Net.Sockets.L2CapListener" /> class provides simple methods 
            that listen for and accept incoming connection requests.  New connections 
            are returned as <see cref="T:InTheHand.Net.Sockets.L2CapClient" /> instances.
            </para><para>In the normal case a the listener is initialised with a 
            <see cref="T:System.Guid" /> holding the Service Class Id on which it is 
            to accept connections, the listener will automatically create a SDP 
            Service Record containg that Service Class Id and the port number
            (L2CAP Protocol Service Multiplexer) that it has started listening on.
            The standard usage is thus as follows.
            </para><code lang="VB.NET">
            Class MyConsts
              Shared ReadOnly MyServiceUuid As Guid _
                = New Guid("{00112233-4455-6677-8899-aabbccddeeff}")
            End Class
            
              ...
              Dim lsnr As New L2CapListener(MyConsts.MyServiceUuid)
              lsnr.Start()
              ' Now accept new connections, perhaps using the thread pool to handle each
              Dim conn As New L2CapClient = lsnr.AcceptClient()
              Dim peerStream As Stream = conn.GetStream()
              ...
            </code><para>One can also pass the L2CapListener a Service Name, or
            a custom Service Record (Service Discovery Protocol record).
            To create a custom Service Record use 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceRecordBuilder" />.
            </para><para>There are overloads of the constructor which take a 
            <see cref="T:InTheHand.Net.BluetoothEndPoint" /> parameter instead of a 
            <see cref="T:System.Guid" /> as the Service Class Id, the Class Id
            value should be specified in that case in the endpoint.
            If the port value is specified in the endpoint, then the listener will 
            attempt to bind to that L2CAP PSM locally.  The address in the endpoint is 
            largely ignored as no current stack supports more than one local radio.
            </para><para>The L2CAP protocol accepts only certain PSM values.  The value is
            a 16-bit integer, and the low byte must be odd and the high byte must
            be even. So e.g. 0x0001 is valid, but 0x0002 and 0x0101 are invalid.
            The range below 0x1001 is reserved for standards allocations.
            See the L2CAP Specification for more information, L2CAP section 4.2
            (and SDP section 5.1.5) in the version 2.1 specification.
            </para></remarks></member>
    <member name="M:InTheHand.Net.Sockets.L2CapListener.#ctor(System.Guid)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Sockets.L2CapListener" /> class
            that listens on the specified service identifier.
            </summary>
            -
            <param name="service">The Bluetooth service to listen on.
            Either one of the values on <see cref="T:InTheHand.Net.Bluetooth.BluetoothService" />,
            or your custom UUID stored in a <see cref="T:System.Guid" />.
            See the <see cref="T:InTheHand.Net.Sockets.L2CapListener" /> documentation for more information 
            on the usage of this argument.
            </param></member>
    <member name="M:InTheHand.Net.Sockets.L2CapListener.#ctor(InTheHand.Net.BluetoothEndPoint)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Sockets.L2CapListener" /> class
            with the specified local endpoint.
            </summary>
            -
            <remarks><para>The simpler constructor <see cref="M:InTheHand.Net.Sockets.L2CapListener.#ctor(System.Guid)" />
            taking just a <see cref="T:System.Guid">System.Guid</see> is used 
            in most cases instead of this one.
            </para></remarks>
            -
            <param name="localEP">A <see cref="T:InTheHand.Net.BluetoothEndPoint" /> that represents 
            the local endpoint to which to bind the listener.
            Either one of the values on <see cref="T:InTheHand.Net.Bluetooth.BluetoothService" />,
            or your custom UUID stored in a <see cref="T:System.Guid" />.
            See the <see cref="T:InTheHand.Net.Sockets.L2CapListener" /> documentation for more information 
            on the usage of this argument.
            </param></member>
    <member name="M:InTheHand.Net.Sockets.L2CapListener.Start">
      <summary>
            Starts listening for incoming connection requests.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Sockets.L2CapListener.Start(System.Int32)">
      <summary>
            Starts listening for incoming connection requests with a maximum
            number of pending connection.
            </summary>
            -
            <param name="backlog">The maximum length of the pending connections
            queue.
            </param></member>
    <member name="M:InTheHand.Net.Sockets.L2CapListener.Stop">
      <summary>
            Closes the listener.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Sockets.L2CapListener.BeginAcceptClient(System.AsyncCallback,System.Object)">
      <summary>
            Begins an asynchronous operation to accept an incoming connection attempt.
            </summary>
            -
            <param name="callback">An AsyncCallback delegate that references
            the method to invoke when the operation is complete.
            </param><param name="state">A user-defined object containing information 
            about the accept operation. This object is passed to the callback
            delegate when the operation is complete.
            </param>
            -
            <returns>An <see cref="T:System.IAsyncResult" /> that represents the 
            asynchronous accept, which could still be pending.
            </returns></member>
    <member name="M:InTheHand.Net.Sockets.L2CapListener.EndAcceptClient(System.IAsyncResult)">
      <summary>
            Asynchronously accepts an incoming connection attempt and creates
            a new <see cref="T:InTheHand.Net.Sockets.L2CapClient" /> to handle remote host communication.
            </summary>
            -
            <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> returned
            by a call to the <see cref="M:InTheHand.Net.Sockets.L2CapListener.BeginAcceptClient(System.AsyncCallback,System.Object)" /> method.
            </param>
            -
            <returns>A <see cref="T:InTheHand.Net.Sockets.L2CapClient" />.
            </returns></member>
    <member name="M:InTheHand.Net.Sockets.L2CapListener.AcceptClient">
      <summary>
            Accepts a pending connection request.
            </summary>
            -
            <remarks>AcceptClient is a blocking method that returns a
            <see cref="T:InTheHand.Net.Sockets.L2CapClient" /> that you can use to send and receive data.
            Use the <see cref="M:InTheHand.Net.Sockets.L2CapListener.Pending" /> method to determine if connection
            requests are available in the incoming connection queue if you want
            to avoid blocking.
            <para>Use the <see cref="M:InTheHand.Net.Sockets.L2CapClient.GetStream" /> method to obtain
            the underlying <see cref="T:System.IO.Stream" /> of the returned
            <see cref="T:InTheHand.Net.Sockets.L2CapClient" />.
            The <see cref="T:System.IO.Stream" /> will provide you with methods for
            sending and receiving with the remote host.
            When you are through with the <see cref="T:InTheHand.Net.Sockets.L2CapClient" />, be sure
            to call its <see cref="M:InTheHand.Net.Sockets.L2CapClient.Close" /> method.
            </para></remarks>
            -
            <returns>A <see cref="T:InTheHand.Net.Sockets.L2CapClient" /> used to send and receive data.</returns>
            -
            <exception cref="T:System.InvalidOperationException">Listener is stopped.</exception></member>
    <member name="M:InTheHand.Net.Sockets.L2CapListener.Pending">
      <summary>
            Determines if there is a connection pending.
            </summary>
            -
            <returns>true if there is a connection pending; otherwise, false.
            </returns></member>
    <member name="P:InTheHand.Net.Sockets.L2CapListener.LocalEndPoint">
      <summary>
            Gets the local endpoint.
            </summary>
            -
            <value>The <see cref="T:InTheHand.Net.BluetoothEndPoint" />
            that the listener is using for communications.
            </value>
            -
            <remarks><para>The <see cref="P:InTheHand.Net.BluetoothEndPoint.Port" /> 
            property of the endpoint will contain the port number (L2CAP PSM) 
            that the listener is listening on.
            On some platforms, the <see cref="P:InTheHand.Net.BluetoothEndPoint.Address" />
            is similarly set, or is <see cref="F:InTheHand.Net.BluetoothAddress.None">BluetoothAddress.None</see> 
            if not known.
            The endpoints <see cref="P:InTheHand.Net.BluetoothEndPoint.Service" />
            is never set.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Sockets.L2CapListener.ServiceName">
      <summary>
            Get or set the ServiceName the server will use in its SDP Record.
            </summary>
            -
            <value>A string representing the value to be used for the Service Name
            SDP Attribute.  Will be <see langword="null" /> if not specfied.
            </value>
            -
            <exception cref="T:System.InvalidOperationException">
            The listener is already started.
            <para>- or -</para>
            A custom Service Record was given at initialization time.  In that case 
            the ServiceName attribute should be added to that record.
            </exception></member>
    <member name="P:InTheHand.Net.Sockets.L2CapListener.ServiceRecord">
      <summary>
            Returns the SDP Service Record for this service.
            </summary>
            -
            <remarks><note>Returns <see langword="null" /> if the listener is not 
            <see cref="M:InTheHand.Net.Sockets.L2CapListener.Start" />ed
            (and an record wasnt supplied at initialization).
            </note></remarks></member>
    <member name="T:InTheHand.Net.Sockets.IrDADeviceInfo">
      <summary>
            Provides information about remote devices connected by infrared communications.
            </summary>
      <seealso cref="T:System.Net.Sockets.IrDADeviceInfo" />
    </member>
    <member name="M:InTheHand.Net.Sockets.IrDADeviceInfo.Equals(System.Object)">
      <summary>
            Compares two <see cref="T:InTheHand.Net.Sockets.IrDADeviceInfo" /> instances for equality.
            </summary>
            -
            <param name="obj">The <see cref="T:InTheHand.Net.Sockets.BluetoothDeviceInfo" />
            to compare with the current instance.
            </param>
            -
            <returns><c>true</c> if <paramref name="obj" />
            is a <see cref="T:InTheHand.Net.Sockets.BluetoothDeviceInfo" /> and equal to the current instance;
            otherwise, <c>false</c>.
            </returns></member>
    <member name="M:InTheHand.Net.Sockets.IrDADeviceInfo.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
      <returns>A hash code for the current object.</returns>
    </member>
    <member name="P:InTheHand.Net.Sockets.IrDADeviceInfo.DeviceAddress">
      <summary>
            Returns the address of the remote device.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Sockets.IrDADeviceInfo.DeviceID">
      <summary>
            Provided solely for compatibility with System.Net.IrDA - consider using <see cref="P:InTheHand.Net.Sockets.IrDADeviceInfo.DeviceAddress" /> instead.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Sockets.IrDADeviceInfo.DeviceName">
      <summary>
            Gets the name of the device.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Sockets.IrDADeviceInfo.CharacterSet">
      <summary>
            Gets the character set used by the server, such as ASCII.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Sockets.IrDADeviceInfo.Hints">
      <summary>
            Gets the type of the device, such as a computer.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Mime.MediaTypeNames">
      <summary>
            Specifies the media type information for an object.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Mime.MediaTypeNames.Image">
      <summary>
            Specifies the type of image data in an object.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Mime.MediaTypeNames.Text">
      <summary>
            Specifies the type of text data in an object.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Mime.MediaTypeNames.ObjectExchange">
      <summary>
            Specifies the type of Object Exchange specific data.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BluetoothPublicFactory">
      <summary>
            Provides the means to create Bluetooth classes on the one selected Bluetooth
            stack where multiple are loaded in the same process.
            </summary>
            -
            <remarks>when 
            <para>When calling <c>new BluetoothClient()</c>, <c>new BluetoothListener()</c>,
            etc when multiple Bluetooth stacks are loaded at the same time then the
            instance is created on the primary stack.  This class allows the application
            to select which stack the instance is created on.
            Access this class via property
            <see cref="P:InTheHand.Net.Bluetooth.BluetoothRadio.StackFactory" />.
            </para></remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothPublicFactory.CreateBluetoothClient">
      <overloads>
            Initialise a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothClient" />
            class, using the respective stack and/or radio.
            </overloads>
            -
            <summary>
            Initialise a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothClient" />
            class, using the respective stack and/or radio.
            </summary>
            -
            <returns>The new instance.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothPublicFactory.CreateBluetoothClient(InTheHand.Net.BluetoothEndPoint)">
      <summary>
            Initialise a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> class,
            with the specified local endpoint and
            using the respective stack and/or radio.
            </summary>
            -
            <param name="localEP">See <see cref="M:InTheHand.Net.Sockets.BluetoothClient.#ctor(InTheHand.Net.BluetoothEndPoint)" />.
            </param>
            -
            <returns>The new instance.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothPublicFactory.CreateBluetoothListener(System.Guid)">
      <overloads>
            Initialise a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" />
            class, using the respective stack and/or radio.
            </overloads>
            -
            <summary>
            Initialise a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" />
            class,
            with the specified Service Class Id
            using the respective stack and/or radio.
            </summary>
            -
            <param name="service">See <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(System.Guid)" />.
            </param>
            -
            <returns>The new instance.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothPublicFactory.CreateBluetoothListener(InTheHand.Net.BluetoothAddress,System.Guid)">
      <summary>
            Initialise a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" />
            class,
            with the specified Service Class Id and local device address
            using the respective stack and/or radio.
            </summary>
            -
            <param name="localAddress">See <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid)" />.
            </param><param name="service">See <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid)" />.
            </param>
            -
            <returns>The new instance.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothPublicFactory.CreateBluetoothListener(InTheHand.Net.BluetoothEndPoint)">
      <summary>
            Initialise a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" />
            class,
            with the specified Service Class Id and local device address as a
            <see cref="T:InTheHand.Net.BluetoothEndPoint" />
            using the respective stack and/or radio.
            </summary>
            -
            <param name="localEP">See <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothEndPoint)" />.
            </param>
            -
            <returns>The new instance.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothPublicFactory.CreateBluetoothListener(System.Guid,System.Byte[],System.Int32)">
      <summary>
            Initialise a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" />
            class,
            with the specified Service Class Id and raw Service Record
            using the respective stack and/or radio.
            </summary>
            -
            <param name="service">See <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(System.Guid,System.Byte[],System.Int32)" />.
            </param><param name="sdpRecord">See <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(System.Guid,System.Byte[],System.Int32)" />.
            </param><param name="channelOffset">See <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(System.Guid,System.Byte[],System.Int32)" />.
            </param>
            -
            <returns>The new instance.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothPublicFactory.CreateBluetoothListener(InTheHand.Net.BluetoothAddress,System.Guid,System.Byte[],System.Int32)">
      <summary>
            Initialise a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" />
            class,
            with the specified Service Class Id, local device address and raw Service Record
            using the respective stack and/or radio.
            </summary>
            -
            <param name="localAddress">See <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid,System.Byte[],System.Int32)" />.
            </param><param name="service">See <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid,System.Byte[],System.Int32)" />.
            </param><param name="sdpRecord">See <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid,System.Byte[],System.Int32)" />.
            </param><param name="channelOffset">See <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid,System.Byte[],System.Int32)" />.
            </param>
            -
            <returns>The new instance.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothPublicFactory.CreateBluetoothListener(InTheHand.Net.BluetoothEndPoint,System.Byte[],System.Int32)">
      <summary>
            Initialise a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" />
            class,
            with the specified Service Class Id and local device address as a
            <see cref="T:InTheHand.Net.BluetoothEndPoint" /> and raw Service Record
            using the respective stack and/or radio.
            </summary>
            -
            <param name="localEP">See <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothEndPoint,System.Byte[],System.Int32)" />.
            </param><param name="sdpRecord">See <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothEndPoint,System.Byte[],System.Int32)" />.
            </param><param name="channelOffset">See <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothEndPoint,System.Byte[],System.Int32)" />.
            </param>
            -
            <returns>The new instance.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothPublicFactory.CreateBluetoothListener(System.Guid,InTheHand.Net.Bluetooth.ServiceRecord)">
      <summary>
            Initialise a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" />
            class,
            with the specified Service Class Id and Service Record
            using the respective stack and/or radio.
            </summary>
            -
            <param name="service">See <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(System.Guid,InTheHand.Net.Bluetooth.ServiceRecord)" />.
            </param><param name="sdpRecord">See <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(System.Guid,InTheHand.Net.Bluetooth.ServiceRecord)" />.
            </param>
            -
            <returns>The new instance.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothPublicFactory.CreateBluetoothListener(InTheHand.Net.BluetoothAddress,System.Guid,InTheHand.Net.Bluetooth.ServiceRecord)">
      <summary>
            Initialise a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" />
            class,
            with the specified Service Class Id, local device address and Service Record
            using the respective stack and/or radio.
            </summary>
            -
            <param name="localAddress">See <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid,InTheHand.Net.Bluetooth.ServiceRecord)" />.
            </param><param name="service">See <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid,InTheHand.Net.Bluetooth.ServiceRecord)" />.
            </param><param name="sdpRecord">See <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid,InTheHand.Net.Bluetooth.ServiceRecord)" />.
            </param>
            -
            <returns>The new instance.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothPublicFactory.CreateBluetoothListener(InTheHand.Net.BluetoothEndPoint,InTheHand.Net.Bluetooth.ServiceRecord)">
      <summary>
            Initialise a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" />
            class,
            with the specified Service Class Id and local device address as a
            <see cref="T:InTheHand.Net.BluetoothEndPoint" /> and Service Record
            using the respective stack and/or radio.
            </summary>
            -
            <param name="localEP">See <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothEndPoint,InTheHand.Net.Bluetooth.ServiceRecord)" />.
            </param><param name="sdpRecord">See <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothEndPoint,InTheHand.Net.Bluetooth.ServiceRecord)" />.
            </param>
            -
            <returns>The new instance.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothPublicFactory.CreateBluetoothDeviceInfo(InTheHand.Net.BluetoothAddress)">
      <summary>
            Initialise a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothDeviceInfo" /> class,
            using the respective stack and/or radio.
            </summary>
            -
            <param name="addr">See <see cref="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.#ctor(InTheHand.Net.BluetoothAddress)" />.
            </param>
            -
            <returns>The new instance.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothPublicFactory.CreateObexWebRequest(System.Uri)">
      <summary>
            Initialise a new instance of the <see cref="T:InTheHand.Net.ObexWebRequest" /> class,
            using the respective stack and/or radio.
            </summary>
            -
            <returns>The new instance of <see cref="T:InTheHand.Net.ObexWebRequest" />.
            </returns>
            -
            <param name="requestUri">See <see cref="M:InTheHand.Net.ObexWebRequest.#ctor(System.Uri)" />.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothPublicFactory.CreateObexWebRequest(System.String,InTheHand.Net.BluetoothAddress,System.String)">
      <summary>
            Initialize an instance of this <see cref="T:InTheHand.Net.ObexWebRequest" /> class,
            given a scheme, a Bluetooth Device Address, and a remote path name; 
            using the respective stack and/or radio.
            </summary>
            -
            <param name="scheme">The Uri scheme. One of 
            <c>obex</c>, <c>obex-push</c>, <c>obex-ftp</c>, or <c>obex-sync</c>.
            </param><param name="target">The Bluetooth Device Address of the OBEX server.
            </param><param name="path">The path on the OBEX server.
            </param>
            -
            <returns>The new instance of <see cref="T:InTheHand.Net.ObexWebRequest" />.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothPublicFactory.CreateObexListener">
      <summary>
            Initialise a new instance of the <see cref="T:InTheHand.Net.ObexListener" /> class,
            using the respective stack and/or radio.
            </summary>
            -
            <returns>The new instance of <see cref="T:InTheHand.Net.ObexListener" />.
            </returns></member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothPublicFactory.BluetoothSecurity">
      <summary>
            Gets the <see cref="T:InTheHand.Net.Bluetooth.BluetoothSecurity" />
            instance for the respective stack and/or radio.
            </summary>
            -
            <value>A <see cref="T:InTheHand.Net.Bluetooth.BluetoothSecurity" />
            as an <see cref="T:InTheHand.Net.Bluetooth.Factory.IBluetoothSecurity" /></value></member>
    <member name="T:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothSecurity">
      <summary>
            Handles security between bluetooth devices.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothSecurity.SetPin(InTheHand.Net.BluetoothAddress,System.String)">
      <summary>
            This function stores the personal identification number (PIN) for the Bluetooth device.
            </summary>
      <param name="device">Address of remote device.</param>
      <param name="pin">Pin, alphanumeric string of between 1 and 16 ASCII characters.</param>
      <remarks>
        <para>On Windows CE platforms this calls <c>BthSetPIN</c>,
            its MSDN remarks say:
            </para>
        <para>Stores the pin for the Bluetooth device identified in pba.
            The active connection to the device is not necessary, nor is the presence
            of the Bluetooth controller. The PIN is persisted in the registry until
            BthRevokePIN is called.
            </para>
        <para>While the PIN is stored, it is supplied automatically
            after the PIN request is issued by the authentication mechanism, so the
            user will not be prompted for it. Typically, for UI-based devices, you
            would set the PIN for the duration of authentication, and then revoke
            it after authentication is complete.
            </para>
        <para>See also 
            <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.RevokePin(InTheHand.Net.BluetoothAddress)" /></para>
      </remarks>
      <returns>True on success, else False.</returns>
      <seealso cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.RevokePin(InTheHand.Net.BluetoothAddress)" />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothSecurity.RevokePin(InTheHand.Net.BluetoothAddress)">
      <summary>
            This function revokes the personal identification number (PIN) for the Bluetooth device.
            </summary>
      <remarks>
        <para>On Windows CE platforms this calls <c>BthRevokePIN</c>,
            its MSDN remarks say:
            </para>
        <para>When the PIN is revoked, it is removed from registry.
            The active connection to the device is not necessary, nor is the presence
            of the Bluetooth controller.
            </para>
        <para>On Windows CE platforms this removes any pending BluetoothWin32Authentication object but does not remove the PIN for an already authenticated device.
            Use RemoveDevice to ensure a pairing is completely removed.</para>
        <para>See also 
            <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.SetPin(InTheHand.Net.BluetoothAddress,System.String)" /></para>
      </remarks>
      <param name="device">The remote device.</param>
      <returns>True on success, else False.</returns>
      <seealso cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.SetPin(InTheHand.Net.BluetoothAddress,System.String)" />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothSecurity.PairRequest(InTheHand.Net.BluetoothAddress,System.String)">
      <summary>
            Intiates pairing for a remote device.
            </summary>
      <param name="device">Remote device with which to pair.</param>
      <param name="pin">Chosen PIN code, must be between 1 and 16 ASCII characters.</param>
      <remarks>
        <para>On Windows CE platforms this calls <c>BthPairRequest</c>,
            its MSDN remarks say:
            </para>
        <para>BthPairRequest passes the parameters to the <c>BthSetPIN</c>
            function and creates an ACL connection. Once the connection is established,
            it calls the <c>BthAuthenticate</c> function to authenticate the device.
            </para>
        <para>On Windows XP/Vista platforms this calls <c>BluetoothAuthenticateDevice</c>,
            if the pin argument is set to null a Wizard is displayed to accept a PIN from the user,
            otherwise the function executes in transparent mode.
            </para>
        <para>See also 
            <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.SetPin(InTheHand.Net.BluetoothAddress,System.String)" /></para>
      </remarks>
      <returns>Whether the operation was successful.</returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothSecurity.PairRequest(InTheHand.Net.BluetoothAddress,InTheHand.Net.Bluetooth.BluetoothAuthenticationRequirements)">
      <summary>
            Intiates pairing for a remote device
            with SSP if it is available.
            </summary>
            -
            <param name="device">Remote device with which to pair.</param><param name="authenticationRequirement">
            Note: not supported by all platforms.
            </param>
            -
            <returns>Whether the operation was successful.</returns></member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothSecurity.RemoveDevice(InTheHand.Net.BluetoothAddress)">
      <summary>
            Remove the pairing with the specified device
            </summary>
            -
            <param name="device">Remote device with which to remove pairing.</param>
            -
            <returns>TRUE if device was successfully removed, else FALSE.</returns></member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothSecurity.SetLinkKey(InTheHand.Net.BluetoothAddress,System.Guid)">
      <summary>
        <para>
          <b>Not supported on Windows XP</b>
        </para>
      </summary>
      <param name="device">
      </param>
      <param name="linkkey">
      </param>
      <remarks>
        <para>On Windows CE platforms this calls <c>BthSetLinkKey</c>,
            its MSDN remarks say:
            </para>
        <para>The link key is persisted in registry until <c>BthRevokeLinkKey</c>
            is called.
            </para>
        <para>Typically, the Bluetooth stack manages link keys automatically,
            for example, it stores them when they are created. This function is useful
            primarily for backup purposes.
            </para>
        <para>While link key is stored, it will be automatically supplied
            once the link key request is issued by the authentication mechanism. If
            the link key is incorrect, the renegotiation that involves the PIN is
            initiated by the Bluetooth adapter, and the PIN code may be requested
            from the user.
            </para>
        <para>The link key length is 16 bytes. You cannot create link
            keys; they are generated by the Bluetooth hardware.
            </para>
      </remarks>
      <returns>
      </returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothSecurity.GetPinRequest">
      <summary>
            Retrieves the address of the Bluetooth peer device authentication that requires the PIN code.
            <para><b>Not supported on Windows XP</b></para></summary>
      <remarks>
        <para>On Windows CE platforms this calls <c>BthGetPINRequest</c>,
            its MSDN remarks say:
            </para>
        <para>There can be multiple requests outstanding. After the event
            that is provided by the UI handler is signaled, the UI handler must call
            this function multiple times until the call fails.
            </para>
        <para>See also 
            <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.RefusePinRequest(InTheHand.Net.BluetoothAddress)" />
            and <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.AnswerPinRequest(InTheHand.Net.BluetoothAddress,System.String)" /></para>
      </remarks>
      <returns>
        <see cref="T:InTheHand.Net.BluetoothAddress" /> of the remote device, or null if there is no outstanding PIN request.</returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothSecurity.RefusePinRequest(InTheHand.Net.BluetoothAddress)">
      <summary>
            Refuses an outstanding PIN request.
            <para><b>Not supported on Windows XP</b></para></summary>
      <param name="device">Address of the requesting device.</param>
      <remarks>
        <para>On Windows CE platforms this calls <c>BthRefusePINRequest</c>,
            its MSDN remarks say:
            </para>
        <para>This function refuses an outstanding PIN request that is
            retrieved by <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.GetPinRequest()" />
            function.
            </para>
        <para>See also 
            <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.GetPinRequest" />
            and <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.AnswerPinRequest(InTheHand.Net.BluetoothAddress,System.String)" /></para>
      </remarks>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Factory.IBluetoothFactoryFactory">
      <exclude />
      <summary>
            Defines a class that provides Bluetooth Factory initialisation but returns
            multiple factories.
            </summary>
            -
            <remarks><para>In most cases configuration is provided so that
            <see cref="T:InTheHand.Net.Bluetooth.BluetoothFactory" /> loads one or more
            classes each derived from <see cref="T:InTheHand.Net.Bluetooth.BluetoothFactory" />.
            There the instance is the factory.  This interface allows a class to be 
            loaded by <see cref="T:InTheHand.Net.Bluetooth.BluetoothFactory" /> but 
            instead <strong>returns</strong> a list of factory instances.
            </para></remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.Factory.IBluetoothFactoryFactory.GetFactories(System.Collections.Generic.IList{System.Exception})">
      <summary>
            Get the list of factories.
            </summary>
      <param name="errors">A list of exceptions, to which any errors in 
            attempting to create the factories are added.
            </param>
      <returns>A list of successfully created factories.
            </returns>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BlueSoleil.IBluesoleilApi">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BlueSoleil.IBluesoleilApi.Btsdk_IsSDKInitialized">
      <summary>
            The Btsdk_IsSDKInitialized function indicates whether a successful
            call to Btsdk_Init is made.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BlueSoleil.IBluesoleilApi.Btsdk_IsServerConnected">
      <summary>
            The Btsdk_IsServerConnected function checks whether client
            application can call BlueSoleil Server APIs.
            </summary>
      <returns>
            When this fuction returns
            <see langword="true" />, client application can call APIs normally, versa versit.
            </returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BlueSoleil.IBluesoleilApi.Btsdk_SetStatusInfoFlag(System.UInt16)">
      <summary>
            The Btsdk_SetStatusInfoFlag function is used to set the status
            changing callback types which the user wants to receive.
            </summary>
            -
            <remarks>
            usMsgType can be one of the following value or their combination:
            <list type="definition"><item><term>BTSDK_NTSERVICE_STATUS_FLAG</term><description>The status change of BlueSoleil server
            event or OS message event.</description></item><item><term>BTSDK_BLUETOOTH_STATUS_FLAG</term><description>Message event of the change of Bluetooth</description>
            status.
            </item><item><term>BTSDK_REFRESH_STATUS_FLAG</term><description>Refresh event.</description></item></list></remarks>
            -
            <param name="usMsgType">See remarks.</param>
            -
            <returns>BTSDK_OK for success, other for error code.</returns></member>
    <member name="M:InTheHand.Net.Bluetooth.BlueSoleil.IBluesoleilApi.Btsdk_IsBluetoothReady">
      <summary>
            The Btsdk_IsBluetoothReady function checks whether the local
            Bluetooth device is working.
            </summary>
      <returns>Boolean</returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BlueSoleil.IBluesoleilApi.Btsdk_UpdateRemoteDeviceName(System.UInt32,System.Byte[],System.UInt16@)">
      <summary>
            Gets the current user-friendly name of the specified remote device.
            </summary>
            -
            <remarks>
            Before calling Btsdk_UpdateRemoteDeviceName, the device database must be initialized by a
            previous successful call to Btsdk_StartBluetooth.
            The user-friendly device name is a UTF-8 character string. The device name acquired by this
            command is stored automatically in the device database.
            </remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.BlueSoleil.IBluesoleilApi.Btsdk_GetRemoteRSSI(System.UInt32,System.SByte@)">
      <summary>
            "gets the RSSI value of the specified remote device."
            </summary>
            -
            <remarks><para></para><para>"a connection between local device and the specified
            remote device must be created first."
            </para></remarks>
            -
            <param name="device_handle">hDev
            </param><param name="prssi">"Range: -128 to 127 (dB)."
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.BlueSoleil.IBluesoleilApi.Btsdk_GetRemoteLinkQuality(System.UInt32,System.UInt16@)">
      <summary>
            "gets the current link quality value of the connection between local
            device and the specified remote device."
            </summary>
            -
            <remarks>"The higher the value, the better the link quality is."
            </remarks>
            -
            <returns>"Range: 0 to 0xFF."
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.BlueSoleil.IBluesoleilApi.Btsdk_GetRemoteDeviceName(System.UInt32,System.Byte[],System.UInt16@)">
      <summary>
            "Gets the user-friendly name of the specified remote device from the device database."
            </summary>
            -
            <remarks>
            "Before calling Btsdk_GetRemoteDeviceName, the device database must be initialized by a
            previous successful call to Btsdk_Init.
            The user-friendly device name is a UTF-8 character string. The Btsdk_GetRemoteDeviceNamefunction returns =BTSDK_OPERATION_FAILURE immediately if the device name doesnt
            exist in the database. In this case, the application shall call Btsdk_UpdateRemoteDeviceName
            to acquire the name information directly from the remote device.
            BlueSoleil will automatically update the device name when the local device connects to the
            specified remote device.
            </remarks></member>
    <member name="M:Utils.Process2.GetProcessesByName(System.String)">
      <summary>
            NETCF Version of: Creates an array of new Process components and associates them with all the process resources on the local computer that share the specified process name.
            </summary>
            -
            <param name="processName">e.g. "BTExplorer"
            </param>
            -
            <returns>An array of type <see cref="T:System.Diagnostics.Process" />
            that represents the process resources running the specified application or file.
            </returns></member>
    <member name="T:InTheHand.Net.ObexTransport">
      <summary>
            Supported network transports for Object Exchange.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexTransport.IrDA">
      <summary>
            Infrared (IrDA)
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexTransport.Bluetooth">
      <summary>
            Bluetooth
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexTransport.Tcp">
      <summary>
            TCP/IP
            </summary>
    </member>
    <member name="T:InTheHand.Net.Sockets.SocketAdapter">
      <summary>
            Provide a <see cref="T:System.Net.Sockets.Socket">System.Net.Sockets.Socket</see>-like
            interace to another connection type e.g. a <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /></summary>
            -
            <remarks><para>See class <see cref="T:InTheHand.Net.Sockets.SocketClientAdapter" />
            for an implementation that adapts <see cref="T:InTheHand.Net.Sockets.BluetoothClient" />
            etc to the <see cref="T:System.Net.Sockets.Socket">Socket</see>-like interface.
            That is required as on Widcomm/Broadcom <see cref="T:InTheHand.Net.Sockets.BluetoothClient" />
            does not support getting a <see cref="T:System.Net.Sockets.Socket" /> from
            the <see cref="T:InTheHand.Net.Sockets.BluetoothClient.Client" /> property.
            Motivated by upgrading of <see cref="T:InTheHand.Net.ObexListener" /> to
            be usable on Widcomm.
            </para></remarks></member>
    <member name="T:InTheHand.Net.Sockets.SocketClientAdapter">
      <summary>
            An adapter that provides a <see cref="T:System.Net.Sockets.Socket">System.Net.Sockets.Socket</see>-like
            interface to <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> etc.
            </summary>
            -
            <remarks><para>Required as  on Widcomm/Broadcom <see cref="T:InTheHand.Net.Sockets.BluetoothClient" />
            does not support getting a <see cref="T:System.Net.Sockets.Socket" /> from
            the <see cref="T:InTheHand.Net.Sockets.BluetoothClient.Client" /> property.
            Motivated by upgrading of <see cref="T:InTheHand.Net.ObexListener" /> to
            be usable on Widcomm.
            </para><para>Also adapts <see cref="T:InTheHand.Net.Sockets.IrDAClient" />, and
            <see cref="T:System.Net.Sockets.TcpClient" />.
            </para></remarks></member>
    <member name="T:InTheHand.Net.Bluetooth.ServiceRecordUtilities">
      <summary>
            Utilities method working on SDP <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />s, for instance to
            produce a 'dump' of the record's contents.
            </summary>
            -
            <remarks>
            This class produces output like the following:
            <code lang="none">
            AttrId: 0x0000 -- ServiceRecordHandle
            UInt32: 0x0
            
            AttrId: 0x0001 -- ServiceClassIdList
            ElementSequence
                Uuid16: 0x1000 -- ServiceDiscoveryServer
            
            AttrId: 0x0004 -- ProtocolDescriptorList
            ElementSequence
                ElementSequence
                    Uuid16: 0x100 -- L2CapProtocol
                    UInt16: 0x1
                ElementSequence
                    Uuid16: 0x1 -- SdpProtocol
            ( ( L2Cap, PSM=Sdp ), ( Sdp ) )
            
            AttrId: 0x0005 -- BrowseGroupList
            ElementSequence
                Uuid16: 0x1002 -- PublicBrowseGroup
            
            AttrId: 0x0006 -- LanguageBaseAttributeIdList
            ElementSequence
                UInt16: 0x656E
                UInt16: 0x6A
                UInt16: 0x100
            
            AttrId: 0x0100 -- ServiceName
            TextString: [en] 'Service Discovery'
            
            AttrId: 0x0101 -- ServiceDescription
            TextString: [en] 'Publishes services to remote devices'
            
            AttrId: 0x0102 -- ProviderName
            TextString: [en] 'Microsoft'
            
            AttrId: 0x0200 -- VersionNumberList
            ElementSequence
                UInt16: 0x100
            
            AttrId: 0x0201 -- ServiceDatabaseState
            UInt32: 0x1
            </code>
            The Service Class Id names and Attribute Id names are looked up using 
            <see cref="M:InTheHand.Net.Bluetooth.BluetoothService.GetName(System.Guid)" />/etc and
            <see cref="T:InTheHand.Net.Bluetooth.MapServiceClassToAttributeIdList" />
            respectively.
            </remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordUtilities.DumpRaw(InTheHand.Net.Bluetooth.ServiceRecord)">
      <overloads>
            Produces a raw 'dump' of the given record, not including attribute names etc.
            </overloads>
            -
            <summary>
            Gets a string containing a raw 'dump' of the given record, not including attribute names etc.
            </summary>
            -
            <param name="record">A <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> to be dumped.</param><returns>A <see cref="T:System.String" /> containing the 'dump' text.</returns><seealso cref="M:InTheHand.Net.Bluetooth.ServiceRecordUtilities.DumpRaw(System.IO.TextWriter,InTheHand.Net.Bluetooth.ServiceRecord)" /></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordUtilities.DumpRaw(System.IO.TextWriter,InTheHand.Net.Bluetooth.ServiceRecord)">
      <summary>
            Produce a raw 'dump' of the given record, not including attribute names etc, to the given
            <see cref="T:System.IO.TextWriter" />.
            </summary>
      <param name="writer">A <see cref="T:System.IO.TextWriter" /> where the 'dump'
            text is to be written.</param>
      <param name="record">A <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> to be dumped.</param>
      <seealso cref="M:InTheHand.Net.Bluetooth.ServiceRecordUtilities.DumpRaw(InTheHand.Net.Bluetooth.ServiceRecord)" />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordUtilities.Dump(InTheHand.Net.Bluetooth.ServiceRecord,System.Type[])">
      <overloads>
            Produces a 'dump' of the given record, including attribute names etc.
            </overloads>
            --
            <summary>
            Gets a <see cref="T:System.String" /> containing a 'dump' of the given record, including attribute names etc.
            </summary>
            -
            <param name="record">A <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> to be dumped.</param><param name="attributeIdEnumDefiningTypes">
            An optional array of <see cref="T:System.Type" /> specifing a set of Ids 
            for the attributes contained in this record.  See the 
            <see cref="M:InTheHand.Net.Bluetooth.ServiceRecordUtilities.Dump(System.IO.TextWriter,InTheHand.Net.Bluetooth.ServiceRecord,System.Type[])" /> 
            overload for more information.
            </param>
            -
            <returns>A <see cref="T:System.String" /> containing the 'dump' text.</returns>
            -
            <seealso cref="M:InTheHand.Net.Bluetooth.ServiceRecordUtilities.Dump(System.IO.TextWriter,InTheHand.Net.Bluetooth.ServiceRecord,System.Type[])" /></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordUtilities.Dump(System.IO.TextWriter,InTheHand.Net.Bluetooth.ServiceRecord,System.Type[])">
      <summary>
            Produce a 'dump' of the given record, including attribute names etc to the given
            <see cref="T:System.IO.TextWriter" />.
            </summary>
            -
            <remarks><para>The system has built-in a set of mappings from Service Class to 
            its Attribute IDs. This is supplied by the 
            <see cref="T:InTheHand.Net.Bluetooth.MapServiceClassToAttributeIdList" /> class,
            and contains the Attribute IDs defined in the base SDP specification as 
            well as in Bluetooth Profiles specification e.g. ObjectPushProfile, Headset,
            Panu, etc.
            If however the record being decoded is a custom one then a set of extra 
            Attribute Id definitions can be supplied in the 
            <paramref name="attributeIdEnumDefiningTypes" /> parameter.
            The Attribute IDs for a particular Service Class 
            should be defined in a static class and the set of such classes should 
            be passed as their <see cref="T:System.Type" /> object. e.g.
            <code lang="C#">
            static class FooAttributeId
            {
                public const ServiceAttributeId BarName = (ServiceAttributeId)0x0300;
            }
            
            
                ServiceRecordUtilities.Dump(writer, myRecord, typeof(FooAttributeId));
            
            </code></para></remarks>
            -
            <param name="writer">A <see cref="T:System.IO.TextWriter" /> where the 'dump'
            text is to be written.</param><param name="record">A <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> to be dumped.</param><param name="attributeIdEnumDefiningTypes">
            An optional array of <see cref="T:System.Type" /> specifing a set of Ids 
            for the attributes contained in this record.  See the 
            </param><seealso cref="M:InTheHand.Net.Bluetooth.ServiceRecordUtilities.Dump(InTheHand.Net.Bluetooth.ServiceRecord,System.Type[])" /></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordUtilities.GuidToHackProtocolId(System.Guid,System.String@)">
      <summary>
            Attempt to get the name of the protocol,
            and optionally it's enum id if we handle it specially.
            </summary>
            -
            <param name="protocolGuid">The input.
            </param><param name="protoStr">The protocol's name if known, or its
            Guid.ToString if not.
            We handle some explicitly, and otherwise we see if there's a
            matching value in BluetoothService that has its name suffixed "Protocol".
            </param>
            -
            <returns>The id as a <see cref="T:InTheHand.Net.Bluetooth.ServiceRecordUtilities.HackProtocolId" />.
            We handle some explicitly,
            otherwise we see if its a UUID16 and convert it automatically,
            finally if neither we return <c>zero</c>.
            </returns></member>
    <member name="T:InTheHand.Net.Bluetooth.BluetoothAuthenticationRequirements">
      <summary>
            The AUTHENTICATION_REQUIREMENTS enumeration specifies the 'Man in the Middle' protection required for authentication.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationRequirements.MITMProtectionNotRequired">
      <summary>
            Protection against a "Man in the Middle" attack is not required for authentication.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationRequirements.MITMProtectionRequired">
      <summary>
            Protection against a "Man in the Middle" attack is required for authentication.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationRequirements.MITMProtectionNotRequiredBonding">
      <summary>
            Protection against a "Man in the Middle" attack is not required for bonding.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationRequirements.MITMProtectionRequiredBonding">
      <summary>
            Protection against a "Man in the Middle" attack is required for bonding.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationRequirements.MITMProtectionNotRequiredGeneralBonding">
      <summary>
            Protection against a "Man in the Middle" attack is not required for General Bonding.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationRequirements.MITMProtectionRequiredGeneralBonding">
      <summary>
            Protection against a "Man in the Middle" attack is required for General Bonding.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationRequirements.MITMProtectionNotDefined">
      <summary>
            Protection against "Man in the Middle" attack is not defined.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Widcomm.WidcommBtIf.CheckDependencies(System.Exception)">
      <summary>
            Check whether all the of dependencies are correct.
            </summary>
            -
            <param name="wrapException">The original exception we got on trying
            to load Widcomm.  Or <c>null</c> if Widcomm loaded successfully and
            we're just doing a check of the dependencies.
            </param>
            -
            <returns>Does not return if <paramref name="wrapException" /> is non-null,
            instead will throw it, or a more explanatory exception (with it as
            an inner exception).
            If <paramref name="wrapException" /> is null,
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.Widcomm.WidcommBtIf.ReportNeedNeedNativeDllUpgrade(System.Exception,System.Boolean)">
      <summary>
            ReportNeedNeedNativeDllUpgrade, call from pair of catch:
            EntryPointNotFoundException and MissingMethodException.
            </summary>
      <param name="ex">The exception.</param>
      <param name="mayAssert">Whether we may put up an (Debug.)Assert dialog box.
            </param>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.DISCOVERY_RESULT.CONNECT_ERR">
      <summary>
            Could not connect to remote device 
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.DISCOVERY_RESULT.CONNECT_REJ">
      <summary>
            Remote device rejected the connection 
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.DISCOVERY_RESULT.SECURITY">
      <summary>
            Security failed 
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.DISCOVERY_RESULT.BAD_RECORD">
      <summary>
            Remote Service Record Error 
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.DISCOVERY_RESULT.OTHER_ERROR">
      <summary>
            Other error
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.REM_DEV_INFO_RETURN_CODE.SUCCESS">
      <summary>
            success response
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.REM_DEV_INFO_RETURN_CODE.EOF">
      <summary>
            no more devices found
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.REM_DEV_INFO_RETURN_CODE.ERROR">
      <summary>
            can not find exsiting entry for bda provided as input
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.REM_DEV_INFO_RETURN_CODE.MEM_ERROR">
      <summary>
            out of memory
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Widcomm.STACK_STATUS">
      <summary>
            Used by OnStackChanges virtual method.
            </summary>
      <remarks>
        <para>1000-WCE-PG100-RCD.pdf (03/20/06) says:
            "... no longer used: DEVST_UP and DEVST_ERROR."
            and:
            "Values defined in BtIfClasses.h are:
            <code lang="none">
             DEVST_DOWN  The stack is down and no longer available.
             DEVST_UNLOADED  The stack is down, but should be available again after DEVST_RELOADED.
             DEVST_RELOADED  The stack has been successfully reloaded."
            </code></para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.STACK_STATUS.Down">
      <summary>
            Device is present, but down [Seen (on BTW)]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.STACK_STATUS.Up">
      <summary>
            Device is present and UP [Doc'd as obsolete, but I see it (on BTW)]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.STACK_STATUS.Error">
      <summary>
            Device is in error (maybe being removed) [Doc'd as obsolete]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.STACK_STATUS.Unloaded">
      <summary>
            Stack is being unloaded
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.STACK_STATUS.Reloaded">
      <summary>
            Stack reloaded after being unloaded
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Widcomm.WidcommBluetoothDeviceInfo.CreateFromStoredRemoteDeviceInfo(InTheHand.Net.Bluetooth.Widcomm.REM_DEV_INFO,InTheHand.Net.Bluetooth.Widcomm.WidcommBluetoothFactoryBase)">
      <summary>
            Used when loading a stack stored/remembered/maybe-paired device.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Widcomm.WidcommBluetoothDeviceInfo.CreateFromHandleDeviceResponded(System.Byte[],System.Byte[],System.Byte[],System.Boolean,InTheHand.Net.Bluetooth.Widcomm.WidcommBluetoothFactoryBase)">
      <summary>
            Used when a device is discovered during Inquiry.
            </summary>
            -
            <remarks><para>When the result of Inquiry and get-stack-stored-devices are merged,
            the remembered/authenticated flags may get set then (with <see cref="M:SetAuthenticated" />).
            </para></remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.Widcomm.WidcommBluetoothDeviceInfo.CheckAndSetIfPaired(InTheHand.Net.Bluetooth.Widcomm.WidcommBluetoothDeviceInfo,InTheHand.Net.Bluetooth.Widcomm.WidcommBluetoothFactoryBase)">
      <summary>
            Called after reading the device from the Registry, to find if it is paired.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Widcomm.WidcommBluetoothDeviceInfo.Merge(InTheHand.Net.Bluetooth.Factory.IBluetoothDeviceInfo)">
      <summary>
            For use when the results of Inquiry and get-stack-stored-devices are merged.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Msft.BTHNS_BLOB">
      <summary>
      </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.BTHNS_BLOB.ToByteArray">
      <summary>
            Internal bytes
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.BTHNS_BLOB.Length">
      <summary>
            Size of the structure.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BlueZ.StackConsts.SdpRecordRegisterFlags">
      <summary>
            Values of the flags parameter to sdp_record_register
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BlueZ.StackConsts.SdpConnectFlags">
      <summary>
            Values of the flags parameter to sdp_connect
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BlueZ.StackConsts.so_RFCOMM_CONNINFO">
      <summary>
            Use with struct rfcomm_conninfo{hci_handle, dev_class}.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BlueZ.StackConsts.BDADDR_ANY" />
    <member name="P:InTheHand.Net.Bluetooth.BlueSoleil.SerialPortNetworkStream.Connected">
      <summary>
            For FooBarClient.Connected
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BlueSoleil.BtSdkError.NO_SERVICE">
      <summary>
            No service record with the specified search pattern is found on the remote device.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BlueSoleil.BtSdkError.SERVICE_RECORD_NOT_EXIST">
      <summary>
            The specified service record does not exist on the remote device..
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BlueSoleil.BtSdkError.PAGE_TIMEOUT">
      <summary>
            HCI error Page Timeout (0X04) is received.
            </summary>
    </member>
    <member name="T:InTheHand.Net.ObexWebRequestCreate">
      <summary>
            Used to create a new web request for obex uri scheme
            </summary>
    </member>
    <member name="T:InTheHand.Net.ObexStatusCode">
      <summary>
            Specifies the status codes returned for an Object Exchange (OBEX) operation.
            </summary>
      <remarks>OBEX codes are directly related to their HTTP equivalents - see <see cref="T:System.Net.HttpStatusCode" />.</remarks>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.Final">
      <summary>
            Applied to another code to indicate this is the only response or final response in a series.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.Continue">
      <summary>
            Equivalent to HTTP status 100.
            Continue indicates that the client can continue with its request.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.OK">
      <summary>
            Equivalent to HTTP status 200.
            OK indicates that the request succeeded and that the requested information is in the response.
            This is the most common status code to receive.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.Created">
      <summary>
            Equivalent to HTTP status 201.
            Created indicates that the request resulted in a new resource created before the response was sent. 
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.Accepted">
      <summary>
            Equivalent to HTTP status 202.
            Accepted indicates that the request has been accepted for further processing.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.NonAuthorativeInformation">
      <summary>
            Equivalent to HTTP status 203.
            NonAuthoritativeInformation indicates that the returned metainformation is from a cached copy instead of the origin server and therefore may be incorrect.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.NoContent">
      <summary>
            Equivalent to HTTP status 204.
            NoContent indicates that the request has been successfully processed and that the response is intentionally blank.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.ResetContent">
      <summary>
            Equivalent to HTTP status 205.
            ResetContent indicates that the client should reset (not reload) the current resource.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.PartialContent">
      <summary>
            Equivalent to HTTP status 206.
            PartialContent indicates that the response is a partial response as requested by a GET request that includes a byte range.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.MultipleChoices">
      <summary>
            Equivalent to HTTP status 300.
            MultipleChoices indicates that the requested information has multiple representations.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.MovedPermanently">
      <summary>
            Equivalent to HTTP status 301.
            MovedPermanently indicates that the requested information has been moved to the URI specified in the Location header.
            The default action when this status is received is to follow the Location header associated with the response.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.MovedTemporarily">
      <summary>
            Equivalent to HTTP status 302.
            Redirect indicates that the requested information is located at the URI specified in the Location header.
            The default action when this status is received is to follow the Location header associated with the response.
            When the original request method was POST, the redirected request will use the GET method.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.SeeOther">
      <summary>
            Equivalent to HTTP status 303.
            SeeOther automatically redirects the client to the URI specified in the Location header as the result of a POST. The request to the resource specified by the Location header will be made with a GET.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.NotModified">
      <summary>
            Equivalent to HTTP status 304.
            NotModified indicates that the client's cached copy is up to date.
            The contents of the resource are not transferred.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.UseProxy">
      <summary>
            Equivalent to HTTP status 305.
            UseProxy indicates that the request should use the proxy server at the URI specified in the Location header.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.BadRequest">
      <summary>
             Equivalent to HTTP status 400.
             BadRequest indicates that the request could not be understood by the server. BadRequest is sent when no other error is applicable, or if the exact error is unknown or does not have its own error code. 
            
             <see cref="T:InTheHand.Net.ObexWebRequest" /> reports errors through 
             <see cref="P:InTheHand.Net.ObexWebResponse.StatusCode">ObexWebResponse.StatusCode</see>,
             this status code is overloaded by it to report failure to connect to the server.
             </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.Unauthorized">
      <summary>
            Equivalent to HTTP status 401.
            Unauthorized indicates that the requested resource requires authentication. The WWW-Authenticate header contains the details of how to perform the authentication.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.PaymentRequired">
      <summary>
            Equivalent to HTTP status 402.
            PaymentRequired is reserved for future use.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.Forbidden">
      <summary>
            Equivalent to HTTP status 403.
            Forbidden indicates that the server refuses to fulfill the request.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.NotFound">
      <summary>
            Equivalent to HTTP status 404.
            NotFound indicates that the requested resource does not exist on the server.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.MethodNotAllowed">
      <summary>
            Equivalent to HTTP status 405.
            MethodNotAllowed indicates that the request method (POST or GET) is not allowed on the requested resource.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.NotAcceptable">
      <summary>
            Equivalent to HTTP status 406.
            NotAcceptable indicates that the client has indicated with Accept headers that it will not accept any of the available representations of the resource.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.ProxyAuthenticationRequired">
      <summary>
            Equivalent to HTTP status 407.
            ProxyAuthenticationRequired indicates that the requested proxy requires authentication.
            The Proxy-authenticate header contains the details of how to perform the authentication.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.RequestTimeout">
      <summary>
            Equivalent to HTTP status 408.
            RequestTimeout indicates that the client did not send a request within the time the server was expecting the request.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.Conflict">
      <summary>
            Equivalent to HTTP status 409.
            Conflict indicates that the request could not be carried out because of a conflict on the server.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.Gone">
      <summary>
            Equivalent to HTTP status 410.
            Gone indicates that the requested resource is no longer available.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.LengthRequired">
      <summary>
            Equivalent to HTTP status 411.
            LengthRequired indicates that the required Content-length header is missing.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.PreconditionFailed">
      <summary>
            Equivalent to HTTP status 412.
            PreconditionFailed indicates that a condition set for this request failed, and the request cannot be carried out.
            Conditions are set with conditional request headers like If-Match, If-None-Match, or If-Unmodified-Since.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.RequestedEntityTooLarge">
      <summary>
            Equivalent to HTTP status 413.
            RequestEntityTooLarge indicates that the request is too large for the server to process.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.RequestedUrlTooLarge">
      <summary>
            Equivalent to HTTP status 414.
            RequestUriTooLong indicates that the URI is too long.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.UnsupportedMediaType">
      <summary>
            Equivalent to HTTP status 415.
            UnsupportedMediaType indicates that the request is an unsupported type.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.InternalServerError">
      <summary>
            Equivalent to HTTP status 500.
            InternalServerError indicates that a generic error has occurred on the server.
            
            <see cref="T:InTheHand.Net.ObexWebRequest" /> reports errors through 
            <see cref="P:InTheHand.Net.ObexWebResponse.StatusCode">ObexWebResponse.StatusCode</see>,
            this status code is used by it to report failure to send the object.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.NotImplemented">
      <summary>
            Equivalent to HTTP status 501.
            NotImplemented indicates that the server does not support the requested function.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.BadGateway">
      <summary>
            Equivalent to HTTP status 502.
            BadGateway indicates that an intermediate proxy server received a bad response from another proxy or the origin server.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.ServiceUnavailable">
      <summary>
            Equivalent to HTTP status 503.
            ServiceUnavailable indicates that the server is temporarily unavailable, usually due to high load or maintenance.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.GatewayTimeout">
      <summary>
            Equivalent to HTTP status 504.
            GatewayTimeout indicates that an intermediate proxy server timed out while waiting for a response from another proxy or the origin server.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.HttpVersionNotSupported">
      <summary>
            Equivalent to HTTP status 505.
            HttpVersionNotSupported indicates that the requested HTTP version is not supported by the server.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.DatabaseFull">
      <summary>
      </summary>
    </member>
    <member name="F:InTheHand.Net.ObexStatusCode.DatabaseLocked">
      <summary>
      </summary>
    </member>
    <member name="T:InTheHand.Net.Sockets.IrDAClient">
      <summary>
            Makes connections to services on peer IrDA devices.
            </summary>
            -
            <remarks><para>Makes connections to services on peer IrDA devices.  It allows 
            discovery of all devices in range, then a connection can be made to 
            the required service on the chosen peer.  Or, given just the 
            service name a connection will be made to an arbitrary peer.  This is 
            most useful when it is expected that there will be only one device in 
            rangeas is often the case.</para><para>It can be used with both the full and Compact frameworks, and can 
            be used as a replacement for the latter's built-in version simply by 
            changing the referenced namespace and assembly.
            It also has features extra 
            to those in the CF's version.  For instance, following the 
            pattern of <see cref="T:System.Net.Sockets.TcpClient" /> in framework 
            version 2, it provides access to the underlying 
            <see cref="T:System.Net.Sockets.Socket" /> via a <c>Client</c> 
            property.  This is particularly useful as it allows setting socket 
            options, for instance IrCOMM Cooked mode with option <see cref="F:InTheHand.Net.Sockets.IrDASocketOptionName.NineWireMode" />.
            </para><para>There a number of well-known services, a few are listed here.
            <list type="bullet"><listheader><term>Service description</term><description>Service Name, Protocol type</description></listheader><item><term>OBEX file transfer</term><description>OBEX:IrXfer, (TinyTP)</description></item><item><term>OBEX general</term><description>OBEX, (TinyTP)</description></item><item><term>Printing</term><description>IrLPT, IrLMP mode</description></item><item><term>IrCOMM e.g. to modems</term><description>IrDA:IrCOMM, IrCOMM 9-Wire/Cooked mode</description></item></list>
            The modes required by the last two are set by socket option, as noted 
            for IrCOMM above.
            </para><para>
            Of course the library also includes specific OBEX protocol support, both 
            client and server, see <see cref="T:InTheHand.Net.ObexWebRequest" /> etc.
            </para></remarks>
            -
            <example>Example code to connect to a IrCOMM service would be as 
            follows.
            <code lang="VB.NET">
            Public Shared Sub Main()
              Dim cli As New IrDAClient
              ' Set IrCOMM Cooked/9-wire mode.
              cli.Client.SetSocketOption(IrDASocketOptionLevel.IrLmp, _
                IrDASocketOptionName.NineWireMode, _
                1)  ' equivalent to 'True'
              ' Connect
              cli.Connect("IrDA:IrCOMM")
              ' Connected, now send and receive e.g. by using the 
              ' NetworkStream returned by cli.GetStream
              ...
            End Sub
            </code></example>
            -
            <seealso cref="N:InTheHand.Net.Sockets" /><seealso cref="T:System.Net.Sockets.IrDAClient" /></member>
    <member name="M:InTheHand.Net.Sockets.IrDAClient.#ctor">
      <overloads>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Sockets.IrDAClient" /> class,
            and optionally connects to a peer device.
            </overloads>
            ----
            <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Sockets.IrDAClient" /> class.
            </summary><remarks><para>
            It then allows discovery of all devices in range using <see cref="M:InTheHand.Net.Sockets.IrDAClient.DiscoverDevices" />, then a 
            connection can be made to the  required service on the chosen peer using <see cref="M:InTheHand.Net.Sockets.IrDAClient.Connect(InTheHand.Net.IrDAEndPoint)" />.
            Or, given just the  service name a connection will be made to an arbitrary 
            peer, using <see cref="M:InTheHand.Net.Sockets.IrDAClient.Connect(System.String)" />.  This is 
            most useful when it is expected that there will be only one device in 
            range  as is often the case.</para></remarks></member>
    <member name="M:InTheHand.Net.Sockets.IrDAClient.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Sockets.IrDAClient" /> 
            class and connects to the specified service name.
            </summary>
            -
            <remarks><para>This is 
            equivalent to calling the default constructor followed by 
            <see cref="M:InTheHand.Net.Sockets.IrDAClient.Connect(System.String)" />.      
            </para><para>
            As noted the connection will be made to an arbitrary peer.  This is 
            most useful when it is expected that there will be only one device in 
            range  as is often the case.  If a connection is to be made to
            a particular remote peer, then use the 
            <see cref="M:InTheHand.Net.Sockets.IrDAClient.#ctor(InTheHand.Net.IrDAEndPoint)" />
            overload.
            </para><para>
            Infrared connections are made by specifying a Service Name, which can 
            be any value provided the participating devices refer the same name.
            </para><para>
            See <see cref="M:InTheHand.Net.Sockets.IrDAClient.Connect(System.String)" /> 
            for the errors that can occur.
            </para></remarks>
            -
            <param name="service">
            A <see cref="T:System.String" /> containing the service name to connect to.
            </param></member>
    <member name="M:InTheHand.Net.Sockets.IrDAClient.#ctor(InTheHand.Net.IrDAEndPoint)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Sockets.IrDAClient" /> 
            class and connects to the specified endpoint.
            </summary>
      <remarks>
        <para>
            This is 
            equivalent to calling the default constructor followed by 
            <see cref="M:InTheHand.Net.Sockets.IrDAClient.Connect(InTheHand.Net.IrDAEndPoint)" />.
            </para>
        <para>
            The endpoint specifies both the peer device and service name 
            to connect to.  If only one device is expected to be in range, or 
            an arbitrary peer device is suitable, then one can use 
            <see cref="M:InTheHand.Net.Sockets.IrDAClient.#ctor(System.String)" /> instead.
            </para>
      </remarks>
      <param name="remoteEP">
            An <see cref="T:InTheHand.Net.IrDAEndPoint" /> initialised with the address of the peer
            device and the service name to connect to.
            </param>
    </member>
    <member name="M:InTheHand.Net.Sockets.IrDAClient.DiscoverDevices">
      <summary>
            Obtains information about available devices.
            </summary>
            -
            <remarks><para>Returns a maximum of 8 devices, for more flexibility use the other overloads.</para></remarks>
            -
            <returns>The discovered devices as an array of <see cref="T:InTheHand.Net.Sockets.IrDADeviceInfo" />.</returns></member>
    <member name="M:InTheHand.Net.Sockets.IrDAClient.DiscoverDevices(System.Int32)">
      <summary>
            Obtains information about a specified number of devices.
            </summary>
            -
            <param name="maxDevices">The maximum number of devices to get information about.</param>
            -
            <returns>The discovered devices as an array of <see cref="T:InTheHand.Net.Sockets.IrDADeviceInfo" />.</returns></member>
    <member name="M:InTheHand.Net.Sockets.IrDAClient.DiscoverDevices(System.Int32,System.Net.Sockets.Socket)">
      <summary>
            Obtains information about available devices using a socket.
            </summary>
            -
            <param name="maxDevices">The maximum number of devices to get information about.</param><param name="irdaSocket">A <see cref="T:System.Net.Sockets.Socket" />
            to be uses to run the discovery process.
            It should have been created for the IrDA protocol</param>
            -
            <returns>The discovered devices as an array of <see cref="T:InTheHand.Net.Sockets.IrDADeviceInfo" />.</returns></member>
    <member name="M:InTheHand.Net.Sockets.IrDAClient.ParseDeviceList(System.Byte[])">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Sockets.IrDAClient.GetRemoteMachineName(System.Net.Sockets.Socket)">
      <summary>
            Gets the name of the peer device using the specified socket.
            </summary>
      <param name="irdaSocket">A connected IrDA <c>Socket</c>.</param>
      <returns>The name of the remote device.</returns>
            -
            <remarks>
            This finds the name of the device to which the socket is connection, 
            an exception will occur if the socket is not connected.
            </remarks>
            -
            <exception cref="T:System.ArgumentNullException"><c>s</c> is null (<c>Nothing</c> in Visual Basic).
            </exception><exception cref="T:System.ArgumentOutOfRangeException">
            The remote device is not present in the list of discovered devices.
            </exception><exception cref="T:System.InvalidOperationException">
            The socket is not connected.
            </exception></member>
    <member name="M:InTheHand.Net.Sockets.IrDAClient.Connect(InTheHand.Net.IrDAEndPoint)">
      <overloads>
            Forms a connection to the specified peer service.
            </overloads>
            --
            <summary>
            Forms a connection to the specified endpoint.
            </summary><remarks><para>
            The endpoint specifies both the peer device and service name 
            to connect to.  If only one device is expected to be in range, or 
            an arbitrary peer device is suitable, then one can use 
            <see cref="M:InTheHand.Net.Sockets.IrDAClient.Connect(System.String)" /> instead.
            </para></remarks><param name="remoteEP">
            An <see cref="T:InTheHand.Net.IrDAEndPoint" /> initialised with the address of the peer
            device and the service name to connect to.
            </param></member>
    <member name="M:InTheHand.Net.Sockets.IrDAClient.Connect(System.String)">
      <summary>
            Forms a connection to the specified service on an arbitrary peer.
            </summary>
      <remarks>
            As noted the connection will be made to an arbitrary peer.  This is 
            most useful when it is expected that there will be only one device in 
            range  as is often the case.  If a connection is to be made to
            a particular remote peer, then use 
            <see cref="M:InTheHand.Net.Sockets.IrDAClient.Connect(InTheHand.Net.IrDAEndPoint)" />.
            </remarks>
      <param name="service">The Service Name to connect to eg "<c>OBEX</c>".
            In the very uncommon case where a connection is to be made to a 
            specific LSAP-SEL (port number), then use 
            the form "<c>LSAP-SELn</c>", where n is an integer.</param>
            -
            <exception cref="T:System.InvalidOperationException">
            No peer IrDA device was found.  The exception has message No device.
            </exception><exception cref="T:System.Net.Sockets.SocketException">
            A connection could not be formed.  See the exception message or 
            <see cref="P:System.Net.Sockets.SocketException.SocketErrorCode" /> 
            (or <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> on NETCF) 
            for what error occurred.
            </exception></member>
    <member name="M:InTheHand.Net.Sockets.IrDAClient.BeginConnect(InTheHand.Net.IrDAEndPoint,System.AsyncCallback,System.Object)">
      <overloads>
            Begins an asynchronous request for a remote host connection.
            </overloads>
            -
            <summary>
            Begins an asynchronous request for a remote host connection.
            The remote host is specified by an endpoint. 
            </summary>
            -
            <param name="remoteEP">
            An <see cref="T:InTheHand.Net.IrDAEndPoint" /> initialised with the address of the peer
            device and the service name to connect to.
            </param><param name="requestCallback">An AsyncCallback delegate that references the method to invoke when the operation is complete.</param><param name="state">A user-defined object that contains information about the connect operation.
            This object is passed to the requestCallback delegate when the operation is complete.</param>
            -
            <returns>An <see cref="T:System.IAsyncResult" /> that represents the 
            asynchronous connect, which could still be pending.
            </returns></member>
    <member name="M:InTheHand.Net.Sockets.IrDAClient.BeginConnect(System.String,System.AsyncCallback,System.Object)">
      <summary>
            Begins an asynchronous request for a remote host connection.
            The remote host is specified by a service name (string). 
            </summary>
            -
            <param name="service">The service name of the remote host.</param><param name="requestCallback">An AsyncCallback delegate that references the method to invoke when the operation is complete.</param><param name="state">A user-defined object that contains information about the connect operation.
            This object is passed to the requestCallback delegate when the operation is complete.</param>
            -
            <returns>An <see cref="T:System.IAsyncResult" /> that represents the 
            asynchronous connect, which could still be pending.
            </returns>
            -
            <remarks><para>
            See <see cref="M:InTheHand.Net.Sockets.IrDAClient.Connect(System.String)" /> 
            for the errors that can occur.
            </para></remarks></member>
    <member name="M:InTheHand.Net.Sockets.IrDAClient.EndConnect(System.IAsyncResult)">
      <summary>
            Asynchronously accepts an incoming connection attempt.
            </summary>
      <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> object returned
            by a call to <see cref="M:InTheHand.Net.Sockets.IrDAClient.BeginConnect(InTheHand.Net.IrDAEndPoint,System.AsyncCallback,System.Object)" />
            / <see cref="M:InTheHand.Net.Sockets.IrDAClient.BeginConnect(System.String,System.AsyncCallback,System.Object)" />.
            </param>
    </member>
    <member name="M:InTheHand.Net.Sockets.IrDAClient.Close">
      <summary>
            Closes the <see cref="T:InTheHand.Net.Sockets.IrDAClient" /> and the underlying connection.
            </summary>
            -
            <remarks>The two XxxxxClient classes produced by Microsoft (TcpClient, 
            and IrDAClient in the NETCF) have various documented behaviours and various
            actual behaviours for close/dispose/finalize on the various platforms. :-(
            The current TcpClient implementation is that 
            Close/Dispose closes the connection by closing the underlying socket and/or
            NetworkStream, and finalization doesn't close either.  This is the behaviour
            we use for the here (for <see cref="T:InTheHand.Net.Sockets.BluetoothClient" />,
            <see cref="T:InTheHand.Net.Sockets.IrDAClient" />).  (The documentation in MSDN for 
            <see cref="T:System.Net.Sockets.TcpClient" /> is still wrong by-the-way,
            see <see href="https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=158480">
            Microsoft feedback #158480</see>).
            </remarks></member>
    <member name="M:InTheHand.Net.Sockets.IrDAClient.GetStream">
      <summary>
            Returns the <see cref="T:System.Net.Sockets.NetworkStream" /> used to send and receive data.
            </summary>
            -
            <returns>The underlying <c>NetworkStream</c>.</returns>
            -
            <remarks><para><c>GetStream</c> returns a <c>NetworkStream</c> 
            that you can use to send and receive data. The <c>NetworkStream</c> class 
            inherits from the <see cref="T:System.IO.Stream" /> class, which provides a 
            rich collection of methods and properties used to facilitate network communications.
            </para><para>You must call the <see cref="M:InTheHand.Net.Sockets.IrDAClient.Connect(InTheHand.Net.IrDAEndPoint)" /> 
            method, or one of its overloads, first, or 
            the <c>GetStream</c> method will throw an <c>InvalidOperationException</c>.
            After you have obtained the <c>NetworkStream</c>, call the 
            <see cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" />
            method to send data to the remote host.
            Call the <see cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" /> 
            method to receive data arriving from the remote host.
            Both of these methods block until the specified operation is performed.
            You can avoid blocking on a read operation by checking the 
            <see cref="P:System.Net.Sockets.NetworkStream.DataAvailable" /> property.
            A <c>true</c> value means that data has arrived from the remote host and
            is available for reading. In this case, <c>Read</c> is 
            guaranteed to complete immediately.
            If the remote host has shutdown its connection, <c>Read</c> will 
            immediately return with zero bytes.
            </para><note>
            Closing the <c>NetworkStream</c> closes the connection.  
            Similarly Closing, Disposing, or the finalization of the <c>IrDAClient</c> 
            Disposes the <c>NetworkStream</c>.
            This is new behaviour post 2.0.60828.0.
            <!-- [dodgy?]TcpClient documentation:
            You must close the NetworkStream when you are through sending and
            receiving data. Closing TcpClient does not release the NetworkStream.--></note><note>
            If you receive a SocketException, use SocketException.ErrorCode to obtain
            the specific error code. After you have obtained this code, you can refer
            to the Windows Sockets version 2 API error code documentation in MSDN
            for a detailed description of the error.
            </note></remarks>
            -
            <exception cref="T:System.InvalidOperationException">
            The <see cref="T:InTheHand.Net.Sockets.IrDAClient" /> is not connected to a remote host.
            </exception><exception cref="T:System.ObjectDisposedException">
            The <c>IrDAClient</c> has been closed.
            </exception></member>
    <member name="M:InTheHand.Net.Sockets.IrDAClient.Dispose(System.Boolean)">
      <summary>
            Releases the unmanaged resources used by the <see cref="T:InTheHand.Net.Sockets.IrDAClient" /> and optionally releases the managed resources.
            </summary>
      <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
    </member>
    <member name="M:InTheHand.Net.Sockets.IrDAClient.Dispose">
      <summary>
            Closes the <see cref="T:InTheHand.Net.Sockets.IrDAClient" /> and the underlying connection.
            </summary>
            -
            <seealso cref="M:InTheHand.Net.Sockets.IrDAClient.Close" /></member>
    <member name="P:InTheHand.Net.Sockets.IrDAClient.Active">
      <summary>
            Gets or set a value that indicates whether a connection has been made. 
            </summary>
    </member>
    <member name="P:InTheHand.Net.Sockets.IrDAClient.Available">
      <summary>
            The number of bytes of data received from the network and available to be read.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Sockets.IrDAClient.Client">
      <summary>
            Gets or sets the underlying <see cref="T:System.Net.Sockets.Socket" />.
            </summary>
      <remarks>
            This is particularly useful as it allows setting socket 
            options, for instance IrCOMM Cooked mode, ie
            <see cref="F:InTheHand.Net.Sockets.IrDASocketOptionName.NineWireMode" />.
            </remarks>
      <example>Example code to connect to a IrCOMM service would be as 
            follows, note the use of the Client property.
            <code lang="VB.NET">
            Public Shared Sub Main()
               Dim cli As New IrDAClient
               ' Set IrCOMM Cooked/9-wire mode.
               cli.Client.SetSocketOption( _
                 IrDASocketOptionLevel.IrLmp, _
                 IrDASocketOptionName.NineWireMode, _
                 1)  ' representing true
               ' Connect
               cli.Connect("IrDA:IrCOMM")
               ' Connected, now send and receive e.g. by using the 
               ' NetworkStream returned by cli.GetStream
               ...
            End Sub
            </code></example>
    </member>
    <member name="P:InTheHand.Net.Sockets.IrDAClient.Connected">
      <summary>
            Gets a value indicating whether the underlying <see cref="T:System.Net.Sockets.Socket" /> for an <see cref="T:InTheHand.Net.Sockets.IrDAClient" /> is connected to a remote host.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Sockets.IrDAClient.RemoteMachineName">
      <summary>
            Gets the name of the peer device participating in the communication.
            </summary>
            -
            <remarks>
            This finds the name of the device to which the client is connection, 
            an exception will occur if the socket is not connected.
            </remarks>
            -
            <exception cref="T:System.ArgumentOutOfRangeException">
            If the remote device is not found in the discovery cache.
            </exception><exception cref="T:System.InvalidOperationException">
            The socket is not connected.
            </exception></member>
    <member name="T:InTheHand.Net.Sockets.BluetoothClient">
      <summary>
            Provides client connections for Bluetooth RFCOMM network services.
            </summary>
      <remarks>
        <note>This class currently only supports devices which use the Microsoft 
            and Widcomm Bluetooth stacks, devices which use the other stacks will 
            not work.
            </note>
        <!--This para is in both the class remarks and in Connect(BtEndPoint)-->
        <para>When connecting
            normally an endpoint with an Address and a Service Class Id 
            is specified, then the system will automatically lookup the SDP 
            record on the remote device for that service class and connect to 
            the port number (RFCOMM Channel Number) specified there.
            If instead a port value is provided in the endpoint then the SDP 
            lookup will be skipped and  the system will connect to the specified 
            port directly.
            </para>
        <para>Note: Do not attempt to connect with service
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.RFCommProtocol">BluetoothService.RFCommProtocol</see>
            this class always uses RFCOMM, instead the Service Class Id of the 
            particular service to which you want to connect must be specified,
            perhaps
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.SerialPort">BluetoothService.SerialPort</see>,
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.ObexObjectPush">BluetoothService.ObexObjectPush</see>,
            or the unique UUID/<see cref="T:System.Guid" /> that you are using in
            your custom server application.
            </para>
      </remarks>
    </member>
    <member name="T:InTheHand.Net.Sockets.BluetoothClient.LiveDiscoveryCallback">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothClient.#ctor">
      <summary>
            Creates a new instance of <see cref="T:InTheHand.Net.Sockets.BluetoothClient" />.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothClient.#ctor(InTheHand.Net.BluetoothEndPoint)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> class and binds it to the specified local endpoint.
            </summary>
      <param name="localEP">The <see cref="T:InTheHand.Net.BluetoothEndPoint" /> to which you bind the Bluetooth Socket.
            Only necessary on multi-radio system where you want to select the local radio to use.</param>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothClient.DiscoverDevices">
      <summary>
            Discovers accessible Bluetooth devices, both remembered and in-range,
            and returns their names and addresses.
            </summary>
            -
            <remarks><para>This is equivalent to calling
            <see cref="M:InTheHand.Net.Sockets.BluetoothClient.DiscoverDevices(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />(255, true, true, true)
            </para></remarks>
            -
            <returns>An array of BluetoothDeviceInfo objects describing the devices discovered.</returns></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothClient.DiscoverDevices(System.Int32)">
      <summary>
            Discovers accessible Bluetooth devices, both remembered and in-range,
            and returns their names and addresses.
            </summary>
            -
            <remarks><para>This is equivalent to calling
            <see cref="M:InTheHand.Net.Sockets.BluetoothClient.DiscoverDevices(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />(maxDevices, true, true, true)
            </para></remarks>
            -
            <param name="maxDevices">The number of in-range devices to find before the inquiry may be stopped early.
            The result can contain more than this number of devices.
            </param>
            -
            <returns>An array of BluetoothDeviceInfo objects describing the devices discovered.</returns></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothClient.DiscoverDevices(System.Int32,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Discovers accessible Bluetooth devices, optionally remembered and in-range,
            and returns their names and addresses.
            </summary>
            -
            <param name="maxDevices">The number of in-range devices to find before the inquiry may be stopped early.
            The result can contain more than this number of devices.
            </param><param name="authenticated">True to return previously authenticated/paired devices.</param><param name="remembered">True to return remembered devices.</param><param name="unknown">True to return previously unknown devices.</param>
            -
            <returns>An array of BluetoothDeviceInfo objects describing the devices discovered.</returns></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothClient.DiscoverDevices(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
      <summary>
            Discovers accessible Bluetooth devices, optionally remembered and in-range or just in-range,
            and returns their names and addresses.
            </summary>
            -
            <remarks><para>The <paramref name="discoverableOnly" /> parameter is not supported 
            on the Microsoft stack on WinXP as the stack there returns the remembered and Device-Inquiry-results already 
            merged, it is however supported on Windows 7.
            It is supported on WM/CE and on Widcomm (both platforms).
            Note when that flag is set the other related flag values are ignored.
            </para><para>To remove devices from the list of remembered/authenticated
            devices use <see cref="M:InTheHand.Net.Bluetooth.BluetoothSecurity.RemoveDevice(InTheHand.Net.BluetoothAddress)">BluetoothSecurity.RemoveDevice</see></para></remarks>
            -
            <param name="maxDevices">The number of in-range devices to find before the inquiry may be stopped early.
            The result can contain more than this number of devices.
            </param><param name="authenticated">True to return previously authenticated/paired devices.</param><param name="remembered">True to return remembered devices.</param><param name="unknown">True to return previously unknown devices.</param><param name="discoverableOnly">True to return only the devices that 
            are in range, and in discoverable mode.  See the remarks section.</param>
            -
            <returns>An array of BluetoothDeviceInfo objects describing the devices discovered.</returns></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothClient.DiscoverDevicesInRange">
      <summary>
            Discovers Bluetooth devices that are in range and are in discoverable mode
            </summary>
            -
            <remarks><para>This is equivalent to calling
            <see cref="M:InTheHand.Net.Sockets.BluetoothClient.DiscoverDevices(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />(255, false, false, false, true)
            </para></remarks>
            -
            <returns>An array of BluetoothDeviceInfo objects describing the devices discovered.</returns></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothClient.BeginDiscoverDevices(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.AsyncCallback,System.Object)">
      <summary>
            An asynchronous version of <see cref="M:InTheHand.Net.Sockets.BluetoothClient.DiscoverDevices(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" /></summary>
            -
            <param name="maxDevices">See <see cref="M:InTheHand.Net.Sockets.BluetoothClient.DiscoverDevices(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />.
            </param><param name="authenticated">See <see cref="M:InTheHand.Net.Sockets.BluetoothClient.DiscoverDevices(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />.
            </param><param name="remembered">See <see cref="M:InTheHand.Net.Sockets.BluetoothClient.DiscoverDevices(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />.
            </param><param name="unknown">See <see cref="M:InTheHand.Net.Sockets.BluetoothClient.DiscoverDevices(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />.
            </param><param name="discoverableOnly">See <see cref="M:InTheHand.Net.Sockets.BluetoothClient.DiscoverDevices(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />.
            </param><param name="callback">An optional asynchronous callback, to be called 
            when the discovery is complete.
            </param><param name="state">A user-provided object that distinguishes this 
            particular asynchronous discovery request from other requests.
            </param>
            -
            <returns>An <see cref="T:System.IAsyncResult" /> that represents the 
            asynchronous discovery, which could still be pending.
            </returns></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothClient.EndDiscoverDevices(System.IAsyncResult)">
      <summary>
            Ends an asynchronous Service Record lookup query.
            </summary>
            -
            <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> returned
            by <see cref="M:InTheHand.Net.Sockets.BluetoothClient.BeginDiscoverDevices(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean,System.AsyncCallback,System.Object)" />.
            </param>
            -
            <returns>See <see cref="M:InTheHand.Net.Sockets.BluetoothClient.DiscoverDevices(System.Int32,System.Boolean,System.Boolean,System.Boolean,System.Boolean)" />.
            </returns></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothClient.Connect(InTheHand.Net.BluetoothEndPoint)">
      <summary>
            Connects a client to a specified endpoint.
            </summary>
            -
            <param name="remoteEP">A <see cref="T:InTheHand.Net.BluetoothEndPoint" /> that represents the server on the remote device.</param>
            -
            <remarks><!--This para is in both the class remarks and in Connect(BtEndPoint)--><para>Normally an endpoint with an Address and a Service Class Id 
            is specified, then the system will automatically lookup the SDP 
            record on the remote device for that service class and connect to 
            the port number (RFCOMM Channel Number) specified there.
            If instead a port value is provided in the endpoint then the SDP 
            lookup will be skipped and  the system will connect to the specified 
            port directly.
            </para><para>Note: Do not attempt to connect with service
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.RFCommProtocol">BluetoothService.RFCommProtocol</see>.
            See the <see cref="T:InTheHand.Net.Sockets.BluetoothClient">class</see> remarks for more information.
            </para></remarks></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothClient.Connect(InTheHand.Net.BluetoothAddress,System.Guid)">
      <summary>
            Connects the client to a remote Bluetooth host using the specified Bluetooth address and service identifier. 
            </summary>
            -
            <remarks><!--This para is in both the class remarks and in Connect(BtEndPoint)--><para>The system will automatically lookup the SDP 
            record on the remote device for that service class and connect to 
            the port number (RFCOMM Channel Number) specified there.
            </para><para>Note: Do not attempt to connect with service
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.RFCommProtocol">BluetoothService.RFCommProtocol</see>.
            See the <see cref="T:InTheHand.Net.Sockets.BluetoothClient">class</see> remarks for more information.
            </para></remarks>
            -
            <param name="address">The <see cref="T:InTheHand.Net.BluetoothAddress" /> of the remote host.
            </param><param name="service">The Service Class Id of the service on the remote host.
            The standard Bluetooth Service Classes are provided on class 
            <see cref="T:InTheHand.Net.Bluetooth.BluetoothService" />.
            </param></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothClient.BeginConnect(InTheHand.Net.BluetoothAddress,System.Guid,System.AsyncCallback,System.Object)">
      <summary>
            Begins an asynchronous request for a remote host connection.
            The remote host is specified by a <see cref="T:InTheHand.Net.BluetoothAddress" /> and a service identifier (Guid). 
            </summary>
            -
            <remarks><para>See the <see cref="M:InTheHand.Net.Sockets.BluetoothClient.Connect(InTheHand.Net.BluetoothAddress,System.Guid)" />
            method for information on the usage of the values in the endpoint.
            </para></remarks>
            -
            <param name="address">The <see cref="T:InTheHand.Net.BluetoothAddress" /> of the remote host.
            </param><param name="service">The Service Class Id of the service on the remote host.
            The standard Bluetooth Service Classes are provided on class 
            <see cref="T:InTheHand.Net.Bluetooth.BluetoothService" /></param><param name="requestCallback">An <see cref="T:System.AsyncCallback" /> delegate that 
            references the method to invoke when the operation is complete.
            </param><param name="state">A user-defined object that contains information 
            about the connect operation. This object is passed to the <paramref name="requestCallback" /> 
            delegate when the operation is complete.
            </param>
            -
            <returns>An <see cref="T:System.IAsyncResult" /> that represents the 
            asynchronous connect, which could still be pending.
            </returns></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothClient.BeginConnect(InTheHand.Net.BluetoothEndPoint,System.AsyncCallback,System.Object)">
      <summary>
            Begins an asynchronous request for a remote host connection.
            The remote server is specified by a <see cref="T:InTheHand.Net.BluetoothEndPoint" />. 
            </summary>
            -
            <param name="remoteEP">A <see cref="T:InTheHand.Net.BluetoothEndPoint" /> that 
            represents the server on the remote device.
            See the <see cref="M:InTheHand.Net.Sockets.BluetoothClient.Connect(InTheHand.Net.BluetoothEndPoint)" />
            method for information on the usage of the values in the endpoint.
            </param><param name="requestCallback">An <see cref="T:System.AsyncCallback" /> delegate that 
            references the method to invoke when the operation is complete.
            </param><param name="state">A user-defined object that contains information 
            about the connect operation. This object is passed to the <paramref name="requestCallback" /> 
            delegate when the operation is complete.
            </param>
            -
            <remarks><para>See the <see cref="M:InTheHand.Net.Sockets.BluetoothClient.Connect(InTheHand.Net.BluetoothEndPoint)" />
            method for information on the usage of the values in the endpoint.
            </para></remarks>
            -
            <returns>An <see cref="T:System.IAsyncResult" /> that represents the 
            asynchronous connect, which could still be pending.
            </returns></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothClient.EndConnect(System.IAsyncResult)">
      <summary>
            Asynchronously accepts an incoming connection attempt.
            </summary>
      <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> object returned by a call to 
            <see cref="M:InTheHand.Net.Sockets.BluetoothClient.BeginConnect(InTheHand.Net.BluetoothEndPoint,System.AsyncCallback,System.Object)" />
            / <see cref="M:InTheHand.Net.Sockets.BluetoothClient.BeginConnect(InTheHand.Net.BluetoothAddress,System.Guid,System.AsyncCallback,System.Object)" />.
            </param>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothClient.Close">
      <summary>
            Closes the <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> and the underlying connection.
            </summary>
            -
            <remarks>The two XxxxxClient classes produced by Microsoft (TcpClient, 
            and IrDAClient in the NETCF) have had various documented behaviours and various
            actual behaviours for close/dispose/finalize on the various platforms. :-(
            The current TcpClient implementation on is that 
            Close/Dispose closes the connection by closing the underlying socket and/or
            NetworkStream, and finalization doesn't close either.  This is the behaviour
            we use for the here (for <see cref="T:InTheHand.Net.Sockets.BluetoothClient" />,
            <see cref="T:InTheHand.Net.Sockets.IrDAClient" />).  (The documentation in MSDN for 
            <see cref="T:System.Net.Sockets.TcpClient" /> is still wrong by-the-way,
            see <see href="https://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=158480">
            Microsoft feedback #158480</see>).
            </remarks></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothClient.GetStream">
      <summary>
            Gets the underlying stream of data.
            </summary>
      <returns>The underlying <see cref="T:System.Net.Sockets.NetworkStream" />.</returns>
      <remarks>
        <see cref="M:InTheHand.Net.Sockets.BluetoothClient.GetStream" /> returns a <see cref="T:System.Net.Sockets.NetworkStream" /> that you can use to send and receive data.
            The <see cref="T:System.Net.Sockets.NetworkStream" /> class inherits from the <see cref="T:System.IO.Stream" /> class, which provides a rich collection of methods and properties used to facilitate network communications.
            <para>You must call the <see cref="M:InTheHand.Net.Sockets.BluetoothClient.Connect(InTheHand.Net.BluetoothEndPoint)" /> / <see cref="M:InTheHand.Net.Sockets.BluetoothClient.Connect(InTheHand.Net.BluetoothAddress,System.Guid)" />
            method first, or the <see cref="M:InTheHand.Net.Sockets.BluetoothClient.GetStream" /> method will throw an <see cref="T:System.InvalidOperationException" />.
            After you have obtained the <see cref="T:System.Net.Sockets.NetworkStream" />, call the <see cref="M:System.Net.Sockets.NetworkStream.Write(System.Byte[],System.Int32,System.Int32)" /> method to send data to the remote host.
            Call the <see cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" /> method to receive data arriving from the remote host.
            Both of these methods block until the specified operation is performed.
            You can avoid blocking on a read operation by checking the <see cref="P:System.Net.Sockets.NetworkStream.DataAvailable" /> property.
            A true value means that data has arrived from the remote host and is available for reading.
            In this case, <see cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" /> is guaranteed to complete immediately.
            If the remote host has shutdown its connection, <see cref="M:System.Net.Sockets.NetworkStream.Read(System.Byte[],System.Int32,System.Int32)" /> will immediately return with zero bytes.</para></remarks>
      <exception cref="T:System.InvalidOperationException">The <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> is not connected to a remote host.</exception>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> has been closed.</exception>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothClient.SetPin(System.String)">
      <summary>
            Sets the PIN associated with the remote device.
            </summary>
      <param name="pin">PIN which must be composed of 1 to 16 ASCII characters.</param>
      <remarks>
        <para>Is not supported on all platforms.
            For instance see the Widcomm documentation 
            </para>
        <para>Assigning null (Nothing in VB) or an empty String will revoke the PIN.
            </para>
        <para>In version 2.3 could only be called when connected.
            </para>
      </remarks>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothClient.SetPin(InTheHand.Net.BluetoothAddress,System.String)">
      <summary>
            Set or change the PIN to be used with a specific remote device.
            </summary>
      <param name="device">Address of Bluetooth device.</param>
      <param name="pin">PIN string consisting of 1 to 16 ASCII characters.</param>
      <remarks>
        <para>Is not supported on all platforms.
            For instance see the Widcomm documentation 
            </para>
        <para>Assigning null (Nothing in VB) or an empty String will revoke the PIN.
            </para>
      </remarks>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothClient.GetRemoteMachineName(InTheHand.Net.BluetoothAddress)">
      <summary>
            Gets the name of the specified remote device.
            </summary>
      <param name="a">Address of remote device.</param>
      <returns>Friendly name of specified device.</returns>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothClient.GetRemoteMachineName(System.Net.Sockets.Socket)">
      <summary>
            Gets the name of a device by a specified socket.
            </summary>
      <param name="s"> A <see cref="T:System.Net.Sockets.Socket" />.</param>
      <returns>Returns a string value of the computer or device name.</returns>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothClient.Dispose">
      <summary>
            Closes the <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> and the underlying connection.
            </summary>
            -
            <seealso cref="M:InTheHand.Net.Sockets.BluetoothClient.Close" /></member>
    <member name="P:InTheHand.Net.Sockets.BluetoothClient.InquiryAccessCode">
      <summary>
            Get or set the Device Discovery Inquiry Access Code.
            </summary>
            -
            <remarks><para>This is supported only the Microsoft stack on WindowsMobile/etc.
            It is not supported on any other platforms.
            </para><para>The default value is
            <see cref="F:InTheHand.Net.BluetoothAddress.Giac">GIAC</see> (0x9E8B33).
            See also constant 
            <see cref="F:InTheHand.Net.BluetoothAddress.Liac">LIAC</see> (0x9E8B00).
            The valid range is 0x9E8B00 through 0x9E8B3f.
            </para></remarks>
            -
            <value>An <see cref="T:System.Int32" /> containing the Access Code
            to be used for Inquiry.
            </value></member>
    <member name="P:InTheHand.Net.Sockets.BluetoothClient.InquiryLength">
      <summary>
            Amount of time allowed to perform the query.
            </summary>
      <remarks>On Windows CE the actual value used is expressed in units of 1.28 seconds, so will be the nearest match for the value supplied.
            The default value is 10 seconds. The maximum is 60 seconds.</remarks>
    </member>
    <member name="P:InTheHand.Net.Sockets.BluetoothClient.Available">
      <summary>
            Gets the amount of data that has been received from the network and is available to be read.
            </summary>
      <value>The number of bytes of data received from the network and available to be read.</value>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
    </member>
    <member name="P:InTheHand.Net.Sockets.BluetoothClient.Client">
      <summary>
            Gets or sets the underlying <see cref="T:System.Net.Sockets.Socket" />.
            </summary>
            -
            <value>The underlying network <see cref="T:System.Net.Sockets.Socket" />.</value>
            -
            <remarks><note>The property is only supported on Microsoft Bluetooth stack platforms.
            </note></remarks></member>
    <member name="P:InTheHand.Net.Sockets.BluetoothClient.Connected">
      <summary>
            Gets a value indicating whether the underlying <see cref="T:System.Net.Sockets.Socket" /> for a <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> is connected to a remote host.
            </summary>
      <value>true if the <see cref="P:InTheHand.Net.Sockets.BluetoothClient.Client" /> socket was connected to a remote resource as of the most recent operation; otherwise, false.</value>
    </member>
    <member name="P:InTheHand.Net.Sockets.BluetoothClient.LingerState">
      <summary>
            Gets or sets a value that specifies whether the client will delay closing 
            in an attempt to send all pending data.
            </summary>
            -
            <remarks><para>See <see cref="P:System.Net.Sockets.Socket.LingerState">Socket.LingerState</see>.
            </para><para>In Widcomm, linger <c>false</c> (disabled) is not supported.
            </para></remarks>
            -
            <value>A <see cref="T:System.Net.Sockets.LingerOption" /> that specifies 
            how to linger while closing a socket.
            </value></member>
    <member name="P:InTheHand.Net.Sockets.BluetoothClient.Authenticate">
      <summary>
            Gets or sets the authentication state of the current connect or behaviour to use when connection is established.
            </summary>
      <remarks>
            For disconnected sockets, specifies that authentication is required in order for a connect or accept operation to complete successfully.
            Setting this option actively initiates authentication during connection establishment, if the two Bluetooth devices were not previously authenticated.
            The user interface for passkey exchange, if necessary, is provided by the operating system outside the application context.
            For outgoing connections that require authentication, the connect operation fails with WSAEACCES if authentication is not successful.
            In response, the application may prompt the user to authenticate the two Bluetooth devices before connection.
            For incoming connections, the connection is rejected if authentication cannot be established and returns a WSAEHOSTDOWN error.
            </remarks>
    </member>
    <member name="P:InTheHand.Net.Sockets.BluetoothClient.Encrypt">
      <summary>
            On unconnected sockets, enforces encryption to establish a connection.
            Encryption is only available for authenticated connections.
            For incoming connections, a connection for which encryption cannot be established is automatically rejected and returns WSAEHOSTDOWN as the error.
            For outgoing connections, the connect function fails with WSAEACCES if encryption cannot be established.
            In response, the application may prompt the user to authenticate the two Bluetooth devices before connection.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Sockets.BluetoothClient.LinkKey">
      <summary>
            Returns link key associated with peer Bluetooth device.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Sockets.BluetoothClient.LinkPolicy">
      <summary>
            Returns the Link Policy of the current connection.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Sockets.BluetoothClient.RemoteEndPoint">
      <summary>
            Get the remote endpoint.
            </summary>
            -
            <value>
            The <see cref="T:InTheHand.Net.BluetoothEndPoint" /> with which the 
            <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> is communicating.
            </value>
            -
            <remarks><para>Note it can't be guaranteed that the <see cref="P:InTheHand.Net.BluetoothEndPoint.Service" />
            and <see cref="P:InTheHand.Net.BluetoothEndPoint.Port" /> parts
            of the returned endpoint are valid; and this will affect the
            <see cref="M:InTheHand.Net.BluetoothEndPoint.ToString" /> output.
            In particular, on MSFT, the <see cref="P:InTheHand.Net.Sockets.BluetoothClient.RemoteEndPoint" />
            for a client connection seems to have no <see cref="P:InTheHand.Net.BluetoothEndPoint.Port" />
            and a garbage <see cref="P:InTheHand.Net.BluetoothEndPoint.Service" />,
            so we would display garbage there in <see cref="M:InTheHand.Net.BluetoothEndPoint.ToString" />.
            An in-bound/server connection however does have a valid Port.
            (There the endpoints are returned from the native socket).
            On the other hand on Widcomm, Bluetopia and on BlueSoleil the
            opposite is the case: for a client the Port is known but it isn't
            for a server, and the <see cref="P:InTheHand.Net.BluetoothEndPoint.Service" />
            is blank in both cases.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Sockets.BluetoothClient.RemoteMachineName">
      <summary>
            Gets the name of the remote device.
            </summary>
    </member>
    <member name="T:InTheHand.Net.IrDA.IrDAAttributeType">
      <summary>
            Defines the type of an IAS attribute.
            </summary>
    </member>
    <member name="F:InTheHand.Net.IrDA.IrDAAttributeType.Integer">
      <summary>
            Identifies an integer attribute value.
            </summary>
    </member>
    <member name="F:InTheHand.Net.IrDA.IrDAAttributeType.OctetSequence">
      <summary>
            Identifies a binary, or octet, attribute value.
            </summary>
    </member>
    <member name="F:InTheHand.Net.IrDA.IrDAAttributeType.String">
      <summary>
            Identifies a string attribute value.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.ServiceRecordBuilder">
      <summary>
            Provides a simple way to build a <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />, 
            including ServiceClassIds and ServiceNames attributes etc.
            </summary>
            -
            <remarks><para>The services Class Id can be set with the 
            <see cref="M:InTheHand.Net.Bluetooth.ServiceRecordBuilder.AddServiceClass(System.Guid)" />/<see cref="M:InTheHand.Net.Bluetooth.ServiceRecordBuilder.AddServiceClass(System.UInt16)" />/etc
            methods, the protocol stack set with the <see cref="P:InTheHand.Net.Bluetooth.ServiceRecordBuilder.ProtocolType" />
            property (default RFCOMM), and the Service Name set with the 
            <see cref="P:InTheHand.Net.Bluetooth.ServiceRecordBuilder.ServiceName" />
            property.  Other properties and methods exist for controlling the more advanced 
            attributes.
            </para><para>Adding the standard text-string attributes (ServiceName etc) is normally quite
            difficult due to the very baroque manner of specifying these strings character 
            encoding and natural language.  The builder handles all the complexity internally; 
            the strings are written in UTF-8 encoding and marked as 'English' language.
            </para></remarks>
            -
            <example><code>
            ServiceRecordBuilder bldr = new ServiceRecordBuilder();
            bldr.AddServiceClass(BluetoothService.SerialPort);
            bldr.ServiceName = "Alan's SPP service";
            //
            ServiceRecord rcd = bldr.ServiceRecord;
            </code><code>
            ServiceRecordBuilder bldr = new ServiceRecordBuilder();
            bldr.ProtocolType = BluetoothProtocolDescriptorType.GeneralObex;
            bldr.AddServiceClass(BluetoothService.ObexFileTransfer);
            bldr.ServiceName = "Alan's FTP service";
            //
            ServiceRecord rcd = bldr.ServiceRecord;
            </code></example></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordBuilder.#ctor">
      <summary>
            Create a new instance of the <see cref="T:InTheHand.Net.Bluetooth.ServiceRecordBuilder" /> class.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordBuilder.ReportIfDuplicates(System.Collections.Generic.List{InTheHand.Net.Bluetooth.ServiceAttribute},System.Boolean)">
      <param name="list">The list to check for duplicates.
            </param>
      <param name="storedList">
        <c>true</c> if checking a previously stored list 
            of attributes, and <c>false</c> if checking a immediate addition of an 
            attribute. Thus throws <c>InvalidOperationException</c> and 
            <c>ArgumentException</c> respectively.
            </param>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordBuilder.AddServiceClass(System.Guid)">
      <summary>
            Add a Service Class Id.
            </summary>
            -
            <remarks><para>Multiple class ids can be added, and they will be written to the 
            <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceClassIdList" />
            attribute in the order in which they were set.
            </para></remarks>
            -
            <param name="uuid128">A <see cref="T:System.Guid" /> containing a 
            UUID for the advertised service.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordBuilder.AddServiceClass(System.UInt16)">
      <summary>
            Add a Service Class Id.
            </summary>
            -
            <remarks><para>Multiple class ids can be added, and they will be written to the 
            <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceClassIdList" />
            attribute in the order in which they were set.
            </para></remarks>
            -
            <param name="uuid16">A <see cref="T:System.UInt16" /> containing a short-form 
            UUID for the advertised service.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordBuilder.AddServiceClass(System.UInt32)">
      <summary>
            Add a Service Class Id.
            </summary>
            -
            <remarks><para>Multiple class ids can be added, and they will be written to the 
            <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceClassIdList" />
            attribute in the order in which they were set.
            </para></remarks>
            -
            <param name="uuid32">A <see cref="T:System.UInt32" /> containing a short-form 
            UUID for the advertised service.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordBuilder.AddServiceClass(System.Int32)">
      <summary>
            Add a Service Class Id.
            </summary>
            -
            <remarks><para>Multiple class ids can be added, and they will be written to the 
            <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceClassIdList" />
            attribute in the order in which they were set.
            </para></remarks>
            -
            <param name="uuid16or32">A <see cref="T:System.Int32" /> containing a short-form 
            UUID for the advertised service.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordBuilder.AddBluetoothProfileDescriptor(System.Guid,System.Byte,System.Byte)">
      <summary>
            Add a <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.BluetoothProfileDescriptorList" /> 
            element.
            </summary>
            -
            <param name="classId">The Service Class Id of the Bluetooth profile, 
            as a <see cref="T:System.Guid" /></param><param name="majorVersion">The major version number, as a <see cref="T:System.Byte" />.
            </param><param name="minorVersion">The minor version number, as a <see cref="T:System.Byte" />.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordBuilder.AddCustomAttributes(System.Collections.Generic.IEnumerable{InTheHand.Net.Bluetooth.ServiceAttribute})">
      <summary>
            Add a set of custom attribute.
            </summary>
            -
            <param name="serviceAttributes">A set of attributes as an 
            <see cref="T:System.Collections.Generic.IEnumerable`1" /> returning 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" /> instances.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordBuilder.AddCustomAttributes(System.Collections.IEnumerable)">
      <summary>
            Add a set of custom attribute.
            </summary>
            -
            <param name="serviceAttributes">A set of attributes as an 
            <see cref="T:System.Collections.IEnumerable" /> returning 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" /> instances.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordBuilder.AddCustomAttributes(InTheHand.Net.Bluetooth.ServiceAttribute[])">
      <summary>
            Add a set of custom attribute.
            </summary>
            -
            <param name="serviceAttributes">A set of attributes as an array of 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" />.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordBuilder.AddCustomAttribute(InTheHand.Net.Bluetooth.ServiceAttribute)">
      <overloads>
            Add a custom attribute.
            </overloads>
            -
            <summary>
            Add a custom attribute from a given <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" /></summary>
            -
            <param name="serviceAttribute">An attribute as a 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" /> instance.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordBuilder.AddCustomAttribute(InTheHand.Net.Bluetooth.ServiceAttributeId,InTheHand.Net.Bluetooth.ElementType,System.Object)">
      <summary>
            Add a custom attribute of simple type.
            </summary>
            -
            <remarks><para>If the <paramref name="elementType" /> is a numerical type
            then this is equivalent to using
            <see cref="M:InTheHand.Net.Bluetooth.ServiceElement.CreateNumericalServiceElement(InTheHand.Net.Bluetooth.ElementType,System.Object)" />
            otherwise the value is used directly in creating the
            <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" />.
            </para></remarks>
            -
            <param name="id">The Attribute Id as a <see cref="T:InTheHand.Net.Bluetooth.ServiceAttributeId" />.</param><param name="elementType">The type of the element as an <see cref="T:InTheHand.Net.Bluetooth.ElementType" />.</param><param name="value">The value for the new element.</param></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordBuilder.AddCustomAttribute(System.UInt16,InTheHand.Net.Bluetooth.ElementType,System.Object)">
      <summary>
            Add a custom attribute of simple type.
            </summary>
            -
            <remarks><para>If the <paramref name="elementType" /> is a numerical type
            then this is equivalent to using
            <see cref="M:InTheHand.Net.Bluetooth.ServiceElement.CreateNumericalServiceElement(InTheHand.Net.Bluetooth.ElementType,System.Object)" />
            otherwise the value is used directly in creating the
            <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" />.
            </para></remarks>
            -
            <param name="id">The Attribute Id as a <see cref="T:System.UInt16" />.</param><param name="elementType">The type of the element as an <see cref="T:InTheHand.Net.Bluetooth.ElementType" />.</param><param name="value">The value for the new element.</param></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecordBuilder.FromJsr82ServerUri(System.String)">
      <summary>
             Converts a Java JSR 82 Bluetooth server URL into a 
             <see cref="T:InTheHand.Net.Bluetooth.ServiceRecordBuilder" /> instance.
             </summary>
             -
             <remarks><note type="caution">The <c>authenticate</c> and <c>encrypt</c> and any 
             related parameters are completely disregarded.  When using with 
             <see cref="T:InTheHand.Net.Sockets.BluetoothListener" /> you must take 
             care to set the required security requirements on it directly.
             </note>
             This method is intended to read the Service Record (SDP) related items only; 
             in particular the Service Class ID UUID and Service Name parameters.
             It supports only the <c>btspp</c> and <c>btObex</c> schemes and only for
             server-side use only.  For instance
            <code lang="none">btspp://localhost:3B9FA89520078C303355AAA694238F08;name=FooBar</code>
             and
            <code lang="none">btgoep://localhost:3B9FA89520078C303355AAA694238F08</code>
             There is no suppport for e.g.
            <code lang="none">btl2cap://localhost:3B9FA89520078C303355AAA694238F08;name=Aserv</code>
             as the library supports only RFCOMM connections currently.
             </remarks>
             -
             <param name="url">A server-side JSR 82 URL in one of the supported forms.
             </param>
             -
             <returns>A <see cref="T:InTheHand.Net.Bluetooth.ServiceRecordBuilder" /> 
             initialised with the supported components of the supplied JSR 82 URL.
             </returns></member>
    <member name="P:InTheHand.Net.Bluetooth.ServiceRecordBuilder.ServiceRecord">
      <summary>
            Gets the <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> instance 
            constructed by the specified <see cref="T:InTheHand.Net.Bluetooth.ServiceRecordBuilder" /> instance.
            </summary>
            -
            <value>
            A <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> that contains 
            the URI constructed by the <see cref="T:InTheHand.Net.Bluetooth.ServiceRecordBuilder" /> .
            </value>
            -
            <exception cref="T:System.InvalidOperationException">The <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> 
            created by the <see cref="T:InTheHand.Net.Bluetooth.ServiceRecordBuilder" /> properties is invalid.
            For instance, if duplicates attributes are disallowed but duplicates are 
            present.
            </exception></member>
    <member name="P:InTheHand.Net.Bluetooth.ServiceRecordBuilder.ServiceName">
      <summary>
            Get or set a value for the <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceName" /> 
            attribute.
            </summary>
            -
            <remarks><para>When present, a corresponding <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.LanguageBaseAttributeIdList" /> 
            attribute will be added too.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.ServiceRecordBuilder.ProviderName">
      <summary>
            Get or set a value for the <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProviderName" /> 
            attribute.
            </summary>
            -
            <remarks><para>When present, a corresponding <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.LanguageBaseAttributeIdList" /> 
            attribute will be added too.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.ServiceRecordBuilder.ServiceDescription">
      <summary>
            Get or set a value for the <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceDescription" /> 
            attribute.
            </summary>
            -
            <remarks><para>When present, a corresponding <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.LanguageBaseAttributeIdList" /> 
            attribute will be added too.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.ServiceRecordBuilder.ProtocolType">
      <summary>
            Get or set which type of element will be added for the <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList" /> 
            attribute.
            </summary>
            -
            <value>An instance of the <see cref="T:InTheHand.Net.Bluetooth.BluetoothProtocolDescriptorType" /> 
            enumeration.
            </value>
            -
            <remarks><para>Supported type are the following:
            </para><list type="bullet"><item><term>None</term><description>No PDL attribute will be added.</description></item><item><term>Rfcomm</term><description>A standard RFCOMM element will be added.</description></item><item><term>Goep</term><description>A standard GOEP (OBEX) element will be added.</description></item></list><para>The default is <see cref="F:InTheHand.Net.Bluetooth.BluetoothProtocolDescriptorType.Rfcomm" />.
            </para></remarks></member>
    <member name="T:InTheHand.Net.Bluetooth.ServiceRecord">
      <summary>
            Holds an SDP service record.
            </summary>
            -
            <remarks><para>A Service Record is the top-level container in the Service Discovery
            protocol/database.  It contains a list of Service Attributes each identified 
            by a numerical identifier (its <see cref="T:InTheHand.Net.Bluetooth.ServiceAttributeId" />),
            and with its data held in a <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" />.
            <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" /> has methods to access the
            various types of data it contains.
            </para><para>The content of the record for a particular service class is defined in the
            profiles specification along with the IDs it uses. The IDs for the 
            common standard services have beed defined here, as e.g. 
            <see cref="T:InTheHand.Net.Bluetooth.AttributeIds.ObexAttributeId" />,
            <see cref="T:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId" />,
            etc. The Service Discovery profile itself defines IDs, some that can be used 
            in any record <see cref="T:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId" />, 
            and others
            <see cref="T:InTheHand.Net.Bluetooth.AttributeIds.ServiceDiscoveryServerAttributeId" />,
            and <see cref="T:InTheHand.Net.Bluetooth.AttributeIds.BrowseGroupDescriptorAttributeId" />.
            </para><para>Note that except for the attributes in the Universal category 
            the IDs are <i>not</i> unique, for instance the ID is 0x0200 for both 
            <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.ServiceDiscoveryServerAttributeId.VersionNumberList" />
            and <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.BrowseGroupDescriptorAttributeId.GroupId" />
            from <see cref="T:InTheHand.Net.Bluetooth.AttributeIds.ServiceDiscoveryServerAttributeId" />
            and <see cref="T:InTheHand.Net.Bluetooth.AttributeIds.BrowseGroupDescriptorAttributeId" />
            respectively.
            </para><para><see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> provides the normal 
            collection-type methods properties e.g. 
            <see cref="P:InTheHand.Net.Bluetooth.ServiceRecord.Count" />, 
            <see cref="M:InTheHand.Net.Bluetooth.ServiceRecord.Contains(InTheHand.Net.Bluetooth.ServiceAttributeId)" />,
            <see cref="M:InTheHand.Net.Bluetooth.ServiceRecord.GetAttributeById(InTheHand.Net.Bluetooth.ServiceAttributeId)" />,
            <see cref="P:InTheHand.Net.Bluetooth.ServiceRecord.Item(System.Int32)" />
            and <see cref="M:InTheHand.Net.Bluetooth.ServiceRecord.GetEnumerator" />.  So, to 
            access a particular attributes content get the 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" /> using one of those methods 
            and then read the data from the <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" />. 
            See the example below.
            </para><para>
            </para><para>The SDP specification defines the content of <c>TextString</c> element
            type very loosely and they are thus very difficult to handle when reading 
            from a record.
            The encoding of the string content is
            not set in the specification, and thus implementors are free to use any 
            encoding they fancy, for instance ASCII, UTF-8, 
            UTF-16, Windows-1252, etc  all of which have been seen in record 
            from real devices.  It would have been much more sensible to mandate UTF-8 
            as the other part of the Bluetooth protocol suite do e.g. the PIN is always
            stored as a UTF-8 encoded string.
            </para><para>Not only that but some of the attributes defined in the SDP specification
            can be included in more than one natural language version,
            and the definition of the language and the strings encoding
            is not included in the element, but is 
            instead defined in a separate element and the ID of the string attribute
            modified.  Yikes!
            </para><para>  This makes it near impossible to decode the bytes in
            a string element at parse time and create the string object then.  Therefore
            the parser creates an element containing the raw bytes from the string which
            hopefully the user will know how to decode, passing the required encoding 
            information to one of methods on the element i.e.
            <see cref="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsString(InTheHand.Net.Bluetooth.LanguageBaseItem)" />,
            which takes a multi-language-base item from the same record (see e.g.
            <see cref="M:InTheHand.Net.Bluetooth.ServiceRecord.GetPrimaryLanguageBaseItem" />),
            <see cref="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsString(System.Text.Encoding)" />
            which takes a .NET <see cref="T:System.Text.Encoding" /> object,
            or <see cref="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsStringUtf8" />,
            or <see cref="M:InTheHand.Net.Bluetooth.ServiceRecord.GetMultiLanguageStringAttributeById(InTheHand.Net.Bluetooth.ServiceAttributeId,InTheHand.Net.Bluetooth.LanguageBaseItem)" />
            on the record which again takes a multi-language-base item.
            </para><para>
            </para><para>A Service Record can be created from the source byte array by using the 
            <see cref="M:InTheHand.Net.Bluetooth.ServiceRecord.CreateServiceRecordFromBytes(System.Byte[])" />
            method or the 
            <see cref="M:InTheHand.Net.Bluetooth.ServiceRecordParser.Parse(System.Byte[],System.Int32,System.Int32)" />
            on <see cref="T:InTheHand.Net.Bluetooth.ServiceRecordParser" />.  A record
            can also be created from a list of <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" />
            passed to the constructor 
            <see cref="M:InTheHand.Net.Bluetooth.ServiceRecord.#ctor(System.Collections.Generic.IList{InTheHand.Net.Bluetooth.ServiceAttribute})" />.
            </para><para>
            </para><para>From the SDP specification:
            </para><list type="bullet"><item><term>2.2 ServiceRecord </term><description>
            a list of service attributes.</description></item><item><term>2.3 ServiceAttribute</term><description>
            two components: an attribute id and an attribute value.</description></item><item><term>2.4 Attribute ID</term><description>
            a 16-bit unsigned integer,
            represented as a data element.</description></item><item><term>2.5 Attribute Value</term><description>
            a variable length field whose meaning is determined by the attribute ID,
            represented by a data element.</description></item><item><term>3.1 Data Element</term><description>
            a typed data representation.
            It consists of two fields: a header field and a data field.
            The header field, in turn, is composed of two parts: a type descriptor and a size descriptor.
            </description></item><item><term>3.2 Data Element Type Descriptor </term><description>
            a 5-bit type descriptor.</description></item><item><term>3.3 Data Element Size Descriptor </term><description>
            The data element size descriptor is represented as a
            3-bit size index followed by 0, 8, 16, or 32 bits.</description></item></list></remarks>
            -
            <example><code lang="C#">
            ServiceRecord record = ...
            ServiceAttribute attr = record.GetAttributeById(UniversalAttributeId.ServiceRecordHandle);
            ServiceElement element = attr.Value;
            if(element.ElementType != ElementType.UInt32) {
              throw new FooException("Invalid record content for ServiceRecordHandle");
            }
            UInt32 handle = (UInt32)element.Value;
            </code>
            or
            <code lang="VB.NET">
            Dim bppRecord As ServiceRecord = ...
            Dim attr As ServiceAttribute = bppRecord.GetAttributeById(BasicPrintingProfileAttributeId.PrinterName)
            Dim element As ServiceElement = attr.Value;
            ' Spec say it is in UTF-8
            Dim printerName As String = element.GetValueAsStringUtf8()
            </code></example></member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceRecord.ErrorMsgNotSeq">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceRecord.ErrorMsgNoAttributeWithId">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceRecord.ErrorMsgListContainsNotAttribute">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecord.#ctor">
      <summary>
            Initializes a new instance of the 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> class 
            containing no <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" />s.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecord.#ctor(System.Collections.Generic.IList{InTheHand.Net.Bluetooth.ServiceAttribute})">
      <overloads>
            Initializes a new instance of the 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> class.
            </overloads>
            ----
            <summary>
            Initializes a new instance of the 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> class 
            with the specified set of <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" />s.
            </summary>
            -
            <param name="attributesList">The list of <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" />
            to add to the record,
            as an <see cref="T:System.Collections.Generic.IList`1" />
            of <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" />.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecord.#ctor(InTheHand.Net.Bluetooth.ServiceAttribute[])">
      <summary>
            Initializes a new instance of the 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> class 
            with the specified set of <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" />s.
            </summary>
            -
            <param name="attributesList">The list of <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" />
            to add to the record,
            as an array of <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" />.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecord.CreateServiceRecordFromBytes(System.Byte[])">
      <summary>
            Create a <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> by parsing
            the given array of <see cref="T:System.Byte" />.
            </summary>
            -
            <remarks>This uses the <see cref="T:InTheHand.Net.Bluetooth.ServiceRecordParser" />
            with its default settings.
            See <see cref="M:InTheHand.Net.Bluetooth.ServiceRecordParser.Parse(System.Byte[],System.Int32,System.Int32)" />
            for more information.  In particular for the errors that can result, two
            of which are listed here.
            </remarks>
            -
            <param name="recordBytes">A byte array containing the encoded Service Record.
            </param>
            -
            <returns>The new <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> parsed from the byte array.
            </returns>
            -
            <exception cref="T:System.Net.ProtocolViolationException">
            The record contains invalid content.
            </exception><exception cref="T:System.NotImplementedException">
            The record contains an element type not supported by the parser.
            </exception>
            -
            <seealso cref="M:InTheHand.Net.Bluetooth.ServiceRecordParser.Parse(System.Byte[],System.Int32,System.Int32)" /></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecord.GetAttributeByIndex(System.Int32)">
      <summary>
            Gets the attribute at the specified index.
            </summary>
            -
            <param name="index">The zero-based index of the attribute to get.</param>
            -
            <returns>A <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" /> holding 
            the attribute at the specified index.
            Is never <see langword="null" />.
            </returns>
            -
            <exception cref="T:System.ArgumentOutOfRangeException"><para>index is less than 0.</para><para>-or-</para><para>index is equal to or greater than Count. </para></exception></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecord.Contains(InTheHand.Net.Bluetooth.ServiceAttributeId)">
      <overloads>
            Determines whether a service attribute with the specified ID, 
            and optional natural language, is in the List.
            </overloads>
            -
            <summary>
            Determines whether a service attribute with the specified ID is in the List.
            </summary>
            -
            <param name="id">The id of the service attribute to locate, as a 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceAttributeId" />.</param>
            -
            <returns>true if item is found in the record; otherwise, false. </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecord.GetAttributeById(InTheHand.Net.Bluetooth.ServiceAttributeId)">
      <overloads>
            Returns the attribute with the given ID.
            </overloads>
            -
            <summary>
            Returns the attribute with the given ID.
            </summary>
            -
            <param name="id">The Attribute Id as a <see cref="T:InTheHand.Net.Bluetooth.ServiceAttributeId" />.</param>
            -
            <returns>A <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" /> holding 
            the attribute with the specified ID.
            Is never <see langword="null" />.
            </returns>
            -
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            There is no attribute with the given Id in the record.
            Throws <see cref="T:System.ArgumentException" /> in NETCFv1
            </exception></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecord.Contains(InTheHand.Net.Bluetooth.ServiceAttributeId,InTheHand.Net.Bluetooth.LanguageBaseItem)">
      <summary>
            Determines whether a TextString service attribute with the specified ID 
            and natural language 
            is in the List.
            </summary>
            -
            <param name="id">The id of the service attribute to locate, as a 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceAttributeId" />.</param><param name="language">
            Which multi-language version of the string attribute to locate.
            </param>
            -
            <returns>true if item is found in the record; otherwise, false. </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecord.GetAttributeById(InTheHand.Net.Bluetooth.ServiceAttributeId,InTheHand.Net.Bluetooth.LanguageBaseItem)">
      <summary>
            Returns the attribute with the given ID and natural language.
            </summary>
            -
            <param name="id">The id of the service attribute to locate, as a 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceAttributeId" />.</param><param name="language">
            Which multi-language version of the string attribute to locate.
            </param>
            -
            <returns>A <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" /> holding 
            the attribute with the specified ID and language.
            Is never <see langword="null" />.
            </returns>
            -
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            There is no attribute with the given Id with the given language base in the record.
            </exception></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecord.CreateLanguageBasedAttributeId(InTheHand.Net.Bluetooth.ServiceAttributeId,InTheHand.Net.Bluetooth.ServiceAttributeId)">
      <summary>
            Create the attribute id resulting for adding the language base attribute id.
            </summary>
            -
            <returns>The result <see cref="T:InTheHand.Net.Bluetooth.ServiceAttributeId" />.</returns>
            -
            <exception cref="T:System.OverflowException"><paramref name="baseId" /> added to the <paramref name="id" />
            would create an id that cannot be represented as an Attribute Id.
            </exception></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecord.GetMultiLanguageStringAttributeById(InTheHand.Net.Bluetooth.ServiceAttributeId,InTheHand.Net.Bluetooth.LanguageBaseItem)">
      <summary>
            Gets a <see cref="T:System.String" /> containing the value of the 
            <see cref="F:InTheHand.Net.Bluetooth.ElementTypeDescriptor.TextString" />
            service attribute with the specified ID,
            using the specified natural language.
            </summary>
            -
            <remarks><para>As noted in the documentation on this class, string are defined in 
            an odd manner, and the multi-language strings defined in the base SDP 
            specification are defined in a very very odd manner.  The natural language and the 
            strings encoding are not included in the element, but instead are 
            defined in a separate element, and the ID of the string attribute is 
            modified.  This pair is present for each natural language.
            </para><para>This method is provided to simplify accessing those strings, given 
            the Language attribute it should use it to find and decode the string.
            If the primary Language attribute is to be used, then use the 
            <see cref="M:InTheHand.Net.Bluetooth.ServiceRecord.GetPrimaryMultiLanguageStringAttributeById(InTheHand.Net.Bluetooth.ServiceAttributeId)" /> 
            method that takes only the id parameter.
            </para></remarks>
            -
            <param name="id">The id of the service attribute to locate, as a 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceAttributeId" />.</param><param name="language">
            Which multi-language version of the string attribute to locate.
            </param>
            -
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            There is no attribute with the given Id in the record.
            Throws <see cref="T:System.ArgumentException" /> in NETCFv1
            </exception><exception cref="T:System.InvalidOperationException">
            The service element is not of type 
            <see cref="F:InTheHand.Net.Bluetooth.ElementTypeDescriptor.TextString" />.
            </exception><exception cref="T:System.Text.DecoderFallbackException">
            If the value in the service element is not a valid string in the encoding 
            specified in the given <see cref="T:InTheHand.Net.Bluetooth.LanguageBaseItem" />.
            </exception>
            -
            <example>
            C#:
            <code lang="C#">
            LanguageBaseItem primaryLang = record.GetPrimaryLanguageBaseItem();
            if (primaryLang == null) {
              Console.WriteLine("Primary multi-language not present, would have to guess the string's encoding.");
              return;
            }
            try {
              String sn = record.GetMultiLanguageStringAttributeById(UniversalAttributeId.ServiceName, primaryLang);
              Console.WriteLine("ServiceName: " + sn);
            } catch (KeyNotFoundException) {
              Console.WriteLine("The record has no ServiceName Attribute.");
            }
            </code></example></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecord.GetPrimaryMultiLanguageStringAttributeById(InTheHand.Net.Bluetooth.ServiceAttributeId)">
      <summary>
            Gets a <see cref="T:System.String" /> containing the value of the 
            <see cref="F:InTheHand.Net.Bluetooth.ElementTypeDescriptor.TextString" />
            service attribute with the specified ID,
            using the primary natural language.
            </summary>
            -
            <remarks><para>As noted in the documentation on this class, string are defined in 
            an odd manner, and the multi-language strings defined in the base SDP 
            specification are defined in a very very odd manner.  The natural language and the 
            strings encoding are not included in the element, but instead are 
            defined in a separate element, and the ID of the string attribute is 
            modified.  This pair is present for each natural language.
            </para><para>This method is provided to simplify accessing those strings, it will 
            find the primary Language attribute and use it to find and decode the string.
            And if there is no primary Language attribute, which is the case in many 
            of the records one sees on mobile phones, it will attempt the operation 
            assuming the string is encoded in UTF-8 (or ASCII).
            </para></remarks>
            -
            <param name="id">The id of the service attribute to locate, as a 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceAttributeId" />.</param>
            -
            <exception cref="T:System.Collections.Generic.KeyNotFoundException">
            There is no attribute with the given Id in the record.
            Throws <see cref="T:System.ArgumentException" /> in NETCFv1
            </exception><exception cref="T:System.InvalidOperationException">
            The service element is not of type 
            <see cref="F:InTheHand.Net.Bluetooth.ElementTypeDescriptor.TextString" />.
            </exception><exception cref="T:System.Text.DecoderFallbackException">
            If the value in the service element is not a valid string in the encoding 
            specified in the given <see cref="T:InTheHand.Net.Bluetooth.LanguageBaseItem" />.
            </exception>
            -
            <example>
            C#:
            <code lang="C#">
            try {
              String sn = record.GetMultiLanguageStringAttributeById(UniversalAttributeId.ServiceName);
              Console.WriteLine("ServiceName: " + sn);
            } catch (KeyNotFoundException) {
              Console.WriteLine("The record has no ServiceName Attribute.");
            }
            </code></example></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecord.GetLanguageBaseList">
      <summary>
            Gets the list of LanguageBaseAttributeId items in the service record.
            </summary>
            -
            <remarks>
            See also <see cref="M:InTheHand.Net.Bluetooth.ServiceRecord.GetPrimaryLanguageBaseItem" />.
            </remarks>
            -
            <returns>
            An array of <see cref="T:InTheHand.Net.Bluetooth.LanguageBaseItem" />.
            An array of length zero is returned if the service record contains no such attribute.
            </returns>
            -
            <seealso cref="M:InTheHand.Net.Bluetooth.ServiceRecord.GetPrimaryLanguageBaseItem" /></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecord.GetPrimaryLanguageBaseItem">
      <summary>
            Gets the primary LanguageBaseAttributeId item in the service record.
            </summary>
            -
            <remarks>
            For instance, can be used with methods 
            <see cref="M:InTheHand.Net.Bluetooth.ServiceRecord.GetMultiLanguageStringAttributeById(InTheHand.Net.Bluetooth.ServiceAttributeId,InTheHand.Net.Bluetooth.LanguageBaseItem)" />,
            and <see cref="M:InTheHand.Net.Bluetooth.ServiceRecord.GetAttributeById(InTheHand.Net.Bluetooth.ServiceAttributeId,InTheHand.Net.Bluetooth.LanguageBaseItem)" />
            etc.  See example code in the first.
            </remarks>
            -
            <returns>
            A <see cref="T:InTheHand.Net.Bluetooth.LanguageBaseItem" />, or null
            if the service record contains no such attribute, or 
            no primary language item (one with Base Id 0x0100) is included.
            </returns>
            -
            <seealso cref="M:InTheHand.Net.Bluetooth.ServiceRecord.GetLanguageBaseList" /></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecord.GetEnumerator">
      <summary>
            Gets an enumerator that can be used to navigate through the record's 
            list of <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" />s.
            </summary>
            -
            <returns>An <see cref="T:System.Collections.Generic.IEnumerator`1" />
            of type <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" />.
            </returns>
            -
            <example>
            In C#:
            <code lang="C#">
            foreach (ServiceAttribute curAttr in record) {
               if (curAttr.Id == UniversalAttributeId.ProtocolDescriptorList) {
               ...
            }
            </code>
            In Visual Basic:
            <code lang="VB.NET">
            For Each curAttr As ServiceAttribute In record
               If curAttr.Id = UniversalAttributeId.ProtocolDescriptorList Then
               ...
            Next
            </code></example></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceRecord.ToByteArray">
      <summary>
            Return the byte array representing the service record.
            </summary>
            -
            <remarks>The byte array content is created dynamically from the
            <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> instance using
            the <see cref="T:InTheHand.Net.Bluetooth.ServiceRecordCreator" /> class.
            </remarks>
            -
            <returns>The result as an array of <see cref="T:System.Byte" />.
            </returns>
            -
            <seealso cref="P:InTheHand.Net.Bluetooth.ServiceRecord.SourceBytes" /></member>
    <member name="P:InTheHand.Net.Bluetooth.ServiceRecord.Count">
      <summary>
            Gets the count of attributes in the record.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.ServiceRecord.Item(System.Int32)">
      <summary>
            Gets the attribute at the specified index.
            </summary>
            -
            <param name="index">The zero-based index of the attribute to get.</param>
            -
            <returns>A <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" /> holding 
            the attribute at the specified index.</returns>
            -
            <exception cref="T:System.Exception"><para>index is less than 0.</para><para>-or-</para><para>index is equal to or greater than Count. </para></exception></member>
    <member name="P:InTheHand.Net.Bluetooth.ServiceRecord.AttributeIds">
      <summary>
            Get a list of the numerical IDs of the Attributes in the record 
            as an <see cref="T:System.Collections.Generic.IList`1" />
            of <see cref="T:InTheHand.Net.Bluetooth.ServiceAttributeId" />.
            </summary>
            -
            <remarks>
            This method will likely be only rarely used: instead 
            one would generally want either to read a specific attribute using 
            <see cref="M:InTheHand.Net.Bluetooth.ServiceRecord.GetAttributeById(InTheHand.Net.Bluetooth.ServiceAttributeId)" />,
            or read every attribute by using 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />'s
            <c>IEnumerable</c> ability e.g.
            <code lang="VB.NET">
               For Each curAttr As ServiceAttribute In record
                  If curAttr.Id = UniversalAttributeId.ProtocolDescriptorList Then
                  ...
               Next
            </code><para>Note, for NETCFv1 this returns an instance of the non-Generic list 
            <see cref="T:System.Collections.IList" />.
            </para></remarks>
            -
            (Provide a pure example since NDocs makes big mess of displaying Generic types).
            <example>
            In C#:
            <code lang="C#">
              IList&lt;ServiceAttributeId&gt; ids = record.GetAttributeIds();
            </code>
            In VB.NET:
            <code lang="VB.NET">
              Dim ids As IList(Of ServiceAttributeId) = record.GetAttributeIds()
            </code>
            Or without Generics in .NET 1.1 (NETCFv1) in VB.NET:
            <code lang="VB.NET">
              Dim ids As IList = record.GetAttributeIds()
            </code></example></member>
    <member name="P:InTheHand.Net.Bluetooth.ServiceRecord.SourceBytes">
      <summary>
            Get the raw byte array from which the record was parsed.
            </summary>
            -
            <remarks><para>A <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> can be created either by manually building new 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" />s holding new 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" />s, or it can be created
            by <see cref="T:InTheHand.Net.Bluetooth.ServiceRecordParser" /> parsing an array
            of bytes read from another machine by e.g. 
            <see cref="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.GetServiceRecords(System.Guid)" />.
            In that case this method returns that source byte array.
            </para><para>To creates a Service Record byte array from the contained
            <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" />s use
            <see cref="M:InTheHand.Net.Bluetooth.ServiceRecord.ToByteArray" /> or <see cref="T:InTheHand.Net.Bluetooth.ServiceRecordCreator" />.
            </para></remarks>
            -
            <value>
            An array of <see cref="T:System.Byte" />, or <see langword="null" /> if
            the record was not created by parsing a raw record.
            </value>
            -
            <seealso cref="M:InTheHand.Net.Bluetooth.ServiceRecord.ToByteArray" /></member>
    <member name="T:InTheHand.Net.Bluetooth.ServiceAttributeId">
      <summary>
            A Service Attribute Id identifies each attribute within an SDP service record.
            </summary>
            -
            <remarks><para>The content of the record for a particular service class is defined in the
            profiles specification along with the IDs it uses. The IDs for the 
            common standard services have beed defined here, as e.g. 
            <see cref="T:InTheHand.Net.Bluetooth.AttributeIds.ObexAttributeId" />,
            <see cref="T:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId" />,
            etc, see namespace <see cref="N:InTheHand.Net.Bluetooth.AttributeIds" />.
            The Service Discovery profile itself defines IDs, some that can be used 
            in any record <see cref="T:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId" />, 
            and others
            <see cref="T:InTheHand.Net.Bluetooth.AttributeIds.ServiceDiscoveryServerAttributeId" />,
            and <see cref="T:InTheHand.Net.Bluetooth.AttributeIds.BrowseGroupDescriptorAttributeId" />.
            </para><para>Note that except for the attributes in the Universal category 
            the IDs are <i>not</i> unique, for instance the ID is 0x0200 for both 
            <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.ServiceDiscoveryServerAttributeId.VersionNumberList" />
            and <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.BrowseGroupDescriptorAttributeId.GroupId" />
            from <see cref="T:InTheHand.Net.Bluetooth.AttributeIds.ServiceDiscoveryServerAttributeId" />
            and <see cref="T:InTheHand.Net.Bluetooth.AttributeIds.BrowseGroupDescriptorAttributeId" />
            respectively.
            </para></remarks></member>
    <member name="T:InTheHand.Net.Bluetooth.AttributeIdLookup">
      <summary>
            Retrieves the name of the SDP Attribute ID with the given value in the
            specified Attribute ID class sets.  Implementing <see cref="T:System.Enum" />-like
            behaviour.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.AttributeIdLookup.GetName(InTheHand.Net.Bluetooth.ServiceAttributeId,System.Type[])">
      <summary>
            Retrieves the name of the SDP Attribute ID with the given value in the
            specified Attribute ID class sets.
            </summary>
            -
            <remarks>
            Each particular service (ObexPushProfile, SerialPortProfile) etc defines
            its own SDP record content and the Attribute IDs are defined locally in
            each, and thus with values overlapping with other service specifications.
            Therefore for each profile we must define the set of Attribute IDs used, this
            is done by creating a class for each with the IDs defined as <c>const</c>
            member fields.
            </remarks>
            -
            <param name="id">
            The Attribute Id as an <see cref="T:InTheHand.Net.Bluetooth.ServiceAttributeId" /></param><param name="attributeIdDefiningClasses">
            The set of classes defining Attribute IDs for the service classed contained
            in the record containing this attribute id.
            </param>
            -
            <returns>
            A string containing the name of the Attribute ID whose numerical value is <paramref name="id" />,
            or a null reference (<c>Nothing</c> in Visual Basic) if no such constant is found.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.AttributeIdLookup.GetName(InTheHand.Net.Bluetooth.ServiceAttributeId,System.Type[],InTheHand.Net.Bluetooth.LanguageBaseItem[],InTheHand.Net.Bluetooth.LanguageBaseItem@)">
      <summary>
            Retrieves the name of the SDP Attribute ID with the given value 
            and using one of the languages from the supplied LanguageBaseItem 
            in the specified AttributeID class sets.
            </summary>
            -
            <remarks>
            Each particular service (ObexPushProfile, SerialPortProfile) etc defines
            its own SDP record content and the Attribute IDs are defined locally in
            each, and thus with values overlapping with other service specifications.
            Therefore for each profile we must define the set of Attribute IDs used, this
            is done by creating a class for each with the IDs defined as <c>const</c>
            member fields.
            </remarks>
            -
            <param name="id">
            The Attribute Id as an <see cref="T:InTheHand.Net.Bluetooth.ServiceAttributeId" /></param><param name="attributeIdDefiningClasses">
            The set of classes defining Attribute IDs for the service classed contained
            in the record containing this attribute id.
            </param><param name="langBaseList">
            The list of <see cref="T:InTheHand.Net.Bluetooth.LanguageBaseItem" /> applying 
            to the current record.  They are used when an attribute is marked as a
            multi-language one and thus need the base offset removed from the specified
            numerical value.
            </param><param name="applicableLangBase">
            The applicable <see cref="T:InTheHand.Net.Bluetooth.LanguageBaseItem" /> if the 
            matched attribute is a multi-language one.  <see langword="null" /> 
            (<see langword="Nothing" /> in Visual Basic), if no attribute was matched
            or it was not a multi-language one.
            </param>
            -
            <returns>
            A string containing the name of the Attribute ID whose numerical value is <paramref name="id" />,
            or a null reference (<c>Nothing</c> in Visual Basic) if no such constant is found.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.AttributeIdLookup._GetNameIfMatchesMultiLang(InTheHand.Net.Bluetooth.ServiceAttributeId,System.Reflection.FieldInfo,InTheHand.Net.Bluetooth.LanguageBaseItem[],InTheHand.Net.Bluetooth.LanguageBaseItem@)">
      <summary>
            Retrieves the name of the SDP Attribute ID with the given value 
            and using one of the languages from the supplied LanguageBaseItem 
            in the specified AttributeID class sets
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.StringWithLanguageBaseAttribute">
      <summary>
            Indicates that the field to which it is applied represents an SDP Attribute 
            that can exist in multiple language instances and thus has a language base 
            offset applied to its numerical ID when added to a record.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.StringWithLanguageBaseAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.StringWithLanguageBaseAttribute" />
            class. 
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs">
      <summary>
            Provides data for an authentication event.
            </summary>
            -
            <remarks><para>For usage information, see the class documentation at
            <see cref="T:InTheHand.Net.Bluetooth.BluetoothWin32Authentication" /> it includes
            an example, 
            also see the documentation on each of this classs properties.
            </para></remarks></member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.SixDigitsFormatString">
      <summary>
            A format string to display the Passkey or comparison Number as six decimal digits.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.ErrorMessageSendingAnotherPinIsDisallowed_">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.#ctor">
      <summary>
            Initialize an instance of <see cref="T:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs" />.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.#ctor(InTheHand.Net.Sockets.BluetoothDeviceInfo)">
      <summary>
            Initialize an instance of <see cref="T:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs" />.
            </summary>
            -
            <param name="device">The device information to store in the event args.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.ConfirmOob(System.Byte[],System.Byte[])">
      <summary>
            Creates a positive response to the
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationMethod.OutOfBand" />
            pairing event also providing optional security values.
            </summary>
            -
            <param name="c">An byte array of length 16 bytes, or null.
            A 128-bit cryptographic key used for two-way authentication.
            </param><param name="r">An byte array of length 16 bytes, or null.
            A randomly generated number used for one-way authentication.
            If this number is not provided by the device initiating the OOB
            session, this value is 0.
            </param></member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.Device">
      <summary>
            Gets the device requiring an authentication response as a
            <see cref="T:InTheHand.Net.Sockets.BluetoothDeviceInfo" />.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.AuthenticationRequirements">
      <summary>
            Gets a <see cref="T:InTheHand.Net.Bluetooth.BluetoothAuthenticationRequirements" />
            enumeration value that specifies the 'Man in the Middle' protection
            required for authentication.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.IoCapability">
      <summary>
            Gets a <see cref="T:InTheHand.Net.Bluetooth.BluetoothIoCapability" />
            enumeration value that defines the input/output capabilities of the
            Bluetooth device.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.AuthenticationMethod">
      <summary>
            Gets a <see cref="T:InTheHand.Net.Bluetooth.BluetoothAuthenticationMethod" />
            enumeration value that defines the authentication method utilized
            by the Bluetooth device.
            </summary>
            -
            <remarks><para>The method to be used depends on the
            and the <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.IoCapability" /> on both machines.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.JustWorksNumericComparison">
      <summary>
            Gets whether the
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationMethod.NumericComparison" />
            method is of subtype "JustWorks".
            </summary>
            -
            <remarks><para>Gets whether the
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationMethod.NumericComparison" />
            method is of subtype "JustWorks".
            </para><para>If true then a simple Yes/No answer from the user is adequate,
            Or if false then the <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.NumberOrPasskey" />.
            value should be displayed to the user(s) so that he/she/they can
            verify that the values displayed on both devices are the same.
            Is null if 
            <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.AuthenticationRequirements" />
            is not 
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationMethod.NumericComparison" />.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.NumberOrPasskey">
      <summary>
            Get the Numeric or Passcode value being used by the 
            SSP pairing event.
            </summary>
            -
            <value>Is a six digit number from 000000 to 999999,
            or <see langword="null" /> if not present.
            </value>
            -
            <remarks><para>Will be present in the
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationMethod.NumericComparison" />,
            <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.JustWorksNumericComparison" />,
            and <see cref="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationMethod.PasskeyNotification" />
            authentication methods only.
            </para><para>Is a six digit number from 000000 to 999999.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.NumberOrPasskeyAsString">
      <summary>
            Gets the <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.NumberOrPasskey" />
            formatted in its correct six decimal digits format.
            </summary>
            -
            <value>A <see cref="T:System.String" /> representing
            <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.NumberOrPasskey" />
            formatted in its six decimal digits format,
            or <see langword="null" /> if 
            <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.NumberOrPasskey" />
            is <see langword="null" />.
            </value></member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.Pin">
      <summary>
            Gets or sets the PIN string to be used to authenticate the specified device.
            </summary>
            -
            <remarks><para>Is only used in the 
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationMethod.Legacy" />
            pairing method.
            </para><para>On an authentication event, a PIN response is sent if the value 
            returned from the handler is not <see langword="null" />.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.Confirm">
      <summary>
            Get or set whether we will respond positively, negatively or
            ignore the SSP pairing event.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.ResponseNumberOrPasskey">
      <summary>
            Get or set what Numeric or Passcode value or whether no value
            will be used in responding to the SSP pairing event.
            </summary>
            -
            <remarks><para>Is a number from 000000 to 999999, or null if not to be included
            in the response.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.CallbackWithResult">
      <summary>
            Gets or sets whether the callback is called again after the PIN response
            is sent.
            </summary>
            -
            <remarks><para>This is useful to see the error code returned by sending
            the PIN response. It can thus also be used to see the successful result 
            of sending the PIN response.  See the documentation on the 
            <see cref="T:InTheHand.Net.Bluetooth.BluetoothWin32Authentication" /> class.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.AttemptNumber">
      <summary>
            Gets how many attempts at sending a PIN have been tried.
            </summary>
      <remarks>
            When theres a new PIN request, the first time the callback is
            called this property will have value zero.  If the PIN is rejected and
            <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.CallbackWithResult" />
            was set, then the callback will be recalled and this property will have
            value one, etc.
            </remarks>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.PreviousNativeErrorCode">
      <summary>
            The Windows error code returned by the last PIN response attempt.
            </summary>
            -
            <remarks><para>A bad PIN/passcode value appears to result in a error code
            with value 1244, which is <see cref="F:InTheHand.Net.Bluetooth.BluetoothWin32Authentication.NativeErrorNotAuthenticated" />.
            </para><para>If one tries to respond to that failure with another passcode,
            then error 1167 <see cref="F:InTheHand.Net.Bluetooth.BluetoothWin32Authentication.NativeErrorDeviceNotConnected" />
            results.  So it seems that only one attempt is possible.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.PreviousNativeErrorCodeAsUnsigned">
      <summary>
            The Windows error code returned by the last PIN response attempt,
            as an unsigned value.
            </summary>
            -
            <remarks>See <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.PreviousNativeErrorCode" />.
            </remarks>
            -
            <seealso cref="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.PreviousNativeErrorCode" /></member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.CannotSendAnotherResponse">
      <summary>
            Gets whether it is not possible to send another PIN response.
            </summary>
      <remarks>
        <para>For instance, in testing it appears that after one response
            the device becomes non-contactable, any PIN response returning error code
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothWin32Authentication.NativeErrorDeviceNotConnected" />.
            </para>
      </remarks>
    </member>
    <member name="T:InTheHand.Net.Sockets.BluetoothSocketOptionName">
      <summary>
            Defines <see cref="T:System.Net.Sockets.Socket" /> configuration option names for the <see cref="T:System.Net.Sockets.Socket" /> class.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.Authenticate">
      <summary>
            On connected socket, triggers authentication.
            On not connected socket, forces authentication on connection.
            For incoming connection this means that connection is rejected if authentication cannot be performed.
            </summary>
      <remarks>The optval and optlen parameters are ignored; however, Winsock implementation on Windows CE requires optlen to be at least 4 and optval to point to at least an integer datum.</remarks>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.XPAuthenticate">
      <summary>
            Toggles authentication under Windows XP.
            </summary>
      <remarks>optlen=sizeof(ULONG), optval = &amp;(ULONG)TRUE/FALSE</remarks>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.Encrypt">
      <summary>
            On a connected socket, this command turns encryption on or off.
            On an unconnected socket, this forces encryption to be on or off on connection.
            For an incoming connection, this means that the connection is rejected if the encryption cannot be turned on.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.SetPin">
      <summary>
            This sets or revokes PIN code to use with a connection or socket.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.SetLink">
      <summary>
            This sets or revokes link key to use with a connection or peer device.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.GetLink">
      <summary>
            Returns link key associated with peer Bluetooth device.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.XPMtu">
      <summary>
            Get or set the default MTU on Windows XP.
            </summary>
      <remarks>optlen=sizeof(ULONG), optval = &amp;mtu</remarks>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.SetMtu">
      <summary>
            This sets default MTU (maximum transmission unit) for connection negotiation.
            While allowed for connected socket, it has no effect if the negotiation has already completed.
            Setting it on listening socket will propagate the value for all incoming connections.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.GetMtu">
      <summary>
            Returns MTU (maximum transmission unit).
            For connected socket, this is negotiated value, for server (accepting) socket it is MTU proposed for negotiation on connection request.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.XPMtuMaximum">
      <summary>
            Get or set the maximum MTU on Windows XP.
            </summary>
      <remarks>optlen=sizeof(ULONG), optval = &amp;max. mtu</remarks>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.SetMtuMaximum">
      <summary>
            This sets maximum MTU for connection negotiation.
            While allowed for connected socket, it has no effect if the negotiation has already completed.
            Setting it on listening socket will propagate the value for all incoming connections.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.GetMtuMaximum">
      <summary>
            Returns maximum MTU acceptable MTU value for a connection on this socket.
            Because negotiation has already happened, has little meaning for connected socket.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.XPMtuMinimum">
      <summary>
            Get or set the minimum MTU on Windows XP.
            </summary>
      <remarks>optlen=sizeof(ULONG), optval = &amp;min. mtu</remarks>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.SetMtuMinimum">
      <summary>
            This sets minimum MTU for connection negotiation.
            While allowed for connected socket, it has no effect if the negotiation has already completed.
            Setting it on listening socket will propagate the value for all incoming connections.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.GetMtuMinimum">
      <summary>
            Returns minimum MTU acceptable MTU value for a connection on this socket.
            Because negotiation has already happened, has little meaning for connected socket. 
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.SetXOnLimit">
      <summary>
            This sets XON limit.
            Setting it on listening socket will propagate the value for all incoming connections.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.GetXOnLimit">
      <summary>
            Returns XON limit for a connection.
            XON limit is only used for peers that do not support credit-based flow control (mandatory in the Bluetooth Core Specification version 1.1).
            When amount of incoming data received, but not read by an application for a given connection grows past this limit, a flow control command is sent to the peer requiring suspension of transmission.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.SetXOffLimit">
      <summary>
            This sets XOFF limit.
            Setting it on listening socket will propagate the value for all incoming connections.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.GetXOffLimit">
      <summary>
            Returns XOFF limit for a connection.
            XOFF limit is only used for peers that do not support credit-based flow control (mandatory in the Bluetooth Core Specification 1.1).
            If flow has been suspended because of buffer run-up, when amount of incoming data received, but not read by an application for a given connection falls below this limit, a flow control command is sent to the peer allowing continuation of transmission.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.SetSendBuffer">
      <summary>
            Specifies maximum amount of data that can be buffered inside RFCOMM (this is amount of data before call to send blocks).
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.GetSendBuffer">
      <summary>
             Returns maximum amount of data that can be buffered inside RFCOMM (this is amount of data before call to send blocks).
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.SetReceiveBuffer">
      <summary>
            Specifies maximum amount of data that can be buffered for a connection.
            This buffer size is used to compute number of credits granted to peer device when credit-based flow control is implemented.
            This specifies the maximum amount of data that can be buffered.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.GetReceiveBuffer">
      <summary>
            Returns maximum amount of data that can be buffered for a connection.
            This buffer size is used to compute number of credits granted to peer device when credit-based flow control is implemented.
            This specifies the maximum amount of data that can be buffered.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.GetV24Break">
      <summary>
            Retrieves last v24 and break signals set through MSC command from peer device.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.GetRls">
      <summary>
            Retrieves last line status signals set through RLS command from peer device.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.SendMsc">
      <summary>
            Sends MSC command. V24 and breaks are as specified in RFCOMM Specification.
            Only modem signals and breaks can be controlled, RFCOMM reserved fields such as flow control are ignored and should be set to 0.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.SendRls">
      <summary>
            Sends RLS command.
            Argument is as specified in RFCOMM Specification.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.GetFlowType">
      <summary>
            Gets flow control type on the connected socket.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.SetPageTimeout">
      <summary>
            Sets the page timeout for the card.
            The socket does not have to be connected.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.GetPageTimeout">
      <summary>
            Gets the current page timeout.
            The socket does not have to be connected.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.SetScan">
      <summary>
            Sets the scan mode for the card.
            The socket does not have to be connected.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.GetScan">
      <summary>
            Gets the current scan mode.
            The socket does not have to be connected.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.SetCod">
      <summary>
            Sets the class of the device.
            The socket does not have to be connected.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.GetCod">
      <summary>
            Retrieve the Class of Device.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.GetLocalVersion">
      <summary>
            Get the version information from the Bluetooth adapter.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.GetRemoteVersion">
      <summary>
            Get the version of the remote adapter.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.GetAuthenticationEnabled">
      <summary>
            Retrieves the authentication settings.
            The socket does not have to be connected.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.SetAuthenticationEnabled">
      <summary>
            Sets the authentication policy of the device.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.ReadRemoteName">
      <summary>
            Reads the remote name of the device.
            The socket does not have to be connected.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.GetLinkPolicy">
      <summary>
            Retrieves the link policy of the device.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.SetLinkPolicy">
      <summary>
            Sets the link policy for an existing baseband connection.
            The socket must be connected.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.EnterHoldMode">
      <summary>
            Places the ACL connection to the specified peer device in HOLD mode.
            The device must be connected.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.EnterSniffMode">
      <summary>
            Places the ACL connection to the specified peer device in SNIFF mode.
            The device must be connected.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.ExitSniffMode">
      <summary>
            Forces the ACL connection to the peer device to leave SNIFF mode.
            The device must be connected.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.EnterParkMode">
      <summary>
            Places the ACL connection to the peer device in PARK mode.
            The device must be connected.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.ExitParkMode">
      <summary>
            Forces the ACL connection to the peer device to leave PARK mode.
            The device must be connected.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothSocketOptionName.GetMode">
      <summary>
            Gets the current mode of the connection.
            The mode can either be sniff, park, or hold. The socket must be connected.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Msft.MicrosoftSdpService">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.MicrosoftSdpService.RemoveService(System.IntPtr,System.Byte[])">
      <exclude />
      <summary>
            Remove a SDP record as added by <see cref="M:InTheHand.Net.Bluetooth.Msft.MicrosoftSdpService.SetService(System.Byte[],InTheHand.Net.Bluetooth.ServiceClass)" />.
            </summary>
      <param name="handle">The handle.
            </param>
      <param name="sdpRecord">The raw record, presumably not actually used by the stack.
            </param>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.MicrosoftSdpService.SetService(System.Byte[],InTheHand.Net.Bluetooth.ServiceClass)">
      <exclude />
      <summary>
            Add a SDP record.
            </summary>
            -
            <param name="sdpRecord">An array of <see cref="T:System.Byte" />
            containing the complete SDP record.
            </param><param name="cod">A <see cref="T:InTheHand.Net.Bluetooth.ServiceClass" />
            containing any bits to set in the devices Class of Device value.
            </param>
            -
            <returns>A handle representing the record, pass to 
            <see cref="M:InTheHand.Net.Bluetooth.Msft.MicrosoftSdpService.RemoveService(System.IntPtr,System.Byte[])" /> to remote the record.
            </returns></member>
    <member name="T:InTheHand.Windows.Forms.SelectBluetoothDeviceForm">
      <summary>
            Managed code dialog for Windows CE systems.
            </summary>
    </member>
    <member name="M:InTheHand.Windows.Forms.SelectBluetoothDeviceForm.Dispose(System.Boolean)">
      <summary>
            Clean up any resources being used.
            </summary>
    </member>
    <member name="M:InTheHand.Windows.Forms.SelectBluetoothDeviceForm.InitializeComponent">
      <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
    </member>
    <member name="T:InTheHand.Net.ObexWebRequest">
      <summary>
            Provides an OBEX implementation of the <see cref="T:System.Net.WebRequest" /> class.
            </summary>
            -
            <remarks><para>If you want to transfer an file or other object using the standard 
            service as used by Windows' Wireless Link / Bluetooth File Transfer Wizard, 
            Palm's Beam, Nokia's Send via Infrared, then use the OBEX protocol.  
            </para><para>The PUT operation is supported, and there is new support for GET,
            (see the documentation at the <see cref="P:InTheHand.Net.ObexWebRequest.Method" />
            property).
            Changing folders is not supported, nor is getting a folder listing.
            </para><para>In the previous version there were some issue with handling file names 
            that include non-English characters, and connections 
            to some device types failed.  Also if the connection to the peer was lost
            then the request could hang reading forever.  See the release note and bugs
            database for more information.
            </para></remarks>
            -
            <example>
            For Bluetooth one can use code like the following to send a file:
            (Note a failure is signalled by an exception).
            <code lang="VB.NET">
            Dim addr As BluetoothAddress = BluetoothAddress.Parse("002233445566")
            Dim path As String = "HelloWorld.txt"
            '
            Dim req As New ObexWebRequest(addr, path)
            req.ReadFile("Hello World.txt")
            Dim rsp As ObexWebResponse = CType(req.GetResponse(),ObexWebResponse)
            Console.WriteLine("Response Code: {0} (0x{0:X})", rsp.StatusCode)
            </code>
            That constructor isn't available for other transports (TCP/IP, IrDA)
            so one has to create a Uri to provide the scheme, address, and path
            parameters.  Thus use code like the following to send a file.
            <code lang="VB.NET">
            ' The host part of the URI is the device address, e.g. IrDAAddress.ToString(),
            ' and the file part is the OBEX object name.
            Dim addr As BluetoothAddress = ...
            Dim addrStr As String = addr.ToString("N")
            Dim uri As New Uri("obex://" &amp; addrStr &amp; "/HelloWorld.txt")
            '
            Dim req As New ObexWebRequest(uri)
            req.ReadFile("Hello World.txt")
            Dim rsp As ObexWebResponse = CType(req.GetResponse(),ObexWebResponse)
            Console.WriteLine("Response Code: {0} (0x{0:X})", rsp.StatusCode)
            </code>
            Or, to send locally generated content use something like the following.
            <code lang="VB.NET">
            Dim addr As BluetoothAddress = ...
            Dim path As String = "HelloWorld2.txt"
            '
            Dim req As New ObexWebRequest(addr, path)
            Using content As Stream = req.GetRequestStream()
               ' Using a StreamWriter to write text to the stream...
               Using wtr As New StreamWriter(content)
                  wtr.WriteLine("Hello World GetRequestStream")
                  wtr.WriteLine("Hello World GetRequestStream 2")
                  wtr.Flush()
                  ' Set the Length header value
                  req.ContentLength = content.Length
               End Using
               ' In this case closing the StreamWriter also closed the Stream, but ...
            End Using
            Dim rsp As ObexWebResponse = CType(req.GetResponse(),ObexWebResponse) 
            Console.WriteLine("Response Code: {0} (0x{0:X})", rsp.StatusCode)
            </code>
            See also the ObexPushApplication and ObexPushVB sample programs.
            </example></member>
    <member name="M:InTheHand.Net.ObexWebRequest.#ctor(System.Uri)">
      <overloads>
            Create a new Obex request with the specified <see cref="T:System.Uri" />.
            </overloads>
            -
            <summary>
            Create a new Obex request with the specified <see cref="T:System.Uri" />.
            </summary><param name="requestUri">e.g. "obex://112233445566/HelloWorld.txt"</param><remarks>Uri must use one of the following schemes - obex, obex-push, obex-ftp, obex-sync.
            The host name must be the device address in short hex, or dotted hex notation - not the default representation using the colon separator</remarks></member>
    <member name="M:InTheHand.Net.ObexWebRequest.#ctor(System.Uri,System.IO.Stream)">
      <summary>
            [Advanced usage]
            Create a new Obex request with the specified <see cref="T:System.Uri" /> 
            and the open <see cref="T:System.IO.Stream" /> connection to an OBEX server.
            </summary>
            -
            <param name="requestUri">[Advanced usage]
            A url of the form 
            <i>scheme</i><c>:///</c><i>filename</i>, 
            e.g. <c>obex:///foo.txt</c>.
            That is the host part is blank, 
            and the scheme and filename parts set as for the other constructor 
            <see cref="M:InTheHand.Net.ObexWebRequest.#ctor(System.Uri)" /></param><param name="stream">An instance of <see cref="T:System.IO.Stream" />
            already connected to an OBEX server.
            </param></member>
    <member name="M:InTheHand.Net.ObexWebRequest.#ctor(System.String,InTheHand.Net.BluetoothAddress,System.String)">
      <summary>
            Initialize an instance of this class given a scheme, 
            a Bluetooth Device Address, and a remote path name.
            </summary>
            -
            <param name="scheme">The Uri scheme. One of 
            <c>obex</c>, <c>obex-push</c>, <c>obex-ftp</c>, or <c>obex-sync</c>.
            </param><param name="target">The Bluetooth Device Address of the OBEX server.
            </param><param name="path">The path on the OBEX server.
            </param></member>
    <member name="M:InTheHand.Net.ObexWebRequest.#ctor(InTheHand.Net.BluetoothAddress,System.String)">
      <summary>
            Initialize an instance of this class given 
            a Bluetooth Device Address, and a remote path name.
            </summary>
            -
            <remarks><para>This is equivalent to calling
            <see cref="M:InTheHand.Net.ObexWebRequest.#ctor(System.String,InTheHand.Net.BluetoothAddress,System.String)">
            ObexWebRequest(String scheme, BluetoothAddress target, String path)
            </see>
            with scheme <c>obex</c>.
            </para></remarks>
            -
            <param name="target">The Bluetooth Device Address of the OBEX server.
            </param><param name="path">The path on the OBEX server.
            </param></member>
    <member name="M:InTheHand.Net.ObexWebRequest.GetRequestStream">
      <summary>
            Gets a <see cref="T:System.IO.Stream" /> object to use to write request data.
            </summary>
            -
            <returns>A <see cref="T:System.IO.Stream" /> to use to write request data.</returns></member>
    <member name="M:InTheHand.Net.ObexWebRequest.ReadFile(System.String)">
      <summary>
            Reads the contents of the specified file to the request stream.
            </summary>
      <param name="fileName">The filename (including the path) from which to read.</param>
      <remarks>Provides an easy equivalent to manually writing the file contents to the request stream.</remarks>
    </member>
    <member name="M:InTheHand.Net.ObexWebRequest.GetResponse">
      <summary>
            Returns the OBEX server response.
            </summary>
            -
            <returns>An <see cref="T:InTheHand.Net.ObexWebResponse" />.</returns>
            -
            <exception cref="T:System.Net.WebException">
            An error occurred, with the error that occured being stored in the 
            <see cref="P:System.Exception.InnerException" /> property.  If the error 
            occurred in the connect phase then the <see cref="P:System.Net.WebException.Status" />
            property will have value <see cref="F:System.Net.WebExceptionStatus.ConnectFailure" />,
            and in the operation phase on the desktop CLR it will have value
            <see cref="F:System.Net.WebExceptionStatus.UnknownError" /></exception></member>
    <member name="M:InTheHand.Net.ObexWebRequest.StreamReadBlockMust(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
      <summary>
            A wrapper for Stream.Read that blocks until the requested number of bytes
            have been read, and throw an exception if the stream is closed before that occurs.
            </summary>
    </member>
    <member name="M:InTheHand.Net.ObexWebRequest.StreamReadBlock(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
      <summary>
            A wrapper for Stream.Read that blocks until the requested number of bytes
            have been read or the end of the Stream has been reached.
            Returns the number of bytes read.
            </summary>
    </member>
    <member name="M:InTheHand.Net.ObexWebRequest.BeginGetResponse(System.AsyncCallback,System.Object)">
      <summary>
            Begins a request for a OBEX server response.
            </summary>
            -
            <param name="callback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</param><param name="state">A user-defined object containing information about the operation.
            This object is passed to the callback delegate when the operation is complete.</param>
            -
            <returns>An <see cref="T:System.IAsyncResult" /> that represents the 
            asynchronous operation, which could still be pending.
            </returns></member>
    <member name="M:InTheHand.Net.ObexWebRequest.EndGetResponse(System.IAsyncResult)">
      <summary>
            Begins a request for a OBEX server response.
            </summary>
            -
            <param name="asyncResult">An <see cref="T:System.IAsyncResult" />
            object that was obtained when the asynchronous operation was started.
            </param>
            -
            <returns>An <see cref="T:InTheHand.Net.ObexWebResponse" />.</returns>
            -
            <exception cref="T:System.Net.WebException">
            An error occurred, with the error that occured being stored in the 
            <see cref="P:System.Exception.InnerException" /> property.  If the error 
            occurred in the connect phase then the <see cref="P:System.Net.WebException.Status" />
            property will have value <see cref="F:System.Net.WebExceptionStatus.ConnectFailure" />,
            and in the operation phase on the desktop CLR it will have value
            <see cref="F:System.Net.WebExceptionStatus.UnknownError" /></exception></member>
    <member name="P:InTheHand.Net.ObexWebRequest.Headers">
      <summary>
            Specifies a collection of the name/value pairs that make up the OBEX headers.
            </summary>
    </member>
    <member name="P:InTheHand.Net.ObexWebRequest.Method">
      <summary>
            Gets or sets the method for the request.
            </summary>
      <remarks>
        <para>For Object Exchange the method code is mapped to the equivalent HTTP style method.
            For example "PUT", "GET" etc. "PUT" is the default value.
            There is new support for GET as of version 2.5.
            </para>
        <para>To use GET change the <c>Method</c> to "<c>GET</c>" and you must also use
            scheme "<c>obex-ftp</c>" in the URL instead of the usual "<c>obex</c>"
            -- unless you know that the default OBEX server you are connecting
            supports GET.
            </para>
        <para>For a PUT sample see the <see cref="T:InTheHand.Net.ObexWebRequest">class</see>
            documentation.  For GET, see below.
            </para>
        <example>
          <code lang="VB.NET">
            ' The host part of the URI is the device address, e.g. IrDAAddress.ToString(),
            ' and the file part is the OBEX object name.
            Dim addr As String = "112233445566"
            Dim uri As New Uri("obex-ftp://" &amp; addr &amp; "/HelloWorld.txt")
            Dim req As New ObexWebRequest(uri)
            req.Method = "GET"
            Dim rsp As ObexWebResponse = CType(req.GetResponse(), ObexWebResponse)
            Console.WriteLine("Response Code: {0} (0x{0:X})", rsp.StatusCode)
            Using content As Stream = rsp.GetResponseStream()
               ' Using a StreamReader to read text from the stream...
               Using rdr As New StreamReader(content)
                  While True
                     Dim line As String = rdr.ReadLine()
                     If line Is Nothing Then Exit While
                     Console.WriteLine(line)
                  End While
               End Using
            End Using
            </code>
        </example>
      </remarks>
    </member>
    <member name="P:InTheHand.Net.ObexWebRequest.ContentType">
      <summary>
            Gets or sets the value of the Type OBEX header.
            </summary>
    </member>
    <member name="P:InTheHand.Net.ObexWebRequest.ContentLength">
      <summary>
            Gets or sets the Length OBEX header.
            </summary>
      <remarks>This property is mandatory, if not set no data will be sent.
            If you use the <see cref="M:InTheHand.Net.ObexWebRequest.ReadFile(System.String)" /> helper method this value is automatically populated with the size of the file that was read.</remarks>
    </member>
    <member name="P:InTheHand.Net.ObexWebRequest.Proxy">
      <summary>
            Not Supported - do not use, this will throw an exception.
            </summary>
    </member>
    <member name="P:InTheHand.Net.ObexWebRequest.Timeout">
      <summary>
            Gets or sets the time-out value for the <see cref="M:InTheHand.Net.ObexWebRequest.GetResponse" /> method.
            </summary>
            -
            <remarks><para>In versions 3.2 and earlier this property was ignored on
            Windows Mobile.  It is now (untested!) supported there,
            but not with the Microsoft Bluetooth stack there as it doesn't
            support timeouts.
            A cunning solution is available let me know of your requirements...
            </para></remarks>
            -
            <value>The number of milliseconds to wait before the request times out.
            The default is 50,000 milliseconds (50 seconds).
            A value of -1 or 0 represents no time-out.</value></member>
    <member name="P:InTheHand.Net.ObexWebRequest.RequestUri">
      <summary>
            Gets the original Uniform Resource Identifier (URI) of the request. 
            </summary>
      <remarks>For an ObexPush request the URI will use the "obex://" prefix, followed by the numerical device id in hex format.
            The path section of the URI represents the remote filename of the pushed object. Subfolders are not supported. Some devices may only support specific object types e.g. V-Card.</remarks>
    </member>
    <member name="T:InTheHand.Net.Sockets.BluetoothListener">
      <summary>
            Listens for connections from Bluetooth RFCOMM network clients.
            </summary>
      <remarks>
        <para>The <see cref="T:InTheHand.Net.Sockets.BluetoothListener" /> class provides simple methods 
            that listen for and accept incoming connection requests.  New connections 
            are returned as <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> instances 
            (on Microsoft Bluetooth stack platforms alone a new <see cref="T:System.Net.Sockets.Socket" /> 
            instance can be returned for new connections).
            </para>
        <para>In the normal case a the listener is initialised with a 
            <see cref="T:System.Guid" /> holding the Service Class Id on which it is 
            to accept connections, the listener will automatically create a SDP 
            Service Record containg that Service Class Id and the port number
            (RFCOMM Service Channel Number) that it has started listening on.
            The standard usage is thus as follows.
            </para>
        <code lang="VB.NET">
            Class MyConsts
              Shared ReadOnly MyServiceUuid As Guid _
                = New Guid("{00112233-4455-6677-8899-aabbccddeeff}")
            End Class
            
              ...
              Dim lsnr As New BluetoothListener(MyConsts.MyServiceUuid)
              lsnr.Start()
              ' Now accept new connections, perhaps using the thread pool to handle each
              Dim conn As New BluetoothClient = lsnr.AcceptBluetoothClient()
              Dim peerStream As Stream = conn.GetStream()
              ...
            </code>
        <para>One can also pass the BluetoothListener a Service Name (v2.4), 
            a custom Service Record (Service Discovery Protocol record), and/or 
            set Class of Service bit(s). To create a custom Service Record use 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceRecordBuilder" />.
            </para>
        <para>There are overloads of the constructor which take a 
            <see cref="T:InTheHand.Net.BluetoothEndPoint" /> parameter instead of a 
            <see cref="T:System.Guid" /> as the Service Class Id, the Class Id
            value should be specified in that case in the endpoint.
            If the port value is specified in the endpoint, then the listener will 
            attempt to bind to that port locally.  The address in the endpoint is 
            largely ignored as no current stack supports more than one local radio.
            </para>
        <para>As of version 3.4 we catch an exception if it occurs on the new 
            port set-up and it is stored. That error will be returned to any subsequent 
            Accept; that is we assume that the error affects the listener completely 
            and so make no attempt to start a new port and all subsequent Accept 
            complete with the original error.
            </para>
        <para>In the Bluetopia case previously the 'one port at a time' error
            was unhandled and occurred on a background thread and therefore killed
            the application.  Now it is caught and returned to the next Accept.
            Even better the first Accept successfully returns back to the caller.
            So BluetoothListener is now usable to that extent: one connection can
            be accepted.  After that it needs to be discarded and a new server created.
            </para>
      </remarks>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(System.Guid)">
      <overloads>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" /> class.
            </overloads>
            ----
            <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" /> class
            to listen on the specified service identifier.
            </summary><param name="service">The Bluetooth service to listen for.</param><remarks><para>
            An SDP record is published on successful <see cref="M:InTheHand.Net.Sockets.BluetoothListener.Start" />
            to advertise the server.
            A generic record is created, containing the essential <c>ServiceClassIdList</c>
            and <c>ProtocolDescriptorList</c> attributes.  The specified service identifier is
            inserted into the former, and the RFCOMM Channel number that the server is
            listening on is inserted into the latter.  See the Bluetooth SDP specification
            for details on the use and format of SDP records.
            </para><para>
            If a SDP record with more elements is required, then use
            one of the other constructors that takes an SDP record e.g. 
            <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(System.Guid,InTheHand.Net.Bluetooth.ServiceRecord)" />,
            or when passing it as a byte array 
            <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(System.Guid,System.Byte[],System.Int32)" />.
            The format of the generic record used here is shown there also.
            </para><para>
            Call the <see cref="M:InTheHand.Net.Sockets.BluetoothListener.Start" /> 
            method to begin listening for incoming connection attempts.
            </para></remarks></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" /> class
            that listens for incoming connection attempts on the specified local Bluetooth address and service identifier. 
            </summary>
      <param name="localaddr">A <see cref="T:InTheHand.Net.BluetoothAddress" /> that represents the local Bluetooth radio address.</param>
      <param name="service">The Bluetooth service on which to listen for incoming connection attempts.</param>
      <remarks>
        <para>
            An SDP record is published on successful <see cref="M:InTheHand.Net.Sockets.BluetoothListener.Start" />
            to advertise the server.
            A generic record is created, containing the essential <c>ServiceClassIdList</c>
            and <c>ProtocolDescriptorList</c> attributes.  The specified service identifier is
            inserted into the former, and the RFCOMM Channel number that the server is
            listening on is inserted into the latter.  See the Bluetooth SDP specification
            for details on the use and format of SDP records.
            </para>
        <para>
            If a SDP record with more elements is required, then use
            one of the other constructors that takes an SDP record e.g. 
            <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid,InTheHand.Net.Bluetooth.ServiceRecord)" />,
            or when passing it as a byte array, e.g. 
            <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid,System.Byte[],System.Int32)" />.
            The format of the generic record used here is shown there also.
            </para>
        <para>
            Call the <see cref="M:InTheHand.Net.Sockets.BluetoothListener.Start" /> 
            method to begin listening for incoming connection attempts.
            </para>
      </remarks>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothEndPoint)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" /> class
            with the specified local endpoint.
            </summary>
            -
            <param name="localEP">A <see cref="T:InTheHand.Net.BluetoothEndPoint" /> that represents 
            the local endpoint to which to bind the listener.
            See the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" /> documentation for more information 
            on the usage of this argument.
            </param>
            -
            <remarks><para>
            An SDP record is published on successful <see cref="M:InTheHand.Net.Sockets.BluetoothListener.Start" />
            to advertise the server.
            A generic record is created, containing the essential <c>ServiceClassIdList</c>
            and <c>ProtocolDescriptorList</c> attributes.  The specified service identifier is
            inserted into the former, and the RFCOMM Channel number that the server is
            listening on is inserted into the latter.  See the Bluetooth SDP specification
            for details on the use and format of SDP records.
            </para><para>
            If a SDP record with more elements is required, then use
            one of the other constructors that takes an SDP record e.g. 
            <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothEndPoint,InTheHand.Net.Bluetooth.ServiceRecord)" />,
            or when passing it as a byte array
            <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothEndPoint,System.Byte[],System.Int32)" />.
            The format of the generic record used here is shown there also.
            </para><para>
            Call the <see cref="M:InTheHand.Net.Sockets.BluetoothListener.Start" /> 
            method to begin listening for incoming connection attempts.
            </para></remarks></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(System.Guid,System.Byte[],System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" /> class
            to listen on the specified service identifier, 
            publishing the specified SDP record.
            </summary>
      <param name="service">The Bluetooth service to listen for.</param>
      <param name="sdpRecord">Prepared SDP Record to publish.</param>
      <param name="channelOffset">
            The index in the <paramref name="sdpRecord" /> byte array where the RFCOMM Channel Number that the
            server is listening on is to be placed.
            However the supplied record is now parsed into an <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            instance, and the channel offset is not used.
            </param>
      <remarks>
        <note>
            The constructors taking the SDP record explicitly (as a byte array) should
            only be used if
            a specialized SDP record is required. For instance when using one of the
            standard profiles.  Otherwise use one of the other constructors 
            e.g. <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(System.Guid)" />
            which create a generic SDP Record from the specified service identifier.
            </note>
        <para>Instead of passing a byte array containing a hand-built record,
            the record can also be built using the <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            and <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" /> classes, and
            passed to the respective constuctor, e.g.
            <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(System.Guid,InTheHand.Net.Bluetooth.ServiceRecord)" /></para>
        <para>Any useful SDP record will include 
            a <c>ProtocolDescriptor</c> element containing
            the RFCOMM Channel number that the server is listening on,
            and a <c>ServiceClassId</c> element containing the service UUIDs.
            The record supplied in the <paramref name="sdpRecord" /> parameter
            should contain those elements.  On successful <see cref="M:InTheHand.Net.Sockets.BluetoothListener.Start" />,
            the RFCOMM Channel number that the protocol stack has assigned to the
            server is retrieved, and copied into the service record before it is
            published.  The <paramref name="channelOffset" /> indicates the location
            of the respective byte in the <paramref name="sdpRecord" /> byte array.
            </para>
        <para>
            An example SDP record is as follows.  This is actually the format of the 
            generic record used in the other constructors.  For another example see
            the code in the <c>ObexListener</c> class.
            <code>
            // The asterisks note where the Service UUID and the Channel number are
            // to be filled in.
            byte[] record = new byte[] {
              //Element Sequence:
              0x35,0x27,
                //UInt16: 0x0001  -- ServiceClassIdList
                0x09,0x00,0x01,
                //Element Sequence:
                0x35,0x11,
                //  UUID128: 00000000-0000-0000-0000-000000000000 -- * Service UUID
                    0x1c,
                      0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
                      0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
                //
                //UInt16: 0x0004  -- ProtocolDescriptorList
                0x09,0x00,0x04,
                //Element Sequence:
                0x35,0x0c,
                //  Element Sequence:
                    0x35,0x03,
                //      UUID16: 0x0100  -- L2CAP
                        0x19,0x01,0x00,
                //  Element Sequence:
                    0x35,0x05,
                //      UUID16: 0x0003  -- RFCOMM
                        0x19,0x00,0x03,
                //      UInt8: 0x00     -- * Channel Number
                        0x08,0x00
            };
            </code>
            For that record the <c>channelOffset</c> is 40.
            </para>
      </remarks>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid,System.Byte[],System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" /> class
            that listens for incoming connection attempts on the specified local Bluetooth address and service identifier,
            publishing the specified SDP record.
            </summary>
      <param name="localaddr">A <see cref="T:InTheHand.Net.BluetoothAddress" /> that represents the local Bluetooth radio address.</param>
      <param name="service">The Bluetooth service to listen for.</param>
      <param name="sdpRecord">Prepared SDP Record to publish</param>
      <param name="channelOffset">
            The index in the <paramref name="sdpRecord" /> byte array where the RFCOMM Channel Number that the
            server is listening on is to be placed.
            However the supplied record is now parsed into an <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            instance, and the channel offset is not used.
            </param>
      <remarks>
        <note>
            The constructors taking the SDP record explicitly (as a byte array) should
            only be used if
            a specialized SDP record is required. For instance when using one of the
            standard profiles.  Otherwise use one of the other constructors 
            e.g. <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid)" />
            which create a generic SDP Record from the specified service identifier.
            </note>
        <para>Instead of passing a byte array containing a hand-built record,
            the record can also be built using the <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            and <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" /> classes, and
            passed to the respective constuctor, e.g.
            <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid,InTheHand.Net.Bluetooth.ServiceRecord)" /></para>
        <para>Any useful SDP record will include 
            a <c>ProtocolDescriptor</c> element containing
            the RFCOMM Channel number that the server is listening on,
            and a <c>ServiceClassId</c> element containing the service UUIDs.
            The record supplied in the <paramref name="sdpRecord" /> parameter
            should contain those elements.  On successful <see cref="M:InTheHand.Net.Sockets.BluetoothListener.Start" />,
            the RFCOMM Channel number that the protocol stack has assigned to the
            server is retrieved, and copied into the service record before it is
            published.  The <paramref name="channelOffset" /> indicates the location
            of the respective byte in the <paramref name="sdpRecord" /> byte array.
            </para>
        <para>
            An example SDP record is as follows.  This is actually the format of the 
            generic record used in the other constructors.  For another example see
            the code in the <c>ObexListener</c> class.
            <code>
            // The asterisks note where the Service UUID and the Channel number are
            // to be filled in.
            byte[] record = new byte[] {
              //Element Sequence:
              0x35,0x27,
                //UInt16: 0x0001  -- ServiceClassIdList
                0x09,0x00,0x01,
                //Element Sequence:
                0x35,0x11,
                //  UUID128: 00000000-0000-0000-0000-000000000000 -- * Service UUID
                    0x1c,
                      0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
                      0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
                //
                //UInt16: 0x0004  -- ProtocolDescriptorList
                0x09,0x00,0x04,
                //Element Sequence:
                0x35,0x0c,
                //  Element Sequence:
                    0x35,0x03,
                //      UUID16: 0x0100  -- L2CAP
                        0x19,0x01,0x00,
                //  Element Sequence:
                    0x35,0x05,
                //      UUID16: 0x0003  -- RFCOMM
                        0x19,0x00,0x03,
                //      UInt8: 0x00     -- * Channel Number
                        0x08,0x00
            };
            </code>
            For that record the <c>channelOffset</c> is 40.
            </para>
      </remarks>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothEndPoint,System.Byte[],System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" /> class
            with the specified local endpoint,
            publishing the specified SDP record.
            </summary>
            -
            <param name="localEP">A <see cref="T:InTheHand.Net.BluetoothEndPoint" /> that represents 
            the local endpoint to which to bind the listener.
            See the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" /> documentation for more information 
            on the usage of this argument.
            </param><param name="sdpRecord">Prepared SDP Record to publish</param><param name="channelOffset">
            The index in the <paramref name="sdpRecord" /> byte array where the RFCOMM Channel Number that the
            server is listening on is to be placed.
            However the supplied record is now parsed into an <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            instance, and the channel offset is not used.
            </param>
            -
            <remarks><note>
            The constructors taking the SDP record explicitly (as a byte array) should
            only be used if
            a specialized SDP record is required. For instance when using one of the
            standard profiles.  Otherwise use one of the other constructors 
            e.g. <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothEndPoint)" />
            which create a generic SDP Record from the specified service identifier.
            </note><para>Instead of passing a byte array containing a hand-built record,
            the record can also be built using the <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            and <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" /> classes, and
            passed to the respective constuctor, e.g.
            <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothEndPoint,InTheHand.Net.Bluetooth.ServiceRecord)" /></para><para>Any useful SDP record will include 
            a <c>ProtocolDescriptor</c> element containing
            the RFCOMM Channel number that the server is listening on,
            and a <c>ServiceClassId</c> element containing the service UUIDs.
            The record supplied in the <paramref name="sdpRecord" /> parameter
            should contain those elements.  On successful <see cref="M:InTheHand.Net.Sockets.BluetoothListener.Start" />,
            the RFCOMM Channel number that the protocol stack has assigned to the
            server is retrieved, and copied into the service record before it is
            published.  The <paramref name="channelOffset" /> indicates the location
            of the respective byte in the <paramref name="sdpRecord" /> byte array.
            </para><para>
            An example SDP record is as follows.  This is actually the format of the 
            generic record used in the other constructors.  For another example see
            the code in the <c>ObexListener</c> class.
            <code>
            // The asterisks note where the Service UUID and the Channel number are
            // to be filled in.
            byte[] record = new byte[] {
              //Element Sequence:
              0x35,0x27,
                //UInt16: 0x0001  -- ServiceClassIdList
                0x09,0x00,0x01,
                //Element Sequence:
                0x35,0x11,
                //  UUID128: 00000000-0000-0000-0000-000000000000 -- * Service UUID
                    0x1c,
                      0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
                      0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
                //
                //UInt16: 0x0004  -- ProtocolDescriptorList
                0x09,0x00,0x04,
                //Element Sequence:
                0x35,0x0c,
                //  Element Sequence:
                    0x35,0x03,
                //      UUID16: 0x0100  -- L2CAP
                        0x19,0x01,0x00,
                //  Element Sequence:
                    0x35,0x05,
                //      UUID16: 0x0003  -- RFCOMM
                        0x19,0x00,0x03,
                //      UInt8: 0x00     -- * Channel Number
                        0x08,0x00
            };
            </code>
            For that record the <c>channelOffset</c> is 40.
            </para></remarks></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(System.Guid,InTheHand.Net.Bluetooth.ServiceRecord)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" /> class
            to listen on the specified service identifier, 
            publishing the specified SDP record.
            </summary>
            -
            <param name="service">The Bluetooth service to listen for.</param><param name="sdpRecord">Prepared SDP Record to publish.</param>
            -
            <remarks><note>
            The constructors taking the SDP record explicitly should
            only be used if
            a specialized SDP record is required. For instance when using one of the
            standard profiles.  Otherwise use one of the other constructors 
            e.g. <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(System.Guid)" />
            which create a generic SDP Record from the specified service identifier.
            </note><para>Any useful SDP record will include 
            a <c>ProtocolDescriptor</c> element containing
            the RFCOMM Channel number that the server is listening on,
            and a <c>ServiceClassId</c> element containing the service UUIDs.
            The record supplied in the <paramref name="sdpRecord" /> parameter
            should contain those elements.  On successful <see cref="M:InTheHand.Net.Sockets.BluetoothListener.Start" />,
            the RFCOMM Channel number that the protocol stack has assigned to the
            server is retrieved, and copied into the service record before it is
            published.
            </para><para>
            An example SDP record is as follows.  This is actually the format of the 
            generic record used in the other constructors.  For another example see
            the code in the <c>ObexListener</c> class.
            <code lang="C#">
            private static ServiceRecord CreateBasicRfcommRecord(Guid serviceClassUuid)
            {
                ServiceElement pdl = ServiceRecordHelper.CreateRfcommProtocolDescriptorList();
                ServiceElement classList = new ServiceElement(ElementType.ElementSequence,
                    new ServiceElement(ElementType.Uuid128, serviceClassUuid));
                ServiceRecord record = new ServiceRecord(
                    new ServiceAttribute(
                        InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceClassIdList,
                        classList),
                    new ServiceAttribute(
                        InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList,
                        pdl));
                return record;
            }
            </code></para></remarks></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid,InTheHand.Net.Bluetooth.ServiceRecord)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" /> class
            that listens for incoming connection attempts on the specified local Bluetooth address and service identifier,
            publishing the specified SDP record.
            </summary>
            -
            <param name="localaddr">A <see cref="T:InTheHand.Net.BluetoothAddress" /> that represents the local Bluetooth radio address.</param><param name="service">The Bluetooth service to listen for.</param><param name="sdpRecord">Prepared SDP Record to publish</param>
            -
            <remarks><note>
            The constructors taking the SDP record explicitly should
            only be used if
            a specialized SDP record is required. For instance when using one of the
            standard profiles.  Otherwise use one of the other constructors 
            e.g. <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid)" />
            which create a generic SDP Record from the specified service identifier.
            </note><para>Any useful SDP record will include 
            a <c>ProtocolDescriptor</c> element containing
            the RFCOMM Channel number that the server is listening on,
            and a <c>ServiceClassId</c> element containing the service UUIDs.
            The record supplied in the <paramref name="sdpRecord" /> parameter
            should contain those elements.  On successful <see cref="M:InTheHand.Net.Sockets.BluetoothListener.Start" />,
            the RFCOMM Channel number that the protocol stack has assigned to the
            server is retrieved, and copied into the service record before it is
            published.
            </para><para>
            An example SDP record is as follows.  This is actually the format of the 
            generic record used in the other constructors.  For another example see
            the code in the <c>ObexListener</c> class.
            <code lang="C#">
            private static ServiceRecord CreateBasicRfcommRecord(Guid serviceClassUuid)
            {
                ServiceElement pdl = ServiceRecordHelper.CreateRfcommProtocolDescriptorList();
                ServiceElement classList = new ServiceElement(ElementType.ElementSequence,
                    new ServiceElement(ElementType.Uuid128, serviceClassUuid));
                ServiceRecord record = new ServiceRecord(
                    new ServiceAttribute(
                        InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceClassIdList,
                        classList),
                    new ServiceAttribute(
                        InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList,
                        pdl));
                return record;
            }
            </code></para></remarks></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothEndPoint,InTheHand.Net.Bluetooth.ServiceRecord)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" /> class
            with the specified local endpoint,
            publishing the specified SDP record.
            </summary>
            -
            <param name="localEP">A <see cref="T:InTheHand.Net.BluetoothEndPoint" /> that represents 
            the local endpoint to which to bind the listener.
            See the <see cref="T:InTheHand.Net.Sockets.BluetoothListener" /> documentation for more information 
            on the usage of this argument.
            </param><param name="sdpRecord">Prepared SDP Record to publish</param>
            -
            <remarks><note>
            The constructors taking the SDP record explicitly (as a byte array) should
            only be used if
            a specialized SDP record is required. For instance when using one of the
            standard profiles.  Otherwise use one of the other constructors 
            e.g. <see cref="M:InTheHand.Net.Sockets.BluetoothListener.#ctor(InTheHand.Net.BluetoothEndPoint)" />
            which create a generic SDP Record from the specified service identifier.
            </note><para>Any useful SDP record will include 
            a <c>ProtocolDescriptor</c> element containing
            the RFCOMM Channel number that the server is listening on,
            and a <c>ServiceClassId</c> element containing the service UUIDs.
            The record supplied in the <paramref name="sdpRecord" /> parameter
            should contain those elements.  On successful <see cref="M:InTheHand.Net.Sockets.BluetoothListener.Start" />,
            the RFCOMM Channel number that the protocol stack has assigned to the
            server is retrieved, and copied into the service record before it is
            published.
            </para><para>
            An example SDP record is as follows.  This is actually the format of the 
            generic record used in the other constructors.  For another example see
            the code in the <c>ObexListener</c> class.
            <code lang="C#">
            private static ServiceRecord CreateBasicRfcommRecord(Guid serviceClassUuid)
            {
                ServiceElement pdl = ServiceRecordHelper.CreateRfcommProtocolDescriptorList();
                ServiceElement classList = new ServiceElement(ElementType.ElementSequence,
                    new ServiceElement(ElementType.Uuid128, serviceClassUuid));
                ServiceRecord record = new ServiceRecord(
                    new ServiceAttribute(
                        InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceClassIdList,
                        classList),
                    new ServiceAttribute(
                        InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList,
                        pdl));
                return record;
            }
            </code></para></remarks></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothListener.Start">
      <summary>
            Starts listening for incoming connection requests.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothListener.Start(System.Int32)">
      <summary>
            Starts listening for incoming connection requests with a maximum number of pending connection.
            </summary>
      <param name="backlog">The maximum length of the pending connections queue.</param>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothListener.Stop">
      <summary>
            Stops the socket from monitoring connections.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothListener.BeginAcceptSocket(System.AsyncCallback,System.Object)">
      <summary>
            Begins an asynchronous operation to accept an incoming connection attempt.
            </summary>
            -
            <remarks><note>The method is only supported on Microsoft Bluetooth stack platforms.
            </note></remarks>
            -
            <param name="callback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</param><param name="state">A user-defined object containing information about the accept operation.
            This object is passed to the callback delegate when the operation is complete.</param>
            -
            <returns>An <see cref="T:System.IAsyncResult" /> that represents the 
            asynchronous accept, which could still be pending.
            </returns>
            -
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothListener.EndAcceptSocket(System.IAsyncResult)">
      <summary>
            Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> to handle remote host communication.
            </summary>
      <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> returned by a call to the <see cref="M:InTheHand.Net.Sockets.BluetoothListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" /> method.</param>
      <returns>A <see cref="T:System.Net.Sockets.Socket" />.</returns>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothListener.BeginAcceptBluetoothClient(System.AsyncCallback,System.Object)">
      <summary>
            Begins an asynchronous operation to accept an incoming connection attempt.
            </summary>
            -
            <param name="callback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</param><param name="state">A user-defined object containing information about the accept operation.
            This object is passed to the callback delegate when the operation is complete.</param>
            -
            <returns>An <see cref="T:System.IAsyncResult" /> that represents the 
            asynchronous accept, which could still be pending.
            </returns></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothListener.EndAcceptBluetoothClient(System.IAsyncResult)">
      <summary>
            Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> to handle remote host communication.
            </summary>
      <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> returned by a call to the <see cref="M:InTheHand.Net.Sockets.BluetoothListener.BeginAcceptBluetoothClient(System.AsyncCallback,System.Object)" /> method.</param>
      <returns>A <see cref="T:InTheHand.Net.Sockets.BluetoothClient" />.</returns>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothListener.AcceptSocket">
      <summary>
            Creates a new socket for a connection.
            </summary>
            -
            <remarks><note>The method is only supported on Microsoft Bluetooth stack platforms.
            </note><para>AcceptSocket is a blocking method that returns a <see cref="T:System.Net.Sockets.Socket" /> that you can use to send and receive data.
            If you want to avoid blocking, use the <see cref="M:InTheHand.Net.Sockets.BluetoothListener.Pending" /> method to determine if connection requests are available in the incoming connection queue.
            </para><para>The <see cref="T:System.Net.Sockets.Socket" /> returned is initialized with the address and channel number of the remote device.
            You can use any of the Send and Receive methods available in the <see cref="T:System.Net.Sockets.Socket" /> class to communicate with the remote device.
            When you are finished using the <see cref="T:System.Net.Sockets.Socket" />, be sure to call its <see cref="M:System.Net.Sockets.Socket.Close" /> method.
            If your application is relatively simple, consider using the <see cref="M:InTheHand.Net.Sockets.BluetoothListener.AcceptBluetoothClient" /> method rather than the AcceptSocket method.
            <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> provides you with simple methods for sending and receiving data over a network in blocking synchronous mode.</para></remarks><returns>A <see cref="T:System.Net.Sockets.Socket" /> used to send and receive data.</returns><exception cref="T:System.InvalidOperationException">Listener is stopped.</exception></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothListener.AcceptBluetoothClient">
      <summary>
            Creates a client object for a connection when the specified service or endpoint is detected by the listener component.
            </summary>
      <remarks>AcceptTcpClient is a blocking method that returns a <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> that you can use to send and receive data.
            Use the <see cref="M:InTheHand.Net.Sockets.BluetoothListener.Pending" /> method to determine if connection requests are available in the incoming connection queue if you want to avoid blocking.
            <para>Use the <see cref="M:InTheHand.Net.Sockets.BluetoothClient.GetStream" /> method to obtain the underlying <see cref="T:System.Net.Sockets.NetworkStream" /> of the returned <see cref="T:InTheHand.Net.Sockets.BluetoothClient" />.
            The <see cref="T:System.Net.Sockets.NetworkStream" /> will provide you with methods for sending and receiving with the remote host.
            When you are through with the <see cref="T:InTheHand.Net.Sockets.BluetoothClient" />, be sure to call its <see cref="M:InTheHand.Net.Sockets.BluetoothClient.Close" /> method.
            If you want greater flexibility than a <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> offers, consider using <see cref="M:InTheHand.Net.Sockets.BluetoothListener.AcceptSocket" />.</para></remarks>
      <returns>A <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> component.</returns>
      <exception cref="T:System.InvalidOperationException">Listener is stopped.</exception>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothListener.Pending">
      <summary>
            Determines if there is a connection pending.
            </summary>
      <returns>true if there is a connection pending; otherwise, false.</returns>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothListener.SetPin(InTheHand.Net.BluetoothAddress,System.String)">
      <summary>
            Set or change the PIN to be used with a specific remote device.
            </summary>
      <param name="device">Address of Bluetooth device.</param>
      <param name="pin">PIN string consisting of 1 to 16 ASCII characters.</param>
      <remarks>Assigning null (Nothing in VB) or an empty String will revoke the PIN.</remarks>
    </member>
    <member name="P:InTheHand.Net.Sockets.BluetoothListener.LocalEndPoint">
      <summary>
            Gets the local endpoint.
            </summary>
            -
            <value>The <see cref="T:InTheHand.Net.BluetoothEndPoint" />
            that the listener is using for communications.
            </value>
            -
            <remarks><para>The <see cref="P:InTheHand.Net.BluetoothEndPoint.Port" /> 
            property of the endpoint will contain the port number (RFCOMM Channel 
            Number) that the listener is listening on.
            On some platforms, the <see cref="P:InTheHand.Net.BluetoothEndPoint.Address" />
            is similarly set, or is <see cref="F:InTheHand.Net.BluetoothAddress.None" /> 
            if not known.  The endpoints <see cref="P:InTheHand.Net.BluetoothEndPoint.Service" />
            is never set.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Sockets.BluetoothListener.ServiceClass">
      <summary>
            Get or set the Service Class flags that this service adds to the host 
            devices Class Of Device field.
            </summary>
            -
            <remarks><para>The Class of Device value contains a Device part which describes 
            the primary service that the device provides, and a Service part which 
            is a set of flags indicating all the service types that the device supports, 
            e.g. <see cref="F:InTheHand.Net.Bluetooth.ServiceClass.ObjectTransfer" />,
            <see cref="F:InTheHand.Net.Bluetooth.ServiceClass.Telephony" />,
            <see cref="F:InTheHand.Net.Bluetooth.ServiceClass.Audio" /> etc.
            This property supports setting those flags; bits set in this value will be 
            <strong>added</strong> to the host devices CoD Service Class bits when the listener
            is active.  For Win32 see <see href="http://msdn.microsoft.com/en-us/library/aa362940(VS.85).aspx">MSDN  BTH_SET_SERVICE Structure</see></para><para><note>Supported on Win32, but not supported on WindowsMobile/WinCE 
            as there's no native API for it.  The WindowCE section of MSDN mentions the
            Registry value <c>COD</c> at key <c>HKEY_LOCAL_MACHINE\Software\Microsoft\Bluetooth\sys</c>. 
            However my (Jam) has value 0x920100 there but advertises a CoD of 0x100114, 
            so its not clear how the values relate to each other.
            </note></para></remarks></member>
    <member name="P:InTheHand.Net.Sockets.BluetoothListener.ServiceName">
      <summary>
            Get or set the ServiceName the server will use in its SDP Record.
            </summary>
            -
            <value>A string representing the value to be used for the Service Name
            SDP Attribute.  Will be <see langword="null" /> if not specfied.
            </value>
            -
            <exception cref="T:System.InvalidOperationException">
            The listener is already started.
            <para>- or -</para>
            A custom Service Record was given at initialization time.  In that case 
            the ServiceName attribute should be added to that record.
            </exception></member>
    <member name="P:InTheHand.Net.Sockets.BluetoothListener.Server">
      <summary>
            Gets the underlying network <see cref="T:System.Net.Sockets.Socket" />.
            </summary>
            -
            <value>The underlying network <see cref="T:System.Net.Sockets.Socket" />.</value>
            -
            <remarks><note>The property is only supported on Microsoft Bluetooth stack platforms.
            </note><para><see cref="T:InTheHand.Net.Sockets.BluetoothListener" /> creates a <see cref="T:System.Net.Sockets.Socket" /> to listen for incoming client connection requests.
            Classes deriving from <see cref="T:InTheHand.Net.Sockets.BluetoothListener" /> can use this property to get this <see cref="T:System.Net.Sockets.Socket" />.
            Use the underlying <see cref="T:System.Net.Sockets.Socket" /> returned by the <see cref="P:InTheHand.Net.Sockets.BluetoothListener.Server" /> property if you require access beyond that which <see cref="T:InTheHand.Net.Sockets.BluetoothListener" /> provides.
            </para><para>Note <see cref="P:InTheHand.Net.Sockets.BluetoothListener.Server" /> property only returns the <see cref="T:System.Net.Sockets.Socket" /> used to listen for incoming client connection requests.
            Use the <see cref="M:InTheHand.Net.Sockets.BluetoothListener.AcceptSocket" /> method to accept a pending connection request and obtain a <see cref="T:System.Net.Sockets.Socket" /> for sending and receiving data.
            You can also use the <see cref="M:InTheHand.Net.Sockets.BluetoothListener.AcceptBluetoothClient" /> method to accept a pending connection request and obtain a <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> for sending and receiving data.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Sockets.BluetoothListener.ServiceRecord">
      <summary>
            Returns the SDP Service Record for this service.
            </summary>
      <remarks>
        <note>Returns <see langword="null" /> if the listener is not 
            <see cref="M:InTheHand.Net.Sockets.BluetoothListener.Start" />ed
            (and an record wasnt supplied at initialization).
            </note>
      </remarks>
    </member>
    <member name="P:InTheHand.Net.Sockets.BluetoothListener.Authenticate">
      <summary>
            Gets or sets the authentication state of the current connect or behaviour to use when connection is established.
            </summary>
      <remarks>
            For disconnected sockets, specifies that authentication is required in order for a connect or accept operation to complete successfully.
            Setting this option actively initiates authentication during connection establishment, if the two Bluetooth devices were not previously authenticated.
            The user interface for passkey exchange, if necessary, is provided by the operating system outside the application context.
            For outgoing connections that require authentication, the connect operation fails with WSAEACCES if authentication is not successful.
            In response, the application may prompt the user to authenticate the two Bluetooth devices before connection.
            For incoming connections, the connection is rejected if authentication cannot be established and returns a WSAEHOSTDOWN error.
            </remarks>
    </member>
    <member name="P:InTheHand.Net.Sockets.BluetoothListener.Encrypt">
      <summary>
            On unconnected sockets, enforces encryption to establish a connection.
            Encryption is only available for authenticated connections.
            For incoming connections, a connection for which encryption cannot be established is automatically rejected and returns WSAEHOSTDOWN as the error.
            For outgoing connections, the connect function fails with WSAEACCES if encryption cannot be established.
            In response, the application may prompt the user to authenticate the two Bluetooth devices before connection.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Sockets.BluetoothDeviceInfo">
      <summary>
            Provides information about an available device obtained by the client during device discovery.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.#ctor(InTheHand.Net.BluetoothAddress)">
      <summary>
            Initializes an instance of the <see cref="T:InTheHand.Net.Sockets.BluetoothDeviceInfo" /> class 
            for the device with the given address.
            </summary>
            -
            <param name="address">The <see cref="T:InTheHand.Net.BluetoothAddress" />.</param></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.Refresh">
      <summary>
            Forces the system to refresh the device information.
            </summary>
            -
            <remarks>
            See <see cref="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.DeviceName" />
            for one reason why this method is necessary.
            </remarks></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.Update">
      <summary>
            Updates the device name used to display the device, affects the local computer cache.
            </summary>
      <remarks>On Windows CE this only affects devices which are already paired.</remarks>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.SetServiceState(System.Guid,System.Boolean)">
      <summary>
             Enables or disables services for a Bluetooth device.
             </summary>
      <param name="service">The service GUID on the remote device.</param>
      <param name="state">Service state - TRUE to enable the service, FALSE to disable it.</param>
      <remarks>
             When called on Windows CE, the device will require a soft-reset to enabled the settings.
             
            <note><para>The system maintains a mapping of service guids to supported drivers for
             Bluetooth-enabled devices. Enabling a service installs the corresponding
             device driver. Disabling a service removes the corresponding device driver.
             If a non-supported service is enabled, a driver will not be installed.
             </para></note><para>This overload is silent on error; the other overload raises an exception
             if required
             (<see cref="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.SetServiceState(System.Guid,System.Boolean,System.Boolean)" />).
             </para></remarks>
             -
             <exception cref="T:System.PlatformNotSupportedException">
             Thrown if this method is called on Windows CE platforms.</exception></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.SetServiceState(System.Guid,System.Boolean,System.Boolean)">
      <summary>
             Enables or disables services for a Bluetooth device.
             </summary>
      <param name="service">The service GUID on the remote device.</param>
      <param name="state">Service state - TRUE to enable the service, FALSE to disable it.</param>
      <param name="throwOnError">Whether the method should raise an exception
             when 
             </param>
      <remarks>
             When called on Windows CE, the device will require a soft-reset to enabled the settings.
            <note><para>The system maintains a mapping of service guids to supported drivers for
             Bluetooth-enabled devices. Enabling a service installs the corresponding
             device driver. Disabling a service removes the corresponding device driver.
             If a non-supported service is enabled, a driver will not be installed.
             </para></note></remarks>
             -
             <exception cref="T:System.ComponentModel.Win32Exception">The call failed.
             </exception></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.GetServiceRecords(System.Guid)">
      <summary>
            Run an SDP query on the devices Service Discovery Database.
            </summary>
            -
            <remarks><para>
            For instance to see whether the device has an an Serial Port service
            search for UUID <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.SerialPort" />,
            or too find all the services that use RFCOMM use 
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.RFCommProtocol" />,
            or all the services use 
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.L2CapProtocol" />.
            </para><para>
            If the device isnt accessible a <see cref="T:System.Net.Sockets.SocketException" />
            with <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />
            10108 (0x277C) occurs.
            </para></remarks>
            -
            <param name="service">The UUID to search for, as a <see cref="T:System.Guid" />.
            </param>
            -
            <returns>The parsed record as an 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />.
            </returns>
            -
            <example><code lang="VB.NET">
            Dim bdi As BluetoothDeviceInfo = ...
            Dim records As ServiceRecord() = bdi.GetServiceRecords(BluetoothService.RFCommProtocol)
            ' Dump each to console
            For Each curRecord As ServiceRecord In records
               ServiceRecordUtilities.Dump(Console.Out, curRecord)
            Next
            </code></example>
            
            -
            <exception cref="T:System.Net.Sockets.SocketException">
            The query failed.
            </exception></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.BeginGetServiceRecords(System.Guid,System.AsyncCallback,System.Object)">
      <summary>
            Begins an asynchronous Service Record lookup query.
            </summary>
            -
            <param name="service">See <see cref="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.GetServiceRecords(System.Guid)" />.
            </param><param name="callback">An optional asynchronous callback, to be called 
            when the query is complete.
            </param><param name="state">A user-provided object that distinguishes this 
            particular asynchronous Service Record lookup query from other requests.
            </param>
            -
            <returns>An <see cref="T:System.IAsyncResult" /> that represents the 
            asynchronous Service Record lookup query, which could still be pending.
            </returns></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.EndGetServiceRecords(System.IAsyncResult)">
      <summary>
            Ends an asynchronous Service Record lookup query.
            </summary>
            -
            <param name="asyncResult">An <see cref="T:System.IAsyncResult" />
            object that was obtained when the asynchronous operation was started.
            </param>
            -
            <returns>The parsed record as an 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />.
            </returns></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.GetServiceRecordsUnparsed(System.Guid)">
      <summary>
            Run an SDP query on the devices Service Discovery Database,
            returning the raw byte rather than a parsed record.
            </summary>
            -
            <remarks>
            If the device isnt accessible a <see cref="T:System.Net.Sockets.SocketException" />
            with <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />
            10108 (0x277C) occurs.
            </remarks>
            -
            <param name="service">The UUID to search for, as a <see cref="T:System.Guid" />.
            </param>
            -
            <returns>An array of array of <see cref="T:System.Byte" />.</returns>
            -
            <exception cref="T:System.Net.Sockets.SocketException">
            The query failed.
            </exception></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.GetVersions">
      <summary>
            Gets the radio version and manufacturer information for the device.
            Needs a connection to the device.
            </summary>
            -
            <remarks><para>Includes information such as the LMP versions, supported
            features and the manufacturer of the radio/Bluetooth Controller.
            </para><para>If the device is not connected this information cannot be
            obtained; an error will occur if there is no connection.
            The values will be cached until <see cref="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.Refresh" /> is called.
            </para><para>This feature is currently supported only on the
            Microsoft Bluetooth stack on both desktop Windows and Windows
            Mobile. However Windows XP does not provide this information.
            Implementation is possible on some of the other Bluetooth stacks
            and will depend on demand/support for the user community.
            </para></remarks>
            -
            <exception cref="T:System.ComponentModel.Win32Exception">
            An error occurred, desktop Windows returns error code
            1167 ERROR_DEVICE_NOT_CONNECTED and Windows Mobile returns error code
            1168 ERROR_NOT_FOUND.
            Windows XP which does not support this functionality returns error code
            2 ERROR_FILE_NOT_FOUND.
            </exception><exception cref="T:System.NotImplementedException">
            Not yet implemented.
            </exception><exception cref="T:System.NotSupportedException">
            This stack does not support getting this information.
            </exception>
            -
            <returns>The radio version etc information as a
            <see cref="T:InTheHand.Net.Bluetooth.RadioVersions" /> instance.
            </returns></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.ShowDialog">
      <summary>
            Displays information about the device.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.Equals(System.Object)">
      <summary>
            Compares two <see cref="T:InTheHand.Net.Sockets.BluetoothDeviceInfo" /> instances for equality.
            </summary>
            -
            <param name="obj">The <see cref="T:InTheHand.Net.Sockets.BluetoothDeviceInfo" />
            to compare with the current instance.
            </param>
            -
            <returns><c>true</c> if <paramref name="obj" />
            is a <see cref="T:InTheHand.Net.Sockets.BluetoothDeviceInfo" /> and equal to the current instance;
            otherwise, <c>false</c>.
            </returns></member>
    <member name="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.IsAMsftInternalType(System.Object)">
      <summary>
            E.g. used internally by WPF.
            </summary>
      <param name="obj">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.GetHashCode">
      <summary>
            Returns the hash code for this instance. 
            </summary>
      <returns>A hash code for the current object.</returns>
    </member>
    <member name="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.DeviceAddress">
      <summary>
            Gets the device identifier.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.DeviceName">
      <summary>
            Gets a name of a device.
            </summary>
            -
            <remarks><para>Note, that due the way in which Bluetooth device discovery works,
            the existence and address of a device is known first, but a separate
            query has to be carried out to find whether the device also has a name.
            This means that if a device is discovered afresh then this property might
            return only a text version of the devices address and not its
            name, one can also see this in the Windows Bluetooth device dialogs
            where the device appears first with its address and the name is later
            updated.  To see the name, wait for some time and access this property again
            having called <see cref="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.Refresh" />
            in the meantime.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.ClassOfDevice">
      <summary>
            Returns the Class of Device of the remote device.
            </summary>
            -
            <remarks><para>
            Some CE 4.2 devices such as original PPC2003 devices don't have the native 
            API on which this property depends  it was added as part of a hotfix. 
            The property will always return zero in such a case.  On WM/CE we also 
            attempt to get the CoD value as part of the discovery process; this is 
            of course only works for devices in-range.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.Rssi">
      <summary>
            Returns the signal strength for the Bluetooth connection with the peer device.
            <para><b>Supports only on some platforms.</b></para></summary>
            -
            <value>Valid values for this property are -128 to 128.  It returns
            <see cref="F:System.Int32.MinValue">Int32.MinValue</see> on failure.
            </value>
            -
            <remarks><para>Thus there are multiple reasons which this property can return
            the error value (i.e. <see cref="F:System.Int32.MinValue">Int32.MinValue</see>).
            </para><list type="number"><item>On an unsupported platform, e.g. MSFT+Win32, or MSFT+CE/WM on an
            older version.  See below.
            </item><item>The remote device is not turned-on or in range.  See below.
            </item><item>On Widcomm, there is no connection to the remote device.  See below.
            </item></list><para>Platform support:</para><list type="bullet"><item>Does <b>not</b> work on Win32 with the Microsoft Bluetooth stack.
            That platform provide no support for RSSI, please contact Microsoft
            to complain.
            </item><item>Works on Windows Mobile 5.0, Windows Embedded CE 6.0, or later
            versions.
            </item><item>Works on Widcomm, both platforms.
            We will <i>not</i> try to connect, see below.
            </item></list><para></para><para>Finally, to get an RSSI value Bluetooth requires an open
            connection to the peer device.
            On Widcomm we will <i>not</i> attempt to connect, so the caller must
            ensure that there's a connection --
            perhaps it could call <see cref="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.GetServiceRecords(System.Guid)" />
            just before accessing this property.
            On CE/WM if there is no active connection, then we will attempt to
            create one.  This of course <i>can</i> be <i>slow</i>, and <i>will</i>
            be slow if the remote device is not in range.
            (Bluetooth 2.1 supports getting the RSSI value at discovery time which
            might provide the solution for many cases.  However only the MSFT+Win32
            stack specifically supports v2.1, and of course it doesn't support RSSI
            at all!)
            </para><para>Note that the Bluetooth specification doesn't require that the
            radio hardware provides any great precision in its RSSI readings.
            The spec says for instance, in v2.1 Volume 2 Part E ("HCI") Section 7.5.4:
            Note: how accurate the dB values will be depends on the Bluetooth hardware.
            The only requirements for the hardware are that the Bluetooth device is able to
            tell whether the RSSI is inside, above or below the Golden Device Power Range.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.InstalledServices">
      <summary>
            Returns a list of services which are already installed for use on the calling machine.
            </summary>
      <remarks>
        <para>This property returns the services already configured for use. 
            Those are the ones that are checked in the Services tab
            of the devices property sheet in the Bluetooth Control panel.
            I presume the behaviour is similar on CE.
            </para>
        <para>Will only return available services for paired devices.
            </para>
        <para>It of course will also only returns standard system services which Windows understands.
            (On desktop Windows this method calls the OS function <c>BluetoothEnumerateInstalledServices</c>).
            </para>
        <para>To see all the services that a device advertises use the 
            <see cref="M:InTheHand.Net.Sockets.BluetoothDeviceInfo.GetServiceRecords(System.Guid)" />
            method.
            </para>
      </remarks>
    </member>
    <member name="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.Connected">
      <summary>
            Specifies whether the device is connected.
            </summary>
      <remarks>Not supported under Windows CE and will always return false.</remarks>
      <seealso cref="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.Remembered" />
      <seealso cref="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.Authenticated" />
    </member>
    <member name="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.Remembered">
      <summary>
            Specifies whether the device is a remembered device. Not all remembered devices are authenticated.
            </summary>
            -
            <remarks>Now supported under Windows CE  will return the same as 
            <see cref="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.Authenticated" />.
            </remarks><seealso cref="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.Connected" /><seealso cref="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.Authenticated" /></member>
    <member name="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.Authenticated">
      <summary>
            Specifies whether the device is authenticated, paired, or bonded. All authenticated devices are remembered.
            </summary>
      <remarks>Is now supported on both CE and XP.</remarks>
      <seealso cref="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.Connected" />
      <seealso cref="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.Remembered" />
    </member>
    <member name="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.LastSeen">
      <summary>
            Date and Time this device was last seen by the system.
            </summary>
            -
            <remarks><para>Is set by the Inquiry (Device Discovery) process on
            the stacks where we handle Inquiry directly  that is
            every platform except the Microsoft stack on Win32 (MSFT+Win32),
            so is supported under MSFT+WM, Widcomm, Bluetopia, etc, etc.
            </para><para>This value is supported on Windows 7 with the Microsoft stack.
            It it not supported on earlier Win32 versions as the native 
            API has a bug.  The value provided is always simply the current 
            time, e.g. after a discovery for every device returned this value has 
            the time of the discovery operation.  Tracked by workitem 
            <see href="http://www.codeplex.com/32feet/WorkItem/View.aspx?WorkItemId=10280">10280</see>.
            </para></remarks>
            -
            <value>
            An instance of <see cref="T:System.DateTime" /> containing the time in UTC,
            or <c>DateTime</c>.<see cref="F:System.DateTime.MinValue" />
            if there's no value.
            </value></member>
    <member name="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.LastUsed">
      <summary>
            Date and Time this device was last used by the system.
            </summary>
            -
            <remarks><para>Not supported on most stacks: Widcomm, Bluetopia, MSFT+WM 
            and will return <see cref="F:System.DateTime.MinValue">DateTime.MinValue</see></para><para>Is supported on Windows 7 with the Microsoft stack.  Is not
            supported on earlier Win32 versions  there it just always
            returns the current time, see <see cref="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.LastSeen" />.
            </para></remarks>
            -
            <value>
            An instance of <see cref="T:System.DateTime" /> containing the time in UTC,
            or <c>DateTime</c>.<see cref="F:System.DateTime.MinValue" /> 
            if there's no value.
            </value></member>
    <member name="T:InTheHand.Net.Bluetooth.DeviceClass">
      <summary>
            Class of Device flags as assigned in the Bluetooth specifications.
            </summary>
      <remarks>
        <para>Is returned by the property <see cref="P:InTheHand.Net.Bluetooth.ClassOfDevice.Device">ClassOfDevice.Device</see>.
            </para>
        <para>Defined in Bluetooth Specifications <see href="https://www.bluetooth.org/Technical/AssignedNumbers/baseband.htm" />.
            </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.Miscellaneous">
      <summary>
            Miscellaneous  
            [Ref #2: Used where a more specific Major Device Class code
            is not suited (but only as specified in this document). Devices
            that do not have a major class code assigned can use the all-1 code
            (<see cref="F:InTheHand.Net.Bluetooth.DeviceClass.Uncategorized" />)
            until 'classified']
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.Computer">
      <summary>
            Major class: Computer (desktop,notebook, PDA, organizers, .... ).
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.DesktopComputer">
      <summary>
            Major class: Computer
             Minor class: Desktop workstation.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.ServerComputer">
      <summary>
            Major class: Computer
             Minor class: Server-class computer.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.LaptopComputer">
      <summary>
            Major class: Computer
             Minor class: Laptop.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.HandheldComputer">
      <summary>
            Major class: Computer
             Minor class: Handheld PC/PDA (clam shell).
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.PdaComputer">
      <summary>
            Major class: Computer
             Minor class: Palm sized PC/PDA.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.WearableComputer">
      <summary>
            Major class: Computer
             Minor class: Wearable computer (Watch sized).
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.Phone">
      <summary>
            Major class: Phone (cellular, cordless, payphone, modem, ...).
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.CellPhone">
      <summary>
            Major class: Phone
             Minor class: Cellular.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.CordlessPhone">
      <summary>
            Major class: Phone
             Minor class: Cordlss.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.SmartPhone">
      <summary>
            Major class: Phone
             Minor class: Smart phone.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.WiredPhone">
      <summary>
            Major class: Phone
             Minor class: Wired modem or voice gateway.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.IsdnAccess">
      <summary>
            Major class: Phone
             Minor class: Common ISDN Access.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.AccessPointAvailable">
      <summary>
            Major class: LAN /Network Access point.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.AudioVideoUnclassified">
      <summary>
            Major class: Audio/Video (headset,speaker,stereo, video display, vcr.....
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.Peripheral">
      <summary>
            Major class: Peripheral (mouse, joystick, keyboards, ..... ).
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.Imaging">
      <summary>
            Major class: Imaging (printing, scanner, camera, display, ...).
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.Wearable">
      <summary>
            Major class: Wearable.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.Toy">
      <summary>
            Major class: Toy.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.Medical">
      <summary>
            Major class: Medical.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.DeviceClass.Uncategorized">
      <summary>
            Uncategorized, specific device code not specified
             see <see cref="F:InTheHand.Net.Bluetooth.DeviceClass.Miscellaneous" /></summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.DeviceClass_Masks">
      <exclude />
    </member>
    <member name="T:InTheHand.Net.Bluetooth.AttributeIds.ObexAttributeId">
      <summary>
            Service Attribute IDs defined by the OBEX related specifications,
            i.e. Object Push and Synchronization Profiles specifications.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.ObexAttributeId.GoepL2capPsm">
      <summary>
            GOEP L2Cap PSM
            </summary>
      <remarks>
            New in GOEP v2.0 but not numbered there.
            New in OPP v1.2, FTP v1.2, and BIP v1.1.
            <para>[<c>UInt16</c>]</para></remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.ObexAttributeId.SupportedDataStoresList">
      <summary>
            Supported Data Stores List (Synchronization Profile)
            </summary>
      <remarks>
            Synchronization Profile  
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.IrMCSync" /> 
            service class.
            <para>[<c>Data Element Sequence of UInt8</c>]</para><list type="table">
            Values
            <listheader><term>Value</term><description>Meaning</description></listheader><item><term>0x01</term><description>Phonebook</description></item><item><term>0x03</term><description>Calendar</description></item><item><term>0x05</term><description>Notes</description></item><item><term>0x06</term><description>Message</description></item></list></remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.ObexAttributeId.SupportedFormatsList">
      <summary>
            Supported Formats List (Object Push Profile)
            </summary>
      <remarks>
            Object Push Profile  
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.ObexObjectPush" /> 
            service class.
            <para>[<c>Data Element Sequence of UInt8</c>]</para><list type="table">
            Values
            <listheader><term>Value</term><description>Meaning</description></listheader><item><term>0x01</term><description>vCard 2.1</description></item><item><term>0x02</term><description>vCard 3.0</description></item><item><term>0x03</term><description>vCard 2.1</description></item><item><term>0x04</term><description>vCal 1.0</description></item><item><term>0x05</term><description>vNote</description></item><item><term>0x06</term><description>vMessage</description></item><item><term>0xFF</term><description>any type of object</description></item></list></remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.ObexAttributeId.SupportedCapabilities">
      <summary>
            Supported Capabilities (BIP)
            </summary>
      <remarks>
            Basic Imaging Profile  
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.Imaging" />, 
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.ImagingResponder" />, 
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.ImagingAutomaticArchive" />, 
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.ImagingReferenceObjects" /> 
            service classes.
            <para>[<c>UInt8</c>]</para><list type="table">
            Values
            <listheader><term>Value</term><description>Meaning</description></listheader><item><term>Bit 0</term><description>Generic imaging</description></item><item><term>Bit 1</term><description>Capturing</description></item><item><term>Bit 2</term><description>Printing</description></item><item><term>Bit 3</term><description>Displaying</description></item><item><term>Bit 4..7</term><description>Reserved</description></item></list></remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.ObexAttributeId.SupportedFeatures">
      <summary>
            Supported Features (BIP)
            </summary>
      <remarks>
            Basic Imaging Profile  
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.Imaging" />, 
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.ImagingResponder" />, 
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.ImagingAutomaticArchive" />, 
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.ImagingReferenceObjects" /> 
            service classes.
            <para>[<c>UInt16</c>]</para><list type="table">
            Values
            <listheader><term>Value</term><description>Meaning</description></listheader><item><term>Bit 0</term><description>ImagePush</description></item><item><term>Bit 1</term><description>ImagePush-Store</description></item><item><term>Bit 2</term><description>ImagePush-Print</description></item><item><term>Bit 3</term><description>ImagePush-Display</description></item><item><term>Bit 4</term><description>ImagePull</description></item><item><term>Bit 5</term><description>AdvancedImagePrinting</description></item><item><term>Bit 6</term><description>AutomaticArchive</description></item><item><term>Bit 7</term><description>RemoteCamera</description></item><item><term>Bit 8</term><description>RemoteDisplay</description></item><item><term>Bit 9..15</term><description>Reserved</description></item></list></remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.ObexAttributeId.SupportedFunctions">
      <summary>
            Supported Functions (BIP)
            </summary>
      <remarks>
            Basic Imaging Profile  
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.Imaging" />, 
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.ImagingResponder" />, 
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.ImagingAutomaticArchive" />, 
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.ImagingReferenceObjects" /> 
            service classes.
            <para>[<c>UInt32</c>]</para><list type="table">
            Values
            <listheader><term>Value</term><description>Meaning</description></listheader><item><term>Bit 0</term><description>GetCapabilities</description></item><item><term>Bit 1</term><description>PutImage</description></item><item><term>Bit 2</term><description>PutLinkedAttachment</description></item><item><term>Bit 3</term><description>PutLinkedThumbnail</description></item><item><term>Bit 4</term><description>RemoteDisplay</description></item><item><term>Bit 5</term><description>GetImagesList</description></item><item><term>Bit 6</term><description>GetImageProperties</description></item><item><term>Bit 7</term><description>GetImage</description></item><item><term>Bit 8</term><description>GetLinkedThumbnail</description></item><item><term>Bit 9</term><description>GetLinkedAttachment</description></item><item><term>Bit 10</term><description>DeleteImage</description></item><item><term>Bit 11</term><description>StartPrint</description></item><item><term>Bit 12</term><description>Reserved</description></item><item><term>Bit 13</term><description>StartArchive</description></item><item><term>Bit 14</term><description>GetMonitoringImage</description></item><item><term>Bit 16</term><description>GetStatus</description></item><item><term>Bit 15, 17..31</term><description>Reserved</description></item></list></remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.ObexAttributeId.TotalImagingDataCapacity">
      <summary>
            Total Imaging Data Capacity (BIP)
            </summary>
      <remarks>
            Basic Imaging Profile  
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.Imaging" />, 
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.ImagingResponder" />, 
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.ImagingAutomaticArchive" />, 
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.ImagingReferenceObjects" /> 
            service classes.
            <para>[<c>UInt64</c>]</para></remarks>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId">
      <summary>
            Service Attribute IDs defined by the Basic Printing Profile specification.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId.DocumentFormatsSupported">
      <summary>
            Document Formats Supported
            </summary>
      <remarks>[<c>String</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId.CharacterRepertoiresSupported">
      <summary>
            Character Repertoires Supported
            </summary>
      <remarks>[<c>UInt128</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId.XhtmlPrintImageFormatsSupported">
      <summary>
            XHTML-Print Image Formats Supported
            </summary>
      <remarks>[<c>String</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId.ColorSupported">
      <summary>
            Color Supported
            </summary>
      <remarks>[<c>Boolean</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId.Model1284Id">
      <summary>
            1284ID
            </summary>
      <remarks>[<c>String</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId.PrinterName">
      <summary>
            Printer Name
            </summary>
      <remarks>[<c>String</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId.PrinterLocation">
      <summary>
            Printer Location
            </summary>
      <remarks>[<c>String</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId.DuplexSupported">
      <summary>
            Duplex Supported
            </summary>
      <remarks>[<c>Boolean</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId.MediaTypesSupported">
      <summary>
            Media Types Supported
            </summary>
      <remarks>[<c>String</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId.MaxMediaWidth">
      <summary>
            MaxMediaWidth
            </summary>
      <remarks>[<c>UInt16</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId.MaxMediaLength">
      <summary>
            MaxMediaLength
            </summary>
      <remarks>[<c>UInt16</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId.EnhancedLayoutSupported">
      <summary>
            Enhanced Layout Supported
            </summary>
      <remarks>[<c>Boolean</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId.RuiFormatsSupported">
      <summary>
            RUI Formats Supported
            </summary>
      <remarks>[<c>String</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId.ReferencePrintingRuiSupported">
      <summary>
            Reference Printing RUI Supported
            </summary>
      <remarks>[<c>Boolean</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId.DirectPrintingRuiSupported">
      <summary>
            Direct Printing RUI Supported
            </summary>
      <remarks>[<c>Boolean</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId.ReferencePrintingTopUrl">
      <summary>
            Reference Printing Top URL
            </summary>
      <remarks>[<c>URL</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId.DirectPrintingTopUrl">
      <summary>
            Direct Printing Top URL
            </summary>
      <remarks>[<c>URL</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId.PrinterAdminRuiTopUrl">
      <summary>
            Printer Admin RUI Top URL
            </summary>
      <remarks>[<c>URL</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.BasicPrintingProfileAttributeId.DeviceName">
      <summary>
            Device Name
            </summary>
      <remarks>[<c>String</c>]</remarks>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.AttributeIds.PersonalAreaNetworkingProfileAttributeId">
      <summary>
            Service Attribute IDs defined by the Personal Area Networking Profile specification.
            </summary>PersonalAreaNetworkingProfile
        </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.PersonalAreaNetworkingProfileAttributeId.SecurityDescription">
      <summary>
            Security Description
            </summary>
      <remarks>Security Description [<c>UInt16</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.PersonalAreaNetworkingProfileAttributeId.NetAccessType">
      <summary>
            NetAccessType
            </summary>
      <remarks>Type of Network Access Available [<c>UInt16</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.PersonalAreaNetworkingProfileAttributeId.MaxNetAccessRate">
      <summary>
            MaxNetAccessRate
            </summary>
      <remarks>Maximum possible Network Access Data Rate [<c>UInt32</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.PersonalAreaNetworkingProfileAttributeId.IPv4Subnet">
      <summary>
            IPv4Subnet
            </summary>
      <remarks>[<c>String</c>]</remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.PersonalAreaNetworkingProfileAttributeId.IPv6Subnet">
      <summary>
            IPv6Subnet
            </summary>
      <remarks>[<c>String</c>]</remarks>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.AttributeIds.HeadsetProfileAttributeId">
      <summary>
            Service Attribute IDs defined by the Headset Profile specification.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.HeadsetProfileAttributeId.RemoteAudioVolumeControl">
      <summary>
            Remote audio volume control
            </summary>
      <remarks>[<c>Boolean</c>]</remarks>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.AttributeIds.HandsFreeProfileAttributeId">
      <summary>
            Service Attribute IDs defined by the Hand-Free Profile specification.
            </summary>HandFreeProfile
        </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.HandsFreeProfileAttributeId.Network">
      <summary>
            Network
            </summary>
      <remarks>
        <para>The "Network" attribute states, if the AG has the capability 
            to reject incoming calls[4]. This attribute is not encoded as a data element 
            sequence; it is simply an 8-bit unsigned integer. The information given 
            in the Network attribute shall be the same as the information given 
            in Bit 5 of the unsolicited result code +BRSF (see Section 4.24.3). An 
            attribute value of 0x00 is translated to a bit value of 0; an attribute 
            value of 0x01 is translated to a bit value of 1.
            </para>
            [<c>UInt8</c>]
            </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.HandsFreeProfileAttributeId.SupportedFeatures">
      <summary>
            SupportedFeatures
            </summary>
      <remarks>
        <para>The attribute SupportedFeatures states the features 
            supported in each device. 
            The set of features supported in each case is bit-wise defined in this 
            attribute on a yes/no basis. The mapping between the features and their 
            corresponding bits within the attribute is listed below in for the HF 
            and in for the AG. 
            <code lang="none">
            Bit     Feature                                                     Default in HF
            (0=LSB)
            0       EC and/or NR function (yes/no, 1 = yes, 0 = no)             0
            1       Call waiting and three way calling(yes/no, 1 = yes, 0 = no) 0
            2       CLI presentation capability (yes/no, 1 = yes, 0 = no)       0
            3       Voice recognition activation (yes/no, 1= yes, 0 = no)       0
            4       Remote volume control (yes/no, 1 = yes, 0 = no)             0
            </code><para>Table 5.2 SupportedFeatures attribute bit mapping for the HF</para><code lang="none">
            Bit     Feature                                             Default in AG
            (0=LSB)
            0       Three-way calling (yes/no, 1 = yes, 0 = no)         1
            1       EC and/or NR function (yes/no, 1 = yes, 0 = no)     0
            2       Voice recognition function (yes/no, 1 = yes, 0 = no)    0
            3       In-band ring tone capability (yes/no, 1 = yes, 0 = no)  1
            4       Attach a phone number to a voice tag (yes/no, 1 = yes, 0 = no)  0
            </code>
            Table 5.4 SupportedFeatures attribute bit mapping for the AG
            </para>
            [<c>UInt16</c>]</remarks>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.AttributeIds.HealthDeviceAttributeId">
      <summary>
            Service Attribute IDs defined by the Health Device Profile specification.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.HealthDeviceAttributeId.SupportFeaturesList">
      <summary>
            SupportFeaturesList
            </summary>
            -
            <remarks><para>"This is a sequence for which each element is a sequence that
            describes a single application data end-point on the device. The
            Supported Features attribute (MDEP List) provides an indication of
            the data types that an MDEP supports.",
            "...each description is itself a sequence of three or more elements."
            </para><c>[Sequence]</c></remarks></member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.HealthDeviceAttributeId.DataExchangeSpecification">
      <summary>
            DataExchangeSpecification
            </summary>
            -
            <remarks><para>"This attribute is a one-byte reference, with the value taken
            from the Bluetooth Assigned Numbers [3] to identify the Data Exchange
            Protocol used (e.g. ISO/IEEE 11073-20601 specification)."
            e.g. value 0x01 is ISO/IEEE 11073-20601, "Health informatics - Personal
            health device communication - Application profile - Optimized exchange
            protocol"
            </para><c>[UInt8]</c></remarks></member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.HealthDeviceAttributeId.McapSupportedProcedures">
      <summary>
            MCAP Supported Procedures
            </summary>
            -
            <remarks><para>"This attribute is a one byte bit-mask that indicates the MCAP
            procedures that are supported by this HDP service."
            </para><code lang="none">
            0x02  Supports Reconnect Initiation 3
            0x04  Supports Reconnect Acceptance 4
            0x08  Supports Clock Synchronization Protocol (includes support for at least Sync-Slave Role)
            0x10  Supports Sync-Master Role
            </code><c>[UInt8]</c></remarks></member>
    <member name="T:InTheHand.Net.ObexListenerContext">
      <summary>
            Provides access to the request and response objects used by the <see cref="T:InTheHand.Net.ObexListener" /> class.
            </summary>
    </member>
    <member name="P:InTheHand.Net.ObexListenerContext.Request">
      <summary>
            Gets the <see cref="T:InTheHand.Net.ObexListenerRequest" /> that represents a client's request for a resource
            </summary>
    </member>
    <member name="T:InTheHand.Net.Sockets.BluetoothProtocolType">
      <summary>
            Specifies additional protocols that the <see cref="T:System.Net.Sockets.Socket" /> class supports.
            </summary>
      <remarks>
        <para>These constants are defined by the Bluetooth SIG - <see href="https://www.bluetooth.org/Technical/AssignedNumbers/service_discovery.htm" /></para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothProtocolType.Sdp">
      <summary>
            Service Discovery Protocol (bt-sdp)
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothProtocolType.RFComm">
      <summary>
            Bluetooth RFComm protocol (bt-rfcomm)
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.BluetoothProtocolType.L2Cap">
      <summary>
            Logical Link Control and Adaptation Protocol (bt-l2cap)
            </summary>
    </member>
    <member name="T:InTheHand.Net.Sockets.IrDASocketOptionName">
      <summary>
            Socket option constants to set IrDA specific connection modes, and 
            get/set IrDA specific features.
            </summary>
      <remarks>
            Socket option constants to set IrDA specific connection modes, and 
            get/set IrDA specific features: 
            for instance to set IrLMP mode, or get the maximum send size.  Pass 
            to <see cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />/etc and
            <see cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />/etc,  
            along with optionLevel <c>IrDASocketOptionLevel.</c><see cref="F:InTheHand.Net.Sockets.IrDASocketOptionLevel.IrLmp" />; 
            see the examples below.
            <para><b>New in v1.5.51015</b></para></remarks>
      <example>
        <para>For instance, where <c>cli</c> is an instance of 
            <see cref="T:InTheHand.Net.Sockets.IrDAClient" />.</para>
            In VB.NET, to set IrLMP mode (<c>IrLptMode</c>).
            <code lang="VB.NET">
            cli.Client.SetSocketOption(IrDASocketOptionLevel.Irlmp,  _
               IrDASocketOptionName.IrLptMode, _
               1) 'representing true; can use True itself in FXv2.
            </code>
            In C#, to retrieve the maximum send size.
            <code lang="C#">
            int maxSendSize = (int)cli.Client.GetSocketOption(
               IrDASocketOptionLevel.Irlmp,
               IrDASocketOptionName.SendPduLength);
            </code></example>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDASocketOptionName.EnumDevice">
      <summary>
            Gets the list of discovered devices.  
            Is used internally by <c>IrDAClient.DiscoverDevices</c>.  
            </summary>
      <remarks>
            In native terms takes a <c>DEVICE_LIST</c> struct.
            </remarks>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDASocketOptionName.IasSet">
      <summary>
            Sets an entry in the local IAS (Information Access Service) database.
            </summary>
      <remarks>
            In native terms takes a <c>IAS_SET</c> struct.
            </remarks>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDASocketOptionName.IasQuery">
      <summary>
            Queries an entry in the peer's IAS (Information Access Service) database.
            </summary>
      <remarks>
            In native terms takes a <c>IAS_QUERY</c> struct.
            </remarks>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDASocketOptionName.SendPduLength">
      <summary>
            Retrieve the maximum send size when using IrLMP directly 
            (<see cref="F:InTheHand.Net.Sockets.IrDASocketOptionName.IrLptMode" />).  
            IrLMP requires sent data to fit in one frame.
            </summary>
      <remarks>
        <c>Integer</c>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDASocketOptionName.ExclusiveMode">
      <summary>
            Restricts the link to one application-level (IrLMP) connection; 
            for use when low latency is required.
            Returns an error on all tested platforms.
            </summary>
      <remarks>
            Returns an error on all tested platforms.  <c>Boolean</c></remarks>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDASocketOptionName.IrLptMode">
      <summary>
            Sets IrLMP mode, disabling TinyTP.  Used for instance when 
            printing with IrLPT.
            </summary>
      <remarks>
            On Windows NT platforms at least, is ignored on server-side sockets.
            <c>Boolean</c></remarks>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDASocketOptionName.NineWireMode">
      <summary>
            Sets IrCOMM 9-Wire/Cooked mode.  Used for instance when connecting 
            to the modem in a mobile phone (service name <c>IrDA:IrCOMM</c>).  
            </summary>
      <remarks>
            In operation, received IrCOMM control information is discarded and 
            null information is sent.
            <c>Boolean</c></remarks>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDASocketOptionName.SharpMode">
      <summary>
            Reportedly sets non-IrDA Sharp ASK mode on the Windows CE 
            platform.  Presence unverified.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.ServiceElement">
      <summary>
             Holds an SDP data element.
             </summary>
             -
             <remarks><para>A Service Element hold the data in a SDP Service Record.  It can 
             hold various types of data, being like the variant type in some
             environments.  Each <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" /> in
             a <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" /> holds its content in a
             Service Element.
             </para><para>The types currently defined in the Service Discovery specification
             include unsigned and signed integers 
             of various sizes (8-bit, 16-bit etc), UUIDs in the full 128-bit form or
             in the 16 and 32-bit forms, TextString, Url etc.  An element can itself
             also contain a list of element, either as a sequence or an
             alternative, and thus an attribute can contain a tree of values,
             e.g. as used by the 
             <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList" />
             attribute.
             </para><para>The type that an element is holding can be accessed with the 
             <see cref="P:InTheHand.Net.Bluetooth.ServiceElement.ElementTypeDescriptor" /> and 
             <see cref="P:InTheHand.Net.Bluetooth.ServiceElement.ElementType" /> properties which
             are of type <see cref="T:InTheHand.Net.Bluetooth.ElementTypeDescriptor" /> and
             <see cref="T:InTheHand.Net.Bluetooth.ElementType" /> respectively, the former being 
             the major type e.g. 
             <see cref="F:InTheHand.Net.Bluetooth.ElementTypeDescriptor.UnsignedInteger" />, and
             the latter the minor type e.g. 
             <see cref="F:InTheHand.Net.Bluetooth.ElementType.UInt16" />.
             </para><para>The element's value can be accessed in various ways, either directly 
             in its internal form through its <see cref="P:InTheHand.Net.Bluetooth.ServiceElement.Value" />
             property.  It has return type <see cref="T:System.Object" /> so the value 
             will have to be cast before use, see the <c>UInt16</c> example below.  There
             are also a number of type-specific methods, e.g. 
             <see cref="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsElementArray" />,
             <see cref="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsUuid" />, 
             <see cref="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsString(System.Text.Encoding)" />
             etc.  Each will throw an <see cref="T:System.InvalidOperationException" />
             if the element is not of a suitable type.  The complete set is:</para><list type="table"><listheader><term><see cref="T:InTheHand.Net.Bluetooth.ElementType" /></term><description>Access method, or .NET Type for direct access</description></listheader><item><term><c>Nil</c></term><description><see langword="null" /></description></item><item><term><c>Uint8</c></term><description><see cref="T:System.Byte" /></description></item><item><term><c>Uint16</c></term><description><see cref="T:System.UInt16" /></description></item><item><term><c>Uint32</c></term><description><see cref="T:System.UInt32" /></description></item><item><term><c>Uint64</c></term><description>Currently unsupported.</description></item><item><term><c>Uint128</c></term><description>Currently unsupported.</description></item><item><term><c>Int8</c></term><description><see cref="T:System.SByte" /></description></item><item><term><c>Int16</c></term><description><see cref="T:System.Int16" /></description></item><item><term><c>Int32</c></term><description><see cref="T:System.Int32" /></description></item><item><term><c>Int64</c></term><description>Currently unsupported.</description></item><item><term><c>Int128</c></term><description>Currently unsupported.</description></item><item><term><c>Uuid16</c></term><description>Via <see cref="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsUuid" />, or as <see cref="T:System.UInt16" /></description></item><item><term><c>Uuid32</c></term><description>Via <see cref="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsUuid" />, or as <see cref="T:System.UInt16" /></description></item><item><term><c>Uuid128</c></term><description>Via <see cref="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsUuid" /></description></item><item><term><c>TextString</c></term><description>With 
             <see cref="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsString(System.Text.Encoding)" />
             or <see cref="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsStringUtf8" /> etc.
             The underlying value can be an array of bytes, or as a <see cref="T:System.String" />
             the <see cref="T:InTheHand.Net.Bluetooth.ServiceRecordParser" /> will set an
             array of bytes, whereas a manually created record will likely contain a
             <see cref="T:System.String" />.
             </description></item><item><term><c>Boolean</c></term><description><see cref="T:System.Boolean" /></description></item><item><term><c>ElementSequence</c></term><description>With
             <see cref="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsElementArray" /> or
             <see cref="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsElementList" /></description></item><item><term><c>ElementSequence</c></term><description>-"-</description></item><item><term><c>Url</c></term><description>Via <see cref="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsUri" />,
             can be stored interally as <see cref="T:System.Uri" /> or as an array of bytes
             </description></item></list><para>Note that there are no access 
             methods for the numeric type for instance so the 
             <see cref="P:InTheHand.Net.Bluetooth.ServiceElement.Value" /> property will have
             to be used e.g.
             <code lang="C#">
             // ElementType is UInt16
             ushort x = (ushort)element.Value;
             </code>
             or
             <code lang="C#">
             // ElementType is UInt16
             Dim x As UShort = CUShort(element.Value);
             </code></para><para>Additional type-specific methods can be added as required, in fact the 
             full set of 19+ could be added, it just requires implementation and test
             </para></remarks></member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceElement.ErrorMsgNotUuidType">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceElement.ErrorMsgNotTextStringType">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceElement.ErrorMsgNotUrlType">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceElement.ErrorMsgNotSeqAltType">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceElement.ErrorMsgSeqAltTypeNeedElementArray">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceElement.ErrorMsgFmtCreateNumericalGivenNonNumber">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceElement.ErrorMsgListContainsNotElement">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceElement.#ctor(InTheHand.Net.Bluetooth.ElementType,System.Object)">
      <overloads>
             Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" /> class.
             </overloads>
             -
             <summary>
             Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" /> class.
             </summary>
             -
             <remarks><para>The type of the object passed in the <paramref name="value" /> parameter
             <strong>must</strong> suit the type of the element.  For instance if the element type is 
             <see cref="F:InTheHand.Net.Bluetooth.ElementType.UInt8" /> then the object
             passed in must be a <see cref="T:System.Byte" />, if the element type is
             <see cref="F:InTheHand.Net.Bluetooth.ElementType.TextString" /> then the object
             must either be a <see cref="T:System.String" /> or the string encoded as 
             an array of <see cref="T:System.Byte" />, 
             and if the element type is <see cref="F:InTheHand.Net.Bluetooth.ElementType.Uuid16" />
             then the object passed in must be a <see cref="T:System.UInt16" />,
             etc.
             For the full list of types see the class level documentation 
             (<see cref="T:InTheHand.Net.Bluetooth.ServiceElement" />).
             </para><para>For numerical element types the 
             <see cref="M:InTheHand.Net.Bluetooth.ServiceElement.CreateNumericalServiceElement(InTheHand.Net.Bluetooth.ElementType,System.Object)" />
             factory method will accept any integer type and attempt to convert it to the 
             required type before creating the <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" />,
             for example for element type <see cref="F:InTheHand.Net.Bluetooth.ElementType.UInt8" /> 
             it will accept an <see cref="T:System.Int32" /> parameter and convert
             it to a <see cref="T:System.Byte" /> internally.
             </para></remarks>
             -
             <param name="type">The type of the element as an ElementType.
             </param><param name="value">The value for the new element,
             <strong>must</strong> suit the type of the element.
             See the remarks for more information.
             </param>
             -
             <example><code lang="C#">
             ServiceElement e
             e = new ServiceElement(ElementType.TextString, "Hello world");
             e = new ServiceElement(ElementType.TextString, new byte[] { (byte)'h', (byte)'i', });
             e = new ServiceElement(ElementType.Uuid16, (UInt16)0x1101);
            
            
             int i = 10;
             int j = -1;
             
             // Error, Int32 not suitable for element type UInt8.
             ServiceElement e0 = new ServiceElement(ElementType.UInt8, i);
             
             // Success, Byte value 10 stored.
             ServiceElement e1 = ServiceElement.CreateNumericalServiceElement(ElementType.UInt8, i);
             
             // Error, -1 not in range of type Byte.
             ServiceElement e2 = ServiceElement.CreateNumericalServiceElement(ElementType.UInt8, j);
             </code></example></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceElement.#ctor(InTheHand.Net.Bluetooth.ElementType,System.Collections.Generic.IList{InTheHand.Net.Bluetooth.ServiceElement})">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" /> class.
            </summary>
            -
            <param name="type">The type of the element as an ElementType.
            Should be either <c>ElementSequence</c>/<c>ElementAlternative</c> types.
            </param><param name="childElements">A list of elements.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceElement.#ctor(InTheHand.Net.Bluetooth.ElementType,InTheHand.Net.Bluetooth.ServiceElement[])">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" /> class.
            </summary>
            -
            <param name="type">The type of the element as an ElementType.
            Should be either <c>ElementSequence</c>/<c>ElementAlternative</c> types.
            </param><param name="childElements">A list of elements.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceElement.#ctor(InTheHand.Net.Bluetooth.ElementTypeDescriptor,InTheHand.Net.Bluetooth.ElementType,System.Object)">
      <summary>
            Obsolete, use <see cref="M:InTheHand.Net.Bluetooth.ServiceElement.#ctor(InTheHand.Net.Bluetooth.ElementType,System.Object)" /> instead.
            Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" /> class.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceElement.CreateNumericalServiceElement(InTheHand.Net.Bluetooth.ElementType,System.Object)">
      <summary>
            Create an instance of <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" />
            but internally converting the numeric value to the required type.
            </summary>
            -
            <remarks><para>As noted in the constructor documentation 
            (<see cref="M:InTheHand.Net.Bluetooth.ServiceElement.#ctor(InTheHand.Net.Bluetooth.ElementType,System.Object)" />)
            the type of the value supplied <strong>must</strong> exactly match the element's natural type,
            the contructor will return an error if that is not the case. This method 
            will instead attempt to convert the value to the required type.  It uses 
            the <see cref="T:System.IConvertible" /> interface to do the conversion, for
            instance if the element type is <c>Uint16</c> then it will cast the input value
            to <see cref="T:System.IConvertible" /> and call 
            <see cref="M:System.IConvertible.ToUInt16(System.IFormatProvider)" /> on it.
            If the value is not convertible to the element type then an 
            <see cref="T:System.ArgumentOutOfRangeException" /> will be thrown see below.
            </para><para>For instance, passing in an C# <c>int</c> / Visual Basic <c>Integer</c>
            to the constructor will fail for element types <see cref="F:InTheHand.Net.Bluetooth.ElementType.UInt8" />
            etc, however by using this method it will succeed if the value is in the
            correct range.
            For example
            <code lang="C#">
            int i = 10;
            int j = -1;
            
            // Error, Int32 not suitable for element type UInt8.
            ServiceElement e0 = new ServiceElement(ElementType.UInt8, i);
            
            // Success, Byte value 10 stored.
            ServiceElement e1 = ServiceElement.CreateNumericalServiceElement(ElementType.UInt8, i);
            
            // Error, -1 not in range of type Byte.
            ServiceElement e2 = ServiceElement.CreateNumericalServiceElement(ElementType.UInt8, j);
            </code>
            The last example failing with:
            <code lang="none">
            System.ArgumentOutOfRangeException: Value '-1'  of type 'System.Int32' not valid for element type UInt16.
             ---&gt; System.OverflowException: Value was either too large or too small for a UInt16.
               at System.Convert.ToUInt16(Int32 value)
               at System.Int32.System.IConvertible.ToUInt16(IFormatProvider provider)
               at InTheHand.Net.Bluetooth.ServiceElement.ConvertNumericalValue(ElementType elementType, Object value)
               --- End of inner exception stack trace ---
               at InTheHand.Net.Bluetooth.ServiceElement.ConvertNumericalValue(ElementType elementType, Object value)
               at InTheHand.Net.Bluetooth.ServiceElement.CreateNumericalServiceElement(ElementType elementType, Object value)
               at MiscFeatureTestCs.Main(String[] args)
            </code></para></remarks>
            -
            <param name="elementType">The type of the element as an ElementType.
            Should be one of the <c>UnsignedInteger</c>/<c>TwosComplementInteger</c> types.
            </param><param name="value">The value for the new element,
            should be a numerical type.
            </param>
            -
            <returns>The new element.
            </returns>
            -
            <exception cref="T:System.ArgumentException">
            The <paramref name="elementType" /> is not a numerical type.
            </exception><exception cref="T:System.ArgumentOutOfRangeException">
            The value wasnt convertible to the required type, e.g. if -1 is
            passed for element type UInt8, as shown above.
            </exception></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsElementList">
      <summary>
            Gets the value as a list of <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" />.
            </summary>
            -
            <returns>The list of elements as an list.
            </returns>
            -
            <exception cref="T:System.InvalidOperationException">
            The service element is not of type
            <c>ElementType</c>.<see cref="F:InTheHand.Net.Bluetooth.ElementType.ElementSequence" />
            or <see cref="F:InTheHand.Net.Bluetooth.ElementType.ElementAlternative" />.
            </exception></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsElementArray">
      <summary>
            Gets the value as a array of <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" />.
            </summary>
            -
            <returns>The list of elements as an array.
            </returns>
            -
            <exception cref="T:System.InvalidOperationException">
            The service element is not of type
            <c>ElementType</c>.<see cref="F:InTheHand.Net.Bluetooth.ElementType.ElementSequence" />
            or <see cref="F:InTheHand.Net.Bluetooth.ElementType.ElementAlternative" />.
            </exception></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsUri">
      <summary>
            Gets the value as a <see cref="T:System.Uri" />.
            </summary>
            -
            <returns>The Url value as a <see cref="T:System.Uri" />.
            </returns>
            -
            <remarks><para>It turns out that we can't trust vendors to add only valid
            URLs to their records, for instance the iPhone has an attribute
            with value "www.apple.com" which isn't a URL as it has no scheme
            part (http://) etc.
            </para><para>Thus a Url value in an element can be stored in a number of
            formats.  If created by the parser then it will be stored as a 
            <see cref="T:System.String" /> or as an array of
            <see cref="T:System.Byte" /> if property
            <see cref="P:InTheHand.Net.Bluetooth.ServiceRecordParser.LazyUrlCreation">ServiceRecordParser.LazyUrlCreation</see>
            is set.  If created locally it can be those types or also 
            <see cref="T:System.Uri" /> .
            </para><para>This method will try to convert from those formats to <see cref="T:System.Uri" />.
            If the URL is invalid e.g. has bad characters or is missing the scheme
            part etc then an error will occur.  One can instead access the
            element's <see cref="P:InTheHand.Net.Bluetooth.ServiceElement.Value" />
            property and expect one of the three types.  When created by the 
            parser it will be of type <see cref="T:System.String" /> unless 
            <see cref="P:InTheHand.Net.Bluetooth.ServiceRecordParser.LazyUrlCreation" />
            is set.
            </para></remarks>
            -
            <exception cref="T:System.InvalidOperationException">
            The service element is not of type
            <c>ElementType</c>.<see cref="F:InTheHand.Net.Bluetooth.ElementType.Url" />.
            </exception></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsUuid">
      <summary>
            Gets the value as a <see cref="T:System.Guid" />.
            </summary>
            -
            <returns>The UUID value as a <see cref="T:System.Guid" />.
            </returns>
            -
            <exception cref="T:System.InvalidOperationException">
            The service element is not of type
            <c>ElementType</c>.<see cref="F:InTheHand.Net.Bluetooth.ElementType.Uuid128" />.
            </exception></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsString(System.Text.Encoding)">
      <summary>
            Get the value of the <see cref="F:InTheHand.Net.Bluetooth.ElementTypeDescriptor.TextString" />,
            where it is encoded using the given encoding form.
            </summary>
            -
            <param name="encoding">The <see cref="T:System.Text.Encoding" />
            object to be used to decode the string value
            if it has been read as a raw byte array.
            </param>
            -
            <returns>
            A <see cref="T:System.String" /> holding the value of the 
            <see cref="F:InTheHand.Net.Bluetooth.ElementTypeDescriptor.TextString" />
            from the service element.
            </returns>
            -
            <exception cref="T:System.InvalidOperationException">
            The service element is not of type 
            <see cref="F:InTheHand.Net.Bluetooth.ElementTypeDescriptor.TextString" />.
            </exception></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsString(InTheHand.Net.Bluetooth.LanguageBaseItem)">
      <summary>
            Get the value of the <see cref="F:InTheHand.Net.Bluetooth.ElementTypeDescriptor.TextString" />,
            when it is encoded as specified by the given IETF Charset identifer.
            </summary>
            -
            <remarks>
            Note that a strict decoding of the string is carried out 
            (except on the NETCF where it is not supported). 
            Thus if the value is not in the specified encoding, or has been
            encoded incorrectly, then an error will occur.
            </remarks>
            -
            <returns>
            A <see cref="T:System.String" /> holding the value of the 
            <see cref="F:InTheHand.Net.Bluetooth.ElementTypeDescriptor.TextString" />
            from the service element.
            </returns>
            -
            <exception cref="T:System.InvalidOperationException">
            The service element is not of type 
            <see cref="F:InTheHand.Net.Bluetooth.ElementTypeDescriptor.TextString" />.
            </exception><exception cref="T:System.Text.DecoderFallbackException">
            If the value in the service element is not a valid string in the given encoding.
            </exception></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsStringUtf8">
      <summary>
            Get the value of the <see cref="F:InTheHand.Net.Bluetooth.ElementTypeDescriptor.TextString" />,
            when it is encoded as UTF-8.
            </summary>
            -
            <remarks>
            Note: a strict decoding is used.
            Thus if the value is not in UTF-8 encoding or has been
            encoded incorrectly an error will occur.
            </remarks>
            -
            <returns>
            A <see cref="T:System.String" /> holding the value of the 
            <see cref="F:InTheHand.Net.Bluetooth.ElementTypeDescriptor.TextString" />
            from the service element.
            </returns>
            -
            <exception cref="T:System.Text.DecoderFallbackException">
            If the value in the service element is not a valid string in the given encoding.
            On NETCF, an <see cref="T:System.ArgumentException" /> is thrown; not that
            <see cref="T:System.ArgumentException" /> is the base class of the
            <see cref="T:System.Text.DecoderFallbackException" /> exception.
            </exception><exception cref="T:System.InvalidOperationException">
            The service element is not of type 
            <see cref="F:InTheHand.Net.Bluetooth.ElementTypeDescriptor.TextString" />.
            </exception></member>
    <member name="P:InTheHand.Net.Bluetooth.ServiceElement.ElementType">
      <summary>
            Gets the type of the element as an <see cref="T:InTheHand.Net.Bluetooth.ElementType" />.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.ServiceElement.ElementTypeDescriptor">
      <summary>
            Gets the SDP Element Type Descriptor of the element
            as an <see cref="T:InTheHand.Net.Bluetooth.ElementTypeDescriptor" />.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.ServiceElement.Value">
      <summary>
            Gets the value of the element as the .NET type it is stored as.
            </summary>
      <remarks>
            In most cases the type-specific property should be used instead, e.g 
            <see cref="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsElementList" />, 
            <see cref="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsUri" />, 
            <see cref="M:InTheHand.Net.Bluetooth.ServiceElement.GetValueAsUuid" />, etc.
            </remarks>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.MapServiceClassToAttributeIdList">
      <summary>
            Gets a list of enum-like classes containing SDP Service Attribute Id definitions 
            for a particular Service Class.
            </summary>
            -
            <remarks>
            See method 
            <see cref="M:InTheHand.Net.Bluetooth.MapServiceClassToAttributeIdList.GetAttributeIdEnumTypes(InTheHand.Net.Bluetooth.ServiceRecord)" />.
            </remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.MapServiceClassToAttributeIdList.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.MapServiceClassToAttributeIdList" /> class.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.MapServiceClassToAttributeIdList.GetAttributeIdEnumTypes(InTheHand.Net.Bluetooth.ServiceRecord)">
      <summary>
            Get a list of enum-like classes containing Service Attribute Id definitions 
            for the type of the Service Class contained in the given Service Record.
            </summary>
            -
            <param name="record">A <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            whose <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceClassIdList" />
            element will be retrieved, and its Service Class Id will used
            for the lookup.
            </param>
            -
            <returns>
            An array of <see cref="T:System.Type" /> each of which is a enum-like class 
            which defines the set of Service Attribute IDs used by a particular 
            Service Class e.g. ObjectPushProfile.
            An empty array will be returned if none of the Service Classes
            are known, or the record contains no 
            <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceClassIdList" />
            attribute, or it is invalid.
            <note>Currently only the first Service Class Id is looked-up.</note></returns>
            -
            <exception cref="T:System.ArgumentNullException"><paramref name="record" /> is null.
            </exception></member>
    <member name="M:InTheHand.Net.Bluetooth.MapServiceClassToAttributeIdList.GetAttributeIdEnumType(InTheHand.Net.Bluetooth.ServiceElement)">
      <summary>
            Get the enum-like class containing the Service Attribute Id definitions 
            for the type of the Service Class contained in the given 
            <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceClassIdList" />
            (type <see cref="F:InTheHand.Net.Bluetooth.ElementTypeDescriptor.Uuid" />) data element.
            </summary>
            -
            <param name="idElement">A <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" />
            of 'UUID' type containing the Service Class to search for.
            </param>
            -
            <returns>
            A <see cref="T:System.Type" /> object representing the enum-like class
            holding the Attribute Id definitions, or null if the Service Class is
            unknown or the element is not of <see cref="F:InTheHand.Net.Bluetooth.ElementTypeDescriptor.Uuid" />
            type.
            </returns>
            -
            <exception cref="T:System.ArgumentNullException"><paramref name="idElement" /> is null.
            </exception></member>
    <member name="M:InTheHand.Net.Bluetooth.MapServiceClassToAttributeIdList.GetAttributeIdEnumType(System.Guid)">
      <overloads>
            Get the enum-like class containing the Service Attribute Id definitions 
            for the type of the Service Class specified.
            </overloads>
            -
            <summary>
            Get the enum-like class containing the Service Attribute Id definitions 
            for the type of the Service Class specified by UUID.
            </summary>
            -
            <param name="uuid">The Service Class to search for, as a <see cref="T:System.Guid" />.
            </param>
            -
            <returns>
            A <see cref="T:System.Type" /> object representing the enum-like class
            holding the Attribute Id definitions, or null if the Service Class is
            unknown.
            </returns></member>
    <member name="T:InTheHand.Net.Bluetooth.LanguageBaseItem">
      <summary>
            Represents a member of the SDP 
            <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.LanguageBaseAttributeIdList" />,
            Attribute
            which provides for multi-language strings in a record.
            </summary>
      <remarks>
            The 
            <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.LanguageBaseAttributeIdList" />
            attribute is a list in which each 
            member contains a language identifier, a character encoding identifier, and 
            a base attribute ID for each of the natural languages used in the service 
            record.
            </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LanguageBaseItem.PrimaryLanguageBaseAttributeId">
      <summary>
            The primary language is specified to have base attribute ID 0x0100.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LanguageBaseItem.Utf8EncodingId">
      <summary>
            The Id for the UTF-8 encoding.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LanguageBaseItem.ErrorMsgLangBaseListParseNotU16">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LanguageBaseItem.ErrorMsgLangBaseListParseBaseInvalid">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LanguageBaseItem.ErrorMsgLangBaseListParseNotSequence">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LanguageBaseItem.ErrorMsgLangBaseListParseNotInThrees">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LanguageBaseItem.ErrorMsgFormatUnrecognizedEncodingId">
      <exclude />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LanguageBaseItem.ErrorMsgLangMustAsciiTwoChars">
      <exclude />
    </member>
    <member name="M:InTheHand.Net.Bluetooth.LanguageBaseItem.#ctor(System.UInt16,System.UInt16,System.UInt16)">
      <summary>
            Initialize a new instance of the <see cref="T:InTheHand.Net.Bluetooth.LanguageBaseItem" /> class.
            </summary>
            -
            <param name="naturalLanguage">The Natural Language field of the entry.
            Some example values are 0x656E which is "en", and 0x6672 which is "fr".
            </param><param name="encodingId">The IETF Charset identifier for this language.
            e.g. 3 for US-ASCII and 106 for UTF-8,
            see <see cref="P:InTheHand.Net.Bluetooth.LanguageBaseItem.EncodingId" /></param><param name="baseAttributeId">The base Attribute Id for this language
            in the record.
            e.g. 0x100 for the Primary language.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.LanguageBaseItem.#ctor(System.Int16,System.Int16,System.Int16)">
      <summary>
            Initialize a new instance of the <see cref="T:InTheHand.Net.Bluetooth.LanguageBaseItem" /> class.
            </summary>
            -
            <param name="naturalLanguage">The Natural Language field of the entry.
            Some example values are 0x656E which is "en", and 0x6672 which is "fr".
            </param><param name="encodingId">The IETF Charset identifier for this language.
            e.g. 3 for US-ASCII and 106 for UTF-8,
            see <see cref="P:InTheHand.Net.Bluetooth.LanguageBaseItem.EncodingId" /></param><param name="baseAttributeId">The base Attribute Id for this language
            in the record.
            e.g. 0x100 for the Primary language.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.LanguageBaseItem.#ctor(System.UInt16,System.UInt16,InTheHand.Net.Bluetooth.ServiceAttributeId)">
      <overloads>
            Initialize a new instance of the <see cref="T:InTheHand.Net.Bluetooth.LanguageBaseItem" /> class.
            </overloads>
            -
            <summary>
            Initialize a new instance of the <see cref="T:InTheHand.Net.Bluetooth.LanguageBaseItem" /> class.
            </summary>
            -
            <param name="naturalLanguage">The Natural Language field of the entry.
            Some example values are 0x656E which is "en", and 0x6672 which is "fr".
            </param><param name="encodingId">The IETF Charset identifier for this language.
            e.g. 3 for US-ASCII and 106 for UTF-8,
            see <see cref="P:InTheHand.Net.Bluetooth.LanguageBaseItem.EncodingId" /></param><param name="baseAttributeId">The base Attribute Id for this language
            in the record.
            e.g. 0x100 for the Primary language.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.LanguageBaseItem.#ctor(System.Int16,System.Int16,InTheHand.Net.Bluetooth.ServiceAttributeId)">
      <summary>
            Initialize a new instance of the <see cref="T:InTheHand.Net.Bluetooth.LanguageBaseItem" /> class.
            </summary>
            -
            <param name="naturalLanguage">The Natural Language field of the entry.
            Some example values are 0x656E which is "en", and 0x6672 which is "fr".
            </param><param name="encodingId">The IETF Charset identifier for this language.
            e.g. 3 for US-ASCII and 106 for UTF-8,
            see <see cref="P:InTheHand.Net.Bluetooth.LanguageBaseItem.EncodingId" /></param><param name="baseAttributeId">The base Attribute Id for this language
            in the record.
            e.g. 0x100 for the Primary language.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.LanguageBaseItem.#ctor(System.String,System.UInt16,InTheHand.Net.Bluetooth.ServiceAttributeId)">
      <summary>
            Initialize a new instance of the <see cref="T:InTheHand.Net.Bluetooth.LanguageBaseItem" /> class.
            </summary>
            -
            <param name="naturalLanguage">The Natural Language field of the entry.
            Some example values are "en", and "fr".
            </param><param name="encodingId">The IETF Charset identifier for this language.
            e.g. 3 for US-ASCII and 106 for UTF-8,
            see <see cref="P:InTheHand.Net.Bluetooth.LanguageBaseItem.EncodingId" /></param><param name="baseAttributeId">The base Attribute Id for this language
            in the record.
            e.g. 0x100 for the Primary language.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.LanguageBaseItem.#ctor(System.String,System.Int16,InTheHand.Net.Bluetooth.ServiceAttributeId)">
      <summary>
            Initialize a new instance of the <see cref="T:InTheHand.Net.Bluetooth.LanguageBaseItem" /> class.
            </summary>
            -
            <param name="naturalLanguage">The Natural Language field of the entry.
            Some example values are "en", and "fr".
            </param><param name="encodingId">The IETF Charset identifier for this language.
            e.g. 3 for US-ASCII and 106 for UTF-8,
            see <see cref="P:InTheHand.Net.Bluetooth.LanguageBaseItem.EncodingId" /></param><param name="baseAttributeId">The base Attribute Id for this language
            in the record.
            e.g. 0x100 for the Primary language.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.LanguageBaseItem.ParseListFromElementSequence(InTheHand.Net.Bluetooth.ServiceElement)">
      <summary>
            Gets the list of <see cref="T:InTheHand.Net.Bluetooth.LanguageBaseItem" />
            items in the service record.
            </summary>
            -
            <param name="elementSequence">
            A <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" /> holding the 
            data from the 
            <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.LanguageBaseAttributeIdList" />
            attribute.
            </param>
            -
            <returns>
            An array of <see cref="T:InTheHand.Net.Bluetooth.LanguageBaseItem" />.  
            An array length zero is returned if the service record contains no such attribute.
            </returns>
            -
            <exception cref="T:System.ArgumentException"><paramref name="elementSequence" /> is not of type 
            <see cref="F:InTheHand.Net.Bluetooth.ElementType.ElementSequence" />.
            </exception><exception cref="T:System.Net.ProtocolViolationException">
            The element sequence contains incorrectly formatted or invalid content,
            for example it contains the wrong element data types, or doesn't contain
            the elements in groups of three as required.
            </exception></member>
    <member name="M:InTheHand.Net.Bluetooth.LanguageBaseItem.CreateElementSequenceFromList(InTheHand.Net.Bluetooth.LanguageBaseItem[])">
      <summary>
            Create a data element for the 
            <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.LanguageBaseAttributeIdList" />
            attribute
            from the list of <see cref="T:InTheHand.Net.Bluetooth.LanguageBaseItem" /></summary>
            -
            <param name="list">
            An array of <see cref="T:InTheHand.Net.Bluetooth.LanguageBaseItem" />.
            </param>
            -
            <returns>
            A <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" /> holding the 
            <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.LanguageBaseAttributeIdList" />
            element, to be added to a generally the 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />.
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.LanguageBaseItem.CreateEnglishUtf8PrimaryLanguageItem">
      <summary>
            Create a <see cref="T:InTheHand.Net.Bluetooth.LanguageBaseItem" /> instance
            for a primary language of English and a string encoding of UTF-8.
            </summary>
      <returns>The <see cref="T:InTheHand.Net.Bluetooth.LanguageBaseItem" /> instance.
            </returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.LanguageBaseItem.GetEncoding">
      <summary>
            Gets an <see cref="T:System.Text.Encoding" /> appropriate for this language base item.
            </summary>
            -
            <returns>The <see cref="T:System.Text.Encoding" />
            appropriate for this language base item.
            </returns>
            -
            <remarks><para>We support the following set of mappings from encoding id to .NET
            Encoding name.
            <list type="table"><listheader><term>Id</term><description>Encoding</description></listheader><item><term>3</term><description>us-ascii</description></item><item><term>4</term><description>iso-8859-1</description></item><item><term>5</term><description>iso-8859-2</description></item><item><term>6</term><description>iso-8859-3</description></item><item><term>7</term><description>iso-8859-4</description></item><item><term>8</term><description>iso-8859-5</description></item><item><term>9</term><description>iso-8859-6</description></item><item><term>10</term><description>iso-8859-7</description></item><item><term>11</term><description>iso-8859-8</description></item><item><term>12</term><description>iso-8859-9</description></item><item><term>13</term><description>iso-8859-10</description></item><item><term>106 (0x006a)</term><description>UTF-8</description></item><item><term>109</term><description>iso-8859-13</description></item><item><term>110</term><description>iso-8859-14</description></item><item><term>111</term><description>iso-8859-15</description></item><item><term>112</term><description>iso-8859-16</description></item><item><term>1013 (0x03f5)</term><description>unicodeFFFE (UTF-16BE)</description></item><item><term>1014</term><description>utf-16 (UTF-16LE)</description></item><item><term>1015</term><description>utf-16 (UTF-16, we assume UTF16-LE)</description></item><item><term>2252 to 2258 (0x08cc to 0x08d2)</term><description>windows-1252 to Windows-1258</description></item></list>
            Note that not all platforms support all these Encodings, for instance on
            my Windows XP SP2 box iso-8859-10/-14/-16 are not supported.  On NETCF on
            Windows Mobile 5 only five of the ISO-8859 encodings are supported.
            Regardless I've seen no SDP records that use ISO-8859 encodings so this is 
            not a problem, most records actually use UTF-8.
            </para></remarks>
            -
            <exception cref="T:System.NotSupportedException">
            The IETF encoding id for this language base item is currently unknown.
            If valid, add it to the <c>s_IetfCharsetIdToDotNetEncodingNameTable</c> table, 
            providing a mapping to its Windows code page name.
            </exception></member>
    <member name="M:InTheHand.Net.Bluetooth.LanguageBaseItem.TestAllDefinedEncodingMappingRows(System.Int32@,System.Int32@)">
      <exclude />
    </member>
    <member name="P:InTheHand.Net.Bluetooth.LanguageBaseItem.NaturalLanguage">
      <summary>
            Gets the value of the Natural Language field of the entry.
            </summary>
      <example>Some example value may be "en", and "fr".</example>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.LanguageBaseItem.NaturalLanguageAsUInt16">
      <summary>
            Gets the value of the Natural Language field of the entry, as a <see cref="T:System.UInt16" />.
            </summary>
      <example>Some example value may be 0x656e for "en", and 0x6672 for "fr".</example>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.LanguageBaseItem.NaturalLanguageAsInt16">
      <summary>
            Gets the value of the Natural Language field of the entry, as a <see cref="T:System.UInt16" />.
            </summary>
      <example>Some example value may be 0x656e for "en", and 0x6672 for "fr".</example>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.LanguageBaseItem.AttributeIdBase">
      <summary>
            Gets the base Attribute Id for this language.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.LanguageBaseItem.EncodingId">
      <summary>
            Get the IETF Charset identifier for this language.
            </summary>
            -
            <remarks><para>Example values are 3 for US-ASCII and 106 for UTF-8.
            See the full list at <see href="http://www.iana.org/assignments/character-sets" /></para></remarks>
            -
            <seealso cref="P:InTheHand.Net.Bluetooth.LanguageBaseItem.EncodingIdAsInt16" /></member>
    <member name="P:InTheHand.Net.Bluetooth.LanguageBaseItem.EncodingIdAsInt16">
      <summary>
            Get the IETF Charset identifier for this language, as an Int16.
            </summary>
            -
            <remarks><para>
            See <see cref="P:InTheHand.Net.Bluetooth.LanguageBaseItem.EncodingId" />.
            </para></remarks>
            -
            <seealso cref="P:InTheHand.Net.Bluetooth.LanguageBaseItem.EncodingId" /></member>
    <member name="T:InTheHand.Net.Bluetooth.ServiceClass">
      <summary>
            Class of Service flags as assigned in the Bluetooth specifications.
            </summary>
            -
            <remarks><para>Is returned by the property <see cref="P:InTheHand.Net.Bluetooth.ClassOfDevice.Service">ClassOfDevice.Service</see>.
            </para><para>Defined in Bluetooth Specifications <see href="http://www.bluetooth.org/Technical/AssignedNumbers/baseband.htm" />.
            </para></remarks></member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceClass.None">
      <summary>
            No service class bits set.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceClass.Information">
      <summary>
      </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceClass.Telephony">
      <summary>
      </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceClass.Audio">
      <summary>
      </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceClass.ObjectTransfer">
      <summary>
      </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceClass.Capturing">
      <summary>
      </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceClass.Rendering">
      <summary>
      </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceClass.Network">
      <summary>
      </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceClass.Positioning">
      <summary>
      </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.ServiceClass.LimitedDiscoverableMode">
      <summary>
      </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.RadioMode">
      <summary>
            Determine all the possible modes of operation of the Bluetooth radio.
            </summary>
            -
            <remarks>See <see cref="P:InTheHand.Net.Bluetooth.BluetoothRadio.Mode">BluetoothRadio.Mode</see>
            for what is supported on what platforms.  For instance setting the mode
            is not supported on Widcomm+Win32.  On Widcomm WM/CE setting <c>PowerOff</c>
            actually sets 'CONNECT_ALLOW_NONE', and not actually disabled/off.
            Also when the stack is disabled, setting connectable/discoverable 
            does not manage to turn the radio on.
            </remarks>
            -
            <seealso cref="P:InTheHand.Net.Bluetooth.BluetoothRadio.Mode">BluetoothRadio.Mode</seealso></member>
    <member name="F:InTheHand.Net.Bluetooth.RadioMode.PowerOff">
      <summary>
            Bluetooth is disabled on the device.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.RadioMode.Connectable">
      <summary>
            Bluetooth is connectable but your device cannot be discovered by other devices.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.RadioMode.Discoverable">
      <summary>
            Bluetooth is activated and fully discoverable.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BlueZ.Structs.rfcomm_conninfo">
      <summary>
            Use with so_RFCOMM_CONNINFO.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.AttributeIds.HidProfileAttributeId">
      <summary>
            Service Attribute IDs defined by the Human Interface Device (HID) Profile specification.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.HidProfileAttributeId.DeviceReleaseNumber">
      <summary>
            HIDDeviceReleaseNumber
            </summary>
      <remarks>
        <para>[<c>16-bit unsigned integer</c>]</para>
        <para>
            A numeric expression identifying the device release number in Binary-Coded 
            Decimal. This is a vendor-assigned field, which defines the version of 
            the product identified by the Bluetooth Device Identification [13] VendorID 
            and ProductID attributes. This attribute is intended to differentiate 
            between versions of products with identical VendorIDs and ProductIDs. 
            The value of the field is 0xJJMN for version JJ.M.N (JJ  major version 
            number, M  minor version number, N  sub-minor version number). 
            </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.HidProfileAttributeId.ParserVersion">
      <summary>
            HIDParserVersion
            </summary>
      <remarks>
        <para>[<c>16-bit unsigned integer</c>]</para>
        <para>
            Each version of a profile is assigned a 16-bit unsigned integer version
            number of the base HID Specification [4] that the device was designed to. The value
            of the field is 0xJJMN for version JJ.M.N 
            </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.HidProfileAttributeId.DeviceSubclass">
      <summary>
            HIDDeviceSubclass
            </summary>
      <remarks>
        <para>[<c>8-bit unsigned integer</c>]</para>
        <para>
            The HIDDeviceSubclass attribute is an 8-bit integer, which
            identifies the type of device (keyboard, mouse, joystick, gamepad,
            remote control, sensing device, etc.). Keyboards and mice are required
            to support boot mode operation. In boot mode, a device presents a fixed
            report, thus negating the requirement for a HID parser.
            <para></para>The Attribute value is identical to the low-order 8 bits
            of the Class of Device/Service (CoD) field in the FHS packet, where
            bits 7-2 contain the 6 bit Minor Device Class value (defined in Section
            1.2 of the Bluetooth Assigned Numbers document [8]) and bits 1-0 are
            set to zero.  
            </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.HidProfileAttributeId.CountryCode">
      <summary>
            HIDCountryCode
            </summary>
      <remarks>
        <para>[<c>8-bit unsigned integer</c>]</para>
        <para>
            The HIDCountryCode attribute is an 8-bit integer, which identifies
            which country the hardware is localized for. Most hardware is not localized
            and thus this value would be zero (0). 
            </para>
        <para>The valid country codes are listed in the HID Specification
            [4].
            </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.HidProfileAttributeId.VirtualCable">
      <summary>
            HIDVirtualCable
            </summary>
      <remarks>
        <para>[<c>8-bit Boolean</c>]</para>
        <para>
            The HIDVirtualCable attribute is a boolean value, which indicates
            whether the device supports virtual connections as described in Section
            Virtual Cables and Connection Re-Establishment. Devices that have this
            attribute True indicate that the device supports 1:1 bonding with a host,
            and the device expects to automatically reconnect if the connection is
            dropped for any unknown reason.
            </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.HidProfileAttributeId.ReconnectInitiate">
      <summary>
            HIDReconnectInitiate
            </summary>
      <remarks>
        <para>[<c>8-bit Boolean</c>]</para>
        <para>
            The HIDReconnectInitiate attribute is a boolean value, which
            indicates whether the device initiates the reconnection process or
            expects the host to. 
            </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.HidProfileAttributeId.DescriptorList">
      <summary>
            HIDDescriptorList
            </summary>
      <remarks>
        <para>[<c>Data element sequence</c>]</para>
        <para>
            The HIDDescriptorList Data Element Sequence performs the function of the
            HID Descriptor that is defined in Section 6.2 of the HID Specification [4]. The
            HIDDescriptorList identifies the descriptors associated with the device. 
            </para>
        <para>The HIDDescriptorList is a Data Element Sequence that consists of
            one or more HIDDescriptors. A HIDDescriptor is a data element sequence containing, 
            minimally, a pair of elements. For compatibility with future versions of the HID
            profile, addition elements found in a HIDDescriptor shall be ignored. 
                   
            </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.HidProfileAttributeId.LangIdBaseList">
      <summary>
            HIDLANGIDBaseList
            </summary>
      <remarks>
        <para>[<c>Data element sequence</c>]</para>
        <para>
            The HIDLANGIDBaseList is a Data Element Sequence that consists of one or
            more HIDLANGIDBases. A HIDLANGIDBase is a data element sequence containing, minimally, 
            two elements for each of the languages used in the service record: a language identifier
            (LANGID) and a base attribute ID. For compatibility with future versions of the
            HID profile, additional elements found in a HIDLANGIDBase shall be ignored.
            </para>
        <para>The first element, called the HIDLANGID, contains an identifier representing
            the natural language ID. The language is encoded according to the Universal Serial
            Bus Language Identifiers (LANGIDs) Specification [9].
            </para>
        <para>The second element, called the HIDLanguageBase, contains an attribute
            ID that serves as the base attribute ID for the natural language in the service
            record. Different service records within a server may use different base attribute
            ID values for the same language. 
            </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.HidProfileAttributeId.SdpDisable">
      <summary>
            HIDSDPDisable
            </summary>
      <remarks>
        <para>[<c>8-bit Boolean</c>]</para>
        <para>
            The HIDSDPDisable attribute is a boolean value, which indicates whether
            connection to the SDP channel and Control or Interrupt channels are mutually exclusive.
            
            </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.HidProfileAttributeId.BatteryPower">
      <summary>
            HIDBatteryPower
            </summary>
      <remarks>
        <para>[<c>8-bit Boolean</c>]</para>
        <para>
            The HIDBatteryPower attribute is a boolean value, which indicates whether
            the device is battery powered (and requires careful power management) or has some
            other source of power that requires minimal management. 
            </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.HidProfileAttributeId.RemoteWake">
      <summary>
            HIDRemoteWake
            </summary>
      <remarks>
        <para>[<c>8-bit Boolean</c>]</para>
        <para>
            The HIDRemoteWake attribute is a boolean value, which indicates whether
            the device considers itself remote wake up-capable. When a system enters a suspend
            (or standby) state, this flag shall be used to determine whether the host includes
            this device in the set of devices that can wake it up. A mouse or keyboard are
            typical examples of Remote Wake up devices.
            </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.HidProfileAttributeId.BootDevice">
      <summary>
            HIDBootDevice
            </summary>
      <remarks>
        <para>[<c>8-bit Boolean</c>]</para>
        <para>
            HIDBootDevice is an 8-bit Boolean value that when True indicates whether
            the device supports boot protocol mode and by inference the Set_Protocol and Get_Protocol
            commands. 
            </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.HidProfileAttributeId.SupervisionTimeout">
      <summary>
            HIDSupervisionTimeout
            </summary>
      <remarks>
        <para>[<c>16-bit unsigned integer</c>]</para>
        <para>
            The HIDSupervisionTimeout is a 16-bit value which indicates the device
            vendors recommended baseband Link Supervision Timeout value in slots. 
            </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.HidProfileAttributeId.NormallyConnectable">
      <summary>
            HIDNormallyConnectable
            </summary>
      <remarks>
        <para>[<c>8-bit Boolean</c>]</para>
        <para>
            HIDNormallyConnectable is an optional Boolean attribute that specifies
            whether a HID is normally in Page Scan mode (when no connection is active) or not.
            
            </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.HidProfileAttributeId.ProfileVersion">
      <summary>
            HIDProfileVersion
            </summary>
      <remarks>
        <para>[<c>16-bit unsigned integer</c>]</para>
        <para>
            Each device designed to this specification shall include a 16-bit unsigned
            integer version number of the Bluetooth HID Specification (this document) that
            the device was designed to. The value of the field is 0xJJMN for version JJ.M.N
            (JJ  major version number, M  minor version number, N  sub-minor version number);
            
            </para>
      </remarks>
    </member>
    <member name="T:InTheHand.Net.Sockets.IrDAListener">
      <summary>
            Places a socket in a listening state to monitor infrared connections from a specified service or network address.
            </summary>
      <remarks>This class monitors a service by specifying a service name or a network address.
            The listener does not listen until you call one of the <see cref="M:InTheHand.Net.Sockets.IrDAListener.Start" />
            methods.</remarks>
      <seealso cref="T:System.Net.Sockets.IrDAListener" />
    </member>
    <member name="M:InTheHand.Net.Sockets.IrDAListener.#ctor(InTheHand.Net.IrDAEndPoint)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Sockets.IrDAListener" /> class.
            </summary>
      <param name="ep">The network address to monitor for making a connection.</param>
    </member>
    <member name="M:InTheHand.Net.Sockets.IrDAListener.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Sockets.IrDAListener" /> class.
            </summary>
      <param name="service">The name of the service to listen for.</param>
    </member>
    <member name="M:InTheHand.Net.Sockets.IrDAListener.Start">
      <summary>
            Starts listening for incoming connection requests.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Sockets.IrDAListener.Start(System.Int32)">
      <summary>
            Starts listening for incoming connection requests with a maximum number of pending connection.
            </summary>
      <param name="backlog">The maximum length of the pending connections queue.</param>
    </member>
    <member name="M:InTheHand.Net.Sockets.IrDAListener.Stop">
      <summary>
            Stops the socket from monitoring connections.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Sockets.IrDAListener.AcceptSocket">
      <summary>
            Creates a new socket for a connection.
            </summary>
      <returns>A socket.</returns>
    </member>
    <member name="M:InTheHand.Net.Sockets.IrDAListener.AcceptIrDAClient">
      <summary>
            Creates a client object for a connection when the specified service or endpoint is detected by the listener component.
            </summary>
      <returns>An <see cref="T:InTheHand.Net.Sockets.IrDAClient" /> object.</returns>
    </member>
    <member name="M:InTheHand.Net.Sockets.IrDAListener.BeginAcceptSocket(System.AsyncCallback,System.Object)">
      <summary>
            Begins an asynchronous operation to accept an incoming connection attempt.
            </summary>
            -
            <param name="callback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</param><param name="state">A user-defined object containing information about the accept operation.
            This object is passed to the callback delegate when the operation is complete.</param>
            -
            <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous creation of the <see cref="T:System.Net.Sockets.Socket" />.</returns>
            -
            <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception></member>
    <member name="M:InTheHand.Net.Sockets.IrDAListener.EndAcceptSocket(System.IAsyncResult)">
      <summary>
            Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> to handle remote host communication.
            </summary>
      <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> returned by a call to the <see cref="M:InTheHand.Net.Sockets.IrDAListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" /> method.</param>
      <returns>A <see cref="T:System.Net.Sockets.Socket" />.</returns>
    </member>
    <member name="M:InTheHand.Net.Sockets.IrDAListener.BeginAcceptIrDAClient(System.AsyncCallback,System.Object)">
      <summary>
            Begins an asynchronous operation to accept an incoming connection attempt.
            </summary>
            -
            <param name="callback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</param><param name="state">A user-defined object containing information about the accept operation.
            This object is passed to the callback delegate when the operation is complete.</param>
            -
            <returns>An <see cref="T:System.IAsyncResult" /> that represents the 
            asynchronous accept, which could still be pending.
            </returns></member>
    <member name="M:InTheHand.Net.Sockets.IrDAListener.EndAcceptIrDAClient(System.IAsyncResult)">
      <summary>
            Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:InTheHand.Net.Sockets.IrDAClient" /> to handle remote host communication.
            </summary>
      <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> returned by a call to the <see cref="M:InTheHand.Net.Sockets.IrDAListener.BeginAcceptIrDAClient(System.AsyncCallback,System.Object)" /> method.</param>
      <returns>An <see cref="T:InTheHand.Net.Sockets.IrDAClient" />.</returns>
    </member>
    <member name="M:InTheHand.Net.Sockets.IrDAListener.Pending">
      <summary>
            Determines if a connection is pending.
            </summary>
      <returns>true if there is a connection pending; otherwise, false.</returns>
    </member>
    <member name="P:InTheHand.Net.Sockets.IrDAListener.Server">
      <summary>
            Gets the underlying network <see cref="T:System.Net.Sockets.Socket" />.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Sockets.IrDAListener.Active">
      <summary>
            Gets a value that indicates whether the <see cref="T:InTheHand.Net.Sockets.IrDAListener" /> is actively listening for client connections.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Sockets.IrDAListener.LocalEndpoint">
      <summary>
            Gets an <see cref="T:InTheHand.Net.IrDAEndPoint" /> representing the local device.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BluetoothProtocolDescriptorType">
      <summary>
            Configures what type of element will be added by the <see cref="T:InTheHand.Net.Bluetooth.ServiceRecordBuilder" />
            for the <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList" /> 
            attribute.
            </summary>
            -
            <remarks><para>Used with the <see cref="P:InTheHand.Net.Bluetooth.ServiceRecordBuilder.ProtocolType" />
            property.
            </para></remarks></member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothProtocolDescriptorType.None">
      <summary>
            No PDL attribute will be added.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothProtocolDescriptorType.L2Cap">
      <summary>
            A standard L2CAP element will be added.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothProtocolDescriptorType.Rfcomm">
      <summary>
            A standard RFCOMM element will be added.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothProtocolDescriptorType.GeneralObex">
      <summary>
            A standard GOEP (OBEX) element will be added.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.ClassOfDevice">
      <summary>
            Describes the device and service capabilities of a device.
            </summary>
            -
            <remarks><para>Is returned by the properties
            <see cref="P:InTheHand.Net.Sockets.BluetoothDeviceInfo.ClassOfDevice">BluetoothDeviceInfo.ClassOfDevice</see>
            and
            <see cref="P:InTheHand.Net.Bluetooth.BluetoothRadio.ClassOfDevice">BluetoothRadio.ClassOfDevice</see>.
            </para></remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.ClassOfDevice.#ctor(System.UInt32)">
      <summary>
            Initialize a new instance of class <see cref="T:InTheHand.Net.Bluetooth.ClassOfDevice" />.
            </summary>
            -
            <remarks><para>An example raw value is 0x00020104, which stands for
            device: DesktopComputer, service: Network.
            </para></remarks>
            -
            <param name="cod">A <see cref="T:System.UInt32" /> containing the
            raw Class of Device value.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.ClassOfDevice.#ctor(InTheHand.Net.Bluetooth.DeviceClass,InTheHand.Net.Bluetooth.ServiceClass)">
      <summary>
            Initialize a new instance of class <see cref="T:InTheHand.Net.Bluetooth.ClassOfDevice" />.
            </summary>
            -
            <param name="device">A <see cref="T:InTheHand.Net.Bluetooth.DeviceClass" />
            value.
            </param><param name="service">A <see cref="T:InTheHand.Net.Bluetooth.ServiceClass" />
            value.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.ClassOfDevice.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
      <returns>A hash code for the current object.</returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.ClassOfDevice.ToString">
      <summary>
            Returns the numerical value represented in a hexadecimal.
            </summary>
            -
            <returns>A <see cref="T:System.String" /> containing
            the numerical value represented in a hexadecimal
            e.g. "720104", "5A020C".
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.ClassOfDevice.Equals(System.Object)">
      <summary>
            Returns a value indicating whether this instance is equal to a specified 
            object.
            </summary>
      <param name="obj">An object
            value to compare with the current instance.
            </param>
      <returns>true if <paramref name="obj" /> is an instance of <see cref="T:InTheHand.Net.Bluetooth.ClassOfDevice" />
            and equals the value of this instance; otherwise, false.
            </returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.ClassOfDevice.Equals(InTheHand.Net.Bluetooth.ClassOfDevice)">
      <summary>
            Returns a value indicating whether this instance is equal to a specified 
            <see cref="T:InTheHand.Net.Bluetooth.ClassOfDevice" /> value.
            </summary>
      <param name="other">An <see cref="T:InTheHand.Net.Bluetooth.ClassOfDevice" />
            value to compare with the current instance.
            </param>
      <returns>true if <paramref name="other" />
            has the same value as this instance; otherwise, false.
            </returns>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.ClassOfDevice.Device">
      <summary>
            Returns the device type.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.ClassOfDevice.MajorDevice">
      <summary>
            Returns the major device type.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.ClassOfDevice.Service">
      <summary>
            Returns supported service types.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.ClassOfDevice.Value">
      <summary>
            Gets the numerical value.
            </summary>
      <seealso cref="P:InTheHand.Net.Bluetooth.ClassOfDevice.ValueAsInt32" />
    </member>
    <member name="P:InTheHand.Net.Bluetooth.ClassOfDevice.ValueAsInt32">
      <summary>
            Gets the numerical value, suitable for CLS Compliance.
            </summary>
      <seealso cref="P:InTheHand.Net.Bluetooth.ClassOfDevice.Value" />
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BluetoothWin32RadioEventArgs">
      <summary>
            The base class for classes containing Radio In- and Out-of-Range events.
            </summary>
            -
            <remarks><para>Supported only by the Microsoft stack on desktop Windows.
            </para><para>Produced by class <see cref="T:InTheHand.Net.Bluetooth.BluetoothWin32Events" />.
            </para></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothWin32RadioEventArgs.Device">
      <summary>
            Gets the device to which the event applies.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BluetoothWin32RadioOutOfRangeEventArgs">
      <summary>
            The data for Radio Out-of-Range event.
            </summary>
            -
            <remarks><para>Supported only by the Microsoft stack on desktop Windows.
            </para><para>Produced by class <see cref="T:InTheHand.Net.Bluetooth.BluetoothWin32Events" />.
            </para></remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothWin32RadioOutOfRangeEventArgs.ToString">
      <summary>
            Gets a string representation of the event.
            </summary>
      <returns>A string (e.g. contains the device address and name).</returns>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BluetoothWin32RadioInRangeEventArgs">
      <summary>
            The data for Radio Out-of-Range event.
            </summary>
            -
            <remarks><para>Supported only by the Microsoft stack on desktop Windows.
            </para><para>Produced by class <see cref="T:InTheHand.Net.Bluetooth.BluetoothWin32Events" />.
            </para></remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothWin32RadioInRangeEventArgs.ToString">
      <summary>
            Gets a string representation of the event.
            </summary>
      <returns>A string (e.g. contains the device address, name and the current and previous flags).</returns>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothWin32RadioInRangeEventArgs.CurrentState">
      <summary>
            The current state of the device according to the Bluetooth stack.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothWin32RadioInRangeEventArgs.PreviousState">
      <summary>
            The previous state of the device according to the Bluetooth stack.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothWin32RadioInRangeEventArgs.GainedStates">
      <summary>
            The flags that are set in the current state
            and weren't in the previous state (calculated).
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.BluetoothWin32RadioInRangeEventArgs.LostStates">
      <summary>
            The flags that are not set in the current state
            but were in the previous state (calculated).
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BluetoothService">
      <summary>
            Standard Bluetooth Profile identifiers.
            </summary>
            -
            <remarks><para>See the list at <see href="http://www.bluetooth.org/Technical/AssignedNumbers/service_discovery.htm" />.
            </para><para>The Bluetooth Base UUID is {00000000-0000-1000-8000-00805F9B34FB}
            </para></remarks></member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.Empty">
      <summary>
            Represents an empty service Guid.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.BluetoothBase">
      <summary>
            Represents the base Guid from which all standard Bluetooth profiles are derived - not used for connections.
            Is {00000000-0000-1000-8000-00805F9B34FB}
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.SdpProtocol">
      <summary>
            [0x0001]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.UdpProtocol">
      <summary>
            [0x0002]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.RFCommProtocol">
      <summary>
            [0x0003]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.TcpProtocol">
      <summary>
            [0x0004]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.TcsBinProtocol">
      <summary>
            [0x0005]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.TcsAtProtocol">
      <summary>
            [0x0006]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.AttProtocol">
      <summary>
            [0x0008]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.ObexProtocol">
      <summary>
            [0x0008]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.IPProtocol">
      <summary>
            [0x0009]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.FtpProtocol">
      <summary>
            [0x000A]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.HttpProtocol">
      <summary>
            [0x000C]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.WspProtocol">
      <summary>
            [0x000E]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.BnepProtocol">
      <summary>
            [0x000F]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.UpnpProtocol">
      <summary>
            [0x0010]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.HidpProtocol">
      <summary>
            [0x0011]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.HardcopyControlChannelProtocol">
      <summary>
            [0x0012]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.HardcopyDataChannelProtocol">
      <summary>
            [0x0014]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.HardcopyNotificationProtocol">
      <summary>
            [0x0016]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.AvctpProtocol">
      <summary>
            [0x0017]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.AvdtpProtocol">
      <summary>
            [0x0019]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.CmtpProtocol">
      <summary>
            [0x001B]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.UdiCPlaneProtocol">
      <summary>
            [0x001D] ?????
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.McapControlChannelProtocol">
      <summary>
            [0x001E]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.McapDataChannelProtocol">
      <summary>
            [0x001F]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.L2CapProtocol">
      <summary>
            [0x0100]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.ServiceDiscoveryServer">
      <summary>
            [0x1000]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.BrowseGroupDescriptor">
      <summary>
            [0x1001]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.PublicBrowseGroup">
      <summary>
            [0x1002]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.SerialPort">
      <summary>
            Provides a basic Serial emulation connect over Bluetooth. [0x1101]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.LanAccessUsingPpp">
      <summary>
            Used to establish PPP connections over RFComm channels. [0x1102]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.DialupNetworking">
      <summary>
            [0x1103]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.IrMCSync">
      <summary>
            [0x1104]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.ObexObjectPush">
      <summary>
            Used for sending binary objects between devices.[0x1105]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.ObexFileTransfer">
      <summary>
            OBEX version of an FTP server [0x1106]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.IrMCSyncCommand">
      <summary>
            [0x1107]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.Headset">
      <summary>
            HSP (Headset Profile)  Supports Bluetooth headset devices.[0x1108]
            See also 
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.HeadsetHeadset" /><see cref="F:InTheHand.Net.Bluetooth.BluetoothService.HeadsetAudioGateway" /></summary>
      <seealso cref="F:InTheHand.Net.Bluetooth.BluetoothService.HeadsetHeadset" />
      <seealso cref="F:InTheHand.Net.Bluetooth.BluetoothService.HeadsetAudioGateway" />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.CordlessTelephony">
      <summary>
            [0x1109]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.AudioSource">
      <summary>
            [0x110A]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.AudioSink">
      <summary>
            [0x110B]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.AVRemoteControlTarget">
      <summary>
            [0x110C]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.AdvancedAudioDistribution">
      <summary>
            [0x110D]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.AVRemoteControl">
      <summary>
            [0x110E]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.AVRemoteControlController">
      <summary>
            [0x110F]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.Intercom">
      <summary>
            [0x1110]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.Fax">
      <summary>
            [0x1111]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.HeadsetAudioGateway">
      <summary>
            [0x1112]
            See also
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.Headset" /><see cref="F:InTheHand.Net.Bluetooth.BluetoothService.HeadsetHeadset" /></summary>
      <seealso cref="F:InTheHand.Net.Bluetooth.BluetoothService.Headset" />
      <seealso cref="F:InTheHand.Net.Bluetooth.BluetoothService.HeadsetHeadset" />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.Wap">
      <summary>
            [0x1113]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.WapClient">
      <summary>
            [0x1114]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.Panu">
      <summary>
            [0x1115]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.Nap">
      <summary>
            [0x1116]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.GN">
      <summary>
            [0x1117]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.DirectPrinting">
      <summary>
            [0x1118]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.ReferencePrinting">
      <summary>
            [0x1119]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.Imaging">
      <summary>
            [0x111A]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.ImagingResponder">
      <summary>
            [0x111B]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.ImagingAutomaticArchive">
      <summary>
            [0x111C]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.ImagingReferenceObjects">
      <summary>
            [0x111D]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.Handsfree">
      <summary>
            Supports hands free kits such as a car kits which provide audio and more advanced call control than the Headset profile. [0x111E]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.HandsfreeAudioGateway">
      <summary>
            [0x111F]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.DirectPrintingReferenceObjects">
      <summary>
            [0x1120]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.ReflectedUI">
      <summary>
            [0x1121]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.BasicPrinting">
      <summary>
            Used for printing simple text, HTML, vCard objects and similar. [0x1122]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.PrintingStatus">
      <summary>
             [0x1123]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.HumanInterfaceDevice">
      <summary>
            Supports human interface devices such as keyboards and mice. [0x1124]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.HardcopyCableReplacement">
      <summary>
             [0x1125]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.HardcopyCableReplacementPrint">
      <summary>
             [0x1126]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.HardcopyCableReplacementScan">
      <summary>
             [0x1127]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.CommonIsdnAccess">
      <summary>
            Common_ISDN_Access [0x1128]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.VideoConferencingGW">
      <summary>
             [0x1129]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.UdiMT">
      <summary>
            UDI_MT [0x112A]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.UdiTA">
      <summary>
            UDI_TA [0x112B]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.AudioVideo">
      <summary>
             [0x112C]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.SimAccess">
      <summary>
            SIM_Access [0x112D]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.PhonebookAccessPce">
      <summary>
            Phonebook Access - PCE [0x112E]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.PhonebookAccessPse">
      <summary>
            Phonebook Access - PSE [0x112F]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.PhonebookAccess">
      <summary>
            Phonebook Access [0x1130]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.HeadsetHeadset">
      <summary>
            Headset [0x1131]
            See also
            <see cref="F:InTheHand.Net.Bluetooth.BluetoothService.Headset" /><see cref="F:InTheHand.Net.Bluetooth.BluetoothService.HeadsetAudioGateway" /></summary>
      <seealso cref="F:InTheHand.Net.Bluetooth.BluetoothService.Headset" />
      <seealso cref="F:InTheHand.Net.Bluetooth.BluetoothService.HeadsetAudioGateway" />
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.MessageAccessServer">
      <summary>
            Message Access Server [0x1132]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.MessageNotificationServer">
      <summary>
            Message Notification Server [0x1133]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.MessageAccessProfile">
      <summary>
            Message Access Profile [0x1134]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.PnPInformation">
      <summary>
            Bluetooth Device Identification. [0x1200]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.GenericNetworking">
      <summary>
             [0x1201]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.GenericFileTransfer">
      <summary>
             [0x1202]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.GenericAudio">
      <summary>
             [0x1203]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.GenericTelephony">
      <summary>
             [0x1204]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.UPnp">
      <summary>
             [0x1205]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.UPnpIP">
      <summary>
             [0x1206]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.UPnpIPPan">
      <summary>
            ESDP_UPNP_IP_PAN [0x1300]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.UPnpIPLap">
      <summary>
            ESDP_UPNP_IP_LAP [0x1301]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.UPnpIPL2Cap">
      <summary>
            ESDP_UPNP_L2CAP [0x1302]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.VideoSource">
      <summary>
            Video Distribution Profile - Source [0x1303]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.VideoSink">
      <summary>
            Video Distribution Profile - Sink [0x1304]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.VideoDistribution">
      <summary>
            Video Distribution Profile [0x1305]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.HealthDevice">
      <summary>
            Health Device Profile (HDP) [0x1400]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.HealthDeviceSource">
      <summary>
            Health Device Profile (HDP) - Source [0x1401]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothService.HealthDeviceSink">
      <summary>
            Health Device Profile (HDP) - Sink [0x1402]
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothService.GetName(System.Guid)">
      <summary>
            Retrieves the name of the Service Class UUID that has the specified value. 
            </summary>
      <param name="uuid">
            The service class UUID as a <see cref="T:System.Guid" />.
            </param>
      <returns>
            A string containing the name of the service class whose UUID value is <paramref name="uuid" />,
            or a null reference (<c>Nothing</c> in Visual Basic) if no such constant is found.
            </returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothService.GetName(System.Int16)">
      <summary>
            Retrieves the name of the Service Class UUID that has the specified value. 
            </summary>
      <param name="uuid16">
            The service class UUID in the 16-bit UUID short form as a <see cref="T:System.Int16" />.
            </param>
      <returns>
            A string containing the name of the service class whose UUID value is <paramref name="uuid" />,
            or a null reference (<c>Nothing</c> in Visual Basic) if no such constant is found.
            </returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothService.GetName(System.UInt16)">
      <summary>
            Retrieves the name of the Service Class UUID that has the specified value. 
            </summary>
      <param name="uuid16">
            The service class UUID in the 16-bit short UUID form as a <see cref="T:System.UInt16" />.
            </param>
      <returns>
            A string containing the name of the service class whose UUID value is <paramref name="uuid" />,
            or a null reference (<c>Nothing</c> in Visual Basic) if no such constant is found.
            </returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothService.GetName(System.Int32)">
      <summary>
            Retrieves the name of the Service Class UUID that has the specified value. 
            </summary>
      <param name="uuid32">
            The service class UUID in the 32-bit short UUID form as a <see cref="T:System.Int32" />.
            </param>
      <returns>
            A string containing the name of the service class whose UUID value is <paramref name="uuid" />,
            or a null reference (<c>Nothing</c> in Visual Basic) if no such constant is found.
            </returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothService.GetName(System.UInt32)">
      <summary>
            Retrieves the name of the Service Class UUID that has the specified value. 
            </summary>
      <param name="uuid32">
            The service class UUID in the 32-bit UUID short form as a <see cref="T:System.UInt32" />.
            </param>
      <returns>
            A string containing the name of the service class whose UUID value is <paramref name="uuid" />,
            or a null reference (<c>Nothing</c> in Visual Basic) if no such constant is found.
            </returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothService.CreateBluetoothUuid(System.Int16)">
      <summary>
            Create a full 128-bit Service class UUID from its 16-bit short form.
            </summary>
      <param name="uuid16">
            The service class UUID in the 16-bit UUID short form as a <see cref="T:System.Int16" />.
            </param>
      <returns>
            A <see cref="T:System.Guid" /> containing the full 128-bit form of the
            supplied Bluetooth service class UUID.
            </returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothService.CreateBluetoothUuid(System.UInt16)">
      <summary>
            Create a full 128-bit Service class UUID from its 16-bit short form.
            </summary>
      <param name="uuid16">
            The service class UUID in the 16-bit UUID short form as a <see cref="T:System.UInt16" />.
            </param>
      <returns>
            A <see cref="T:System.Guid" /> containing the full 128-bit form of the
            supplied Bluetooth service class UUID.
            </returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothService.CreateBluetoothUuid(System.Int32)">
      <summary>
            Create a full 128-bit Service class UUID from its 16-bit short form.
            </summary>
      <param name="uuid32">
            The service class UUID in the 32-bit UUID short form as a <see cref="T:System.Int32" />.
            </param>
      <returns>
            A <see cref="T:System.Guid" /> containing the full 128-bit form of the
            supplied Bluetooth service class UUID.
            </returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothService.CreateBluetoothUuid(System.UInt32)">
      <summary>
            Create a full 128-bit Service class UUID from its 16-bit short form.
            </summary>
      <param name="uuid32">
            The service class UUID in the 32-bit UUID short form as a <see cref="T:System.UInt32" />.
            </param>
      <returns>
            A <see cref="T:System.Guid" /> containing the full 128-bit form of the
            supplied Bluetooth service class UUID.
            </returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Widcomm.WidcommBtInterface.DeleteKnownDevice(InTheHand.Net.BluetoothAddress)">
      <summary>
            Remove the device by deleting it from the Registry.
            </summary>
      <param name="device">The device address.</param>
      <returns>Whether the device is deleted -- it is no longer a remembered device.
            </returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Widcomm.WidcommBtInterface.GetExtendedError">
      <summary>
            Call CBtIf::GetExtendedError.
            </summary>
            -
            <remarks><para>Is not currently used anywhere...
            </para><para>Not supported on Widcomm WCE WM/WinCE, we (natively) return -1.
            </para></remarks>
            -
            <returns>A <see cref="T:InTheHand.Net.Bluetooth.Widcomm.WBtRc" /> value.</returns></member>
    <member name="M:InTheHand.Net.Bluetooth.Widcomm.WidcommBtInterface.IsRemoteDevicePresent(System.Byte[])">
      <summary>
            CBtIf::IsRemoteDevicePresent
            </summary>
            -
            <remarks><note>"added BTW and SDK 5.0.1.1000"</note><note>"added BTW-CE and SDK 1.7.1.2700"</note></remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.Widcomm.WidcommBtInterface.IsRemoteDeviceConnected(System.Byte[])">
      <summary>
            CBtIf::IsRemoteDeviceConnected
            </summary>
            -
            <remarks><note>"added BTW 5.0.1.300, SDK 5.0"</note><note>"added BTW-CE and SDK 1.7.1.2700"</note></remarks></member>
    <member name="T:InTheHand.Net.Bluetooth.Msft.BTHNS_RESULT">
      <summary>
            Bluetooth specific flags returned from WSALookupServiceNext 
            in WSAQUERYSET.dwOutputFlags in response to device inquiry.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BlueSoleil.StackConsts.AttributeLookup">
      <summary>
            "Possible flags for member 'mask' in _BtSdkRemoteServiceAttrStru"
            </summary>
    </member>
    <member name="T:InTheHand.Net.IrDAEndPoint">
      <summary>
            Represents an end point for an infrared connection.
            </summary>
      <seealso cref="T:System.Net.IrDAEndPoint" />
    </member>
    <member name="M:InTheHand.Net.IrDAEndPoint.#ctor(System.Byte[],System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.IrDAEndPoint" /> class.
            </summary>
      <param name="irdaDeviceID">The device identifier.</param>
      <param name="serviceName">The Service Name to connect to/listen on eg "<c>OBEX</c>".
            In the very uncommon case where a connection is to be made to
            / a server is to listen on 
            a specific LSAP-SEL (port number), then use 
            the form "<c>LSAP-SELn</c>", where n is an integer.
            </param>
    </member>
    <member name="M:InTheHand.Net.IrDAEndPoint.#ctor(InTheHand.Net.IrDAAddress,System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.IrDAEndPoint" /> class.
            </summary>
      <param name="irdaDeviceAddress">The device address.</param>
      <param name="serviceName">The Service Name to connect to/listen on eg "<c>OBEX</c>".
            In the very uncommon case where a connection is to be made to
            / a server is to listen on 
            a specific LSAP-SEL (port number), then use 
            the form "<c>LSAP-SELn</c>", where n is an integer.
            </param>
    </member>
    <member name="M:InTheHand.Net.IrDAEndPoint.Serialize">
      <inheritdoc />
    </member>
    <member name="M:InTheHand.Net.IrDAEndPoint.Create(System.Net.SocketAddress)">
      <inheritdoc />
    </member>
    <member name="M:InTheHand.Net.IrDAEndPoint.Equals(System.Object)">
      <summary>
            Compares two <see cref="T:InTheHand.Net.IrDAEndPoint" /> instances for equality.
            </summary>
            -
            <param name="obj">The <see cref="T:InTheHand.Net.BluetoothEndPoint" />
            to compare with the current instance.
            </param>
            -
            <returns><c>true</c> if <paramref name="obj" />
            is a <see cref="T:InTheHand.Net.IrDAEndPoint" /> and equal to the current instance;
            otherwise, <c>false</c>.
            </returns></member>
    <member name="M:InTheHand.Net.IrDAEndPoint.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
      <returns>A hash code for the current object.</returns>
    </member>
    <member name="M:InTheHand.Net.IrDAEndPoint.ToString">
      <summary>
            Returns the string representation of the IrDAEndPoint.
            </summary>
      <remarks>
        <para>
            The string is in format <c>&lt;DeviceAddress&gt;:&lt;ServiceName&gt;</c></para>
            An example is:
            <code lang="none">"04E20304:OBEX"</code></remarks>
      <returns>The string representation of the IrDAEndPoint.</returns>
    </member>
    <member name="P:InTheHand.Net.IrDAEndPoint.Address">
      <summary>
            Gets or sets an address for the device.
            </summary>
    </member>
    <member name="P:InTheHand.Net.IrDAEndPoint.DeviceID">
      <summary>
            Gets or sets an identifier for the device.
            </summary>
      <exception cref="T:System.ArgumentNullException">
            The specified byte array is null (<c>Nothing</c> in Visual Basic).
            </exception>
      <exception cref="T:System.ArgumentOutOfRangeException">
            The specified byte array is not four bytes long.
            </exception>
    </member>
    <member name="P:InTheHand.Net.IrDAEndPoint.ServiceName">
      <summary>
            Gets or sets the name of the service.
            </summary>
    </member>
    <member name="P:InTheHand.Net.IrDAEndPoint.AddressFamily">
      <summary>
            Gets the address family to which the endpoint belongs.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.LinkPolicy">
      <summary>
            Flags to describe Link Policy.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LinkPolicy.Disabled">
      <summary>
            Disables all LAN Manager (LM) modes. 
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LinkPolicy.MasterSlave">
      <summary>
            Enables the master slave switch.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LinkPolicy.Hold">
      <summary>
            Enables Hold mode.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LinkPolicy.Sniff">
      <summary>
            Enables Sniff Mode.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LinkPolicy.Park">
      <summary>
            Enables Park Mode.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BluetoothWin32Authentication">
      <summary>
             Provides Bluetooth authentication services on desktop Windows.
             </summary>
             -
             <remarks><note>This class is supported on desktop Windows and with the Microsoft
             stack only.
             </note><para>This class can be used in one of two ways.  Firstly
             an instance can be created specifying one device that is being connected
             to and the PIN string to use for it.  (That form is used internally by
             <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> to support
             its <see cref="M:InTheHand.Net.Sockets.BluetoothClient.SetPin(System.String)" /> method).
             </para><para>Secondly it can also be used a mode where a user supplied
             callback will be called when any device requires authentication,
             the callback includes a parameter of type 
             <see cref="T:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs" />.
             Various authentication methods are available in Bluetooth version
             2.1 and later.  Which one is being used is indicated by the
             <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.AuthenticationMethod" />
             property.
             If it is <see cref="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationMethod.Legacy" />
             then the callback method should set the
             <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.Pin" />
             property.
             </para><para>
             For the other authentication methods 
             e.g. <see cref="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationMethod.NumericComparison" />
             or <see cref="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationMethod.OutOfBand" />
             the callback method should use one or more of the other properties and
             methods e.g.
             <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.NumberOrPasskey" />,
             <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.Confirm" />,
             <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.ResponseNumberOrPasskey" />,
             <see cref="M:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.ConfirmOob(System.Byte[],System.Byte[])" />
             etc.
             </para><para>
             See the example below for a 'Legacy' method handler.
             The callback mode can be configured to do a callback after the 
             send PIN action, this allows one to see if it was successful 
             etc.  An example sequence where the PIN was <strong>incorrect</strong> is as follows.
             </para><code lang="none">
            Authenticate one device -- with wrong passcode here the first two times.
            Passcode respectively: 'BAD-x', 'BAD-y', '9876'
            Making PC discoverable
            Hit Return to complete
            Authenticating 0017E464CF1E wm_alan1
              Attempt# 0, Last error code 0
              Sending "BAD-x"
            Authenticating 0017E464CF1E wm_alan1
              Attempt# 1, Last error code 1244
              Sending "BAD-y"
            Authenticating 0017E464CF1E wm_alan1
              Attempt# 2, Last error code 1167
              Sending "9876"
            Authenticating 0017E464CF1E wm_alan1
              Attempt# 3, Last error code 1167
            etc
            </code><para>
             That is we see the error code of <c>1244=NativeErrorNotAuthenticated</c>
             once, and then the peer device disappears (<c>1167=NativeErrorDeviceNotConnected</c>).
             I suppose that's a security feature -- its stops an attacker
             from trying again and again with different passcodes.
            
             Anyway the result of that is that is it <strong>not</strong> worth repeating 
             the callback after the device disappears.  The code now enforces this.  With 
             <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.CallbackWithResult" /> 
             set to <c>true</c>, if the result of the previous attempt was success 
             or device not connected then any new PIN set in the callback 
             wont be used and thus the callback wont be called again 
             for that authentication attempt.
             </para><para>A successful authentication process can thus be detected by checking if
             <code>e.PreviousNativeErrorCode == NativeErrorSuccess &amp;&amp; e.AttemptNumber != 0</code></para><para></para><para>The instance will continue receiving authentication requests
             until it is disposed or garbage collected, so keep a reference to it
             whilst it should be active and call 
             <see cref="M:InTheHand.Net.Bluetooth.BluetoothWin32Authentication.Dispose" />
             when youre finished.
             </para></remarks>
             -
             <example>
             If one wants to respond to PIN requests for one device with a known PIN then
             use the simple form which is initialized with an address and PIN.
             <code lang="C#">
             BluetoothWin32Authentication authenticator
                 = new BluetoothWin32Authentication(remoteEP.Address, m_pin);
             // when the peer is expected to require pairing, perhaps do some work.
             authenticator.Dispose();
             </code>
             
             If one wants to see the PIN request, perhaps to be able to check the type
             of the peer by its address then use the form here which requests callbacks.
             (Note that this code assumes that 'Legacy' PIN-based pairing is being
             used; setting the Pin property will presumably have no effect if the
             authentication method being used is one of the v2.1 SSP forms).
             <code lang="VB.NET">
             Using pairer As New BluetoothWin32Authentication(AddressOf Win32AuthCallbackHandler)
                 Console.WriteLine("Hit Return to stop authenticating")
                 Console.ReadLine()
             End Using
             ...
             
             Sub Win32AuthCallbackHandler(ByVal sender As Object, ByVal e As InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs)
                ' Note we assume here that 'Legacy' pairing is being used,
                ' and thus we only set the Pin property!
                Dim address As String = e.Device.DeviceAddress.ToString()
                Console.WriteLine("Received an authentication request from address " + address)
                
                ' compare the first 8 hex numbers, this is just a special case because in the
                ' used scenario the model of the devices can be identified by the first 8 hex
                ' numbers, the last 4 numbers being the device specific part.
                If address.Substring(0, 8).Equals("0099880D") OrElse _
                        address.Substring(0, 8).Equals("0099880E") Then
                    ' send authentication response
                    e.Pin = "5276"
                ElseIf (address.Substring(0, 8).Equals("00997788")) Then
                    ' send authentication response
                    e.Pin = "sdfghjkl"
                End If
             End Sub
             </code></example></member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothWin32Authentication.NativeErrorSuccess">
      <summary>
            Windows ERROR_SUCCESS
            </summary>
      <remarks>
        <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.PreviousNativeErrorCode" />
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothWin32Authentication.NativeErrorNotAuthenticated">
      <summary>
            Windows ERROR_NOT_AUTHENTICATED
            </summary>
      <remarks>
        <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.PreviousNativeErrorCode" />
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothWin32Authentication.NativeErrorDeviceNotConnected">
      <summary>
            Windows ERROR_DEVICE_NOT_CONNECTED
            </summary>
      <remarks>
        <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.PreviousNativeErrorCode" />
      </remarks>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothWin32Authentication.#ctor(InTheHand.Net.BluetoothAddress,System.String)">
      <overloads>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.BluetoothWin32Authentication" /> class.
            </overloads>
            -
            <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.BluetoothWin32Authentication" /> class,
            to respond to a specific address with a specific PIN string.
            </summary>
            -
            <remarks><para>The instance will continue receiving authentication requests
            until it is disposed or garbage collected, so keep a reference to it
            whilst it should be active, and call 
            <see cref="M:InTheHand.Net.Bluetooth.BluetoothWin32Authentication.Dispose" />
            when youre finished.
            </para></remarks>
            -
            <param name="remoteAddress">The address of the device to authenticate,
            as a <see cref="T:InTheHand.Net.BluetoothAddress" />.
            </param><param name="pin">The PIN string to use for authentication, as a
            <see cref="T:System.String" />.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothWin32Authentication.#ctor(System.EventHandler{InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs})">
      <summary>
             Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.BluetoothWin32Authentication" /> class,
             to call a specified handler when any device requires authentication.
             </summary>
             -
             <remarks><para>See the example below.
             </para><para>The callback mode can be configured to do a callback after the 
             send PINaction, this allows one to see if it was successful 
             etc.  An example sequence where the PIN was <strong>incorrect</strong> is as follows.
             </para><code lang="none">
            Authenticate one device -- with wrong passcode here the first two times.
            Passcode respectively: 'BAD-x', 'BAD-y', '9876'
            Making PC discoverable
            Hit Return to complete
            Authenticating 0017E464CF1E wm_alan1
              Attempt# 0, Last error code 0
              Sending "BAD-x"
            Authenticating 0017E464CF1E wm_alan1
              Attempt# 1, Last error code 1244
              Sending "BAD-y"
            Authenticating 0017E464CF1E wm_alan1
              Attempt# 2, Last error code 1167
              Sending "9876"
            Authenticating 0017E464CF1E wm_alan1
              Attempt# 3, Last error code 1167
            etc
            </code><para>
             That is we see the error code of <c>1244=NativeErrorNotAuthenticated</c>
             once, and then the peer device disappears (<c>1167=NativeErrorDeviceNotConnected</c>).
             I suppose that's a security feature -- its stops an attacker
             from trying again and again with different passcodes.
            
             Anyway the result of that is that is it <strong>not</strong> worth repeating 
             the callback after the device disappears.  The code now enforces this.  With 
             <see cref="P:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs.CallbackWithResult" /> 
             set to <c>true</c>, if the result of the previous attempt was success 
             or device not connected then any new PIN set in the callback 
             wont be used and thus the callback wont be called again 
             for that authentication attempt.
             </para><para>A successful authentication process can thus be detected by setting
             <c>CallbackWithResult=true</c> and checking in the callback if
             <code>  e.PreviousNativeErrorCode == NativeErrorSuccess &amp;&amp; e.AttemptNumber != 0</code></para><para></para><para>The instance will continue receiving authentication requests
             until it is disposed or garbage collected, so keep a reference to it
             whilst it should be active, and call 
             <see cref="M:InTheHand.Net.Bluetooth.BluetoothWin32Authentication.Dispose" />
             when youre finished.
             </para></remarks>
             -
             <param name="handler">A reference to a handler function that can respond
             to authentication requests.
             </param>
             -
             <example><code lang="VB.NET">
             Using pairer As New BluetoothWin32Authentication(AddressOf Win32AuthCallbackHandler)
                 Console.WriteLine("Hit Return to stop authenticating")
                 Console.ReadLine()
             End Using
             ...
             
             Sub Win32AuthCallbackHandler(ByVal sender As Object, ByVal e As InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs)
                Dim address As String = e.Device.DeviceAddress.ToString()
                Console.WriteLine("Received an authentication request from address " + address)
                
                ' compare the first 8 hex numbers, this is just a special case because in the
                ' used scenario the model of the devices can be identified by the first 8 hex
                ' numbers, the last 4 numbers being the device specific part.
                If address.Substring(0, 8).Equals("0099880D") OrElse _
                        address.Substring(0, 8).Equals("0099880E") Then
                    ' send authentication response
                    e.Pin = "5276"
                ElseIf (address.Substring(0, 8).Equals("00997788")) Then
                    ' send authentication response
                    e.Pin = "sdfghjkl"
                End If
             End Sub
             </code></example></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothWin32Authentication.OnAuthentication(InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs)">
      <summary>
            Calls the authentication callback handler.
            </summary>
            -
            <param name="e">An instance of <see cref="T:InTheHand.Net.Bluetooth.BluetoothWin32AuthenticationEventArgs" /> 
            containing the details of the authentication callback.
            </param></member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothWin32Authentication.Dispose">
      <summary>
            Release the unmanaged resources used by the <see cref="T:InTheHand.Net.Bluetooth.BluetoothWin32Authentication" />.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BluetoothWin32Authentication.Dispose(System.Boolean)">
      <summary>
            Release the unmanaged resources used by the <see cref="T:InTheHand.Net.Bluetooth.BluetoothWin32Authentication" />,
            and optionally disposes of the managed resources.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BluetoothAuthenticationMethod">
      <summary>
            The BluetoothAuthenticationMethod enumeration defines the supported
            authentication types during device pairing.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationMethod.Legacy">
      <summary>
            The Bluetooth device supports authentication via a PIN.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationMethod.OutOfBand">
      <summary>
            The Bluetooth device supports authentication via out-of-band data.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationMethod.NumericComparison">
      <summary>
            The Bluetooth device supports authentication via numeric comparison.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationMethod.PasskeyNotification">
      <summary>
            The Bluetooth device supports authentication via passkey notification.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.BluetoothAuthenticationMethod.Passkey">
      <summary>
            The Bluetooth device supports authentication via passkey.
            </summary>
    </member>
    <member name="T:InTheHand.Net.ObexMethod">
      <summary>
            Methods which can be carried out in an Object Exchange transaction.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexMethod.Put">
      <summary>
            Sends an object to a receiving device.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexMethod.Get">
      <summary>
            Requests a file from the remote device.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexMethod.Connect">
      <summary>
            Negotiate an Object Exchange connection with a remote device.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexMethod.Disconnect">
      <summary>
            Disconnect an existing Object Exchange session.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexMethod.PutFinal">
      <summary>
            Sends the last packet of an object to a receiving device.
            </summary>
    </member>
    <member name="F:InTheHand.Net.ObexMethod.SetPath">
      <summary>
            Change remote path on an Object Exchange server.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Sockets.L2CapClient">
      <summary>
            Provides client connections to a remote Bluetooth L2CAP service.
            </summary>
            -
            <remarks><para>For RFCOMM connections use <see cref="T:InTheHand.Net.Sockets.BluetoothClient" />.
            </para><para>The normal usage is o create an instance, connect with 
            <see cref="M:InTheHand.Net.Sockets.L2CapClient.Connect(InTheHand.Net.BluetoothEndPoint)" />
            or <see cref="M:InTheHand.Net.Sockets.L2CapClient.BeginConnect(InTheHand.Net.BluetoothEndPoint,System.AsyncCallback,System.Object)" />,
            and if successful one then calls <see cref="M:InTheHand.Net.Sockets.L2CapClient.GetStream" />
            to send and receive data.
            </para><para>See the <see cref="M:InTheHand.Net.Sockets.L2CapClient.Connect(InTheHand.Net.BluetoothEndPoint)" />
            method for more information
            on specifying the remote service to connect to.
            </para></remarks></member>
    <member name="M:InTheHand.Net.Sockets.L2CapClient.#ctor">
      <summary>
            Creates a new instance of <see cref="T:InTheHand.Net.Sockets.L2CapClient" />.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Sockets.L2CapClient.Close">
      <summary>
            Closes the <see cref="T:InTheHand.Net.Sockets.L2CapClient" /> and the underlying connection.
            </summary>
            -
            <seealso cref="M:InTheHand.Net.Sockets.L2CapClient.Dispose" /></member>
    <member name="M:InTheHand.Net.Sockets.L2CapClient.Dispose">
      <summary>
            Closes the <see cref="T:InTheHand.Net.Sockets.L2CapClient" /> and the underlying connection.
            </summary>
            -
            <seealso cref="M:InTheHand.Net.Sockets.L2CapClient.Close" /></member>
    <member name="M:InTheHand.Net.Sockets.L2CapClient.Connect(InTheHand.Net.BluetoothEndPoint)">
      <summary>
            Connects to a remote Bluetooth L2CAP service
            using the specified remote endpoint.
            </summary>
            -
            <remarks><para>The <see cref="T:InTheHand.Net.BluetoothEndPoint" /> must
            have the <see cref="P:InTheHand.Net.BluetoothEndPoint.Address" />
            set, and either the <see cref="P:InTheHand.Net.BluetoothEndPoint.Service" />
            or <see cref="P:InTheHand.Net.BluetoothEndPoint.Port" /> properties
            set.
            The port is the L2CAP PSM number, and if set a connection will be
            made to that PSM and the Service Class Id ignored.
            Note that only certain PSM values are valid.  See 
            <see cref="T:InTheHand.Net.Sockets.L2CapListener" /> for more
            information.
            </para></remarks>
            -
            <param name="remoteEP">The <see cref="T:InTheHand.Net.BluetoothEndPoint" />
            to which you intend to connect. See the remarks for usage.
            </param></member>
    <member name="M:InTheHand.Net.Sockets.L2CapClient.BeginConnect(InTheHand.Net.BluetoothEndPoint,System.AsyncCallback,System.Object)">
      <summary>
            Begins an asynchronous request for a remote host connection.
            </summary>
            -
            <remarks><para>See 
            <see cref="M:InTheHand.Net.Sockets.L2CapClient.Connect(InTheHand.Net.BluetoothEndPoint)" />
            for more information.
            </para></remarks>
            -
            <param name="remoteEP">The <see cref="T:InTheHand.Net.BluetoothEndPoint" />
            to which you intend to connect.
            See 
            or <see cref="M:InTheHand.Net.Sockets.L2CapClient.Connect(InTheHand.Net.BluetoothEndPoint)" />,
            for more information.
            </param><param name="requestCallback">An <see cref="T:System.AsyncCallback" />
            delegate that references the method to invoke when the operation is
            complete.
            </param><param name="state">A user-defined object that contains information
            about the connect operation. This object is passed to the
            <paramref name="requestCallback" /> delegate when the operation is
            complete.
            </param>
            -
            <returns>An <see cref="T:System.IAsyncResult" /> object that
            references the asynchronous connection,
            which may still be pending.
            </returns></member>
    <member name="M:InTheHand.Net.Sockets.L2CapClient.EndConnect(System.IAsyncResult)">
      <summary>
            Asynchronously accepts an incoming connection attempt.
            </summary>
            -
            <param name="asyncResult">An <see cref="T:System.IAsyncResult" />
            object returned by a call to 
            or <see cref="M:InTheHand.Net.Sockets.L2CapClient.BeginConnect(InTheHand.Net.BluetoothEndPoint,System.AsyncCallback,System.Object)" />,
            </param></member>
    <member name="M:InTheHand.Net.Sockets.L2CapClient.GetStream">
      <summary>
            Returns the <see cref="T:System.IO.Stream" /> used to send and
            receive data.
            </summary>
            -
            <remarks><para>Note it is NOT a <see cref="T:System.Net.Sockets.NetworkStream" />.
            That type handles SOCK_STREAM connections, whereas L2CAP uses
            SOCK_SEQPACKET.
            Different Stream subclasses may be returned by different platforms.
            </para></remarks>
            -
            <returns>The <see cref="T:System.IO.Stream" /> used to send and
            receive data.
            </returns></member>
    <member name="M:InTheHand.Net.Sockets.L2CapClient.GetMtu">
      <summary>
            Get the MTU................
            </summary>
      <returns>int</returns>
    </member>
    <member name="P:InTheHand.Net.Sockets.L2CapClient.RemoteEndPoint">
      <summary>
            Get the remote endpoint.
            </summary>
            -
            <value>
            The <see cref="T:InTheHand.Net.BluetoothEndPoint" /> with which the 
            <see cref="T:InTheHand.Net.Sockets.L2CapClient" /> is communicating.
            </value></member>
    <member name="M:InTheHand.Net.Bluetooth.BlueSoleil.NativeMethods.Btsdk_UpdateRemoteDeviceName(System.UInt32,System.Byte[],System.UInt16@)">
      <summary>
            Gets the current user-friendly name of the specified remote device.
            </summary>
            -
            <remarks>
            Before calling Btsdk_UpdateRemoteDeviceName, the device database must be initialized by a
            previous successful call to Btsdk_StartBluetooth.
            The user-friendly device name is a UTF-8 character string. The device name acquired by this
            command is stored automatically in the device database.
            </remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.BlueSoleil.NativeMethods.Btsdk_GetRemoteLinkQuality(System.UInt32,System.UInt16@)">
      <summary>
            "gets the current link quality value of the connection between local
            device and the specified remote device."
            </summary>
            -
            <remarks>"The higher the value, the better the link quality is."
            </remarks>
            -
            <returns>"Range: 0 to 0xFF."
            </returns></member>
    <member name="M:InTheHand.Net.Bluetooth.BlueSoleil.NativeMethods.Btsdk_GetRemoteDeviceName(System.UInt32,System.Byte[],System.UInt16@)">
      <summary>
            "Gets the user-friendly name of the specified remote device from the device database."
            </summary>
            -
            <remarks>
            "Before calling Btsdk_GetRemoteDeviceName, the device database must be initialized by a
            previous successful call to Btsdk_Init.
            The user-friendly device name is a UTF-8 character string. The Btsdk_GetRemoteDeviceNamefunction returns =BTSDK_OPERATION_FAILURE immediately if the device name doesnt
            exist in the database. In this case, the application shall call Btsdk_UpdateRemoteDeviceName
            to acquire the name information directly from the remote device.
            BlueSoleil will automatically update the device name when the local device connects to the
            specified remote device.
            </remarks></member>
    <member name="T:InTheHand.Net.ObexListenerRequest">
      <summary>
            Describes an incoming OBEX request to an <see cref="T:InTheHand.Net.ObexListener" /> object.
            </summary>
    </member>
    <member name="M:InTheHand.Net.ObexListenerRequest.WriteFile(System.String)">
      <summary>
            Writes the body of the request to the specified file path.
            </summary>
      <param name="fileName">The filename (including the path) to write to.</param>
    </member>
    <member name="P:InTheHand.Net.ObexListenerRequest.ContentLength64">
      <summary>
            Gets the length of the body data included in the request.
            <para><b>New in v1.5.51015</b></para></summary>
      <value>A long value that contains the value from the request's Length header.
            This value is -1 if the content length is not known.</value>
      <remarks>The Length header expresses the length, in bytes, of the body data that accompanies the request.</remarks>
    </member>
    <member name="P:InTheHand.Net.ObexListenerRequest.ContentType">
      <summary>
            Gets the MIME type of the body data included in the request.
            </summary>
      <value>A <see cref="T:System.String" /> that contains the text of the request's Type header.</value>
    </member>
    <member name="P:InTheHand.Net.ObexListenerRequest.Headers">
      <summary>
            Gets the collection of header name/value pairs sent in the request.
            </summary>
      <value>A <see cref="T:System.Net.WebHeaderCollection" /> that contains the OBEX headers included in the request.</value>
      <remarks>For a complete list of request headers, see the <see cref="T:InTheHand.Net.ObexHeader" /> enumeration.</remarks>
    </member>
    <member name="P:InTheHand.Net.ObexListenerRequest.LocalEndPoint">
      <summary>
            Get the device address and service to which the request is directed.
            </summary>
            -
            <remarks>
            The <see cref="T:System.Net.EndPoint" /> instance returned will be of the 
            subtype that matches the address family that the <see cref="T:InTheHand.Net.ObexListener" /> 
            is listening on.  For instance if the listener was created with 
            <see cref="T:InTheHand.Net.ObexTransport" />.<see cref="F:InTheHand.Net.ObexTransport.Bluetooth" />
            then the <see cref="T:System.Net.EndPoint" /> will be of type
            <see cref="T:InTheHand.Net.BluetoothEndPoint" />, and similarly for 
            <see cref="T:InTheHand.Net.IrDAEndPoint" /> and
            <see cref="T:System.Net.IPEndPoint" />.
            </remarks>
            -
            <seealso cref="P:InTheHand.Net.ObexListenerRequest.RemoteEndPoint" /></member>
    <member name="P:InTheHand.Net.ObexListenerRequest.ObexMethod">
      <summary>
            Gets the method specified by the client.
            </summary>
      <remarks>Only PUT is supported in this version.</remarks>
    </member>
    <member name="P:InTheHand.Net.ObexListenerRequest.InputStream">
      <summary>
            Gets a stream that contains the body data sent by the client.
            </summary>
    </member>
    <member name="P:InTheHand.Net.ObexListenerRequest.ProtocolVersion">
      <summary>
            Gets the OBEX version used by the requesting client
            </summary>
    </member>
    <member name="P:InTheHand.Net.ObexListenerRequest.RawUrl">
      <summary>
            Gets the URL information (without the host and port) requested by the client.
            </summary>
      <value>A <see cref="T:System.String" /> that contains the raw URL for this request.</value>
    </member>
    <member name="P:InTheHand.Net.ObexListenerRequest.RemoteEndPoint">
      <summary>
            Gets the device address and service from which the request originated.
            </summary>
            -
            <remarks>
            The <see cref="T:System.Net.EndPoint" /> instance returned will be of the 
            subtype that matches the address family that the <see cref="T:InTheHand.Net.ObexListener" /> 
            is listening on.  For instance if the listener was created with 
            <see cref="T:InTheHand.Net.ObexTransport" />.<see cref="F:InTheHand.Net.ObexTransport.Bluetooth" />
            then the <see cref="T:System.Net.EndPoint" /> will be of type
            <see cref="T:InTheHand.Net.BluetoothEndPoint" />, and similarly for 
            <see cref="T:InTheHand.Net.IrDAEndPoint" /> and
            <see cref="T:System.Net.IPEndPoint" />.
            </remarks>
            -
            <example>
            C#
            <code lang="C#">
              ObexListener lsnr = new ObexListener(ObexTransport.Bluetooth)
              ... ...
              ObexListenerRequest olr = ...
              BluetoothEndPoint remoteEp = (BluetoothEndPoint)olr.RemoteEndPoint;
              BluetoothAddress remoteAddr = remoteEp.Address;
            </code>
            Visual Basic
            <code lang="VB.NET">
              Dim lsnr As New ObexListener(ObexTransport.IrDA)
              ... ...
              Dim olr As ObexListenerRequest = ...
              Dim remoteEp As IrDAEndPoint = CType(olr.RemoteEndPoint, IrDAEndPoint);
              Dim remoteAddr As IrDAAddress = remoteEp.Address;
            </code></example>
            -
            <seealso cref="P:InTheHand.Net.ObexListenerRequest.LocalEndPoint" /></member>
    <member name="P:InTheHand.Net.ObexListenerRequest.UserHostAddress">
      <summary>
            Gets the server address to which the request is directed.
            </summary>
    </member>
    <member name="P:InTheHand.Net.ObexListenerRequest.Url">
      <summary>
            Gets the <see cref="T:System.Uri" /> object requested by the client.
            </summary>
      <value>A <see cref="T:System.Uri" /> object that identifies the resource requested by the client.</value>
    </member>
    <member name="T:InTheHand.Net.AsyncResultCompletion">
      <summary>
            Used with
            <see cref="M:InTheHand.Net.AsyncResultNoResult.SetAsCompleted(System.Exception,InTheHand.Net.AsyncResultCompletion)">
            AsyncResultNoResult.SetAsCompleted</see> and 
            <see cref="M:InTheHand.Net.AsyncResult{TResult}.SetAsCompleted(TResult,AsyncResultNoResult.AsyncResultCompletion)">
            AsyncResult&lt;TResult&gt;.SetAsCompleted</see>.
            </summary>
    </member>
    <member name="F:InTheHand.Net.AsyncResultCompletion.IsSync">
      <summary>
            Equivalent to <c>true</c> for the <see cref="T:System.Boolean" />
            #x201C;completedSynchronously parameter.
            </summary>
    </member>
    <member name="F:InTheHand.Net.AsyncResultCompletion.IsAsync">
      <summary>
            Equivalent to <c>false</c> for the <see cref="T:System.Boolean" />
            #x201C;completedSynchronously parameter.
            </summary>
    </member>
    <member name="F:InTheHand.Net.AsyncResultCompletion.MakeAsync">
      <summary>
            Forces the callback to run on a thread-pool thread.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Sockets.IrDACharacterSet">
      <summary>
            Describes the character sets supported by the device.
            </summary>
      <remarks>The <see cref="T:InTheHand.Net.Sockets.IrDACharacterSet" /> enumeration describes the following character sets, which are used by the <see cref="T:InTheHand.Net.Sockets.IrDAClient" /> and <see cref="T:InTheHand.Net.Sockets.IrDADeviceInfo" /> classes.</remarks>
      <seealso cref="T:InTheHand.Net.Sockets.IrDAClient" />
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDACharacterSet.ASCII">
      <summary>
            The ASCII character set.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDACharacterSet.ISO8859Latin1">
      <summary>
            The western European graphic character set.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDACharacterSet.ISO8859Latin2">
      <summary>
            The eastern European graphic character set.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDACharacterSet.ISO8859Latin3">
      <summary>
            The southern European graphic character set.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDACharacterSet.ISO8859Latin4">
      <summary>
            The northern European graphic character set.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDACharacterSet.ISO8859Cyrillic">
      <summary>
            The Cyrillic graphic character set.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDACharacterSet.ISO8859Arabic">
      <summary>
            The Arabic graphic character set.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDACharacterSet.ISO8859Greek">
      <summary>
            The Greek graphic character set.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDACharacterSet.ISO8859Hebrew">
      <summary>
            The Hebrew graphic character set.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDACharacterSet.ISO8859Latin5">
      <summary>
            The Turkish graphic character set.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDACharacterSet.Unicode">
      <summary>
            The Unicode character set.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.LmpFeatures">
      <summary>
            Created from v2.1 specification.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.None">
      <summary>
            There are no supported features.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.ThreeSlotPackets">
      <summary>
            [0]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.ParkState">
      <summary>
            [8]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.CvsdSynchronousData">
      <summary>
            [16]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.EnhancedDataRateAcl2MbpsMode">
      <summary>
            [25]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.EV4Packets">
      <summary>
            [32]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.EV5Packets">
      <summary>
            [33]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.AfhCapableSlave">
      <summary>
            [35]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.AfhClassificationSlave">
      <summary>
            [36]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.BrEdrNotSupported">
      <summary>
            [37] v4.0
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.LeSupported_Controller">
      <summary>
            [38] v4.0
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.ThreeSlotEnhancedDataRateAclPackets">
      <summary>
            [39]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.FiveSlotEnhancedDataRateAclPackets">
      <summary>
            [40]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.SniffSubrating">
      <summary>
            [41] v2.1
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.PauseEncryption">
      <summary>
            [42] v2.1
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.ExtendedInquiryResponse">
      <summary>
            [48] v2.1
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.SimultaneousLeAndBrEdrToSameDeviceCapable_Controller">
      <summary>
            [49]
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.SecureSimplePairing">
      <summary>
            [51] v2.1
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.EncapsulatedPdu">
      <summary>
            [52] v2.1
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.ErroneousDataReporting">
      <summary>
            [53] v2.1
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.NonFlushablePacketBoundaryFlag">
      <summary>
            [54] v2.1
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.LinkSupervisionTimeoutChangedEvent">
      <summary>
            [56] v2.1
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.InquiryTxPowerLevel">
      <summary>
            [57] v2.1
            (Changed name from 'InquiryResponseTxPowerLevel' in v2.1 
            to 'InquiryTxPowerLevel' in v3.0).
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.EnhancedPowerControl">
      <summary>
            [58] v3.0
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.LmpFeatures.ExtendedFeatures">
      <summary>
            [63] Present since v2.0 at least.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.HardwareStatus">
      <summary>
            Specifies the current status of the Bluetooth hardware.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.HardwareStatus.Unknown">
      <summary>
            Status cannot be determined.
            </summary>
            XXXX The stack is not present. CE5
        </member>
    <member name="F:InTheHand.Net.Bluetooth.HardwareStatus.NotPresent">
      <summary>
            Bluetooth radio not present.
            </summary>
            The adapter is not present. CE5
        </member>
    <member name="F:InTheHand.Net.Bluetooth.HardwareStatus.Initializing">
      <summary>
            Bluetooth radio is in the process of starting up.
            </summary>
            The adapter might be installed.
            The stack is currently on the way up. Call again later. CE5
        </member>
    <member name="F:InTheHand.Net.Bluetooth.HardwareStatus.Running">
      <summary>
            Bluetooth radio is active.
            </summary>
            The adapter is installed and the stack is running. CE5
        </member>
    <member name="F:InTheHand.Net.Bluetooth.HardwareStatus.Shutdown">
      <summary>
            Bluetooth radio is in the process of shutting down.
            </summary>
            The adapter is installed, but the stack is not running. CE5
        </member>
    <member name="F:InTheHand.Net.Bluetooth.HardwareStatus.Error">
      <summary>
            Bluetooth radio is in an error state.
            </summary>
            The adapter might be installed.
            The stack is on the way down. Call again later. CE5
        </member>
    <member name="T:InTheHand.Net.Bluetooth.Widcomm.SDK_RETURN_CODE">
      <summary>
            "Define common return code for new SDK functions that would normally return BOOL"
            </summary>
            -
            <remarks>"Added BTW and SDK 5.0.1.1100".
            </remarks></member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.SDK_RETURN_CODE.Success">
      <summary>
            "The call was successful"
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.SDK_RETURN_CODE.Fail">
      <summary>
            "Unspecified failure"
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.SDK_RETURN_CODE.NotSupported">
      <summary>
            "The API is not supported on the platform BTW stack version"
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.SDK_RETURN_CODE.Busy">
      <summary>
            "The API cannot complete at this time, but may be retried"
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.SDK_RETURN_CODE.InvalidParam">
      <summary>
            "One of the API parameters was invalid"
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.SDK_RETURN_CODE.ErrResources">
      <summary>
            "A necessary resource could not be obtained"
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.SDK_RETURN_CODE.Timeout">
      <summary>
            "The operation timed out before completion"
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BlueSoleil.Structs.BtSdkRemoteServiceAttrStru.#ctor(InTheHand.Net.Bluetooth.BlueSoleil.StackConsts.AttributeLookup,System.UInt16,System.Byte[],System.IntPtr)">
      <summary>
            for Test.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.BlueSoleil.Structs.BtSdkRmtSPPSvcExtAttrStru.#ctor(System.Byte)">
      <summary>
            for Test.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.BlueSoleil.BlueSoleilSocketException">
      <summary>
            SocketException holding a BlueSoleil error code from the original error,
            which is added to the exception message.
            </summary>
            -
            <remarks>
            Will always be internal so just catch SocketException as for the other stacks.
            </remarks></member>
    <member name="T:InTheHand.Net.IrDAAddress">
      <summary>
            Represents an IrDA device address.
            </summary>
    </member>
    <member name="F:InTheHand.Net.IrDAAddress.None">
      <summary>
            Provides a null IrDA address.
            </summary>
    </member>
    <member name="M:InTheHand.Net.IrDAAddress.#ctor(System.Byte[])">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.IrDAAddress" /> class with the specified address.
            </summary>
      <param name="address">Address as 4 byte array.</param>
      <exception cref="T:System.ArgumentNullException">
        <paramref name="address" /> was null.</exception>
      <exception cref="T:System.ArgumentException">
        <paramref name="address" /> was not a 4 byte array.</exception>
    </member>
    <member name="M:InTheHand.Net.IrDAAddress.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.IrDAAddress" /> class with the specified address.
            </summary>
      <param name="address">
        <see cref="T:System.Int32" /> representation of the address.</param>
    </member>
    <member name="M:InTheHand.Net.IrDAAddress.ToInt32">
      <summary>
            Returns the IrDA address as an integer.
            </summary>
            -
            <returns>An <see cref="T:System.Int64" />.</returns></member>
    <member name="M:InTheHand.Net.IrDAAddress.ToByteArray">
      <summary>
            Returns the internal byte array.
            </summary>
            -
            <returns>An array of <see cref="T:System.Byte" />.</returns></member>
    <member name="M:InTheHand.Net.IrDAAddress.TryParse(System.String,InTheHand.Net.IrDAAddress@)">
      <summary>
            Converts the string representation of an address to it's <see cref="T:InTheHand.Net.IrDAAddress" /> equivalent.
            A return value indicates whether the operation succeeded.
            </summary>
      <param name="s">A string containing an address to convert.</param>
      <param name="result">When this method returns, contains the <see cref="T:InTheHand.Net.IrDAAddress" /> equivalent to the address contained in s, if the conversion succeeded, or null (Nothing in Visual Basic) if the conversion failed.
            The conversion fails if the s parameter is null or is not of the correct format.</param>
      <returns>true if s is a valid IrDA address; otherwise, false.</returns>
    </member>
    <member name="M:InTheHand.Net.IrDAAddress.Parse(System.String)">
      <summary>
            Converts the string representation of an IrDA address to a new <see cref="T:InTheHand.Net.IrDAAddress" /> instance.
            </summary>
      <param name="irdaString">A string containing an address to convert.</param>
      <returns>New <see cref="T:InTheHand.Net.IrDAAddress" /> instance.</returns>
      <remarks>Address must be specified in hex format optionally separated by the colon or period character e.g. 00000000, 00:00:00:00 or 00.00.00.00.</remarks>
      <exception cref="T:System.ArgumentNullException">irdaString is null.</exception>
      <exception cref="T:System.FormatException">irdaString is not a valid IrDA address.</exception>
    </member>
    <member name="M:InTheHand.Net.IrDAAddress.ToString">
      <summary>
            Converts the address to its equivalent string representation.
            </summary>
      <returns>The string representation of this instance.</returns>
    </member>
    <member name="M:InTheHand.Net.IrDAAddress.ToString(System.String)">
      <summary>
            Returns a <see cref="T:System.String" /> representation of the value of this <see cref="T:InTheHand.Net.IrDAAddress" /> instance, according to the provided format specifier.
            </summary>
      <param name="format">A single format specifier that indicates how to format the value of this Guid. The format parameter can be "N", "C" or "P". If format is null or the empty string (""), "N" is used.</param>
      <returns>A <see cref="T:System.String" /> representation of the value of this <see cref="T:InTheHand.Net.BluetoothAddress" />.</returns>
      <remarks>
        <list type="table">
          <listheader>
            <term>Specifier</term>
            <term>Format of Return Value </term>
          </listheader>
          <item>
            <term>N</term>
            <term>8 digits: <para>XXXXXXXX</para></term>
          </item>
          <item>
            <term>C</term>
            <term>8 digits separated by colons: <para>XX:XX:XX:XX</para></term>
          </item>
          <item>
            <term>P</term>
            <term>8 digits separated by periods: <para>XX.XX.XX.XX</para></term>
          </item>
        </list>
      </remarks>
    </member>
    <member name="M:InTheHand.Net.IrDAAddress.Equals(System.Object)">
      <summary>
            Compares two <see cref="T:InTheHand.Net.IrDAAddress" /> instances for equality.
            </summary>
            -
            <param name="obj">The <see cref="T:InTheHand.Net.IrDAAddress" />
            to compare with the current instance.
            </param>
            -
            <returns><c>true</c> if <paramref name="obj" />
            is a <see cref="T:InTheHand.Net.IrDAAddress" /> and equal to the current instance;
            otherwise, <c>false</c>.
            </returns></member>
    <member name="M:InTheHand.Net.IrDAAddress.GetHashCode">
      <summary>
            Returns the hash code for this instance.
            </summary>
      <returns>A hash code for the current object.</returns>
    </member>
    <member name="M:InTheHand.Net.IrDAAddress.op_Equality(InTheHand.Net.IrDAAddress,InTheHand.Net.IrDAAddress)">
      <summary>
            Returns an indication whether the values of two specified <see cref="T:InTheHand.Net.IrDAAddress" /> objects are equal.
            </summary>
            -
            <param name="x">A <see cref="T:InTheHand.Net.IrDAAddress" /> or <see langword="null" />.</param><param name="y">A <see cref="T:InTheHand.Net.IrDAAddress" /> or <see langword="null" />.</param>
            -
            <returns><c>true</c> if the values of the two instance are equal;
            otherwise, <c>false</c>.
            </returns></member>
    <member name="M:InTheHand.Net.IrDAAddress.op_Inequality(InTheHand.Net.IrDAAddress,InTheHand.Net.IrDAAddress)">
      <summary>
            Returns an indication whether the values of two specified <see cref="T:InTheHand.Net.IrDAAddress" /> objects are not equal.
            </summary>
            -
            <param name="x">A <see cref="T:InTheHand.Net.IrDAAddress" /> or <see langword="null" />.</param><param name="y">A <see cref="T:InTheHand.Net.IrDAAddress" /> or <see langword="null" />.</param>
            -
            <returns><c>true</c> if the value of the two instance is different;
            otherwise, <c>false</c>.
            </returns></member>
    <member name="M:InTheHand.Net.IrDAAddress.ToString(System.String,System.IFormatProvider)">
      <summary>
            Returns a <see cref="T:System.String" /> representation of the value of this <see cref="T:InTheHand.Net.IrDAAddress" /> instance, according to the provided format specifier.
            </summary>
      <param name="format">A single format specifier that indicates how to format the value of this Guid. The format parameter can be "N", "C" or "P". If format is null or the empty string (""), "N" is used.</param>
      <param name="formatProvider">Ignored.</param>
            -
            <returns>A <see cref="T:System.String" /> representation of the value of this <see cref="T:InTheHand.Net.IrDAAddress" />.</returns>
            -
            <remarks>See <see cref="M:InTheHand.Net.IrDAAddress.ToString(System.String)" />
            for the possible format strings and their output.
            </remarks></member>
    <member name="T:InTheHand.Net.Sockets.IrDASocketOptionLevel">
      <summary>
            Defines additional IrDA socket option levels for the <see cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" /> and <see cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" /> methods.
            </summary>
      <remarks>
            Use along with the socket options defined by 
            <see cref="T:InTheHand.Net.Sockets.IrDASocketOptionName" />.
            </remarks>
      <seealso cref="T:InTheHand.Net.Sockets.IrDASocketOptionName" />
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDASocketOptionLevel.IrLmp">
      <summary>
            The socket option level for use with IrDA sockets 
            along with the options defined in <see cref="T:InTheHand.Net.Sockets.IrDASocketOptionName" />.
            </summary>
      <remarks>
            Use along with the socket options defined by 
            <see cref="T:InTheHand.Net.Sockets.IrDASocketOptionName" />.
            </remarks>
      <seealso cref="T:InTheHand.Net.Sockets.IrDASocketOptionName" />
    </member>
    <member name="T:InTheHand.Net.Sockets.IrDAHints">
      <summary>
            Describes an enumeration of possible device types, such as Fax.
            </summary>
      <seealso cref="T:System.Net.Sockets.IrDAHints" />
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDAHints.None">
      <summary>
            Unspecified device type.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDAHints.PnP">
      <summary>
            A Plug and Play interface.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDAHints.PdaAndPalmtop">
      <summary>
            A Pocket PC or similar.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDAHints.Computer">
      <summary>
            A personal computer.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDAHints.Printer">
      <summary>
            A printer.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDAHints.Modem">
      <summary>
            A modem.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDAHints.Fax">
      <summary>
            A fax.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDAHints.LanAccess">
      <summary>
            A local area network access.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDAHints.Extension">
      <summary>
            Contains extended hint bytes.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDAHints.Telephony">
      <summary>
            A telephonic device.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDAHints.FileServer">
      <summary>
            A personal computer file server.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDAHints.IrCOMM">
      <summary>
            Device supports IrCOMM.
            </summary>
    </member>
    <member name="F:InTheHand.Net.Sockets.IrDAHints.Obex">
      <summary>
            Device supports Object Exchange.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Widcomm.WidcommSppClient.SPP_STATE_CODE">
      <summary>
            Define SPP connection states
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Widcomm.WidcommSppClient.SPP_STATE_CODE__WCE">
      <summary>
            Define SPP connection states
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Widcomm.WidcommSppClient.SPP_CLIENT_RETURN_CODE">
      <summary>
            Define return code for SPP Client functions
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Widcomm.WidcommSppClient.SPP_CLIENT_RETURN_CODE__WCE">
      <summary>
            Define return code for SPP Client functions
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener">
      <summary>
            Listens for connections from Bluetooth network clients.
            </summary>
      <remarks>The <see cref="T:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener" /> class provides simple methods that listen for and accept incoming connection requests in blocking synchronous mode.
            You can use either a <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> or a <see cref="T:System.Net.Sockets.Socket" /> to connect with a <see cref="T:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener" /></remarks>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.Construct(System.Guid)">
      <overloads>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener" /> class.
            </overloads>
            ----
            <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener" /> class
            to listen on the specified service identifier.
            </summary><param name="service">The Bluetooth service to listen for.</param><remarks><para>
            An SDP record is published on successful <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.Start" />
            to advertise the server.
            A generic record is created, containing the essential <c>ServiceClassIdList</c>
            and <c>ProtocolDescriptorList</c> attributes.  The specified service identifier is
            inserted into the former, and the RFCOMM Channel number that the server is
            listening on is inserted into the latter.  See the Bluetooth SDP specification
            for details on the use and format of SDP records.
            </para><para>
            If a SDP record with more elements is required, then use
            one of the other constructors that takes an SDP record e.g. 
            <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.#ctor(System.Guid,InTheHand.Net.Bluetooth.ServiceRecord)" />,
            or when passing it as a byte array 
            <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.#ctor(System.Guid,System.Byte[],System.Int32)" />.
            The format of the generic record used here is shown there also.
            </para><para>
            Call the <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.Start" /> 
            method to begin listening for incoming connection attempts.
            </para></remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.Construct(InTheHand.Net.BluetoothAddress,System.Guid)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener" /> class
            that listens for incoming connection attempts on the specified local Bluetooth address and service identifier. 
            </summary>
      <param name="localAddress">A <see cref="T:InTheHand.Net.BluetoothAddress" /> that represents the local Bluetooth radio address.</param>
      <param name="service">The Bluetooth service on which to listen for incoming connection attempts.</param>
      <remarks>
        <para>
            An SDP record is published on successful <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.Start" />
            to advertise the server.
            A generic record is created, containing the essential <c>ServiceClassIdList</c>
            and <c>ProtocolDescriptorList</c> attributes.  The specified service identifier is
            inserted into the former, and the RFCOMM Channel number that the server is
            listening on is inserted into the latter.  See the Bluetooth SDP specification
            for details on the use and format of SDP records.
            </para>
        <para>
            If a SDP record with more elements is required, then use
            one of the other constructors that takes an SDP record e.g. 
            <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid,InTheHand.Net.Bluetooth.ServiceRecord)" />,
            or when passing it as a byte array, e.g. 
            <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid,System.Byte[],System.Int32)" />.
            The format of the generic record used here is shown there also.
            </para>
        <para>
            Call the <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.Start" /> 
            method to begin listening for incoming connection attempts.
            </para>
      </remarks>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.Construct(InTheHand.Net.BluetoothEndPoint)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener" /> class
            with the specified local endpoint.
            </summary>
      <param name="localEP">A <see cref="T:InTheHand.Net.BluetoothEndPoint" /> that represents the local endpoint to which to bind the listener <see cref="T:System.Net.Sockets.Socket" />.</param>
      <remarks>
        <para>
            An SDP record is published on successful <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.Start" />
            to advertise the server.
            A generic record is created, containing the essential <c>ServiceClassIdList</c>
            and <c>ProtocolDescriptorList</c> attributes.  The specified service identifier is
            inserted into the former, and the RFCOMM Channel number that the server is
            listening on is inserted into the latter.  See the Bluetooth SDP specification
            for details on the use and format of SDP records.
            </para>
        <para>
            If a SDP record with more elements is required, then use
            one of the other constructors that takes an SDP record e.g. 
            <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.#ctor(InTheHand.Net.BluetoothEndPoint,InTheHand.Net.Bluetooth.ServiceRecord)" />,
            or when passing it as a byte array
            <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.#ctor(InTheHand.Net.BluetoothEndPoint,System.Byte[],System.Int32)" />.
            The format of the generic record used here is shown there also.
            </para>
        <para>
            Call the <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.Start" /> 
            method to begin listening for incoming connection attempts.
            </para>
      </remarks>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.Construct(System.Guid,System.Byte[],System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener" /> class
            to listen on the specified service identifier, 
            publishing the specified SDP record.
            </summary>
      <param name="service">The Bluetooth service to listen for.</param>
      <param name="sdpRecord">Prepared SDP Record to publish.</param>
      <param name="channelOffset">
            The index in the <paramref name="sdpRecord" /> byte array where the RFCOMM Channel Number that the
            server is listening on is to be placed.
            However the supplied record is now parsed into an <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            instance, and the channel offset is not used.
            </param>
      <remarks>
        <note>
            The constructors taking the SDP record explicitly (as a byte array) should
            only be used if
            a specialized SDP record is required. For instance when using one of the
            standard profiles.  Otherwise use one of the other constructors 
            e.g. <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.#ctor(System.Guid)" />
            which create a generic SDP Record from the specified service identifier.
            </note>
        <para>Instead of passing a byte array containing a hand-built record,
            the record can also be built using the <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            and <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" /> classes, and
            passed to the respective constuctor, e.g.
            <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.#ctor(System.Guid,InTheHand.Net.Bluetooth.ServiceRecord)" /></para>
        <para>Any useful SDP record will include 
            a <c>ProtocolDescriptor</c> element containing
            the RFCOMM Channel number that the server is listening on,
            and a <c>ServiceClassId</c> element containing the service UUIDs.
            The record supplied in the <paramref name="sdpRecord" /> parameter
            should contain those elements.  On successful <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.Start" />,
            the RFCOMM Channel number that the protocol stack has assigned to the
            server is retrieved, and copied into the service record before it is
            published.  The <paramref name="channelOffset" /> indicates the location
            of the respective byte in the <paramref name="sdpRecord" /> byte array.
            </para>
        <para>
            An example SDP record is as follows.  This is actually the format of the 
            generic record used in the other constructors.  For another example see
            the code in the <c>ObexListener</c> class.
            <code>
            // The asterisks note where the Service UUID and the Channel number are
            // to be filled in.
            byte[] record = new byte[] {
              //Element Sequence:
              0x35,0x27,
                //UInt16: 0x0001  -- ServiceClassIdList
                0x09,0x00,0x01,
                //Element Sequence:
                0x35,0x11,
                //  UUID128: 00000000-0000-0000-0000-000000000000 -- * Service UUID
                    0x1c,
                      0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
                      0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
                //
                //UInt16: 0x0004  -- ProtocolDescriptorList
                0x09,0x00,0x04,
                //Element Sequence:
                0x35,0x0c,
                //  Element Sequence:
                    0x35,0x03,
                //      UUID16: 0x0100  -- L2CAP
                        0x19,0x01,0x00,
                //  Element Sequence:
                    0x35,0x05,
                //      UUID16: 0x0003  -- RFCOMM
                        0x19,0x00,0x03,
                //      UInt8: 0x00     -- * Channel Number
                        0x08,0x00
            };
            </code>
            For that record the <c>channelOffset</c> is 40.
            </para>
      </remarks>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.Construct(InTheHand.Net.BluetoothAddress,System.Guid,System.Byte[],System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener" /> class
            that listens for incoming connection attempts on the specified local Bluetooth address and service identifier,
            publishing the specified SDP record.
            </summary>
      <param name="localAddress">A <see cref="T:InTheHand.Net.BluetoothAddress" /> that represents the local Bluetooth radio address.</param>
      <param name="service">The Bluetooth service to listen for.</param>
      <param name="sdpRecord">Prepared SDP Record to publish</param>
      <param name="channelOffset">
            The index in the <paramref name="sdpRecord" /> byte array where the RFCOMM Channel Number that the
            server is listening on is to be placed.
            However the supplied record is now parsed into an <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            instance, and the channel offset is not used.
            </param>
      <remarks>
        <note>
            The constructors taking the SDP record explicitly (as a byte array) should
            only be used if
            a specialized SDP record is required. For instance when using one of the
            standard profiles.  Otherwise use one of the other constructors 
            e.g. <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid)" />
            which create a generic SDP Record from the specified service identifier.
            </note>
        <para>Instead of passing a byte array containing a hand-built record,
            the record can also be built using the <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            and <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" /> classes, and
            passed to the respective constuctor, e.g.
            <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid,InTheHand.Net.Bluetooth.ServiceRecord)" /></para>
        <para>Any useful SDP record will include 
            a <c>ProtocolDescriptor</c> element containing
            the RFCOMM Channel number that the server is listening on,
            and a <c>ServiceClassId</c> element containing the service UUIDs.
            The record supplied in the <paramref name="sdpRecord" /> parameter
            should contain those elements.  On successful <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.Start" />,
            the RFCOMM Channel number that the protocol stack has assigned to the
            server is retrieved, and copied into the service record before it is
            published.  The <paramref name="channelOffset" /> indicates the location
            of the respective byte in the <paramref name="sdpRecord" /> byte array.
            </para>
        <para>
            An example SDP record is as follows.  This is actually the format of the 
            generic record used in the other constructors.  For another example see
            the code in the <c>ObexListener</c> class.
            <code>
            // The asterisks note where the Service UUID and the Channel number are
            // to be filled in.
            byte[] record = new byte[] {
              //Element Sequence:
              0x35,0x27,
                //UInt16: 0x0001  -- ServiceClassIdList
                0x09,0x00,0x01,
                //Element Sequence:
                0x35,0x11,
                //  UUID128: 00000000-0000-0000-0000-000000000000 -- * Service UUID
                    0x1c,
                      0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
                      0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
                //
                //UInt16: 0x0004  -- ProtocolDescriptorList
                0x09,0x00,0x04,
                //Element Sequence:
                0x35,0x0c,
                //  Element Sequence:
                    0x35,0x03,
                //      UUID16: 0x0100  -- L2CAP
                        0x19,0x01,0x00,
                //  Element Sequence:
                    0x35,0x05,
                //      UUID16: 0x0003  -- RFCOMM
                        0x19,0x00,0x03,
                //      UInt8: 0x00     -- * Channel Number
                        0x08,0x00
            };
            </code>
            For that record the <c>channelOffset</c> is 40.
            </para>
      </remarks>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.Construct(InTheHand.Net.BluetoothEndPoint,System.Byte[],System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener" /> class
            with the specified local endpoint,
            publishing the specified SDP record.
            </summary>
      <param name="localEP">A <see cref="T:InTheHand.Net.BluetoothEndPoint" /> that represents the local endpoint to which to bind the listener <see cref="T:System.Net.Sockets.Socket" />.</param>
      <param name="sdpRecord">Prepared SDP Record to publish</param>
      <param name="channelOffset">
            The index in the <paramref name="sdpRecord" /> byte array where the RFCOMM Channel Number that the
            server is listening on is to be placed.
            However the supplied record is now parsed into an <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            instance, and the channel offset is not used.
            </param>
      <remarks>
        <note>
            The constructors taking the SDP record explicitly (as a byte array) should
            only be used if
            a specialized SDP record is required. For instance when using one of the
            standard profiles.  Otherwise use one of the other constructors 
            e.g. <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.#ctor(InTheHand.Net.BluetoothEndPoint)" />
            which create a generic SDP Record from the specified service identifier.
            </note>
        <para>Instead of passing a byte array containing a hand-built record,
            the record can also be built using the <see cref="T:InTheHand.Net.Bluetooth.ServiceRecord" />
            and <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" /> classes, and
            passed to the respective constuctor, e.g.
            <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.#ctor(InTheHand.Net.BluetoothEndPoint,InTheHand.Net.Bluetooth.ServiceRecord)" /></para>
        <para>Any useful SDP record will include 
            a <c>ProtocolDescriptor</c> element containing
            the RFCOMM Channel number that the server is listening on,
            and a <c>ServiceClassId</c> element containing the service UUIDs.
            The record supplied in the <paramref name="sdpRecord" /> parameter
            should contain those elements.  On successful <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.Start" />,
            the RFCOMM Channel number that the protocol stack has assigned to the
            server is retrieved, and copied into the service record before it is
            published.  The <paramref name="channelOffset" /> indicates the location
            of the respective byte in the <paramref name="sdpRecord" /> byte array.
            </para>
        <para>
            An example SDP record is as follows.  This is actually the format of the 
            generic record used in the other constructors.  For another example see
            the code in the <c>ObexListener</c> class.
            <code>
            // The asterisks note where the Service UUID and the Channel number are
            // to be filled in.
            byte[] record = new byte[] {
              //Element Sequence:
              0x35,0x27,
                //UInt16: 0x0001  -- ServiceClassIdList
                0x09,0x00,0x01,
                //Element Sequence:
                0x35,0x11,
                //  UUID128: 00000000-0000-0000-0000-000000000000 -- * Service UUID
                    0x1c,
                      0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
                      0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00,
                //
                //UInt16: 0x0004  -- ProtocolDescriptorList
                0x09,0x00,0x04,
                //Element Sequence:
                0x35,0x0c,
                //  Element Sequence:
                    0x35,0x03,
                //      UUID16: 0x0100  -- L2CAP
                        0x19,0x01,0x00,
                //  Element Sequence:
                    0x35,0x05,
                //      UUID16: 0x0003  -- RFCOMM
                        0x19,0x00,0x03,
                //      UInt8: 0x00     -- * Channel Number
                        0x08,0x00
            };
            </code>
            For that record the <c>channelOffset</c> is 40.
            </para>
      </remarks>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.Construct(System.Guid,InTheHand.Net.Bluetooth.ServiceRecord)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener" /> class
            to listen on the specified service identifier, 
            publishing the specified SDP record.
            </summary>
            -
            <param name="service">The Bluetooth service to listen for.</param><param name="sdpRecord">Prepared SDP Record to publish.</param>
            -
            <remarks><note>
            The constructors taking the SDP record explicitly should
            only be used if
            a specialized SDP record is required. For instance when using one of the
            standard profiles.  Otherwise use one of the other constructors 
            e.g. <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.#ctor(System.Guid)" />
            which create a generic SDP Record from the specified service identifier.
            </note><para>Any useful SDP record will include 
            a <c>ProtocolDescriptor</c> element containing
            the RFCOMM Channel number that the server is listening on,
            and a <c>ServiceClassId</c> element containing the service UUIDs.
            The record supplied in the <paramref name="sdpRecord" /> parameter
            should contain those elements.  On successful <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.Start" />,
            the RFCOMM Channel number that the protocol stack has assigned to the
            server is retrieved, and copied into the service record before it is
            published.
            </para><para>
            An example SDP record is as follows.  This is actually the format of the 
            generic record used in the other constructors.  For another example see
            the code in the <c>ObexListener</c> class.
            <code lang="C#">
            private static ServiceRecord CreateBasicRfcommRecord(Guid serviceClassUuid)
            {
                ServiceElement pdl = ServiceRecordHelper.CreateRfcommProtocolDescriptorList();
                ServiceElement classList = new ServiceElement(ElementType.ElementSequence,
                    new ServiceElement(ElementType.Uuid128, serviceClassUuid));
                ServiceRecord record = new ServiceRecord(
                    new ServiceAttribute(
                        InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceClassIdList,
                        classList),
                    new ServiceAttribute(
                        InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList,
                        pdl));
                return record;
            }
            </code></para></remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.Construct(InTheHand.Net.BluetoothAddress,System.Guid,InTheHand.Net.Bluetooth.ServiceRecord)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener" /> class
            that listens for incoming connection attempts on the specified local Bluetooth address and service identifier,
            publishing the specified SDP record.
            </summary>
            -
            <param name="localAddress">A <see cref="T:InTheHand.Net.BluetoothAddress" /> that represents the local Bluetooth radio address.</param><param name="service">The Bluetooth service to listen for.</param><param name="sdpRecord">Prepared SDP Record to publish</param>
            -
            <remarks><note>
            The constructors taking the SDP record explicitly should
            only be used if
            a specialized SDP record is required. For instance when using one of the
            standard profiles.  Otherwise use one of the other constructors 
            e.g. <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.#ctor(InTheHand.Net.BluetoothAddress,System.Guid)" />
            which create a generic SDP Record from the specified service identifier.
            </note><para>Any useful SDP record will include 
            a <c>ProtocolDescriptor</c> element containing
            the RFCOMM Channel number that the server is listening on,
            and a <c>ServiceClassId</c> element containing the service UUIDs.
            The record supplied in the <paramref name="sdpRecord" /> parameter
            should contain those elements.  On successful <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.Start" />,
            the RFCOMM Channel number that the protocol stack has assigned to the
            server is retrieved, and copied into the service record before it is
            published.
            </para><para>
            An example SDP record is as follows.  This is actually the format of the 
            generic record used in the other constructors.  For another example see
            the code in the <c>ObexListener</c> class.
            <code lang="C#">
            private static ServiceRecord CreateBasicRfcommRecord(Guid serviceClassUuid)
            {
                ServiceElement pdl = ServiceRecordHelper.CreateRfcommProtocolDescriptorList();
                ServiceElement classList = new ServiceElement(ElementType.ElementSequence,
                    new ServiceElement(ElementType.Uuid128, serviceClassUuid));
                ServiceRecord record = new ServiceRecord(
                    new ServiceAttribute(
                        InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceClassIdList,
                        classList),
                    new ServiceAttribute(
                        InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList,
                        pdl));
                return record;
            }
            </code></para></remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.Construct(InTheHand.Net.BluetoothEndPoint,InTheHand.Net.Bluetooth.ServiceRecord)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener" /> class
            with the specified local endpoint,
            publishing the specified SDP record.
            </summary>
      <param name="localEP">A <see cref="T:InTheHand.Net.BluetoothEndPoint" /> that represents the local endpoint to which to bind the listener <see cref="T:System.Net.Sockets.Socket" />.</param>
      <param name="sdpRecord">Prepared SDP Record to publish</param>
            -
            <remarks><note>
            The constructors taking the SDP record explicitly (as a byte array) should
            only be used if
            a specialized SDP record is required. For instance when using one of the
            standard profiles.  Otherwise use one of the other constructors 
            e.g. <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.#ctor(InTheHand.Net.BluetoothEndPoint)" />
            which create a generic SDP Record from the specified service identifier.
            </note><para>Any useful SDP record will include 
            a <c>ProtocolDescriptor</c> element containing
            the RFCOMM Channel number that the server is listening on,
            and a <c>ServiceClassId</c> element containing the service UUIDs.
            The record supplied in the <paramref name="sdpRecord" /> parameter
            should contain those elements.  On successful <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.Start" />,
            the RFCOMM Channel number that the protocol stack has assigned to the
            server is retrieved, and copied into the service record before it is
            published.
            </para><para>
            An example SDP record is as follows.  This is actually the format of the 
            generic record used in the other constructors.  For another example see
            the code in the <c>ObexListener</c> class.
            <code lang="C#">
            private static ServiceRecord CreateBasicRfcommRecord(Guid serviceClassUuid)
            {
                ServiceElement pdl = ServiceRecordHelper.CreateRfcommProtocolDescriptorList();
                ServiceElement classList = new ServiceElement(ElementType.ElementSequence,
                    new ServiceElement(ElementType.Uuid128, serviceClassUuid));
                ServiceRecord record = new ServiceRecord(
                    new ServiceAttribute(
                        InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceClassIdList,
                        classList),
                    new ServiceAttribute(
                        InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList,
                        pdl));
                return record;
            }
            </code></para></remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.Start">
      <summary>
            Starts listening for incoming connection requests.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.Start(System.Int32)">
      <summary>
            Starts listening for incoming connection requests with a maximum number of pending connection.
            </summary>
      <param name="backlog">The maximum length of the pending connections queue.</param>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.Stop">
      <summary>
            Stops the socket from monitoring connections.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.BeginAcceptSocket(System.AsyncCallback,System.Object)">
      <summary>
            Begins an asynchronous operation to accept an incoming connection attempt.
            </summary>
      <param name="callback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</param>
      <param name="state">A user-defined object containing information about the accept operation.
            This object is passed to the callback delegate when the operation is complete.</param>
      <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous creation of the <see cref="T:System.Net.Sockets.Socket" />.</returns>
      <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.EndAcceptSocket(System.IAsyncResult)">
      <summary>
            Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> to handle remote host communication.
            </summary>
      <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> returned by a call to the <see cref="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" /> method.</param>
      <returns>A <see cref="T:System.Net.Sockets.Socket" />.</returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.BeginAcceptBluetoothClient(System.AsyncCallback,System.Object)">
      <summary>
            Begins an asynchronous operation to accept an incoming connection attempt.
            </summary>
      <param name="callback">
      </param>
      <param name="state">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.EndAcceptBluetoothClient(System.IAsyncResult)">
      <summary>
            Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> to handle remote host communication.
            </summary>
      <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> returned by a call to the <see cref="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.BeginAcceptBluetoothClient(System.AsyncCallback,System.Object)" /> method.</param>
      <returns>A <see cref="T:InTheHand.Net.Sockets.BluetoothClient" />.</returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.AcceptSocket">
      <summary>
            Creates a new socket for a connection.
            </summary>
      <remarks>AcceptSocket is a blocking method that returns a <see cref="T:System.Net.Sockets.Socket" /> that you can use to send and receive data.
            If you want to avoid blocking, use the <see cref="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.Pending" /> method to determine if connection requests are available in the incoming connection queue.
            <para>The <see cref="T:System.Net.Sockets.Socket" /> returned is initialized with the address and channel number of the remote device.
            You can use any of the Send and Receive methods available in the <see cref="T:System.Net.Sockets.Socket" /> class to communicate with the remote device.
            When you are finished using the <see cref="T:System.Net.Sockets.Socket" />, be sure to call its <see cref="M:System.Net.Sockets.Socket.Close" /> method.
            If your application is relatively simple, consider using the <see cref="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.AcceptBluetoothClient" /> method rather than the AcceptSocket method.
            <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> provides you with simple methods for sending and receiving data over a network in blocking synchronous mode.</para></remarks>
      <returns>A <see cref="T:System.Net.Sockets.Socket" /> used to send and receive data.</returns>
      <exception cref="T:System.InvalidOperationException">Listener is stopped.</exception>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.AcceptBluetoothClient">
      <summary>
            Creates a client object for a connection when the specified service or endpoint is detected by the listener component.
            </summary>
      <remarks>AcceptTcpClient is a blocking method that returns a <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> that you can use to send and receive data.
            Use the <see cref="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.Pending" /> method to determine if connection requests are available in the incoming connection queue if you want to avoid blocking.
            <para>Use the <see cref="M:InTheHand.Net.Sockets.BluetoothClient.GetStream" /> method to obtain the underlying <see cref="T:System.Net.Sockets.NetworkStream" /> of the returned <see cref="T:InTheHand.Net.Sockets.BluetoothClient" />.
            The <see cref="T:System.Net.Sockets.NetworkStream" /> will provide you with methods for sending and receiving with the remote host.
            When you are through with the <see cref="T:InTheHand.Net.Sockets.BluetoothClient" />, be sure to call its <see cref="M:InTheHand.Net.Sockets.BluetoothClient.Close" /> method.
            If you want greater flexibility than a <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> offers, consider using <see cref="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.AcceptSocket" />.</para></remarks>
      <returns>A <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> component.</returns>
      <exception cref="T:System.InvalidOperationException">Listener is stopped.</exception>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.Pending">
      <summary>
            Determines if there is a connection pending.
            </summary>
      <returns>true if there is a connection pending; otherwise, false.</returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.SetPin(InTheHand.Net.BluetoothAddress,System.String)">
      <summary>
            Set or change the PIN to be used with a specific remote device.
            </summary>
      <param name="device">Address of Bluetooth device.</param>
      <param name="pin">PIN string consisting of 1 to 16 ASCII characters.</param>
      <remarks>Assigning null (Nothing in VB) or an empty String will revoke the PIN.</remarks>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.LocalEndPoint">
      <summary>
             Gets the underlying <see cref="T:InTheHand.Net.BluetoothEndPoint" /> of the current <see cref="T:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener" />.  
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.ServiceClass">
      <summary>
            Get or set the Service Class flags that this service adds to the host 
            devices Class Of Device field.
            </summary>
            -
            <remarks><para>The Class of Device value contains a Device part which describes 
            the primary service that the device provides, and a Service part which 
            is a set of flags indicating all the service types that the device supports, 
            e.g. <see cref="F:InTheHand.Net.Bluetooth.ServiceClass.ObjectTransfer" />,
            <see cref="F:InTheHand.Net.Bluetooth.ServiceClass.Telephony" />,
            <see cref="F:InTheHand.Net.Bluetooth.ServiceClass.Audio" /> etc.
            This property supports setting those flags; bits set in this value will be 
            added to the host devices CoD Service Class bits when the listener
            is active.
            </para><para><note>Supported on Win32, but not supported on WindowsMobile/WinCE 
            as there's no native API for it.  The WindowCE section of MSDN mentions the
            Registry value <c>COD</c> at key <c>HKEY_LOCAL_MACHINE\Software\Microsoft\Bluetooth\sys</c>. 
            However my (Jam) has value 0x920100 there but advertises a CoD of 0x100114, 
            so its not clear how the values relate to each other.
            </note></para></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.ServiceName">
      <summary>
            Get or set the ServiceName the server will use in its SDP Record.
            </summary>
            -
            <value>A string representing the value to be used for the Service Name
            SDP Attribute.  Will be <see langword="null" /> if not specfied.
            </value>
            -
            <exception cref="T:System.InvalidOperationException">
            The listener is already started.
            <para>- or -</para>
            A custom Service Record was given at initialization time.  In that case 
            the ServiceName attribute should be added to that record.
            </exception></member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.Server">
      <summary>
            Gets the underlying network <see cref="T:System.Net.Sockets.Socket" />.
            </summary>
      <value>The underlying <see cref="T:System.Net.Sockets.Socket" />.</value>
      <remarks>
        <see cref="T:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener" /> creates a <see cref="T:System.Net.Sockets.Socket" /> to listen for incoming client connection requests.
            Classes deriving from <see cref="T:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener" /> can use this property to get this <see cref="T:System.Net.Sockets.Socket" />.
            Use the underlying <see cref="T:System.Net.Sockets.Socket" /> returned by the <see cref="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.Server" /> property if you require access beyond that which <see cref="T:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener" /> provides.
            <para>Note <see cref="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.Server" /> property only returns the <see cref="T:System.Net.Sockets.Socket" /> used to listen for incoming client connection requests.
            Use the <see cref="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.AcceptSocket" /> method to accept a pending connection request and obtain a <see cref="T:System.Net.Sockets.Socket" /> for sending and receiving data.
            You can also use the <see cref="M:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.AcceptBluetoothClient" /> method to accept a pending connection request and obtain a <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> for sending and receiving data.</para></remarks>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.ServiceRecord">
      <summary>
            Returns the SDP Service Record for this service.
            </summary>
      <remarks>
        <note>Returns <see langword="null" /> if the listener is not 
            <see cref="M:InTheHand.Net.Sockets.WindowsBluetoothListener.Start" />ed
            (and an record wasnt supplied at initialization).
            </note>
      </remarks>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.Authenticate">
      <summary>
            Gets or sets the authentication state of the current connect or behaviour to use when connection is established.
            </summary>
      <remarks>
            For disconnected sockets, specifies that authentication is required in order for a connect or accept operation to complete successfully.
            Setting this option actively initiates authentication during connection establishment, if the two Bluetooth devices were not previously authenticated.
            The user interface for passkey exchange, if necessary, is provided by the operating system outside the application context.
            For outgoing connections that require authentication, the connect operation fails with WSAEACCES if authentication is not successful.
            In response, the application may prompt the user to authenticate the two Bluetooth devices before connection.
            For incoming connections, the connection is rejected if authentication cannot be established and returns a WSAEHOSTDOWN error.
            </remarks>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.WindowsBluetoothListener.Encrypt">
      <summary>
            On unconnected sockets, enforces encryption to establish a connection.
            Encryption is only available for authenticated connections.
            For incoming connections, a connection for which encryption cannot be established is automatically rejected and returns WSAEHOSTDOWN as the error.
            For outgoing connections, the connect function fails with WSAEACCES if encryption cannot be established.
            In response, the application may prompt the user to authenticate the two Bluetooth devices before connection.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.SocketBluetoothClient.MsftSocketOptionHelper.Authenticate">
      <summary>
            Gets or sets the authentication state of the current connect or behaviour to use when connection is established.
            </summary>
      <remarks>
            For disconnected sockets, specifies that authentication is required in order for a connect or accept operation to complete successfully.
            Setting this option actively initiates authentication during connection establishment, if the two Bluetooth devices were not previously authenticated.
            The user interface for passkey exchange, if necessary, is provided by the operating system outside the application context.
            For outgoing connections that require authentication, the connect operation fails with WSAEACCES if authentication is not successful.
            In response, the application may prompt the user to authenticate the two Bluetooth devices before connection.
            For incoming connections, the connection is rejected if authentication cannot be established and returns a WSAEHOSTDOWN error.
            </remarks>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.SocketBluetoothClient.MsftSocketOptionHelper.Encrypt">
      <summary>
            On unconnected sockets, enforces encryption to establish a connection.
            Encryption is only available for authenticated connections.
            For incoming connections, a connection for which encryption cannot be established is automatically rejected and returns WSAEHOSTDOWN as the error.
            For outgoing connections, the connect function fails with WSAEACCES if encryption cannot be established.
            In response, the application may prompt the user to authenticate the two Bluetooth devices before connection.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.SocketBluetoothClient.Connect(InTheHand.Net.BluetoothEndPoint)">
      <summary>
            Connects a client to a specified endpoint.
            </summary>
      <param name="remoteEP">A <see cref="T:InTheHand.Net.BluetoothEndPoint" /> that represents the remote device.</param>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.SocketBluetoothClient.BeginConnect(InTheHand.Net.BluetoothEndPoint,System.AsyncCallback,System.Object)">
      <summary>
            Begins an asynchronous request for a remote host connection.
            The remote host is specified by a <see cref="T:InTheHand.Net.BluetoothEndPoint" />. 
            </summary>
      <param name="remoteEP">A <see cref="T:InTheHand.Net.BluetoothEndPoint" /> containing the 
            address and UUID of the remote service.</param>
      <param name="requestCallback">An AsyncCallback delegate that references the method to invoke when the operation is complete.</param>
      <param name="state">A user-defined object that contains information about the connect operation.
            This object is passed to the requestCallback delegate when the operation is complete.</param>
      <returns>
      </returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.SocketBluetoothClient.EndConnect(System.IAsyncResult)">
      <summary>
            Asynchronously accepts an incoming connection attempt.
            </summary>
      <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> object returned by a call to 
            <see cref="M:BeginConnect(InTheHand.Net.Sockets.BluetoothEndPoint,System.AsyncCallback,System.Object)" />
            / <see cref="M:BeginConnect(InTheHand.Net.Sockets.BluetoothAddress,System.Guid,System.AsyncCallback,System.Object)" />.
            </param>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.SocketBluetoothClient.SetPin(System.String)">
      <summary>
            Sets the PIN associated with the currently connected device.
            </summary>
      <param name="pin">PIN which must be composed of 1 to 16 ASCII characters.</param>
      <remarks>Assigning null (Nothing in VB) or an empty String will revoke the PIN.</remarks>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.SocketBluetoothClient.SetPin(InTheHand.Net.BluetoothAddress,System.String)">
      <summary>
            Set or change the PIN to be used with a specific remote device.
            </summary>
      <param name="device">Address of Bluetooth device.</param>
      <param name="pin">PIN string consisting of 1 to 16 ASCII characters.</param>
      <remarks>Assigning null (Nothing in VB) or an empty String will revoke the PIN.</remarks>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.SocketBluetoothClient.GetRemoteMachineName(InTheHand.Net.BluetoothAddress)">
      <summary>
            Gets the name of the specified remote device.
            </summary>
      <param name="a">Address of remote device.</param>
      <returns>Friendly name of specified device.</returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.SocketBluetoothClient.GetRemoteMachineName(System.Net.Sockets.Socket)">
      <summary>
            Gets the name of a device by a specified socket.
            </summary>
      <param name="s"> A <see cref="T:System.Net.Sockets.Socket" />.</param>
      <returns>Returns a string value of the computer or device name.</returns>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.SocketBluetoothClient.Dispose(System.Boolean)">
      <summary>
            Releases the unmanaged resources used by the BluetoothClient and optionally releases the managed resources.
            </summary>
      <param name="disposing">true to release both managed and unmanaged resources; false to release only unmanaged resources.</param>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.SocketBluetoothClient.Dispose">
      <summary>
            Closes the <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> and the underlying connection.
            </summary>
            -
            <seealso cref="M:InTheHand.Net.Sockets.BluetoothClient.Close" /></member>
    <member name="M:InTheHand.Net.Bluetooth.Msft.SocketBluetoothClient.Finalize">
      <summary>
            Frees resources used by the <see cref="T:InTheHand.Net.Sockets.BluetoothClient" /> class.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.SocketBluetoothClient.InquiryLength">
      <summary>
            Amount of time allowed to perform the query.
            </summary>
      <remarks>On Windows CE the actual value used is expressed in units of 1.28 seconds, so will be the nearest match for the value supplied.
            The default value is 10 seconds. The maximum is 60 seconds.</remarks>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.SocketBluetoothClient.Active">
      <summary>
            Gets or set a value that indicates whether a connection has been made.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.SocketBluetoothClient.Authenticate">
      <summary>
            Gets or sets the authentication state of the current connect or behaviour to use when connection is established.
            </summary>
      <remarks>
            For disconnected sockets, specifies that authentication is required in order for a connect or accept operation to complete successfully.
            Setting this option actively initiates authentication during connection establishment, if the two Bluetooth devices were not previously authenticated.
            The user interface for passkey exchange, if necessary, is provided by the operating system outside the application context.
            For outgoing connections that require authentication, the connect operation fails with WSAEACCES if authentication is not successful.
            In response, the application may prompt the user to authenticate the two Bluetooth devices before connection.
            For incoming connections, the connection is rejected if authentication cannot be established and returns a WSAEHOSTDOWN error.
            </remarks>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.SocketBluetoothClient.Encrypt">
      <summary>
            On unconnected sockets, enforces encryption to establish a connection.
            Encryption is only available for authenticated connections.
            For incoming connections, a connection for which encryption cannot be established is automatically rejected and returns WSAEHOSTDOWN as the error.
            For outgoing connections, the connect function fails with WSAEACCES if encryption cannot be established.
            In response, the application may prompt the user to authenticate the two Bluetooth devices before connection.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.SocketBluetoothClient.LinkKey">
      <summary>
            Returns link key associated with peer Bluetooth device.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.SocketBluetoothClient.LinkPolicy">
      <summary>
            Returns the Link Policy of the current connection.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.Msft.SocketBluetoothClient.RemoteMachineName">
      <summary>
            Gets the name of the remote device.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId">
      <summary>
            Defines the ids for the universal attributes, those 
            whose definitions are common to all service records.
            </summary>
      <remarks>
        <para>
            Universal attributes are those service attributes whose definitions are common
            to all service records. Note that this does not mean that every service record
            must contain values for all of these service attributes. However, if a service
            record has a service attribute with an attribute ID allocated to a universal
            attribute, the attribute value must conform to the universal attributes definition.
            </para>
        <para>
            Only two attributes are required to exist in every service record instance. They
            are the ServiceRecordHandle (attribute ID 0x0000) and the ServiceClassIDList
            (attribute ID 0x0001). All other service attributes are optional within a service
            record.
            </para>
        <para>Attribute IDs in the range of 0x000D-0x01FF are reserved.</para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceRecordHandle">
      <summary>
            A service record handle is a 32-bit number that uniquely identifies each service
            record within an SDP server.
            [0x0000]
            </summary>
      <remarks>
        <para>[<c>32-bit unsigned integer</c>]</para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceClassIdList">
      <summary>
            The ServiceClassIDList attribute consists of a data element sequence in which
            each data element is a UUID representing the service classes that a given service
            record conforms to.
            [0x0001]
            </summary>
      <remarks>
        <para>[<c>Data Element Sequence</c>]</para>
        <para>The ServiceClassIDList attribute consists of a data element sequence in which
            each data element is a UUID representing the service classes that a given service
            record conforms to. The UUIDs are listed in order from the most specific
            class to the most general class. The ServiceClassIDList must contain at least
            one service class UUID.</para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceRecordState">
      <summary>
             The ServiceRecordState is a 32-bit integer that is used to facilitate caching of
             ServiceAttributes.
             [0x0002]
             </summary>
      <remarks>
        <para>[<c>32-bit unsigned integer</c>]</para>
        <para>
             The ServiceRecordState is a 32-bit integer that is used to facilitate caching of
             ServiceAttributes. If this attribute is contained in a service record, its value is
             guaranteed to change when any other attribute value is added to, deleted from
             or changed within the service record. This permits a client to check the value of
             this single attribute. If its value has not changed since it was last checked, the
             client knows that no other attribute values within the service record have
             changed.
             </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceId">
      <summary>
             The ServiceID is a UUID that universally and uniquely identifies the service
             instance described by the service record.
             [0x0003]
             </summary>
      <remarks>
        <para>[<c>UUID</c>]</para>
        <para>
             The ServiceID is a UUID that universally and uniquely identifies the service
             instance described by the service record. This service attribute is particularly
             useful if the same service is described by service records in more than one
             SDP server.
             </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList">
      <summary>
             The ProtocolDescriptorList attribute describes one or more protocol stacks that
             may be used to gain access to the service described by the service record.
             [0x0004]
             </summary>
      <remarks>
        <para>[<c>Data Element Sequence</c> or <c>Data Element Alternative</c>]</para>
        <para>
             The ProtocolDescriptorList attribute describes one or more protocol stacks that
             may be used to gain access to the service described by the service record.
             </para>
        <para>
             If the ProtocolDescriptorList describes a single stack, it takes the form of a data
             element sequence in which each element of the sequence is a protocol
             descriptor. Each protocol descriptor is, in turn, a data element sequence whose
             first element is a UUID identifying the protocol and whose successive elements
             are protocol-specific parameters. Potential protocol-specific parameters are a
             protocol version number and a connection-port number. The protocol descriptors
             are listed in order from the lowest layer protocol to the highest layer protocol
             used to gain access to the service.
             </para>
        <para>
             If it is possible for more than one kind of protocol stack to be used to gain
             access to the service, the ProtocolDescriptorList takes the form of a data element
             alternative where each member is a data element sequence as described
             in the previous paragraph.
             </para>
        <para>
             Protocol Descriptors
             </para>
        <para>
             A protocol descriptor identifies a communications protocol and provides protocol-
             specific parameters. A protocol descriptor is represented as a data element
             sequence. The first data element in the sequence must be the UUID that identifies
             the protocol. Additional data elements optionally provide protocol-specific
             information, such as the L2CAP protocol/service multiplexer (PSM) and the
             RFCOMM server channel number (CN) shown below.
             </para>
        <para>
             ProtocolDescriptorList Examples
             </para>
        <para>
             These examples are intended to be illustrative. The parameter formats for each
             protocol are not defined within this specification.
             </para>
        <para>
             In the first two examples, it is assumed that a single RFCOMM instance exists
             on top of the L2CAP layer. In this case, the L2CAP protocol specific information
             (PSM) points to the single instance of RFCOMM. In the last example, two different
             and independent RFCOMM instances are available on top of the L2CAP
             layer. In this case, the L2CAP protocol specific information (PSM) points to a
             distinct identifier that distinguishes each of the RFCOMM instances. According
             to the L2CAP specification, this identifier takes values in the range
             0x1000-0xFFFF.
             </para>
        <para>
             IrDA-like printer
             </para>
        <para>
             ( ( L2CAP, PSM=RFCOMM ), ( RFCOMM, CN=1 ), ( PostscriptStream ) )
             </para>
        <para>
             IP Network Printing
             </para>
        <para>
             ( ( L2CAP, PSM=RFCOMM ), ( RFCOMM, CN=2 ), ( PPP ), ( IP ), ( TCP ),
             ( IPP ) )
             </para>
        <para>
             Synchronization Protocol Descriptor Example
             </para>
        <para>
             ( ( L2CAP, PSM=0x1001 ), ( RFCOMM, CN=1 ), ( Obex ), ( vCal ) )
             </para>
        <para>
             ( ( L2CAP, PSM=0x1002 ), ( RFCOMM, CN=1 ), ( Obex ),
             </para>
        <para>
             ( otherSynchronisationApplication ) )
             </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.BrowseGroupList">
      <summary>
             The BrowseGroupList attribute consists of a data element sequence in which
             each element is a UUID that represents a browse group to which the service
             record belongs.
             [0x0005]
             </summary>
      <remarks>
        <para>[<c>Data Element Sequence</c>]</para>
        <para>
             The BrowseGroupList attribute consists of a data element sequence in which
             each element is a UUID that represents a browse group to which the service
             record belongs. The top-level browse group ID, called PublicBrowseRoot and
             representing the root of the browsing hierarchy, has the value 
             00001002-0000-1000-8000-00805F9B34FB 
             (UUID16: 0x1002) from the Bluetooth Assigned
             Numbers document.
             </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.LanguageBaseAttributeIdList">
      <summary>
             In order to support human-readable attributes for multiple natural languages in
             a single service record, a base attribute ID is assigned for each of the natural
             languages used in a service record. The human-readable universal attributes
             are then defined with an attribute ID offset from each of these base values,
             rather than with an absolute attribute ID.
             [0x0006]
             </summary>
      <remarks>
        <para>[<c>Data Element Sequence</c>]</para>
        <para>
             In order to support human-readable attributes for multiple natural languages in
             a single service record, a base attribute ID is assigned for each of the natural
             languages used in a service record. The human-readable universal attributes
             are then defined with an attribute ID offset from each of these base values,
             rather than with an absolute attribute ID.
             </para>
        <para>
             The LanguageBaseAttributeIDList attribute is a list in which each member contains
             a language identifier, a character encoding identifier, and a base attribute
             ID for each of the natural languages used in the service record. The Language-
             BaseAttributeIDList attribute consists of a data element sequence in which
             each element is a 16-bit unsigned integer. The elements are grouped as triplets
             (threes).
             </para>
        <para>
             The first element of each triplet contains an identifier representing the natural
             language. The language is encoded according to ISO 639:1988 (E/F): Code
             for the representation of names of languages.
             </para>
        <para>
             The second element of each triplet contains an identifier that specifies a character
             encoding used for the language. Values for character encoding can be
             found in IANA's database1, and have the values that are referred to as MIBEnum
             values. The recommended character encoding is UTF-8.
             </para>
        <para>
             The third element of each triplet contains an attribute ID that serves as the
             base attribute ID for the natural language in the service record. Different service
             records within a server may use different base attribute ID values for the
             same language.
             </para>
        <para>
             To facilitate the retrieval of human-readable universal attributes in a principal
             language, the base attribute ID value for the primary language supported by a
             service record must be 0x0100. Also, if a LanguageBaseAttributeIDList
             attribute is contained in a service record, the base attribute ID value contained
             in its first element must be 0x0100.
             </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceInfoTimeToLive">
      <summary>
             The ServiceTimeToLive attribute is a 32-bit integer that contains the number of
             seconds for which the information in a service record is expected to remain
             valid and unchanged.
             [0x0007]
             </summary>
      <remarks>
        <para>[<c>32-bit unsigned integer</c>]</para>
        <para>
             The ServiceTimeToLive attribute is a 32-bit integer that contains the number of
             seconds for which the information in a service record is expected to remain
             valid and unchanged. This time interval is measured from the time that the
             attribute value is retrieved from the SDP server. This value does not imply a
             guarantee that the service record will remain available or unchanged. It is
             simply a hint that a client may use to determine a suitable polling interval to revalidate
             the service record contents.
             </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceAvailability">
      <summary>
             The ServiceAvailability attribute is an 8-bit unsigned integer that represents the
             relative ability of the service to accept additional clients.
             [0x0008]
             </summary>
      <remarks>
        <para>[<c>8-bit unsigned integer</c>]</para>
        <para>
             The ServiceAvailability attribute is an 8-bit unsigned integer that represents the
             relative ability of the service to accept additional clients. A value of 0xFF indicates
             that the service is not currently in use and is thus fully available, while a
             value of 0x00 means that the service is not accepting new clients. For services
             that support multiple simultaneous clients, intermediate values indicate the relative
             availability of the service on a linear scale.
             </para>
        <para>
             For example, a service that can accept up to 3 clients should provide ServiceAvailability
             values of 0xFF, 0xAA, 0x55, and 0x00 when 0, 1, 2, and 3 clients, respectively,
             are utilizing the service. The value 0xAA is approximately (2/3) * 0xFF and
             represents 2/3 availability, while the value 0x55 is approximately (1/3)*0xFF and
             represents 1/3 availability. Note that the availability value may be approximated as
             </para>
        <para>
             <c>( 1 - ( current_number_of_clients / maximum_number_of_clients ) ) * 0xFF</c>
             </para>
        <para>
             When the maximum number of clients is large, this formula must be modified to
             ensure that ServiceAvailability values of 0x00 and 0xFF are reserved for their
             defined meanings of unavailability and full availability, respectively.
             </para>
        <para>
             Note that the maximum number of clients a service can support may vary
             according to the resources utilized by the service's current clients.
             </para>
        <para>
             A non-zero value for ServiceAvailability does not guarantee that the service will
             be available for use. It should be treated as a hint or an approximation of availability
             status.
             </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.BluetoothProfileDescriptorList">
      <summary>
             The BluetoothProfileDescriptorList attribute consists of a data element
             sequence in which each element is a profile descriptor that contains information
             about a Bluetooth profile to which the service represented by this service
             record conforms.
             [0x0009]
             </summary>
      <remarks>
        <para>[<c>Data Element Sequence</c>]</para>
        <para>
             The BluetoothProfileDescriptorList attribute consists of a data element
             sequence in which each element is a profile descriptor that contains information
             about a Bluetooth profile to which the service represented by this service
             record conforms. Each profile descriptor is a data element sequence whose
             first element is the UUID assigned to the profile and whose second element is
             a 16-bit profile version number.
             </para>
        <para>
             Each version of a profile is assigned a 16-bit unsigned integer profile version
             number, which consists of two 8-bit fields. The higher-order 8 bits contain the
             major version number field and the lower-order 8 bits contain the minor version
             number field. The initial version of each profile has a major version of 1 and a
             minor version of 0. When upward compatible changes are made to the profile,
             the minor version number will be incremented. If incompatible changes are
             made to the profile, the major version number will be incremented.
             </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.DocumentationUrl">
      <summary>
             This attribute is a URL which points to documentation on the service described
             by a service record.
             [0x000A]
             </summary>
      <remarks>
        <para>[<c>URL</c>]</para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ClientExecutableUrl">
      <summary>
             This attribute contains a URL that refers to the location of an application that
             may be used to utilize the service described by the service record.
             [0x000B]
             </summary>
      <remarks>
        <para>[<c>URL</c>]</para>
        <para>
             This attribute contains a URL that refers to the location of an application that
             may be used to utilize the service described by the service record. Since different
             operating environments require different executable formats, a mechanism
             has been defined to allow this single attribute to be used to locate an executable
             that is appropriate for the client devices operating environment. In the
             attribute value URL, the first byte with the value 0x2A (ASCII character *) is to
             be replaced by the client application with a string representing the desired
             operating environment before the URL is to be used.
             </para>
        <para>
             The list of standardized strings representing operating environments is contained
             in the Bluetooth Assigned Numbers document.
             </para>
        <para>
             For example, assume that the value of the ClientExecutableURL attribute is
             http://my.fake/public/*/client.exe. On a device capable of executing SH3 WindowsCE
             files, this URL would be changed to http://my.fake/public/sh3-
             microsoft-wince/client.exe. On a device capable of executing Windows 98 binaries,
             this URL would be changed to http://my.fake/public/i86-microsoft-win98/
             client.exe.
             </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.IconUrl">
      <summary>
             This attribute contains a URL that refers to the location of an icon that may be
             used to represent the service described by the service record.
             [0x000C]
             </summary>
      <remarks>
        <para>[<c>URL</c>]</para>
        <para>
             This attribute contains a URL that refers to the location of an icon that may be
             used to represent the service described by the service record. Since different
             hardware devices require different icon formats, a mechanism has been
             defined to allow this single attribute to be used to locate an icon that is appropriate
             for the client device. In the attribute value URL, the first byte with the
             value 0x2A (ASCII character *) is to be replaced by the client application with
             a string representing the desired icon format before the URL is to be used.
             </para>
        <para>
             The list of standardized strings representing icon formats is contained in the
             Bluetooth Assigned Numbers document.
             </para>
        <para>
             For example, assume that the value of the IconURL attribute is http://my.fake/
             public/icons/*. On a device that prefers 24 x 24 icons with 256 colors, this URL
             would be changed to http://my.fake/public/icons/24x24x8.png. On a device that
             prefers 10 x 10 monochrome icons, this URL would be changed to http://
             my.fake/public/icons/10x10x1.png.
             </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceName">
      <summary>
             The ServiceName attribute is a string containing the name of the service represented
             by a service record.
             [0x0000 + LangBaseAttrId]
             </summary>
      <remarks>
        <para>[<c>String</c>]</para>
        <para>
             The ServiceName attribute is a string containing the name of the service represented
             by a service record. It should be brief and suitable for display with an
             Icon representing the service. The offset 0x0000 must be added to the attribute
             ID base (contained in the LanguageBaseAttributeIDList attribute) in order to
             compute the attribute ID for this attribute.
             </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ServiceDescription">
      <summary>
             This attribute is a string containing a brief description of the service.
             [0x0001 + LangBaseAttrId]
             </summary>
      <remarks>
        <para>[<c>String</c>]</para>
        <para>
             This attribute is a string containing a brief description of the service. It should
             be less than 200 characters in length. The offset 0x0001 must be added to the
             attribute ID base (contained in the LanguageBaseAttributeIDList attribute) in
             order to compute the attribute ID for this attribute.
             </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProviderName">
      <summary>
             This attribute is a string containing the name of the person or organization providing
             the service.
             [0x0002 + LangBaseAttrId]
             </summary>
      <remarks>
        <para>[<c>String</c>]</para>
        <para>
             This attribute is a string containing the name of the person or organization providing
             the service. The offset 0x0002 must be added to the attribute ID base
             (contained in the LanguageBaseAttributeIDList attribute) in order to compute
             the attribute ID for this attribute.
             </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.AdditionalProtocolDescriptorLists">
      <summary>
             The AdditionalProtocolDescriptorLists attribute supports services that 
             require more channels in addition to the service described in the ProtocolDescriptorList
             attribute.  It contains a sequence of ProtocolDescriptorList-elements.
             [0x000D]
             </summary>
      <remarks>
        <para>[<c>Data Element Sequence</c> or <c>Data Element Alternative</c>]</para>
        <para>Defined in Bluetooth version 2.1, SDP section 5.1.6.</para>
        <para>The AdditionalProtocolDescriptorLists attribute contains 
             a sequence of ProtocolDescriptorList-elements. Each element having the 
             same format as the <see cref="F:InTheHand.Net.Bluetooth.AttributeIds.UniversalAttributeId.ProtocolDescriptorList" />
             described in section 5.1.5. The ordering of the elements is
             significant and should be specified and fixed in Profiles that make use of this
             attribute.</para>
        <para>The AdditionalProtocolDescriptorLists attribute supports services that require
             more channels in addition to the service described in Section 5.1.5 . If the AdditionalProtocolDescriptorLists
             attribute is included in a service record, the ProtocolDescriptorList
             attribute must be included.
             </para>
      </remarks>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.AttributeIds.ServiceDiscoveryServerAttributeId">
      <summary>
            This service class describes service records that contain attributes of service
            discovery server itself.
            </summary>
      <remarks>
        <para>
            This service class describes service records that contain attributes of service
            discovery server itself. The attributes listed in this section are only valid if the
            ServiceClassIDList attribute contains the
            ServiceDiscoveryServerServiceClassID. Note that all of the universal attributes
            may be included in service records of the ServiceDiscoveryServer class.
            </para>
        <para>Attribute IDs in the range of 0x0202-0x02FF are reserved.</para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.ServiceDiscoveryServerAttributeId.VersionNumberList">
      <summary>
             The VersionNumberList is a data element sequence in which each element of
             the sequence is a version number supported by the SDP server.
             </summary>
      <remarks>
        <para>[<c>Data Element Sequence</c>]</para>
        <para>
             The VersionNumberList is a data element sequence in which each element of
             the sequence is a version number supported by the SDP server.
             </para>
        <para>
             A version number is a 16-bit unsigned integer consisting of two fields. The
             higher-order 8 bits contain the major version number field and the low-order 8
             bits contain the minor version number field. The initial version of SDP has a
             major version of 1 and a minor version of 0. When upward compatible changes
             are made to the protocol, the minor version number will be incremented. If
             incompatible changes are made to SDP, the major version number will be
             incremented. This guarantees that if a client and a server support a common
             major version number, they can communicate if each uses only features of the
             specification with a minor version number that is supported by both client and
             server.
             </para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.ServiceDiscoveryServerAttributeId.ServiceDatabaseState">
      <summary>
             The ServiceDatabaseState is a 32-bit integer that is used to facilitate caching
             of service records.
             </summary>
      <remarks>
        <para>[<c>32-bit unsigned integer</c>]</para>
        <para>
             The ServiceDatabaseState is a 32-bit integer that is used to facilitate caching
             of service records. If this attribute exists, its value is guaranteed to change
             when any of the other service records are added to or deleted from the server's
             database. If this value has not changed since the last time a client queried its
             value, the client knows that a) none of the other service records maintained by
             the SDP server have been added or deleted; and b) any service record handles
             acquired from the server are still valid. A client should query this attribute's
             value when a connection to the server is established, prior to using any service
             record handles acquired during a previous connection.
             </para>
        <para>
             Note that the ServiceDatabaseState attribute does not change when existing
             service records are modified, including the addition, removal, or modification of
             service attributes. A service record's ServiceRecordState attribute indicates
             when that service record is modified.
             </para>
      </remarks>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.AttributeIds.BrowseGroupDescriptorAttributeId">
      <summary>
            This service class describes the ServiceRecord provided for each BrowseGroupDescriptor
             service offered on a Bluetooth device.
            </summary>
      <remarks>
        <para>
            This service class describes the ServiceRecord provided for each BrowseGroupDescriptor
             service offered on a Bluetooth device. The attributes listed in
            this section are only valid if the ServiceClassIDList attribute contains the BrowseGroupDescriptorServiceClassID.
            Note that all of the universal attributes may
            be included in service records of the BrowseGroupDescriptor class.
            </para>
        <para>Attribute IDs in the range of 0x0201-0x02FF are reserved.</para>
      </remarks>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.AttributeIds.BrowseGroupDescriptorAttributeId.GroupId">
      <summary>
             This attribute contains a UUID that can be used to locate services that are
             members of the browse group that this service record describes.
             </summary>
      <remarks>
        <para>[<c>UUID</c>]</para>
      </remarks>
    </member>
    <member name="T:InTheHand.TextWriterTraceListener32f">
      <summary>
            For use on NETCFv2
            </summary>
            -
            <inheritdoc /></member>
    <member name="M:InTheHand.TextWriterTraceListener32f.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.TextWriterTraceListener32f" /> class
            </summary>
            -
            <param name="filename">The filename of the log file to write to.
            Unlike the .NET supplied class this filename is relative to the
            folder that the calling assembly is located in.
            </param></member>
    <member name="M:InTheHand.Runtime.InteropServices.Marshal32.ReadIntPtr(System.IntPtr,System.Int32)">
      <summary>
            NETCF doesn't have <see cref="M:System.Runtime.InteropServices.Marshal.ReadIntPtr(System.IntPtr,System.Int32)" /></summary>
    </member>
    <member name="T:InTheHand.Net.IrDA.IrDAService">
      <summary>
            Standard IrDA service names.
            </summary>
    </member>
    <member name="F:InTheHand.Net.IrDA.IrDAService.IrComm">
      <summary>
            Well-known Service Name IrDA:IrCOMM
            </summary>
    </member>
    <member name="F:InTheHand.Net.IrDA.IrDAService.IrLpt">
      <summary>
            Well-known Service Name IrLPT
            </summary>
    </member>
    <member name="F:InTheHand.Net.IrDA.IrDAService.ObjectExchange">
      <summary>
            Well-known Service Name OBEX
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.ServiceAttribute">
      <summary>
            Holds an attribute from an SDP service record.
            </summary>
            -
            <remarks>
            Access its SDP Data Element through the 
            <see cref="P:InTheHand.Net.Bluetooth.ServiceElement.Value" /> property and read the 
            data value through the methods and properties on the returned 
            <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" />.
            </remarks></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceAttribute.#ctor(InTheHand.Net.Bluetooth.ServiceAttributeId,InTheHand.Net.Bluetooth.ServiceElement)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" /> class.
            </summary>
            -
            <param name="id">The Attribute Id as a <see cref="T:InTheHand.Net.Bluetooth.ServiceAttributeId" />.</param><param name="value">The value as a <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" />.</param></member>
    <member name="M:InTheHand.Net.Bluetooth.ServiceAttribute.#ctor(System.UInt16,InTheHand.Net.Bluetooth.ServiceElement)">
      <summary>
            Initializes a new instance of the <see cref="T:InTheHand.Net.Bluetooth.ServiceAttribute" /> class.
            </summary>
            -
            <param name="id">The Attribute Id as a <see cref="T:System.UInt16" />.</param><param name="value">The value as a <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" />.</param></member>
    <member name="P:InTheHand.Net.Bluetooth.ServiceAttribute.Id">
      <summary>
            Get the Attribute Id for this attribute.
            </summary>
            -
            <remarks><note>Id is a <em>unsigned</em> 32-bit integer but we use return it
            is a <em>signed</em> 32-bit integer for CLS Compliance reasons.  It
            should not thus be used for ordering etc, for example 0xFFFF will sort
            before 0x0001 which is backwards.
            </note></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.ServiceAttribute.IdAsOrdinalNumber">
      <summary>
            Get the Attribute Id as a number, e.g. for comparison.
            </summary>
            -
            <remarks><para>Property <see cref="P:Id" /> should be used as an identifier,
            but not as a number.  That#x2019;s because the range is <em>unsigned</em>
            32-bit integer but we use return it is a <em>signed</em> 32-bit integer.
            Thus an example list will sort as { 0xFFFF, 0x8001, 0x0001, 0x0302 }
            when it should sort as { 0x0001, 0x0302, 0x8001,0xFFFF }
            </para></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.ServiceAttribute.Value">
      <summary>
            Get the value of this attributes as a <see cref="T:InTheHand.Net.Bluetooth.ServiceElement" /></summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.RadioVersions">
      <summary>
            Stores the LMP etc versions.
            </summary>
    </member>
    <member name="M:InTheHand.Net.Bluetooth.RadioVersions.#ctor(InTheHand.Net.Bluetooth.LmpVersion,System.UInt16,InTheHand.Net.Bluetooth.LmpFeatures,InTheHand.Net.Bluetooth.Manufacturer)">
      <summary>
            Initialises a new instance.
            </summary>
            -
            <param name="lmpVersion">The LMP Version.
            </param><param name="lmpSubversion">The LMP Subversion
            as a <see cref="T:System.UInt16" />.
            </param><param name="lmpSupportedFeatures">The LMP Supported Features.
            </param><param name="mfg">The Manufacturer.
            </param><summary>
            Get the LMP Subversion value.
            </summary></member>
    <member name="P:InTheHand.Net.Bluetooth.RadioVersions.LmpVersion">
      <summary>
            Get the LMP Version.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.RadioVersions.LmpSubversion">
      <summary>
            Get the LMP Subversion.
            </summary>
            -
            <remarks><note>This is of CLR type <see cref="T:System.Int32" /> for CLS
            compliance.  The Bluetooth value is of course of type
            <see cref="T:System.UInt16" />.
            </note></remarks></member>
    <member name="P:InTheHand.Net.Bluetooth.RadioVersions.LmpSupportedFeatures">
      <summary>
            Get the LMP Supported Features.
            </summary>
    </member>
    <member name="P:InTheHand.Net.Bluetooth.RadioVersions.Manufacturer">
      <summary>
            Get the Manufacturer.
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Widcomm.WidcommBluetoothListener">
      <exclude />
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Widcomm.SdpService.DESC_TYPE">
      <summary>
            Define for service attribute, all the 'Descriptor Type' values.
            These are also referred to as 'attribute type' values
            </summary>
    </member>
    <member name="T:InTheHand.Net.Bluetooth.Widcomm.PORT_EV">
      <summary>
            Define RFCOMM Port events that registered application can receive in the callback
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.PORT_EV.RXCHAR">
      <summary>
            Any Character received
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.PORT_EV.RXFLAG">
      <summary>
            Received certain character
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.PORT_EV.TXEMPTY">
      <summary>
            Transmitt Queue Empty
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.PORT_EV.CTS">
      <summary>
            CTS changed state
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.PORT_EV.DSR">
      <summary>
            DSR changed state
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.PORT_EV.RLSD">
      <summary>
            RLSD changed state
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.PORT_EV.BREAK">
      <summary>
            Ring signal detected
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.PORT_EV.ERR">
      <summary>
            Line status error occurred
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.PORT_EV.RING">
      <summary>
            Ring signal detected
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.PORT_EV.CTSS">
      <summary>
            CTS state
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.PORT_EV.DSRS">
      <summary>
            DSR state
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.PORT_EV.RLSDS">
      <summary>
            RLSD state
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.PORT_EV.OVERRUN">
      <summary>
            receiver buffer overrun
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.PORT_EV.TXCHAR">
      <summary>
            Any character transmitted
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.PORT_EV.CONNECTED">
      <summary>
            RFCOMM connection established
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.PORT_EV.CONNECT_ERR">
      <summary>
            Was not able to establish connection; or disconnected
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.PORT_EV.FC">
      <summary>
            flow control enabled flag changed by remote
            </summary>
    </member>
    <member name="F:InTheHand.Net.Bluetooth.Widcomm.PORT_EV.FCS">
      <summary>
            flow control status true = enabled
            </summary>
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.JSONSerializer.SerialiseDataObjectInt(System.IO.Stream,System.Object,System.Collections.Generic.Dictionary{System.String,System.String})">
      <inheritdoc />
    </member>
    <member name="M:NetworkCommsDotNet.DPSBase.JSONSerializer.DeserialiseDataObjectInt(System.IO.Stream,System.Type,System.Collections.Generic.Dictionary{System.String,System.String})">
      <inheritdoc />
    </member>
    <member name="T:Newtonsoft.Json.JsonReader">
      <summary>
            Represents a reader that provides fast, non-cached, forward-only access to serialized Json data.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonReader.State">
      <summary>
            Specifies the state of the reader.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReader" /> class with the specified <see cref="T:System.IO.TextReader" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.Read">
      <summary>
            Reads the next JSON token from the stream.
            </summary>
      <returns>true if the next token was read successfully; false if there are no more tokens to read.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.ReadAsInt32">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.ReadAsString">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.String" />.
            </summary>
      <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.ReadAsBytes">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:Byte[]" />.
            </summary>
      <returns>A <see cref="T:Byte[]" /> or a null reference if the next JSON token is null. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.ReadAsDecimal">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.ReadAsDateTime">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.ReadAsDateTimeOffset">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.Skip">
      <summary>
            Skips the children of the current token.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.SetToken(Newtonsoft.Json.JsonToken)">
      <summary>
            Sets the current token.
            </summary>
      <param name="newToken">The new token.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.SetToken(Newtonsoft.Json.JsonToken,System.Object)">
      <summary>
            Sets the current token and value.
            </summary>
      <param name="newToken">The new token.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.SetStateBasedOnCurrent">
      <summary>
            Sets the state based on current token type.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.Dispose(System.Boolean)">
      <summary>
            Releases unmanaged and - optionally - managed resources
            </summary>
      <param name="disposing">
        <c>true</c> to release both managed and unmanaged resources; <c>false</c> to release only unmanaged resources.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonReader.Close">
      <summary>
            Changes the <see cref="T:Newtonsoft.Json.JsonReader.State" /> to Closed. 
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.CurrentState">
      <summary>
            Gets the current reader state.
            </summary>
      <value>The current reader state.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.CloseInput">
      <summary>
            Gets or sets a value indicating whether the underlying stream or
            <see cref="T:System.IO.TextReader" /> should be closed when the reader is closed.
            </summary>
      <value>
            true to close the underlying stream or <see cref="T:System.IO.TextReader" /> when
            the reader is closed; otherwise false. The default is true.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.SupportMultipleContent">
      <summary>
            Gets or sets a value indicating whether multiple pieces of JSON content can
            be read from a continuous stream without erroring.
            </summary>
      <value>
            true to support reading multiple pieces of JSON content; otherwise false. The default is false.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.QuoteChar">
      <summary>
            Gets the quotation mark character used to enclose the value of a string.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.DateTimeZoneHandling">
      <summary>
            Get or set how <see cref="T:System.DateTime" /> time zones are handling when reading JSON.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.DateParseHandling">
      <summary>
            Get or set how date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed when reading JSON.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.FloatParseHandling">
      <summary>
            Get or set how floating point numbers, e.g. 1.0 and 9.9, are parsed when reading JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.MaxDepth">
      <summary>
            Gets or sets the maximum depth allowed when reading JSON. Reading past this depth will throw a <see cref="T:Newtonsoft.Json.JsonReaderException" />.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.TokenType">
      <summary>
            Gets the type of the current JSON token. 
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.Value">
      <summary>
            Gets the text value of the current JSON token.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.ValueType">
      <summary>
            Gets The Common Language Runtime (CLR) type for the current JSON token.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.Depth">
      <summary>
            Gets the depth of the current token in the JSON document.
            </summary>
      <value>The depth of the current token in the JSON document.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.Path">
      <summary>
            Gets the path of the current JSON token. 
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonReader.Culture">
      <summary>
            Gets or sets the culture used when reading JSON. Defaults to <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Bson.BsonReader">
      <summary>
            Represents a reader that provides fast, non-cached, forward-only access to serialized Json data.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.#ctor(System.IO.Stream)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonReader" /> class.
            </summary>
      <param name="stream">The stream.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.#ctor(System.IO.BinaryReader)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonReader" /> class.
            </summary>
      <param name="reader">The reader.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.#ctor(System.IO.Stream,System.Boolean,System.DateTimeKind)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonReader" /> class.
            </summary>
      <param name="stream">The stream.</param>
      <param name="readRootValueAsArray">if set to <c>true</c> the root object will be read as a JSON array.</param>
      <param name="dateTimeKindHandling">The <see cref="T:System.DateTimeKind" /> used when reading <see cref="T:System.DateTime" /> values from BSON.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.#ctor(System.IO.BinaryReader,System.Boolean,System.DateTimeKind)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonReader" /> class.
            </summary>
      <param name="reader">The reader.</param>
      <param name="readRootValueAsArray">if set to <c>true</c> the root object will be read as a JSON array.</param>
      <param name="dateTimeKindHandling">The <see cref="T:System.DateTimeKind" /> used when reading <see cref="T:System.DateTime" /> values from BSON.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.ReadAsBytes">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:Byte[]" />.
            </summary>
      <returns>
            A <see cref="T:Byte[]" /> or a null reference if the next JSON token is null. This method will return <c>null</c> at the end of an array.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.ReadAsDecimal">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.ReadAsInt32">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.ReadAsString">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.String" />.
            </summary>
      <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.ReadAsDateTime">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.ReadAsDateTimeOffset">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>
            A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.Read">
      <summary>
            Reads the next JSON token from the stream.
            </summary>
      <returns>
            true if the next token was read successfully; false if there are no more tokens to read.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonReader.Close">
      <summary>
            Changes the <see cref="T:Newtonsoft.Json.JsonReader.State" /> to Closed.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Bson.BsonReader.JsonNet35BinaryCompatibility">
      <summary>
            Gets or sets a value indicating whether binary data reading should compatible with incorrect Json.NET 3.5 written binary.
            </summary>
      <value>
        <c>true</c> if binary data reading will be compatible with incorrect Json.NET 3.5 written binary; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Bson.BsonReader.ReadRootValueAsArray">
      <summary>
            Gets or sets a value indicating whether the root object will be read as a JSON array.
            </summary>
      <value>
        <c>true</c> if the root object will be read as a JSON array; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Bson.BsonReader.DateTimeKindHandling">
      <summary>
            Gets or sets the <see cref="T:System.DateTimeKind" /> used when reading <see cref="T:System.DateTime" /> values from BSON.
            </summary>
      <value>The <see cref="T:System.DateTimeKind" /> used when reading <see cref="T:System.DateTime" /> values from BSON.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonWriter">
      <summary>
            Represents a writer that provides a fast, non-cached, forward-only way of generating Json data.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.#ctor">
      <summary>
            Creates an instance of the <c>JsonWriter</c> class. 
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.Flush">
      <summary>
            Flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.Close">
      <summary>
            Closes this stream and the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteStartObject">
      <summary>
            Writes the beginning of a Json object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteEndObject">
      <summary>
            Writes the end of a Json object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteStartArray">
      <summary>
            Writes the beginning of a Json array.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteEndArray">
      <summary>
            Writes the end of an array.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteStartConstructor(System.String)">
      <summary>
            Writes the start of a constructor with the given name.
            </summary>
      <param name="name">The name of the constructor.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteEndConstructor">
      <summary>
            Writes the end constructor.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WritePropertyName(System.String)">
      <summary>
            Writes the property name of a name/value pair on a JSON object.
            </summary>
      <param name="name">The name of the property.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WritePropertyName(System.String,System.Boolean)">
      <summary>
            Writes the property name of a name/value pair on a JSON object.
            </summary>
      <param name="name">The name of the property.</param>
      <param name="escape">A flag to indicate whether the text should be escaped when it is written as a JSON property name.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteEnd">
      <summary>
            Writes the end of the current Json object or array.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteToken(Newtonsoft.Json.JsonReader)">
      <summary>
            Writes the current <see cref="T:Newtonsoft.Json.JsonReader" /> token and its children.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read the token from.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteToken(Newtonsoft.Json.JsonReader,System.Boolean)">
      <summary>
            Writes the current <see cref="T:Newtonsoft.Json.JsonReader" /> token.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read the token from.</param>
      <param name="writeChildren">A flag indicating whether the current token's children should be written.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteEnd(Newtonsoft.Json.JsonToken)">
      <summary>
            Writes the specified end token.
            </summary>
      <param name="token">The end token to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteIndent">
      <summary>
            Writes indent characters.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValueDelimiter">
      <summary>
            Writes the JSON value delimiter.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteIndentSpace">
      <summary>
            Writes an indent space.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteNull">
      <summary>
            Writes a null value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteUndefined">
      <summary>
            Writes an undefined value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteRaw(System.String)">
      <summary>
            Writes raw JSON without changing the writer's state.
            </summary>
      <param name="json">The raw JSON to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteRawValue(System.String)">
      <summary>
            Writes raw JSON where a value is expected and updates the writer's state.
            </summary>
      <param name="json">The raw JSON to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.String)">
      <summary>
            Writes a <see cref="T:System.String" /> value.
            </summary>
      <param name="value">The <see cref="T:System.String" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Int32)">
      <summary>
            Writes a <see cref="T:System.Int32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.UInt32)">
      <summary>
            Writes a <see cref="T:System.UInt32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Int64)">
      <summary>
            Writes a <see cref="T:System.Int64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.UInt64)">
      <summary>
            Writes a <see cref="T:System.UInt64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Single)">
      <summary>
            Writes a <see cref="T:System.Single" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Single" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Double)">
      <summary>
            Writes a <see cref="T:System.Double" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Double" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Boolean)">
      <summary>
            Writes a <see cref="T:System.Boolean" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Boolean" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Int16)">
      <summary>
            Writes a <see cref="T:System.Int16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.UInt16)">
      <summary>
            Writes a <see cref="T:System.UInt16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Char)">
      <summary>
            Writes a <see cref="T:System.Char" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Byte)">
      <summary>
            Writes a <see cref="T:System.Byte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Byte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.SByte)">
      <summary>
            Writes a <see cref="T:System.SByte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.SByte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Decimal)">
      <summary>
            Writes a <see cref="T:System.Decimal" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Decimal" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.DateTime)">
      <summary>
            Writes a <see cref="T:System.DateTime" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTime" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.DateTimeOffset)">
      <summary>
            Writes a <see cref="T:System.DateTimeOffset" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTimeOffset" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Guid)">
      <summary>
            Writes a <see cref="T:System.Guid" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Guid" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.TimeSpan)">
      <summary>
            Writes a <see cref="T:System.TimeSpan" /> value.
            </summary>
      <param name="value">The <see cref="T:System.TimeSpan" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Int32})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.UInt32})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Int64})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.UInt64})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Single})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Double})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Boolean})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Int16})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.UInt16})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Char})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Byte})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.SByte})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Decimal})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.DateTime})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.DateTimeOffset})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.Guid})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Nullable{System.TimeSpan})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Byte[])">
      <summary>
            Writes a <see cref="T:Byte[]" /> value.
            </summary>
      <param name="value">The <see cref="T:Byte[]" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Uri)">
      <summary>
            Writes a <see cref="T:System.Uri" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Uri" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteValue(System.Object)">
      <summary>
            Writes a <see cref="T:System.Object" /> value.
            An error will raised if the value cannot be written as a single JSON token.
            </summary>
      <param name="value">The <see cref="T:System.Object" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteComment(System.String)">
      <summary>
            Writes out a comment <code>/*...*/</code> containing the specified text. 
            </summary>
      <param name="text">Text to place inside the comment.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.WriteWhitespace(System.String)">
      <summary>
            Writes out the given white space.
            </summary>
      <param name="ws">The string of white space characters.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriter.SetWriteState(Newtonsoft.Json.JsonToken,System.Object)">
      <summary>
            Sets the state of the JsonWriter,
            </summary>
      <param name="token">The JsonToken being written.</param>
      <param name="value">The value being written.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.CloseOutput">
      <summary>
            Gets or sets a value indicating whether the underlying stream or
            <see cref="T:System.IO.TextReader" /> should be closed when the writer is closed.
            </summary>
      <value>
            true to close the underlying stream or <see cref="T:System.IO.TextReader" /> when
            the writer is closed; otherwise false. The default is true.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.Top">
      <summary>
            Gets the top.
            </summary>
      <value>The top.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.WriteState">
      <summary>
            Gets the state of the writer.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.Path">
      <summary>
            Gets the path of the writer. 
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.Formatting">
      <summary>
            Indicates how JSON text output is formatted.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.DateFormatHandling">
      <summary>
            Get or set how dates are written to JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.DateTimeZoneHandling">
      <summary>
            Get or set how <see cref="T:System.DateTime" /> time zones are handling when writing JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.StringEscapeHandling">
      <summary>
            Get or set how strings are escaped when writing JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.FloatFormatHandling">
      <summary>
            Get or set how special floating point numbers, e.g. <see cref="F:System.Double.NaN" />,
            <see cref="F:System.Double.PositiveInfinity" /> and <see cref="F:System.Double.NegativeInfinity" />,
            are written to JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.DateFormatString">
      <summary>
            Get or set how <see cref="T:System.DateTime" /> and <see cref="T:System.DateTimeOffset" /> values are formatting when writing JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriter.Culture">
      <summary>
            Gets or sets the culture used when writing JSON. Defaults to <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Bson.BsonWriter">
      <summary>
            Represents a writer that provides a fast, non-cached, forward-only way of generating JSON data.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.#ctor(System.IO.Stream)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonWriter" /> class.
            </summary>
      <param name="stream">The stream.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.#ctor(System.IO.BinaryWriter)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonWriter" /> class.
            </summary>
      <param name="writer">The writer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.Flush">
      <summary>
            Flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteEnd(Newtonsoft.Json.JsonToken)">
      <summary>
            Writes the end.
            </summary>
      <param name="token">The token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteComment(System.String)">
      <summary>
            Writes out a comment <code>/*...*/</code> containing the specified text.
            </summary>
      <param name="text">Text to place inside the comment.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteStartConstructor(System.String)">
      <summary>
            Writes the start of a constructor with the given name.
            </summary>
      <param name="name">The name of the constructor.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteRaw(System.String)">
      <summary>
            Writes raw JSON.
            </summary>
      <param name="json">The raw JSON to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteRawValue(System.String)">
      <summary>
            Writes raw JSON where a value is expected and updates the writer's state.
            </summary>
      <param name="json">The raw JSON to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteStartArray">
      <summary>
            Writes the beginning of a Json array.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteStartObject">
      <summary>
            Writes the beginning of a Json object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WritePropertyName(System.String)">
      <summary>
            Writes the property name of a name/value pair on a Json object.
            </summary>
      <param name="name">The name of the property.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.Close">
      <summary>
            Closes this stream and the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Object)">
      <summary>
            Writes a <see cref="T:System.Object" /> value.
            An error will raised if the value cannot be written as a single JSON token.
            </summary>
      <param name="value">The <see cref="T:System.Object" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteNull">
      <summary>
            Writes a null value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteUndefined">
      <summary>
            Writes an undefined value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.String)">
      <summary>
            Writes a <see cref="T:System.String" /> value.
            </summary>
      <param name="value">The <see cref="T:System.String" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Int32)">
      <summary>
            Writes a <see cref="T:System.Int32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.UInt32)">
      <summary>
            Writes a <see cref="T:System.UInt32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Int64)">
      <summary>
            Writes a <see cref="T:System.Int64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.UInt64)">
      <summary>
            Writes a <see cref="T:System.UInt64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Single)">
      <summary>
            Writes a <see cref="T:System.Single" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Single" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Double)">
      <summary>
            Writes a <see cref="T:System.Double" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Double" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Boolean)">
      <summary>
            Writes a <see cref="T:System.Boolean" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Boolean" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Int16)">
      <summary>
            Writes a <see cref="T:System.Int16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.UInt16)">
      <summary>
            Writes a <see cref="T:System.UInt16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Char)">
      <summary>
            Writes a <see cref="T:System.Char" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Byte)">
      <summary>
            Writes a <see cref="T:System.Byte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Byte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.SByte)">
      <summary>
            Writes a <see cref="T:System.SByte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.SByte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Decimal)">
      <summary>
            Writes a <see cref="T:System.Decimal" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Decimal" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.DateTime)">
      <summary>
            Writes a <see cref="T:System.DateTime" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTime" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.DateTimeOffset)">
      <summary>
            Writes a <see cref="T:System.DateTimeOffset" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTimeOffset" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Byte[])">
      <summary>
            Writes a <see cref="T:Byte[]" /> value.
            </summary>
      <param name="value">The <see cref="T:Byte[]" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Guid)">
      <summary>
            Writes a <see cref="T:System.Guid" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Guid" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.TimeSpan)">
      <summary>
            Writes a <see cref="T:System.TimeSpan" /> value.
            </summary>
      <param name="value">The <see cref="T:System.TimeSpan" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteValue(System.Uri)">
      <summary>
            Writes a <see cref="T:System.Uri" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Uri" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteObjectId(System.Byte[])">
      <summary>
            Writes a <see cref="T:Byte[]" /> value that represents a BSON object id.
            </summary>
      <param name="value">The Object ID value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonWriter.WriteRegex(System.String,System.String)">
      <summary>
            Writes a BSON regex.
            </summary>
      <param name="pattern">The regex pattern.</param>
      <param name="options">The regex options.</param>
    </member>
    <member name="P:Newtonsoft.Json.Bson.BsonWriter.DateTimeKindHandling">
      <summary>
            Gets or sets the <see cref="T:System.DateTimeKind" /> used when writing <see cref="T:System.DateTime" /> values to BSON.
            When set to <see cref="F:System.DateTimeKind.Unspecified" /> no conversion will occur.
            </summary>
      <value>The <see cref="T:System.DateTimeKind" /> used when writing <see cref="T:System.DateTime" /> values to BSON.</value>
    </member>
    <member name="T:Newtonsoft.Json.Bson.BsonObjectId">
      <summary>
            Represents a BSON Oid (object id).
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Bson.BsonObjectId.#ctor(System.Byte[])">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Bson.BsonObjectId" /> class.
            </summary>
      <param name="value">The Oid value.</param>
    </member>
    <member name="P:Newtonsoft.Json.Bson.BsonObjectId.Value">
      <summary>
            Gets or sets the value of the Oid.
            </summary>
      <value>The value of the Oid.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonConverter">
      <summary>
            Converts an object to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConverter.GetSchema">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of the JSON produced by the JsonConverter.
            </summary>
      <returns>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of the JSON produced by the JsonConverter.</returns>
    </member>
    <member name="P:Newtonsoft.Json.JsonConverter.CanRead">
      <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.JsonConverter" /> can read JSON.
            </summary>
      <value>
        <c>true</c> if this <see cref="T:Newtonsoft.Json.JsonConverter" /> can read JSON; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonConverter.CanWrite">
      <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON.
            </summary>
      <value>
        <c>true</c> if this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Newtonsoft.Json.Converters.BinaryConverter">
      <summary>
            Converts a binary value to and from a base 64 string value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.BinaryConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.BinaryConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.BinaryConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.DataSetConverter">
      <summary>
            Converts a <see cref="T:System.Data.DataSet" /> to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DataSetConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DataSetConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DataSetConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified value type.
            </summary>
      <param name="valueType">Type of the value.</param>
      <returns>
        <c>true</c> if this instance can convert the specified value type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.DataTableConverter">
      <summary>
            Converts a <see cref="T:System.Data.DataTable" /> to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DataTableConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DataTableConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DataTableConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified value type.
            </summary>
      <param name="valueType">Type of the value.</param>
      <returns>
        <c>true</c> if this instance can convert the specified value type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.CustomCreationConverter`1">
      <summary>
            Create a custom object
            </summary>
      <typeparam name="T">The object type to convert.</typeparam>
    </member>
    <member name="M:Newtonsoft.Json.Converters.CustomCreationConverter`1.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.CustomCreationConverter`1.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.CustomCreationConverter`1.Create(System.Type)">
      <summary>
            Creates an object which will then be populated by the serializer.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>The created object.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.CustomCreationConverter`1.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Converters.CustomCreationConverter`1.CanWrite">
      <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON.
            </summary>
      <value>
        <c>true</c> if this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Newtonsoft.Json.Converters.DateTimeConverterBase">
      <summary>
            Provides a base class for converting a <see cref="T:System.DateTime" /> to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DateTimeConverterBase.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.DiscriminatedUnionConverter">
      <summary>
            Converts a F# discriminated union type to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DiscriminatedUnionConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DiscriminatedUnionConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.DiscriminatedUnionConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.EntityKeyMemberConverter">
      <summary>
            Converts an Entity Framework EntityKey to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.EntityKeyMemberConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.EntityKeyMemberConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.EntityKeyMemberConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.ExpandoObjectConverter">
      <summary>
            Converts an ExpandoObject to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.ExpandoObjectConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.ExpandoObjectConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.ExpandoObjectConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Converters.ExpandoObjectConverter.CanWrite">
      <summary>
            Gets a value indicating whether this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON.
            </summary>
      <value>
        <c>true</c> if this <see cref="T:Newtonsoft.Json.JsonConverter" /> can write JSON; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Newtonsoft.Json.Converters.KeyValuePairConverter">
      <summary>
            Converts a <see cref="T:System.Collections.Generic.KeyValuePair`2" /> to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.KeyValuePairConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.KeyValuePairConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.KeyValuePairConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.BsonObjectIdConverter">
      <summary>
            Converts a <see cref="T:Newtonsoft.Json.Bson.BsonObjectId" /> to and from JSON and BSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.BsonObjectIdConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.BsonObjectIdConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.BsonObjectIdConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.RegexConverter">
      <summary>
            Converts a <see cref="T:System.Text.RegularExpressions.Regex" /> to and from JSON and BSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.RegexConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.RegexConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.RegexConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.StringEnumConverter">
      <summary>
            Converts an <see cref="T:System.Enum" /> to and from its name string value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.StringEnumConverter.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Converters.StringEnumConverter" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.StringEnumConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.StringEnumConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.StringEnumConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Converters.StringEnumConverter.CamelCaseText">
      <summary>
            Gets or sets a value indicating whether the written enum text should be camel case.
            </summary>
      <value>
        <c>true</c> if the written enum text will be camel case; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.Converters.StringEnumConverter.AllowIntegerValues">
      <summary>
            Gets or sets a value indicating whether integer values are allowed.
            </summary>
      <value>
        <c>true</c> if integers are allowed; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Newtonsoft.Json.ConstructorHandling">
      <summary>
            Specifies how constructors are used when initializing objects during deserialization by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ConstructorHandling.Default">
      <summary>
            First attempt to use the public default constructor, then fall back to single paramatized constructor, then the non-public default constructor.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ConstructorHandling.AllowNonPublicDefaultConstructor">
      <summary>
            Json.NET will use a non-public default constructor before falling back to a paramatized constructor.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Converters.VersionConverter">
      <summary>
            Converts a <see cref="T:System.Version" /> to and from a string (e.g. "1.2.3.4").
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.VersionConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.VersionConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing property value of the JSON that is being converted.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.VersionConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified object type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>
        <c>true</c> if this instance can convert the specified object type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.FloatFormatHandling">
      <summary>
            Specifies float format handling options when writing special floating point numbers, e.g. <see cref="F:System.Double.NaN" />,
            <see cref="F:System.Double.PositiveInfinity" /> and <see cref="F:System.Double.NegativeInfinity" /> with <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.FloatFormatHandling.String">
      <summary>
            Write special floating point values as strings in JSON, e.g. "NaN", "Infinity", "-Infinity".
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.FloatFormatHandling.Symbol">
      <summary>
            Write special floating point values as symbols in JSON, e.g. NaN, Infinity, -Infinity.
            Note that this will produce non-valid JSON.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.FloatFormatHandling.DefaultValue">
      <summary>
            Write special floating point values as the property's default value in JSON, e.g. 0.0 for a <see cref="T:System.Double" /> property, null for a <see cref="T:System.Nullable`1" /> property.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.FloatParseHandling">
      <summary>
            Specifies how floating point numbers, e.g. 1.0 and 9.9, are parsed when reading JSON text.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.FloatParseHandling.Double">
      <summary>
            Floating point numbers are parsed to <see cref="F:Newtonsoft.Json.FloatParseHandling.Double" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.FloatParseHandling.Decimal">
      <summary>
            Floating point numbers are parsed to <see cref="F:Newtonsoft.Json.FloatParseHandling.Decimal" />.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonContainerAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> how to serialize the object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonContainerAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonContainerAttribute" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonContainerAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonContainerAttribute" /> class with the specified container Id.
            </summary>
      <param name="id">The container Id.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonContainerAttribute.Id">
      <summary>
            Gets or sets the id.
            </summary>
      <value>The id.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonContainerAttribute.Title">
      <summary>
            Gets or sets the title.
            </summary>
      <value>The title.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonContainerAttribute.Description">
      <summary>
            Gets or sets the description.
            </summary>
      <value>The description.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonContainerAttribute.ItemConverterType">
      <summary>
            Gets the collection's items converter.
            </summary>
      <value>The collection's items converter.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonContainerAttribute.IsReference">
      <summary>
            Gets or sets a value that indicates whether to preserve object references.
            </summary>
      <value>
        <c>true</c> to keep object reference; otherwise, <c>false</c>. The default is <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonContainerAttribute.ItemIsReference">
      <summary>
            Gets or sets a value that indicates whether to preserve collection's items references.
            </summary>
      <value>
        <c>true</c> to keep collection's items object references; otherwise, <c>false</c>. The default is <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonContainerAttribute.ItemReferenceLoopHandling">
      <summary>
            Gets or sets the reference loop handling used when serializing the collection's items.
            </summary>
      <value>The reference loop handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonContainerAttribute.ItemTypeNameHandling">
      <summary>
            Gets or sets the type name handling used when serializing the collection's items.
            </summary>
      <value>The type name handling.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonDictionaryAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> how to serialize the collection.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonDictionaryAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonDictionaryAttribute" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonDictionaryAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonDictionaryAttribute" /> class with the specified container Id.
            </summary>
      <param name="id">The container Id.</param>
    </member>
    <member name="T:Newtonsoft.Json.JsonException">
      <summary>
            The exception thrown when an error occurs during Json serialization or deserialization.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonException" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonException" /> class
            with a specified error message.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonException" /> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="T:Newtonsoft.Json.DateFormatHandling">
      <summary>
            Specifies how dates are formatted when writing JSON text.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DateFormatHandling.IsoDateFormat">
      <summary>
            Dates are written in the ISO 8601 format, e.g. "2012-03-21T05:40Z".
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DateFormatHandling.MicrosoftDateFormat">
      <summary>
            Dates are written in the Microsoft JSON format, e.g. "\/Date(1198908717056)\/".
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.DateParseHandling">
      <summary>
            Specifies how date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed when reading JSON text.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DateParseHandling.None">
      <summary>
            Date formatted strings are not parsed to a date type and are read as strings.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DateParseHandling.DateTime">
      <summary>
            Date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed to <see cref="F:Newtonsoft.Json.DateParseHandling.DateTime" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DateParseHandling.DateTimeOffset">
      <summary>
            Date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed to <see cref="F:Newtonsoft.Json.DateParseHandling.DateTimeOffset" />.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.DateTimeZoneHandling">
      <summary>
            Specifies how to treat the time value when converting between string and <see cref="T:System.DateTime" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DateTimeZoneHandling.Local">
      <summary>
            Treat as local time. If the <see cref="T:System.DateTime" /> object represents a Coordinated Universal Time (UTC), it is converted to the local time.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DateTimeZoneHandling.Utc">
      <summary>
            Treat as a UTC. If the <see cref="T:System.DateTime" /> object represents a local time, it is converted to a UTC.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DateTimeZoneHandling.Unspecified">
      <summary>
            Treat as a local time if a <see cref="T:System.DateTime" /> is being converted to a string.
            If a string is being converted to <see cref="T:System.DateTime" />, convert to a local time if a time zone is specified.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DateTimeZoneHandling.RoundtripKind">
      <summary>
            Time zone information should be preserved when converting.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Formatting">
      <summary>
            Specifies formatting options for the <see cref="T:Newtonsoft.Json.JsonTextWriter" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Formatting.None">
      <summary>
            No special formatting is applied. This is the default.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Formatting.Indented">
      <summary>
            Causes child objects to be indented according to the <see cref="P:Newtonsoft.Json.JsonTextWriter.Indentation" /> and <see cref="P:Newtonsoft.Json.JsonTextWriter.IndentChar" /> settings.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonConstructorAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> to use the specified constructor when deserializing that object.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonExtensionDataAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> to deserialize properties with no matching class member into the specified collection
            and write values during serialization.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonExtensionDataAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonExtensionDataAttribute" /> class.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonExtensionDataAttribute.WriteData">
      <summary>
            Gets or sets a value that indicates whether to write extension data when serializing the object.
            </summary>
      <value>
        <c>true</c> to write extension data when serializing the object; otherwise, <c>false</c>. The default is <c>true</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonExtensionDataAttribute.ReadData">
      <summary>
            Gets or sets a value that indicates whether to read extension data when deserializing the object.
            </summary>
      <value>
        <c>true</c> to read extension data when deserializing the object; otherwise, <c>false</c>. The default is <c>true</c>.
            </value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.ITraceWriter">
      <summary>
            Represents a trace writer.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.ITraceWriter.Trace(System.Diagnostics.TraceLevel,System.String,System.Exception)">
      <summary>
            Writes the specified trace level, message and optional exception.
            </summary>
      <param name="level">The <see cref="T:System.Diagnostics.TraceLevel" /> at which to write this trace.</param>
      <param name="message">The trace message.</param>
      <param name="ex">The trace exception. This parameter is optional.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ITraceWriter.LevelFilter">
      <summary>
            Gets the <see cref="T:System.Diagnostics.TraceLevel" /> that will be used to filter the trace messages passed to the writer.
            For example a filter level of <code>Info</code> will exclude <code>Verbose</code> messages and include <code>Info</code>,
            <code>Warning</code> and <code>Error</code> messages.
            </summary>
      <value>The <see cref="T:System.Diagnostics.TraceLevel" /> that will be used to filter the trace messages passed to the writer.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.DiagnosticsTraceWriter">
      <summary>
            Represents a trace writer that writes to the application's <see cref="T:System.Diagnostics.TraceListener" /> instances.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DiagnosticsTraceWriter.Trace(System.Diagnostics.TraceLevel,System.String,System.Exception)">
      <summary>
            Writes the specified trace level, message and optional exception.
            </summary>
      <param name="level">The <see cref="T:System.Diagnostics.TraceLevel" /> at which to write this trace.</param>
      <param name="message">The trace message.</param>
      <param name="ex">The trace exception. This parameter is optional.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.DiagnosticsTraceWriter.LevelFilter">
      <summary>
            Gets the <see cref="T:System.Diagnostics.TraceLevel" /> that will be used to filter the trace messages passed to the writer.
            For example a filter level of <code>Info</code> will exclude <code>Verbose</code> messages and include <code>Info</code>,
            <code>Warning</code> and <code>Error</code> messages.
            </summary>
      <value>
            The <see cref="T:System.Diagnostics.TraceLevel" /> that will be used to filter the trace messages passed to the writer.
            </value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.IValueProvider">
      <summary>
            Provides methods to get and set values.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.IValueProvider.SetValue(System.Object,System.Object)">
      <summary>
            Sets the value.
            </summary>
      <param name="target">The target to set the value on.</param>
      <param name="value">The value to set on the target.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.IValueProvider.GetValue(System.Object)">
      <summary>
            Gets the value.
            </summary>
      <param name="target">The target to get the value from.</param>
      <returns>The value.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.ExpressionValueProvider">
      <summary>
            Get and set values for a <see cref="T:System.Reflection.MemberInfo" /> using dynamic methods.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.ExpressionValueProvider.#ctor(System.Reflection.MemberInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.ExpressionValueProvider" /> class.
            </summary>
      <param name="memberInfo">The member info.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.ExpressionValueProvider.SetValue(System.Object,System.Object)">
      <summary>
            Sets the value.
            </summary>
      <param name="target">The target to set the value on.</param>
      <param name="value">The value to set on the target.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.ExpressionValueProvider.GetValue(System.Object)">
      <summary>
            Gets the value.
            </summary>
      <param name="target">The target to get the value from.</param>
      <returns>The value.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.UnderlyingType">
      <summary>
            Gets the underlying type for the contract.
            </summary>
      <value>The underlying type for the contract.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.CreatedType">
      <summary>
            Gets or sets the type created during deserialization.
            </summary>
      <value>The type created during deserialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.IsReference">
      <summary>
            Gets or sets whether this type contract is serialized as a reference.
            </summary>
      <value>Whether this type contract is serialized as a reference.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.Converter">
      <summary>
            Gets or sets the default <see cref="T:Newtonsoft.Json.JsonConverter" /> for this contract.
            </summary>
      <value>The converter.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnDeserializedCallbacks">
      <summary>
            Gets or sets all methods called immediately after deserialization of the object.
            </summary>
      <value>The methods called immediately after deserialization of the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnDeserializingCallbacks">
      <summary>
            Gets or sets all methods called during deserialization of the object.
            </summary>
      <value>The methods called during deserialization of the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnSerializedCallbacks">
      <summary>
            Gets or sets all methods called after serialization of the object graph.
            </summary>
      <value>The methods called after serialization of the object graph.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnSerializingCallbacks">
      <summary>
            Gets or sets all methods called before serialization of the object.
            </summary>
      <value>The methods called before serialization of the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnErrorCallbacks">
      <summary>
            Gets or sets all method called when an error is thrown during the serialization of the object.
            </summary>
      <value>The methods called when an error is thrown during the serialization of the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnDeserialized">
      <summary>
            Gets or sets the method called immediately after deserialization of the object.
            </summary>
      <value>The method called immediately after deserialization of the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnDeserializing">
      <summary>
            Gets or sets the method called during deserialization of the object.
            </summary>
      <value>The method called during deserialization of the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnSerialized">
      <summary>
            Gets or sets the method called after serialization of the object graph.
            </summary>
      <value>The method called after serialization of the object graph.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnSerializing">
      <summary>
            Gets or sets the method called before serialization of the object.
            </summary>
      <value>The method called before serialization of the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.OnError">
      <summary>
            Gets or sets the method called when an error is thrown during the serialization of the object.
            </summary>
      <value>The method called when an error is thrown during the serialization of the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.DefaultCreator">
      <summary>
            Gets or sets the default creator method used to create the object.
            </summary>
      <value>The default creator method used to create the object.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContract.DefaultCreatorNonPublic">
      <summary>
            Gets or sets a value indicating whether the default creator is non public.
            </summary>
      <value>
        <c>true</c> if the default object creator is non-public; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonContainerContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonContainerContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonContainerContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContainerContract.ItemConverter">
      <summary>
            Gets or sets the default collection items <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
      <value>The converter.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContainerContract.ItemIsReference">
      <summary>
            Gets or sets a value indicating whether the collection items preserve object references.
            </summary>
      <value>
        <c>true</c> if collection items preserve object references; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContainerContract.ItemReferenceLoopHandling">
      <summary>
            Gets or sets the collection item reference loop handling.
            </summary>
      <value>The reference loop handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonContainerContract.ItemTypeNameHandling">
      <summary>
            Gets or sets the collection item type name handling.
            </summary>
      <value>The type name handling.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.MemoryTraceWriter">
      <summary>
            Represents a trace writer that writes to memory. When the trace message limit is
            reached then old trace messages will be removed as new messages are added.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.MemoryTraceWriter.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.MemoryTraceWriter" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.MemoryTraceWriter.Trace(System.Diagnostics.TraceLevel,System.String,System.Exception)">
      <summary>
            Writes the specified trace level, message and optional exception.
            </summary>
      <param name="level">The <see cref="T:System.Diagnostics.TraceLevel" /> at which to write this trace.</param>
      <param name="message">The trace message.</param>
      <param name="ex">The trace exception. This parameter is optional.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.MemoryTraceWriter.GetTraceMessages">
      <summary>
            Returns an enumeration of the most recent trace messages.
            </summary>
      <returns>An enumeration of the most recent trace messages.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.MemoryTraceWriter.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> of the most recent trace messages.
            </summary>
      <returns>
            A <see cref="T:System.String" /> of the most recent trace messages.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.MemoryTraceWriter.LevelFilter">
      <summary>
            Gets the <see cref="T:System.Diagnostics.TraceLevel" /> that will be used to filter the trace messages passed to the writer.
            For example a filter level of <code>Info</code> will exclude <code>Verbose</code> messages and include <code>Info</code>,
            <code>Warning</code> and <code>Error</code> messages.
            </summary>
      <value>
            The <see cref="T:System.Diagnostics.TraceLevel" /> that will be used to filter the trace messages passed to the writer.
            </value>
    </member>
    <member name="T:Newtonsoft.Json.IJsonLineInfo">
      <summary>
            Provides an interface to enable a class to return line and position information.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.IJsonLineInfo.HasLineInfo">
      <summary>
            Gets a value indicating whether the class can return line information.
            </summary>
      <returns>
        <c>true</c> if LineNumber and LinePosition can be provided; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.IJsonLineInfo.LineNumber">
      <summary>
            Gets the current line number.
            </summary>
      <value>The current line number or 0 if no line information is available (for example, HasLineInfo returns false).</value>
    </member>
    <member name="P:Newtonsoft.Json.IJsonLineInfo.LinePosition">
      <summary>
            Gets the current line position.
            </summary>
      <value>The current line position or 0 if no line information is available (for example, HasLineInfo returns false).</value>
    </member>
    <member name="T:Newtonsoft.Json.StringEscapeHandling">
      <summary>
            Specifies how strings are escaped when writing JSON text.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.StringEscapeHandling.Default">
      <summary>
            Only control characters (e.g. newline) are escaped.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.StringEscapeHandling.EscapeNonAscii">
      <summary>
            All non-ASCII and control characters (e.g. newline) are escaped.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.StringEscapeHandling.EscapeHtml">
      <summary>
            HTML (&lt;, &gt;, &amp;, ', ") and control characters (e.g. newline) are escaped.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Linq.IJEnumerable`1">
      <summary>
            Represents a collection of <see cref="T:Newtonsoft.Json.Linq.JToken" /> objects.
            </summary>
      <typeparam name="T">The type of token</typeparam>
    </member>
    <member name="P:Newtonsoft.Json.Linq.IJEnumerable`1.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JToken">
      <summary>
            Represents an abstract JSON token.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.DeepEquals(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Linq.JToken)">
      <summary>
            Compares the values of two tokens, including the values of all descendant tokens.
            </summary>
      <param name="t1">The first <see cref="T:Newtonsoft.Json.Linq.JToken" /> to compare.</param>
      <param name="t2">The second <see cref="T:Newtonsoft.Json.Linq.JToken" /> to compare.</param>
      <returns>true if the tokens are equal; otherwise false.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.AddAfterSelf(System.Object)">
      <summary>
            Adds the specified content immediately after this token.
            </summary>
      <param name="content">A content object that contains simple content or a collection of content objects to be added after this token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.AddBeforeSelf(System.Object)">
      <summary>
            Adds the specified content immediately before this token.
            </summary>
      <param name="content">A content object that contains simple content or a collection of content objects to be added before this token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Ancestors">
      <summary>
            Returns a collection of the ancestor tokens of this token.
            </summary>
      <returns>A collection of the ancestor tokens of this token.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.AfterSelf">
      <summary>
            Returns a collection of the sibling tokens after this token, in document order.
            </summary>
      <returns>A collection of the sibling tokens after this tokens, in document order.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.BeforeSelf">
      <summary>
            Returns a collection of the sibling tokens before this token, in document order.
            </summary>
      <returns>A collection of the sibling tokens before this token, in document order.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Value``1(System.Object)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key converted to the specified type.
            </summary>
      <typeparam name="T">The type to convert the token to.</typeparam>
      <param name="key">The token key.</param>
      <returns>The converted token value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Children">
      <summary>
            Returns a collection of the child tokens of this token, in document order.
            </summary>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the child tokens of this <see cref="T:Newtonsoft.Json.Linq.JToken" />, in document order.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Children``1">
      <summary>
            Returns a collection of the child tokens of this token, in document order, filtered by the specified type.
            </summary>
      <typeparam name="T">The type to filter the child tokens on.</typeparam>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1" /> containing the child tokens of this <see cref="T:Newtonsoft.Json.Linq.JToken" />, in document order.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Values``1">
      <summary>
            Returns a collection of the child values of this token, in document order.
            </summary>
      <typeparam name="T">The type to convert the values to.</typeparam>
      <returns>A <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing the child values of this <see cref="T:Newtonsoft.Json.Linq.JToken" />, in document order.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Remove">
      <summary>
            Removes this token from its parent.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Replace(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Replaces this token with the specified token.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
      <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.ToString">
      <summary>
            Returns the indented JSON for this token.
            </summary>
      <returns>
            The indented JSON for this token.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.ToString(Newtonsoft.Json.Formatting,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Returns the JSON for this token using the given formatting and converters.
            </summary>
      <param name="formatting">Indicates how the output is formatted.</param>
      <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
      <returns>The JSON for this token using the given formatting and converters.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Boolean">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Boolean" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.DateTimeOffset">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.DateTimeOffset" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Boolean}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Int64">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Int64" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.DateTime}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.DateTimeOffset}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Decimal}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Double}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Char}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Int32">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Int32" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Int16">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Int16" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.UInt16">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.UInt16" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Char">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Char" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Byte">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Byte" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.SByte">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.SByte" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Int32}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Int16}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.UInt16}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Byte}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.SByte}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.DateTime">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.DateTime" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Int64}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Single}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Decimal">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Decimal" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.UInt32}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.UInt64}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Nullable`1" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Double">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Double" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Single">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Single" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.String">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.String" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.UInt32">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.UInt32" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.UInt64">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.UInt64" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Byte[]">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Byte[]" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Guid">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Guid" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.Guid}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Guid" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.TimeSpan">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.TimeSpan" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Nullable{System.TimeSpan}">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.TimeSpan" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Explicit(Newtonsoft.Json.Linq.JToken)~System.Uri">
      <summary>
            Performs an explicit conversion from <see cref="T:Newtonsoft.Json.Linq.JToken" /> to <see cref="T:System.Uri" />.
            </summary>
      <param name="value">The value.</param>
      <returns>The result of the conversion.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Boolean)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Boolean" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.DateTimeOffset)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.DateTimeOffset" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Byte)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Byte" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Byte})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.SByte)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.SByte" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.SByte})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Boolean})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Int64)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.DateTime})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.DateTimeOffset})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Decimal})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Double})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Int16)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Int16" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.UInt16)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.UInt16" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Int32)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Int32" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Int32})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.DateTime)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.DateTime" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Int64})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Single})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Decimal)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Decimal" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Int16})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.UInt16})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.UInt32})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.UInt64})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Double)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Double" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Single)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Single" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.String)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.String" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.UInt32)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.UInt32" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.UInt64)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.UInt64" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Byte[])~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Byte[]" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Uri)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Uri" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.TimeSpan)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.TimeSpan" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.TimeSpan})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Guid)~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Guid" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.op_Implicit(System.Nullable{System.Guid})~Newtonsoft.Json.Linq.JToken">
      <summary>
            Performs an implicit conversion from <see cref="T:System.Nullable`1" /> to <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="value">The value to create a <see cref="T:Newtonsoft.Json.Linq.JValue" /> from.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JValue" /> initialized with the specified value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.CreateReader">
      <summary>
            Creates an <see cref="T:Newtonsoft.Json.JsonReader" /> for this token.
            </summary>
      <returns>An <see cref="T:Newtonsoft.Json.JsonReader" /> that can be used to read this token and its descendants.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.FromObject(System.Object)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from an object.
            </summary>
      <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the value of the specified object</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.FromObject(System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from an object using the specified <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
      <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
      <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer" /> that will be used when reading the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the value of the specified object</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.ToObject``1">
      <summary>
            Creates the specified .NET type from the <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <typeparam name="T">The object type that the token will be deserialized to.</typeparam>
      <returns>The new object created from the JSON value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.ToObject(System.Type)">
      <summary>
            Creates the specified .NET type from the <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="objectType">The object type that the token will be deserialized to.</param>
      <returns>The new object created from the JSON value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.ToObject``1(Newtonsoft.Json.JsonSerializer)">
      <summary>
            Creates the specified .NET type from the <see cref="T:Newtonsoft.Json.Linq.JToken" /> using the specified <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
      <typeparam name="T">The object type that the token will be deserialized to.</typeparam>
      <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer" /> that will be used when creating the object.</param>
      <returns>The new object created from the JSON value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.ToObject(System.Type,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Creates the specified .NET type from the <see cref="T:Newtonsoft.Json.Linq.JToken" /> using the specified <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
      <param name="objectType">The object type that the token will be deserialized to.</param>
      <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer" /> that will be used when creating the object.</param>
      <returns>The new object created from the JSON value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.ReadFrom(Newtonsoft.Json.JsonReader)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
      <param name="reader">An <see cref="T:Newtonsoft.Json.JsonReader" /> positioned at the token to read into this <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
      <returns>
            An <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the token and its descendant tokens
            that were read from the reader. The runtime type of the token is determined
            by the token type of the first token encountered in the reader.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Parse(System.String)">
      <summary>
            Load a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from a string that contains JSON.
            </summary>
      <param name="json">A <see cref="T:System.String" /> that contains JSON.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken" /> populated from the string that contains JSON.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.Load(Newtonsoft.Json.JsonReader)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JToken" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
      <param name="reader">An <see cref="T:Newtonsoft.Json.JsonReader" /> positioned at the token to read into this <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
      <returns>
            An <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the token and its descendant tokens
            that were read from the reader. The runtime type of the token is determined
            by the token type of the first token encountered in the reader.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.SelectToken(System.String)">
      <summary>
            Selects a <see cref="T:Newtonsoft.Json.Linq.JToken" /> using a JPath expression. Selects the token that matches the object path.
            </summary>
      <param name="path">
            A <see cref="T:System.String" /> that contains a JPath expression.
            </param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken" />, or null.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.SelectToken(System.String,System.Boolean)">
      <summary>
            Selects a <see cref="T:Newtonsoft.Json.Linq.JToken" /> using a JPath expression. Selects the token that matches the object path.
            </summary>
      <param name="path">
            A <see cref="T:System.String" /> that contains a JPath expression.
            </param>
      <param name="errorWhenNoMatch">A flag to indicate whether an error should be thrown if no tokens are found when evaluating part of the expression.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JToken" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.SelectTokens(System.String)">
      <summary>
            Selects a collection of elements using a JPath expression.
            </summary>
      <param name="path">
            A <see cref="T:System.String" /> that contains a JPath expression.
            </param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the selected elements.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.SelectTokens(System.String,System.Boolean)">
      <summary>
            Selects a collection of elements using a JPath expression.
            </summary>
      <param name="path">
            A <see cref="T:System.String" /> that contains a JPath expression.
            </param>
      <param name="errorWhenNoMatch">A flag to indicate whether an error should be thrown if no tokens are found when evaluating part of the expression.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the selected elements.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>
            Returns the <see cref="T:System.Dynamic.DynamicMetaObject" /> responsible for binding operations performed on this object.
            </summary>
      <param name="parameter">The expression tree representation of the runtime value.</param>
      <returns>
            The <see cref="T:System.Dynamic.DynamicMetaObject" /> to bind this object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JToken.DeepClone">
      <summary>
            Creates a new instance of the <see cref="T:Newtonsoft.Json.Linq.JToken" />. All child tokens are recursively cloned.
            </summary>
      <returns>A new instance of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.</returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.EqualityComparer">
      <summary>
            Gets a comparer that can compare two tokens for value equality.
            </summary>
      <value>A <see cref="T:Newtonsoft.Json.Linq.JTokenEqualityComparer" /> that can compare two nodes for value equality.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Parent">
      <summary>
            Gets or sets the parent.
            </summary>
      <value>The parent.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Root">
      <summary>
            Gets the root <see cref="T:Newtonsoft.Json.Linq.JToken" /> of this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <value>The root <see cref="T:Newtonsoft.Json.Linq.JToken" /> of this <see cref="T:Newtonsoft.Json.Linq.JToken" />.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Type">
      <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <value>The type.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.HasValues">
      <summary>
            Gets a value indicating whether this token has child tokens.
            </summary>
      <value>
        <c>true</c> if this token has child values; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Next">
      <summary>
            Gets the next sibling token of this node.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the next sibling token.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Previous">
      <summary>
            Gets the previous sibling token of this node.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the previous sibling token.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Path">
      <summary>
            Gets the path of the JSON token. 
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.First">
      <summary>
            Get the first child token of this token.
            </summary>
      <value>A <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the first child token of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JToken.Last">
      <summary>
            Get the last child token of this token.
            </summary>
      <value>A <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the last child token of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.</value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JValue">
      <summary>
            Represents a value in JSON (string, integer, date, etc).
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(Newtonsoft.Json.Linq.JValue)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class from another <see cref="T:Newtonsoft.Json.Linq.JValue" /> object.
            </summary>
      <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JValue" /> object to copy from.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Int64)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Decimal)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Char)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.UInt64)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Double)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Single)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.DateTime)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.DateTimeOffset)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Guid)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Uri)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.TimeSpan)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JValue" /> class with the given value.
            </summary>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.CreateComment(System.String)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JValue" /> comment with the given value.
            </summary>
      <param name="value">The value.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JValue" /> comment with the given value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.CreateString(System.String)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JValue" /> string with the given value.
            </summary>
      <param name="value">The value.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JValue" /> string with the given value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
      <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.Equals(Newtonsoft.Json.Linq.JValue)">
      <summary>
            Indicates whether the current object is equal to another object of the same type.
            </summary>
      <returns>
            true if the current object is equal to the <paramref name="other" /> parameter; otherwise, false.
            </returns>
      <param name="other">An object to compare with this object.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with the current <see cref="T:System.Object" />.</param>
      <returns>
            true if the specified <see cref="T:System.Object" /> is equal to the current <see cref="T:System.Object" />; otherwise, false.
            </returns>
      <exception cref="T:System.NullReferenceException">
            The <paramref name="obj" /> parameter is null.
            </exception>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.GetHashCode">
      <summary>
            Serves as a hash function for a particular type.
            </summary>
      <returns>
            A hash code for the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.ToString(System.String)">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <param name="format">The format.</param>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.ToString(System.IFormatProvider)">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <param name="formatProvider">The format provider.</param>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.ToString(System.String,System.IFormatProvider)">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <param name="format">The format.</param>
      <param name="formatProvider">The format provider.</param>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>
            Returns the <see cref="T:System.Dynamic.DynamicMetaObject" /> responsible for binding operations performed on this object.
            </summary>
      <param name="parameter">The expression tree representation of the runtime value.</param>
      <returns>
            The <see cref="T:System.Dynamic.DynamicMetaObject" /> to bind this object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JValue.CompareTo(Newtonsoft.Json.Linq.JValue)">
      <summary>
            Compares the current instance with another object of the same type and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.
            </summary>
      <param name="obj">An object to compare with this instance.</param>
      <returns>
            A 32-bit signed integer that indicates the relative order of the objects being compared. The return value has these meanings:
            Value
            Meaning
            Less than zero
            This instance is less than <paramref name="obj" />.
            Zero
            This instance is equal to <paramref name="obj" />.
            Greater than zero
            This instance is greater than <paramref name="obj" />.
            </returns>
      <exception cref="T:System.ArgumentException">
        <paramref name="obj" /> is not the same type as this instance.
            </exception>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JValue.HasValues">
      <summary>
            Gets a value indicating whether this token has child tokens.
            </summary>
      <value>
        <c>true</c> if this token has child values; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JValue.Type">
      <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <value>The type.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JValue.Value">
      <summary>
            Gets or sets the underlying token value.
            </summary>
      <value>The underlying token value.</value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JRaw">
      <summary>
            Represents a raw JSON string.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JRaw.#ctor(Newtonsoft.Json.Linq.JRaw)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JRaw" /> class from another <see cref="T:Newtonsoft.Json.Linq.JRaw" /> object.
            </summary>
      <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JRaw" /> object to copy from.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JRaw.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JRaw" /> class.
            </summary>
      <param name="rawJson">The raw json.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JRaw.Create(Newtonsoft.Json.JsonReader)">
      <summary>
            Creates an instance of <see cref="T:Newtonsoft.Json.Linq.JRaw" /> with the content of the reader's current token.
            </summary>
      <param name="reader">The reader.</param>
      <returns>An instance of <see cref="T:Newtonsoft.Json.Linq.JRaw" /> with the content of the reader's current token.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Required">
      <summary>
            Indicating whether a property is required.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Required.Default">
      <summary>
            The property is not required. The default state.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Required.AllowNull">
      <summary>
            The property must be defined in JSON but can be a null value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Required.Always">
      <summary>
            The property must be defined in JSON and cannot be a null value.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonDynamicContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonDynamicContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonDynamicContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonDynamicContract.Properties">
      <summary>
            Gets the object's properties.
            </summary>
      <value>The object's properties.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonDynamicContract.PropertyNameResolver">
      <summary>
            Gets or sets the property name resolver.
            </summary>
      <value>The property name resolver.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonISerializableContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonISerializableContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonISerializableContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonISerializableContract.ISerializableCreator">
      <summary>
            Gets or sets the ISerializable object constructor.
            </summary>
      <value>The ISerializable object constructor.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonLinqContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonLinqContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonLinqContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonPrimitiveContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonPrimitiveContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonPrimitiveContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.DynamicValueProvider">
      <summary>
            Get and set values for a <see cref="T:System.Reflection.MemberInfo" /> using dynamic methods.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DynamicValueProvider.#ctor(System.Reflection.MemberInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.DynamicValueProvider" /> class.
            </summary>
      <param name="memberInfo">The member info.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DynamicValueProvider.SetValue(System.Object,System.Object)">
      <summary>
            Sets the value.
            </summary>
      <param name="target">The target to set the value on.</param>
      <param name="value">The value to set on the target.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DynamicValueProvider.GetValue(System.Object)">
      <summary>
            Gets the value.
            </summary>
      <param name="target">The target to get the value from.</param>
      <returns>The value.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.ErrorEventArgs">
      <summary>
            Provides data for the Error event.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.ErrorEventArgs.#ctor(System.Object,Newtonsoft.Json.Serialization.ErrorContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.ErrorEventArgs" /> class.
            </summary>
      <param name="currentObject">The current object.</param>
      <param name="errorContext">The error context.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ErrorEventArgs.CurrentObject">
      <summary>
            Gets the current object the error event is being raised against.
            </summary>
      <value>The current object the error event is being raised against.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ErrorEventArgs.ErrorContext">
      <summary>
            Gets the error context.
            </summary>
      <value>The error context.</value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JPropertyDescriptor">
      <summary>
            Represents a view of a <see cref="T:Newtonsoft.Json.Linq.JProperty" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JPropertyDescriptor" /> class.
            </summary>
      <param name="name">The name.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.CanResetValue(System.Object)">
      <summary>
            When overridden in a derived class, returns whether resetting an object changes its value.
            </summary>
      <returns>
            true if resetting the component changes its value; otherwise, false.
            </returns>
      <param name="component">The component to test for reset capability. 
                            </param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.GetValue(System.Object)">
      <summary>
            When overridden in a derived class, gets the current value of the property on a component.
            </summary>
      <returns>
            The value of a property for a given component.
            </returns>
      <param name="component">The component with the property for which to retrieve the value. 
                            </param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.ResetValue(System.Object)">
      <summary>
            When overridden in a derived class, resets the value for this property of the component to the default value.
            </summary>
      <param name="component">The component with the property value that is to be reset to the default value. 
                            </param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.SetValue(System.Object,System.Object)">
      <summary>
            When overridden in a derived class, sets the value of the component to a different value.
            </summary>
      <param name="component">The component with the property value that is to be set. 
                            </param>
      <param name="value">The new value. 
                            </param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JPropertyDescriptor.ShouldSerializeValue(System.Object)">
      <summary>
            When overridden in a derived class, determines a value indicating whether the value of this property needs to be persisted.
            </summary>
      <returns>
            true if the property should be persisted; otherwise, false.
            </returns>
      <param name="component">The component with the property to be examined for persistence. 
                            </param>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JPropertyDescriptor.ComponentType">
      <summary>
            When overridden in a derived class, gets the type of the component this property is bound to.
            </summary>
      <returns>
            A <see cref="T:System.Type" /> that represents the type of component this property is bound to. When the <see cref="M:System.ComponentModel.PropertyDescriptor.GetValue(System.Object)" /> or <see cref="M:System.ComponentModel.PropertyDescriptor.SetValue(System.Object,System.Object)" /> methods are invoked, the object specified might be an instance of this type.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JPropertyDescriptor.IsReadOnly">
      <summary>
            When overridden in a derived class, gets a value indicating whether this property is read-only.
            </summary>
      <returns>
            true if the property is read-only; otherwise, false.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JPropertyDescriptor.PropertyType">
      <summary>
            When overridden in a derived class, gets the type of the property.
            </summary>
      <returns>
            A <see cref="T:System.Type" /> that represents the type of the property.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JPropertyDescriptor.NameHashCode">
      <summary>
            Gets the hash code for the name of the member.
            </summary>
      <value>
      </value>
      <returns>
            The hash code for the name of the member.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.IReferenceResolver">
      <summary>
            Used to resolve references when serializing and deserializing JSON by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.IReferenceResolver.ResolveReference(System.Object,System.String)">
      <summary>
            Resolves a reference to its object.
            </summary>
      <param name="context">The serialization context.</param>
      <param name="reference">The reference to resolve.</param>
      <returns>The object that</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.IReferenceResolver.GetReference(System.Object,System.Object)">
      <summary>
            Gets the reference for the sepecified object.
            </summary>
      <param name="context">The serialization context.</param>
      <param name="value">The object to get a reference for.</param>
      <returns>The reference to the object.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.IReferenceResolver.IsReferenced(System.Object,System.Object)">
      <summary>
            Determines whether the specified object is referenced.
            </summary>
      <param name="context">The serialization context.</param>
      <param name="value">The object to test for a reference.</param>
      <returns>
        <c>true</c> if the specified object is referenced; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.IReferenceResolver.AddReference(System.Object,System.String,System.Object)">
      <summary>
            Adds a reference to the specified object.
            </summary>
      <param name="context">The serialization context.</param>
      <param name="reference">The reference.</param>
      <param name="value">The object to reference.</param>
    </member>
    <member name="T:Newtonsoft.Json.PreserveReferencesHandling">
      <summary>
            Specifies reference handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            Note that references cannot be preserved when a value is set via a non-default constructor such as types that implement ISerializable.
            </summary>
      <example>
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="PreservingObjectReferencesOn" title="Preserve Object References" />
      </example>
    </member>
    <member name="F:Newtonsoft.Json.PreserveReferencesHandling.None">
      <summary>
            Do not preserve references when serializing types.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.PreserveReferencesHandling.Objects">
      <summary>
            Preserve references when serializing into a JSON object structure.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.PreserveReferencesHandling.Arrays">
      <summary>
            Preserve references when serializing into a JSON array structure.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.PreserveReferencesHandling.All">
      <summary>
            Preserve references when serializing.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonArrayAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> how to serialize the collection.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonArrayAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonArrayAttribute" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonArrayAttribute.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonObjectAttribute" /> class with a flag indicating whether the array can contain null items
            </summary>
      <param name="allowNullItems">A flag indicating whether the array can contain null items.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonArrayAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonArrayAttribute" /> class with the specified container Id.
            </summary>
      <param name="id">The container Id.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonArrayAttribute.AllowNullItems">
      <summary>
            Gets or sets a value indicating whether null items are allowed in the collection.
            </summary>
      <value>
        <c>true</c> if null items are allowed in the collection; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Newtonsoft.Json.DefaultValueHandling">
      <summary>
            Specifies default value handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
      <example>
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeDefaultValueHandlingObject" title="DefaultValueHandling Class" />
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeDefaultValueHandlingExample" title="DefaultValueHandling Ignore Example" />
      </example>
    </member>
    <member name="F:Newtonsoft.Json.DefaultValueHandling.Include">
      <summary>
            Include members where the member value is the same as the member's default value when serializing objects.
            Included members are written to JSON. Has no effect when deserializing.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DefaultValueHandling.Ignore">
      <summary>
            Ignore members where the member value is the same as the member's default value when serializing objects
            so that is is not written to JSON.
            This option will ignore all default values (e.g. <c>null</c> for objects and nullable typesl; <c>0</c> for integers,
            decimals and floating point numbers; and <c>false</c> for booleans). The default value ignored can be changed by
            placing the <see cref="T:System.ComponentModel.DefaultValueAttribute" /> on the property.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DefaultValueHandling.Populate">
      <summary>
            Members with a default value but no JSON will be set to their default value when deserializing.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.DefaultValueHandling.IgnoreAndPopulate">
      <summary>
            Ignore members where the member value is the same as the member's default value when serializing objects
            and sets members to their default value when deserializing.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonConverterAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> to use the specified <see cref="T:Newtonsoft.Json.JsonConverter" /> when serializing the member or class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonConverterAttribute.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonConverterAttribute" /> class.
            </summary>
      <param name="converterType">Type of the converter.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonConverterAttribute.ConverterType">
      <summary>
            Gets the type of the converter.
            </summary>
      <value>The type of the converter.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonObjectAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> how to serialize the object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonObjectAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonObjectAttribute" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonObjectAttribute.#ctor(Newtonsoft.Json.MemberSerialization)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonObjectAttribute" /> class with the specified member serialization.
            </summary>
      <param name="memberSerialization">The member serialization.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonObjectAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonObjectAttribute" /> class with the specified container Id.
            </summary>
      <param name="id">The container Id.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonObjectAttribute.MemberSerialization">
      <summary>
            Gets or sets the member serialization.
            </summary>
      <value>The member serialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonObjectAttribute.ItemRequired">
      <summary>
            Gets or sets a value that indicates whether the object's properties are required.
            </summary>
      <value>
            	A value indicating whether the object's properties are required.
            </value>
    </member>
    <member name="T:Newtonsoft.Json.JsonSerializerSettings">
      <summary>
            Specifies the settings on a <see cref="T:Newtonsoft.Json.JsonSerializer" /> object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializerSettings.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> class.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.ReferenceLoopHandling">
      <summary>
            Gets or sets how reference loops (e.g. a class referencing itself) is handled.
            </summary>
      <value>Reference loop handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.MissingMemberHandling">
      <summary>
            Gets or sets how missing members (e.g. JSON contains a property that isn't a member on the object) are handled during deserialization.
            </summary>
      <value>Missing member handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.ObjectCreationHandling">
      <summary>
            Gets or sets how objects are created during deserialization.
            </summary>
      <value>The object creation handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.NullValueHandling">
      <summary>
            Gets or sets how null values are handled during serialization and deserialization.
            </summary>
      <value>Null value handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.DefaultValueHandling">
      <summary>
            Gets or sets how null default are handled during serialization and deserialization.
            </summary>
      <value>The default value handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.Converters">
      <summary>
            Gets or sets a collection <see cref="T:Newtonsoft.Json.JsonConverter" /> that will be used during serialization.
            </summary>
      <value>The converters.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.PreserveReferencesHandling">
      <summary>
            Gets or sets how object references are preserved by the serializer.
            </summary>
      <value>The preserve references handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.TypeNameHandling">
      <summary>
            Gets or sets how type name writing and reading is handled by the serializer.
            </summary>
      <value>The type name handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.TypeNameAssemblyFormat">
      <summary>
            Gets or sets how a type name assembly is written and resolved by the serializer.
            </summary>
      <value>The type name assembly format.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.ConstructorHandling">
      <summary>
            Gets or sets how constructors are used during deserialization.
            </summary>
      <value>The constructor handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.ContractResolver">
      <summary>
            Gets or sets the contract resolver used by the serializer when
            serializing .NET objects to JSON and vice versa.
            </summary>
      <value>The contract resolver.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.ReferenceResolver">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Serialization.IReferenceResolver" /> used by the serializer when resolving references.
            </summary>
      <value>The reference resolver.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.TraceWriter">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Serialization.ITraceWriter" /> used by the serializer when writing trace messages.
            </summary>
      <value>The trace writer.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.Binder">
      <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.SerializationBinder" /> used by the serializer when resolving type names.
            </summary>
      <value>The binder.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.Error">
      <summary>
            Gets or sets the error handler called during serialization and deserialization.
            </summary>
      <value>The error handler called during serialization and deserialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.Context">
      <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.StreamingContext" /> used by the serializer when invoking serialization callback methods.
            </summary>
      <value>The context.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.DateFormatString">
      <summary>
            Get or set how <see cref="T:System.DateTime" /> and <see cref="T:System.DateTimeOffset" /> values are formatting when writing JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.MaxDepth">
      <summary>
            Gets or sets the maximum depth allowed when reading JSON. Reading past this depth will throw a <see cref="T:Newtonsoft.Json.JsonReaderException" />.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.Formatting">
      <summary>
            Indicates how JSON text output is formatted.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.DateFormatHandling">
      <summary>
            Get or set how dates are written to JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.DateTimeZoneHandling">
      <summary>
            Get or set how <see cref="T:System.DateTime" /> time zones are handling during serialization and deserialization.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.DateParseHandling">
      <summary>
            Get or set how date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed when reading JSON.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.FloatFormatHandling">
      <summary>
            Get or set how special floating point numbers, e.g. <see cref="F:System.Double.NaN" />,
            <see cref="F:System.Double.PositiveInfinity" /> and <see cref="F:System.Double.NegativeInfinity" />,
            are written as JSON.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.FloatParseHandling">
      <summary>
            Get or set how floating point numbers, e.g. 1.0 and 9.9, are parsed when reading JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.StringEscapeHandling">
      <summary>
            Get or set how strings are escaped when writing JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.Culture">
      <summary>
            Gets or sets the culture used when reading JSON. Defaults to <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializerSettings.CheckAdditionalContent">
      <summary>
            Gets a value indicating whether there will be a check for additional content after deserializing an object.
            </summary>
      <value>
        <c>true</c> if there will be a check for additional content after deserializing an object; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Newtonsoft.Json.JsonValidatingReader">
      <summary>
            Represents a reader that provides <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> validation.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonValidatingReader.#ctor(Newtonsoft.Json.JsonReader)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonValidatingReader" /> class that
            validates the content returned from the given <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from while validating.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonValidatingReader.ReadAsInt32">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonValidatingReader.ReadAsBytes">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:Byte[]" />.
            </summary>
      <returns>
            A <see cref="T:Byte[]" /> or a null reference if the next JSON token is null.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonValidatingReader.ReadAsDecimal">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonValidatingReader.ReadAsString">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.String" />.
            </summary>
      <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonValidatingReader.ReadAsDateTime">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonValidatingReader.ReadAsDateTimeOffset">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonValidatingReader.Read">
      <summary>
            Reads the next JSON token from the stream.
            </summary>
      <returns>
            true if the next token was read successfully; false if there are no more tokens to read.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.Value">
      <summary>
            Gets the text value of the current JSON token.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.Depth">
      <summary>
            Gets the depth of the current token in the JSON document.
            </summary>
      <value>The depth of the current token in the JSON document.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.Path">
      <summary>
            Gets the path of the current JSON token. 
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.QuoteChar">
      <summary>
            Gets the quotation mark character used to enclose the value of a string.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.TokenType">
      <summary>
            Gets the type of the current JSON token.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.ValueType">
      <summary>
            Gets the Common Language Runtime (CLR) type for the current JSON token.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.Schema">
      <summary>
            Gets or sets the schema.
            </summary>
      <value>The schema.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonValidatingReader.Reader">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.JsonReader" /> used to construct this <see cref="T:Newtonsoft.Json.JsonValidatingReader" />.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.JsonReader" /> specified in the constructor.</value>
    </member>
    <member name="E:Newtonsoft.Json.JsonValidatingReader.ValidationEventHandler">
      <summary>
            Sets an event handler for receiving schema validation errors.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JTokenEqualityComparer">
      <summary>
            Compares tokens to determine whether they are equal.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenEqualityComparer.Equals(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Linq.JToken)">
      <summary>
            Determines whether the specified objects are equal.
            </summary>
      <param name="x">The first object of type <see cref="T:Newtonsoft.Json.Linq.JToken" /> to compare.</param>
      <param name="y">The second object of type <see cref="T:Newtonsoft.Json.Linq.JToken" /> to compare.</param>
      <returns>
            true if the specified objects are equal; otherwise, false.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenEqualityComparer.GetHashCode(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Returns a hash code for the specified object.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> for which a hash code is to be returned.</param>
      <returns>A hash code for the specified object.</returns>
      <exception cref="T:System.ArgumentNullException">The type of <paramref name="obj" /> is a reference type and <paramref name="obj" /> is null.</exception>
    </member>
    <member name="T:Newtonsoft.Json.MemberSerialization">
      <summary>
            Specifies the member serialization options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.MemberSerialization.OptOut">
      <summary>
            All public members are serialized by default. Members can be excluded using <see cref="T:Newtonsoft.Json.JsonIgnoreAttribute" /> or <see cref="T:System.NonSerializedAttribute" />.
            This is the default member serialization mode.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.MemberSerialization.OptIn">
      <summary>
            Only members must be marked with <see cref="T:Newtonsoft.Json.JsonPropertyAttribute" /> or <see cref="T:System.Runtime.Serialization.DataMemberAttribute" /> are serialized.
            This member serialization mode can also be set by marking the class with <see cref="T:System.Runtime.Serialization.DataContractAttribute" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.MemberSerialization.Fields">
      <summary>
            All public and private fields are serialized. Members can be excluded using <see cref="T:Newtonsoft.Json.JsonIgnoreAttribute" /> or <see cref="T:System.NonSerializedAttribute" />.
            This member serialization mode can also be set by marking the class with <see cref="T:System.SerializableAttribute" />
            and setting IgnoreSerializableAttribute on <see cref="T:Newtonsoft.Json.Serialization.DefaultContractResolver" /> to false.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.ObjectCreationHandling">
      <summary>
            Specifies how object creation is handled by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ObjectCreationHandling.Auto">
      <summary>
            Reuse existing objects, create new objects when needed.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ObjectCreationHandling.Reuse">
      <summary>
            Only reuse existing objects.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ObjectCreationHandling.Replace">
      <summary>
            Always create new objects.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Converters.IsoDateTimeConverter">
      <summary>
            Converts a <see cref="T:System.DateTime" /> to and from the ISO 8601 date format (e.g. 2008-04-12T12:53Z).
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.IsoDateTimeConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.IsoDateTimeConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="P:Newtonsoft.Json.Converters.IsoDateTimeConverter.DateTimeStyles">
      <summary>
            Gets or sets the date time styles used when converting a date to and from JSON.
            </summary>
      <value>The date time styles used when converting a date to and from JSON.</value>
    </member>
    <member name="P:Newtonsoft.Json.Converters.IsoDateTimeConverter.DateTimeFormat">
      <summary>
            Gets or sets the date time format used when converting a date to and from JSON.
            </summary>
      <value>The date time format used when converting a date to and from JSON.</value>
    </member>
    <member name="P:Newtonsoft.Json.Converters.IsoDateTimeConverter.Culture">
      <summary>
            Gets or sets the culture used when converting a date to and from JSON.
            </summary>
      <value>The culture used when converting a date to and from JSON.</value>
    </member>
    <member name="T:Newtonsoft.Json.Converters.JavaScriptDateTimeConverter">
      <summary>
            Converts a <see cref="T:System.DateTime" /> to and from a JavaScript date constructor (e.g. new Date(52231943)).
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.JavaScriptDateTimeConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="value">The value.</param>
      <param name="serializer">The calling serializer.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.JavaScriptDateTimeConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing property value of the JSON that is being converted.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Converters.XmlNodeConverter">
      <summary>
            Converts XML to and from JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Converters.XmlNodeConverter.WriteJson(Newtonsoft.Json.JsonWriter,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Writes the JSON representation of the object.
            </summary>
      <param name="writer">The <see cref="T:Newtonsoft.Json.JsonWriter" /> to write to.</param>
      <param name="serializer">The calling serializer.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Converters.XmlNodeConverter.ReadJson(Newtonsoft.Json.JsonReader,System.Type,System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Reads the JSON representation of the object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> to read from.</param>
      <param name="objectType">Type of the object.</param>
      <param name="existingValue">The existing value of object being read.</param>
      <param name="serializer">The calling serializer.</param>
      <returns>The object value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.XmlNodeConverter.IsNamespaceAttribute(System.String,System.String@)">
      <summary>
            Checks if the attributeName is a namespace attribute.
            </summary>
      <param name="attributeName">Attribute name to test.</param>
      <param name="prefix">The attribute name prefix if it has one, otherwise an empty string.</param>
      <returns>True if attribute name is for a namespace attribute, otherwise false.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Converters.XmlNodeConverter.CanConvert(System.Type)">
      <summary>
            Determines whether this instance can convert the specified value type.
            </summary>
      <param name="valueType">Type of the value.</param>
      <returns>
        <c>true</c> if this instance can convert the specified value type; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Converters.XmlNodeConverter.DeserializeRootElementName">
      <summary>
            Gets or sets the name of the root element to insert when deserializing to XML if the JSON structure has produces multiple root elements.
            </summary>
      <value>The name of the deserialize root element.</value>
    </member>
    <member name="P:Newtonsoft.Json.Converters.XmlNodeConverter.WriteArrayAttribute">
      <summary>
            Gets or sets a flag to indicate whether to write the Json.NET array attribute.
            This attribute helps preserve arrays when converting the written XML back to JSON.
            </summary>
      <value>
        <c>true</c> if the array attibute is written to the XML; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.Converters.XmlNodeConverter.OmitRootObject">
      <summary>
            Gets or sets a value indicating whether to write the root JSON object.
            </summary>
      <value>
        <c>true</c> if the JSON root object is omitted; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonTextReader">
      <summary>
            Represents a reader that provides fast, non-cached, forward-only access to JSON text data.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.#ctor(System.IO.TextReader)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReader" /> class with the specified <see cref="T:System.IO.TextReader" />.
            </summary>
      <param name="reader">The <c>TextReader</c> containing the XML data to read.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.Read">
      <summary>
            Reads the next JSON token from the stream.
            </summary>
      <returns>
            true if the next token was read successfully; false if there are no more tokens to read.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.ReadAsBytes">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:Byte[]" />.
            </summary>
      <returns>
            A <see cref="T:Byte[]" /> or a null reference if the next JSON token is null. This method will return <c>null</c> at the end of an array.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.ReadAsDecimal">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.ReadAsInt32">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.ReadAsString">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.String" />.
            </summary>
      <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.ReadAsDateTime">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.ReadAsDateTimeOffset">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.DateTimeOffset" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.Close">
      <summary>
            Changes the state to closed. 
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextReader.HasLineInfo">
      <summary>
            Gets a value indicating whether the class can return line information.
            </summary>
      <returns>
        <c>true</c> if LineNumber and LinePosition can be provided; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.JsonTextReader.LineNumber">
      <summary>
            Gets the current line number.
            </summary>
      <value>
            The current line number or 0 if no line information is available (for example, HasLineInfo returns false).
            </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonTextReader.LinePosition">
      <summary>
            Gets the current line position.
            </summary>
      <value>
            The current line position or 0 if no line information is available (for example, HasLineInfo returns false).
            </value>
    </member>
    <member name="T:Newtonsoft.Json.JsonPropertyAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> to always serialize the member with the specified name.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonPropertyAttribute.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonPropertyAttribute" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonPropertyAttribute.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonPropertyAttribute" /> class with the specified name.
            </summary>
      <param name="propertyName">Name of the property.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.ItemConverterType">
      <summary>
            Gets or sets the converter used when serializing the property's collection items.
            </summary>
      <value>The collection's items converter.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.NullValueHandling">
      <summary>
            Gets or sets the null value handling used when serializing this property.
            </summary>
      <value>The null value handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.DefaultValueHandling">
      <summary>
            Gets or sets the default value handling used when serializing this property.
            </summary>
      <value>The default value handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.ReferenceLoopHandling">
      <summary>
            Gets or sets the reference loop handling used when serializing this property.
            </summary>
      <value>The reference loop handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.ObjectCreationHandling">
      <summary>
            Gets or sets the object creation handling used when deserializing this property.
            </summary>
      <value>The object creation handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.TypeNameHandling">
      <summary>
            Gets or sets the type name handling used when serializing this property.
            </summary>
      <value>The type name handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.IsReference">
      <summary>
            Gets or sets whether this property's value is serialized as a reference.
            </summary>
      <value>Whether this property's value is serialized as a reference.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.Order">
      <summary>
            Gets or sets the order of serialization and deserialization of a member.
            </summary>
      <value>The numeric order of serialization or deserialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.Required">
      <summary>
            Gets or sets a value indicating whether this property is required.
            </summary>
      <value>
            	A value indicating whether this property is required.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.PropertyName">
      <summary>
            Gets or sets the name of the property.
            </summary>
      <value>The name of the property.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.ItemReferenceLoopHandling">
      <summary>
            Gets or sets the the reference loop handling used when serializing the property's collection items.
            </summary>
      <value>The collection's items reference loop handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.ItemTypeNameHandling">
      <summary>
            Gets or sets the the type name handling used when serializing the property's collection items.
            </summary>
      <value>The collection's items type name handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonPropertyAttribute.ItemIsReference">
      <summary>
            Gets or sets whether this property's collection items are serialized as a reference.
            </summary>
      <value>Whether this property's collection items are serialized as a reference.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonIgnoreAttribute">
      <summary>
            Instructs the <see cref="T:Newtonsoft.Json.JsonSerializer" /> not to serialize the public field or public read/write property value.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonTextWriter">
      <summary>
            Represents a writer that provides a fast, non-cached, forward-only way of generating Json data.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.#ctor(System.IO.TextWriter)">
      <summary>
            Creates an instance of the <c>JsonWriter</c> class using the specified <see cref="T:System.IO.TextWriter" />. 
            </summary>
      <param name="textWriter">The <c>TextWriter</c> to write to.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.Flush">
      <summary>
            Flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.Close">
      <summary>
            Closes this stream and the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteStartObject">
      <summary>
            Writes the beginning of a Json object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteStartArray">
      <summary>
            Writes the beginning of a Json array.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteStartConstructor(System.String)">
      <summary>
            Writes the start of a constructor with the given name.
            </summary>
      <param name="name">The name of the constructor.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteEnd(Newtonsoft.Json.JsonToken)">
      <summary>
            Writes the specified end token.
            </summary>
      <param name="token">The end token to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WritePropertyName(System.String)">
      <summary>
            Writes the property name of a name/value pair on a Json object.
            </summary>
      <param name="name">The name of the property.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WritePropertyName(System.String,System.Boolean)">
      <summary>
            Writes the property name of a name/value pair on a JSON object.
            </summary>
      <param name="name">The name of the property.</param>
      <param name="escape">A flag to indicate whether the text should be escaped when it is written as a JSON property name.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteIndent">
      <summary>
            Writes indent characters.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValueDelimiter">
      <summary>
            Writes the JSON value delimiter.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteIndentSpace">
      <summary>
            Writes an indent space.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Object)">
      <summary>
            Writes a <see cref="T:System.Object" /> value.
            An error will raised if the value cannot be written as a single JSON token.
            </summary>
      <param name="value">The <see cref="T:System.Object" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteNull">
      <summary>
            Writes a null value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteUndefined">
      <summary>
            Writes an undefined value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteRaw(System.String)">
      <summary>
            Writes raw JSON.
            </summary>
      <param name="json">The raw JSON to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.String)">
      <summary>
            Writes a <see cref="T:System.String" /> value.
            </summary>
      <param name="value">The <see cref="T:System.String" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Int32)">
      <summary>
            Writes a <see cref="T:System.Int32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.UInt32)">
      <summary>
            Writes a <see cref="T:System.UInt32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Int64)">
      <summary>
            Writes a <see cref="T:System.Int64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.UInt64)">
      <summary>
            Writes a <see cref="T:System.UInt64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Single)">
      <summary>
            Writes a <see cref="T:System.Single" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Single" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Nullable{System.Single})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Double)">
      <summary>
            Writes a <see cref="T:System.Double" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Double" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Nullable{System.Double})">
      <summary>
            Writes a <see cref="T:System.Nullable`1" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Nullable`1" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Boolean)">
      <summary>
            Writes a <see cref="T:System.Boolean" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Boolean" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Int16)">
      <summary>
            Writes a <see cref="T:System.Int16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.UInt16)">
      <summary>
            Writes a <see cref="T:System.UInt16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Char)">
      <summary>
            Writes a <see cref="T:System.Char" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Byte)">
      <summary>
            Writes a <see cref="T:System.Byte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Byte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.SByte)">
      <summary>
            Writes a <see cref="T:System.SByte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.SByte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Decimal)">
      <summary>
            Writes a <see cref="T:System.Decimal" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Decimal" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.DateTime)">
      <summary>
            Writes a <see cref="T:System.DateTime" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTime" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Byte[])">
      <summary>
            Writes a <see cref="T:Byte[]" /> value.
            </summary>
      <param name="value">The <see cref="T:Byte[]" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.DateTimeOffset)">
      <summary>
            Writes a <see cref="T:System.DateTimeOffset" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTimeOffset" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Guid)">
      <summary>
            Writes a <see cref="T:System.Guid" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Guid" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.TimeSpan)">
      <summary>
            Writes a <see cref="T:System.TimeSpan" /> value.
            </summary>
      <param name="value">The <see cref="T:System.TimeSpan" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteValue(System.Uri)">
      <summary>
            Writes a <see cref="T:System.Uri" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Uri" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteComment(System.String)">
      <summary>
            Writes out a comment <code>/*...*/</code> containing the specified text. 
            </summary>
      <param name="text">Text to place inside the comment.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonTextWriter.WriteWhitespace(System.String)">
      <summary>
            Writes out the given white space.
            </summary>
      <param name="ws">The string of white space characters.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonTextWriter.Indentation">
      <summary>
            Gets or sets how many IndentChars to write for each level in the hierarchy when <see cref="T:Newtonsoft.Json.Formatting" /> is set to <c>Formatting.Indented</c>.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonTextWriter.QuoteChar">
      <summary>
            Gets or sets which character to use to quote attribute values.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonTextWriter.IndentChar">
      <summary>
            Gets or sets which character to use for indenting when <see cref="T:Newtonsoft.Json.Formatting" /> is set to <c>Formatting.Indented</c>.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonTextWriter.QuoteName">
      <summary>
            Gets or sets a value indicating whether object names will be surrounded with quotes.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonWriterException">
      <summary>
            The exception thrown when an error occurs while reading Json text.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriterException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonWriterException" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriterException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonWriterException" /> class
            with a specified error message.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriterException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonWriterException" /> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonWriterException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonWriterException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="P:Newtonsoft.Json.JsonWriterException.Path">
      <summary>
            Gets the path to the JSON where the error occurred.
            </summary>
      <value>The path to the JSON where the error occurred.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonReaderException">
      <summary>
            The exception thrown when an error occurs while reading Json text.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonReaderException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReaderException" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonReaderException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReaderException" /> class
            with a specified error message.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonReaderException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReaderException" /> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonReaderException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonReaderException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="P:Newtonsoft.Json.JsonReaderException.LineNumber">
      <summary>
            Gets the line number indicating where the error occurred.
            </summary>
      <value>The line number indicating where the error occurred.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonReaderException.LinePosition">
      <summary>
            Gets the line position indicating where the error occurred.
            </summary>
      <value>The line position indicating where the error occurred.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonReaderException.Path">
      <summary>
            Gets the path to the JSON where the error occurred.
            </summary>
      <value>The path to the JSON where the error occurred.</value>
    </member>
    <member name="T:Newtonsoft.Json.JsonConverterCollection">
      <summary>
            Represents a collection of <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonConvert">
      <summary>
            Provides methods for converting between common language runtime types and JSON types.
            </summary>
      <example>
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="SerializeObject" title="Serializing and Deserializing JSON with JsonConvert" />
      </example>
    </member>
    <member name="F:Newtonsoft.Json.JsonConvert.True">
      <summary>
            Represents JavaScript's boolean value true as a string. This field is read-only.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonConvert.False">
      <summary>
            Represents JavaScript's boolean value false as a string. This field is read-only.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonConvert.Null">
      <summary>
            Represents JavaScript's null as a string. This field is read-only.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonConvert.Undefined">
      <summary>
            Represents JavaScript's undefined as a string. This field is read-only.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonConvert.PositiveInfinity">
      <summary>
            Represents JavaScript's positive infinity as a string. This field is read-only.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonConvert.NegativeInfinity">
      <summary>
            Represents JavaScript's negative infinity as a string. This field is read-only.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonConvert.NaN">
      <summary>
            Represents JavaScript's NaN as a string. This field is read-only.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.DateTime)">
      <summary>
            Converts the <see cref="T:System.DateTime" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.DateTime" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.DateTime,Newtonsoft.Json.DateFormatHandling,Newtonsoft.Json.DateTimeZoneHandling)">
      <summary>
            Converts the <see cref="T:System.DateTime" /> to its JSON string representation using the <see cref="T:Newtonsoft.Json.DateFormatHandling" /> specified.
            </summary>
      <param name="value">The value to convert.</param>
      <param name="format">The format the date will be converted to.</param>
      <param name="timeZoneHandling">The time zone handling when the date is converted to a string.</param>
      <returns>A JSON string representation of the <see cref="T:System.DateTime" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.DateTimeOffset)">
      <summary>
            Converts the <see cref="T:System.DateTimeOffset" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.DateTimeOffset" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.DateTimeOffset,Newtonsoft.Json.DateFormatHandling)">
      <summary>
            Converts the <see cref="T:System.DateTimeOffset" /> to its JSON string representation using the <see cref="T:Newtonsoft.Json.DateFormatHandling" /> specified.
            </summary>
      <param name="value">The value to convert.</param>
      <param name="format">The format the date will be converted to.</param>
      <returns>A JSON string representation of the <see cref="T:System.DateTimeOffset" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Boolean)">
      <summary>
            Converts the <see cref="T:System.Boolean" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Boolean" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Char)">
      <summary>
            Converts the <see cref="T:System.Char" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Char" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Enum)">
      <summary>
            Converts the <see cref="T:System.Enum" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Enum" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Int32)">
      <summary>
            Converts the <see cref="T:System.Int32" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Int32" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Int16)">
      <summary>
            Converts the <see cref="T:System.Int16" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Int16" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.UInt16)">
      <summary>
            Converts the <see cref="T:System.UInt16" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.UInt16" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.UInt32)">
      <summary>
            Converts the <see cref="T:System.UInt32" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.UInt32" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Int64)">
      <summary>
            Converts the <see cref="T:System.Int64" />  to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Int64" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.UInt64)">
      <summary>
            Converts the <see cref="T:System.UInt64" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.UInt64" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Single)">
      <summary>
            Converts the <see cref="T:System.Single" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Single" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Double)">
      <summary>
            Converts the <see cref="T:System.Double" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Double" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Byte)">
      <summary>
            Converts the <see cref="T:System.Byte" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Byte" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.SByte)">
      <summary>
            Converts the <see cref="T:System.SByte" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.SByte" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Decimal)">
      <summary>
            Converts the <see cref="T:System.Decimal" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.SByte" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Guid)">
      <summary>
            Converts the <see cref="T:System.Guid" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Guid" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.TimeSpan)">
      <summary>
            Converts the <see cref="T:System.TimeSpan" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.TimeSpan" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Uri)">
      <summary>
            Converts the <see cref="T:System.Uri" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Uri" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.String)">
      <summary>
            Converts the <see cref="T:System.String" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.String,System.Char)">
      <summary>
            Converts the <see cref="T:System.String" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <param name="delimiter">The string delimiter character.</param>
      <returns>A JSON string representation of the <see cref="T:System.String" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.ToString(System.Object)">
      <summary>
            Converts the <see cref="T:System.Object" /> to its JSON string representation.
            </summary>
      <param name="value">The value to convert.</param>
      <returns>A JSON string representation of the <see cref="T:System.Object" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object)">
      <summary>
            Serializes the specified object to a JSON string.
            </summary>
      <param name="value">The object to serialize.</param>
      <returns>A JSON string representation of the object.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft.Json.Formatting)">
      <summary>
            Serializes the specified object to a JSON string using formatting.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <returns>
            A JSON string representation of the object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Serializes the specified object to a JSON string using a collection of <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="converters">A collection converters used while serializing.</param>
      <returns>A JSON string representation of the object.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft.Json.Formatting,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Serializes the specified object to a JSON string using formatting and a collection of <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <param name="converters">A collection converters used while serializing.</param>
      <returns>A JSON string representation of the object.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Serializes the specified object to a JSON string using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="settings">The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to serialize the object.
            If this is null, default serialization settings will be is used.</param>
      <returns>
            A JSON string representation of the object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,System.Type,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Serializes the specified object to a JSON string using a type, formatting and <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="settings">The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to serialize the object.
            If this is null, default serialization settings will be is used.</param>
      <param name="type">
            The type of the value being serialized.
            This parameter is used when <see cref="T:Newtonsoft.Json.TypeNameHandling" /> is Auto to write out the type name if the type of the value does not match.
            Specifing the type is optional.
            </param>
      <returns>
            A JSON string representation of the object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,Newtonsoft.Json.Formatting,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Serializes the specified object to a JSON string using formatting and <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <param name="settings">The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to serialize the object.
            If this is null, default serialization settings will be is used.</param>
      <returns>
            A JSON string representation of the object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObject(System.Object,System.Type,Newtonsoft.Json.Formatting,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Serializes the specified object to a JSON string using a type, formatting and <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <param name="settings">The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to serialize the object.
            If this is null, default serialization settings will be is used.</param>
      <param name="type">
            The type of the value being serialized.
            This parameter is used when <see cref="T:Newtonsoft.Json.TypeNameHandling" /> is Auto to write out the type name if the type of the value does not match.
            Specifing the type is optional.
            </param>
      <returns>
            A JSON string representation of the object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObjectAsync(System.Object)">
      <summary>
            Asynchronously serializes the specified object to a JSON string.
            Serialization will happen on a new thread.
            </summary>
      <param name="value">The object to serialize.</param>
      <returns>
            A task that represents the asynchronous serialize operation. The value of the <c>TResult</c> parameter contains a JSON string representation of the object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObjectAsync(System.Object,Newtonsoft.Json.Formatting)">
      <summary>
            Asynchronously serializes the specified object to a JSON string using formatting.
            Serialization will happen on a new thread.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <returns>
            A task that represents the asynchronous serialize operation. The value of the <c>TResult</c> parameter contains a JSON string representation of the object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeObjectAsync(System.Object,Newtonsoft.Json.Formatting,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Asynchronously serializes the specified object to a JSON string using formatting and a collection of <see cref="T:Newtonsoft.Json.JsonConverter" />.
            Serialization will happen on a new thread.
            </summary>
      <param name="value">The object to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <param name="settings">The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to serialize the object.
            If this is null, default serialization settings will be is used.</param>
      <returns>
            A task that represents the asynchronous serialize operation. The value of the <c>TResult</c> parameter contains a JSON string representation of the object.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject(System.String)">
      <summary>
            Deserializes the JSON to a .NET object.
            </summary>
      <param name="value">The JSON to deserialize.</param>
      <returns>The deserialized object from the Json string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject(System.String,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Deserializes the JSON to a .NET object using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
      <param name="value">The JSON to deserialize.</param>
      <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is null, default serialization settings will be is used.
            </param>
      <returns>The deserialized object from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject(System.String,System.Type)">
      <summary>
            Deserializes the JSON to the specified .NET type.
            </summary>
      <param name="value">The JSON to deserialize.</param>
      <param name="type">The <see cref="T:System.Type" /> of object being deserialized.</param>
      <returns>The deserialized object from the Json string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject``1(System.String)">
      <summary>
            Deserializes the JSON to the specified .NET type.
            </summary>
      <typeparam name="T">The type of the object to deserialize to.</typeparam>
      <param name="value">The JSON to deserialize.</param>
      <returns>The deserialized object from the Json string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeAnonymousType``1(System.String,``0)">
      <summary>
            Deserializes the JSON to the given anonymous type.
            </summary>
      <typeparam name="T">
            The anonymous type to deserialize to. This can't be specified
            traditionally and must be infered from the anonymous type passed
            as a parameter.
            </typeparam>
      <param name="value">The JSON to deserialize.</param>
      <param name="anonymousTypeObject">The anonymous type object.</param>
      <returns>The deserialized anonymous type from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeAnonymousType``1(System.String,``0,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Deserializes the JSON to the given anonymous type using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
      <typeparam name="T">
            The anonymous type to deserialize to. This can't be specified
            traditionally and must be infered from the anonymous type passed
            as a parameter.
            </typeparam>
      <param name="value">The JSON to deserialize.</param>
      <param name="anonymousTypeObject">The anonymous type object.</param>
      <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is null, default serialization settings will be is used.
            </param>
      <returns>The deserialized anonymous type from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject``1(System.String,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Deserializes the JSON to the specified .NET type using a collection of <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
      <typeparam name="T">The type of the object to deserialize to.</typeparam>
      <param name="value">The JSON to deserialize.</param>
      <param name="converters">Converters to use while deserializing.</param>
      <returns>The deserialized object from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject``1(System.String,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Deserializes the JSON to the specified .NET type using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
      <typeparam name="T">The type of the object to deserialize to.</typeparam>
      <param name="value">The object to deserialize.</param>
      <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is null, default serialization settings will be is used.
            </param>
      <returns>The deserialized object from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject(System.String,System.Type,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Deserializes the JSON to the specified .NET type using a collection of <see cref="T:Newtonsoft.Json.JsonConverter" />.
            </summary>
      <param name="value">The JSON to deserialize.</param>
      <param name="type">The type of the object to deserialize.</param>
      <param name="converters">Converters to use while deserializing.</param>
      <returns>The deserialized object from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObject(System.String,System.Type,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Deserializes the JSON to the specified .NET type using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
      <param name="value">The JSON to deserialize.</param>
      <param name="type">The type of the object to deserialize to.</param>
      <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is null, default serialization settings will be is used.
            </param>
      <returns>The deserialized object from the JSON string.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObjectAsync``1(System.String)">
      <summary>
            Asynchronously deserializes the JSON to the specified .NET type.
            Deserialization will happen on a new thread.
            </summary>
      <typeparam name="T">The type of the object to deserialize to.</typeparam>
      <param name="value">The JSON to deserialize.</param>
      <returns>
            A task that represents the asynchronous deserialize operation. The value of the <c>TResult</c> parameter contains the deserialized object from the JSON string.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObjectAsync``1(System.String,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Asynchronously deserializes the JSON to the specified .NET type using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            Deserialization will happen on a new thread.
            </summary>
      <typeparam name="T">The type of the object to deserialize to.</typeparam>
      <param name="value">The JSON to deserialize.</param>
      <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is null, default serialization settings will be is used.
            </param>
      <returns>
            A task that represents the asynchronous deserialize operation. The value of the <c>TResult</c> parameter contains the deserialized object from the JSON string.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObjectAsync(System.String)">
      <summary>
            Asynchronously deserializes the JSON to the specified .NET type.
            Deserialization will happen on a new thread.
            </summary>
      <param name="value">The JSON to deserialize.</param>
      <returns>
            A task that represents the asynchronous deserialize operation. The value of the <c>TResult</c> parameter contains the deserialized object from the JSON string.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeObjectAsync(System.String,System.Type,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Asynchronously deserializes the JSON to the specified .NET type using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            Deserialization will happen on a new thread.
            </summary>
      <param name="value">The JSON to deserialize.</param>
      <param name="type">The type of the object to deserialize to.</param>
      <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is null, default serialization settings will be is used.
            </param>
      <returns>
            A task that represents the asynchronous deserialize operation. The value of the <c>TResult</c> parameter contains the deserialized object from the JSON string.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.PopulateObject(System.String,System.Object)">
      <summary>
            Populates the object with values from the JSON string.
            </summary>
      <param name="value">The JSON to populate values from.</param>
      <param name="target">The target object to populate values onto.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.PopulateObject(System.String,System.Object,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Populates the object with values from the JSON string using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
      <param name="value">The JSON to populate values from.</param>
      <param name="target">The target object to populate values onto.</param>
      <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is null, default serialization settings will be is used.
            </param>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.PopulateObjectAsync(System.String,System.Object,Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Asynchronously populates the object with values from the JSON string using <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            </summary>
      <param name="value">The JSON to populate values from.</param>
      <param name="target">The target object to populate values onto.</param>
      <param name="settings">
            The <see cref="T:Newtonsoft.Json.JsonSerializerSettings" /> used to deserialize the object.
            If this is null, default serialization settings will be is used.
            </param>
      <returns>
            A task that represents the asynchronous populate operation.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeXmlNode(System.Xml.XmlNode)">
      <summary>
            Serializes the XML node to a JSON string.
            </summary>
      <param name="node">The node to serialize.</param>
      <returns>A JSON string of the XmlNode.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeXmlNode(System.Xml.XmlNode,Newtonsoft.Json.Formatting)">
      <summary>
            Serializes the XML node to a JSON string using formatting.
            </summary>
      <param name="node">The node to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <returns>A JSON string of the XmlNode.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeXmlNode(System.Xml.XmlNode,Newtonsoft.Json.Formatting,System.Boolean)">
      <summary>
            Serializes the XML node to a JSON string using formatting and omits the root object if <paramref name="omitRootObject" /> is <c>true</c>.
            </summary>
      <param name="node">The node to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <param name="omitRootObject">Omits writing the root object.</param>
      <returns>A JSON string of the XmlNode.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXmlNode(System.String)">
      <summary>
            Deserializes the XmlNode from a JSON string.
            </summary>
      <param name="value">The JSON string.</param>
      <returns>The deserialized XmlNode</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXmlNode(System.String,System.String)">
      <summary>
            Deserializes the XmlNode from a JSON string nested in a root elment specified by <paramref name="deserializeRootElementName" />.
            </summary>
      <param name="value">The JSON string.</param>
      <param name="deserializeRootElementName">The name of the root element to append when deserializing.</param>
      <returns>The deserialized XmlNode</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXmlNode(System.String,System.String,System.Boolean)">
      <summary>
            Deserializes the XmlNode from a JSON string nested in a root elment specified by <paramref name="deserializeRootElementName" />
            and writes a .NET array attribute for collections.
            </summary>
      <param name="value">The JSON string.</param>
      <param name="deserializeRootElementName">The name of the root element to append when deserializing.</param>
      <param name="writeArrayAttribute">
            A flag to indicate whether to write the Json.NET array attribute.
            This attribute helps preserve arrays when converting the written XML back to JSON.
            </param>
      <returns>The deserialized XmlNode</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeXNode(System.Xml.Linq.XObject)">
      <summary>
            Serializes the <see cref="T:System.Xml.Linq.XNode" /> to a JSON string.
            </summary>
      <param name="node">The node to convert to JSON.</param>
      <returns>A JSON string of the XNode.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeXNode(System.Xml.Linq.XObject,Newtonsoft.Json.Formatting)">
      <summary>
            Serializes the <see cref="T:System.Xml.Linq.XNode" /> to a JSON string using formatting.
            </summary>
      <param name="node">The node to convert to JSON.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <returns>A JSON string of the XNode.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.SerializeXNode(System.Xml.Linq.XObject,Newtonsoft.Json.Formatting,System.Boolean)">
      <summary>
            Serializes the <see cref="T:System.Xml.Linq.XNode" /> to a JSON string using formatting and omits the root object if <paramref name="omitRootObject" /> is <c>true</c>.
            </summary>
      <param name="node">The node to serialize.</param>
      <param name="formatting">Indicates how the output is formatted.</param>
      <param name="omitRootObject">Omits writing the root object.</param>
      <returns>A JSON string of the XNode.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXNode(System.String)">
      <summary>
            Deserializes the <see cref="T:System.Xml.Linq.XNode" /> from a JSON string.
            </summary>
      <param name="value">The JSON string.</param>
      <returns>The deserialized XNode</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXNode(System.String,System.String)">
      <summary>
            Deserializes the <see cref="T:System.Xml.Linq.XNode" /> from a JSON string nested in a root elment specified by <paramref name="deserializeRootElementName" />.
            </summary>
      <param name="value">The JSON string.</param>
      <param name="deserializeRootElementName">The name of the root element to append when deserializing.</param>
      <returns>The deserialized XNode</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonConvert.DeserializeXNode(System.String,System.String,System.Boolean)">
      <summary>
            Deserializes the <see cref="T:System.Xml.Linq.XNode" /> from a JSON string nested in a root elment specified by <paramref name="deserializeRootElementName" />
            and writes a .NET array attribute for collections.
            </summary>
      <param name="value">The JSON string.</param>
      <param name="deserializeRootElementName">The name of the root element to append when deserializing.</param>
      <param name="writeArrayAttribute">
            A flag to indicate whether to write the Json.NET array attribute.
            This attribute helps preserve arrays when converting the written XML back to JSON.
            </param>
      <returns>The deserialized XNode</returns>
    </member>
    <member name="P:Newtonsoft.Json.JsonConvert.DefaultSettings">
      <summary>
            Gets or sets a function that creates default <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            Default settings are automatically used by serialization methods on <see cref="T:Newtonsoft.Json.JsonConvert" />,
            and <see cref="M:Newtonsoft.Json.Linq.JToken.ToObject``1" /> and <see cref="M:Newtonsoft.Json.Linq.JToken.FromObject(System.Object)" /> on <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            To serialize without using any default settings create a <see cref="T:Newtonsoft.Json.JsonSerializer" /> with
            <see cref="M:Newtonsoft.Json.JsonSerializer.Create" />.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.JsonSerializationException">
      <summary>
            The exception thrown when an error occurs during Json serialization or deserialization.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializationException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializationException" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializationException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializationException" /> class
            with a specified error message.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializationException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializationException" /> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializationException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="T:Newtonsoft.Json.JsonSerializer">
      <summary>
            Serializes and deserializes objects into and from the JSON format.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> enables you to control how objects are encoded into JSON.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.JsonSerializer" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Create">
      <summary>
            Creates a new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will not use default settings.
            </summary>
      <returns>
            A new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will not use default settings.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Create(Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Creates a new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance using the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will not use default settings.
            </summary>
      <param name="settings">The settings to be applied to the <see cref="T:Newtonsoft.Json.JsonSerializer" />.</param>
      <returns>
            A new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance using the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will not use default settings.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.CreateDefault">
      <summary>
            Creates a new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will use default settings.
            </summary>
      <returns>
            A new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will use default settings.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.CreateDefault(Newtonsoft.Json.JsonSerializerSettings)">
      <summary>
            Creates a new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance using the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will use default settings.
            </summary>
      <param name="settings">The settings to be applied to the <see cref="T:Newtonsoft.Json.JsonSerializer" />.</param>
      <returns>
            A new <see cref="T:Newtonsoft.Json.JsonSerializer" /> instance using the specified <see cref="T:Newtonsoft.Json.JsonSerializerSettings" />.
            The <see cref="T:Newtonsoft.Json.JsonSerializer" /> will use default settings.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Populate(System.IO.TextReader,System.Object)">
      <summary>
            Populates the JSON values onto the target object.
            </summary>
      <param name="reader">The <see cref="T:System.IO.TextReader" /> that contains the JSON structure to reader values from.</param>
      <param name="target">The target object to populate values onto.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Populate(Newtonsoft.Json.JsonReader,System.Object)">
      <summary>
            Populates the JSON values onto the target object.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> that contains the JSON structure to reader values from.</param>
      <param name="target">The target object to populate values onto.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Deserialize(Newtonsoft.Json.JsonReader)">
      <summary>
            Deserializes the Json structure contained by the specified <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> that contains the JSON structure to deserialize.</param>
      <returns>The <see cref="T:System.Object" /> being deserialized.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Deserialize(System.IO.TextReader,System.Type)">
      <summary>
            Deserializes the Json structure contained by the specified <see cref="T:System.IO.StringReader" />
            into an instance of the specified type.
            </summary>
      <param name="reader">The <see cref="T:System.IO.TextReader" /> containing the object.</param>
      <param name="objectType">The <see cref="T:System.Type" /> of object being deserialized.</param>
      <returns>The instance of <paramref name="objectType" /> being deserialized.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Deserialize``1(Newtonsoft.Json.JsonReader)">
      <summary>
            Deserializes the Json structure contained by the specified <see cref="T:Newtonsoft.Json.JsonReader" />
            into an instance of the specified type.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> containing the object.</param>
      <typeparam name="T">The type of the object to deserialize.</typeparam>
      <returns>The instance of <typeparamref name="T" /> being deserialized.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Deserialize(Newtonsoft.Json.JsonReader,System.Type)">
      <summary>
            Deserializes the Json structure contained by the specified <see cref="T:Newtonsoft.Json.JsonReader" />
            into an instance of the specified type.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> containing the object.</param>
      <param name="objectType">The <see cref="T:System.Type" /> of object being deserialized.</param>
      <returns>The instance of <paramref name="objectType" /> being deserialized.</returns>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Serialize(System.IO.TextWriter,System.Object)">
      <summary>
            Serializes the specified <see cref="T:System.Object" /> and writes the Json structure
            to a <c>Stream</c> using the specified <see cref="T:System.IO.TextWriter" />. 
            </summary>
      <param name="textWriter">The <see cref="T:System.IO.TextWriter" /> used to write the Json structure.</param>
      <param name="value">The <see cref="T:System.Object" /> to serialize.</param>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Serialize(Newtonsoft.Json.JsonWriter,System.Object,System.Type)">
      <summary>
            Serializes the specified <see cref="T:System.Object" /> and writes the Json structure
            to a <c>Stream</c> using the specified <see cref="T:System.IO.TextWriter" />. 
            </summary>
      <param name="jsonWriter">The <see cref="T:Newtonsoft.Json.JsonWriter" /> used to write the Json structure.</param>
      <param name="value">The <see cref="T:System.Object" /> to serialize.</param>
      <param name="objectType">
            The type of the value being serialized.
            This parameter is used when <see cref="P:Newtonsoft.Json.JsonSerializer.TypeNameHandling" /> is Auto to write out the type name if the type of the value does not match.
            Specifing the type is optional.
            </param>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Serialize(System.IO.TextWriter,System.Object,System.Type)">
      <summary>
            Serializes the specified <see cref="T:System.Object" /> and writes the Json structure
            to a <c>Stream</c> using the specified <see cref="T:System.IO.TextWriter" />. 
            </summary>
      <param name="textWriter">The <see cref="T:System.IO.TextWriter" /> used to write the Json structure.</param>
      <param name="value">The <see cref="T:System.Object" /> to serialize.</param>
      <param name="objectType">
            The type of the value being serialized.
            This parameter is used when <see cref="P:Newtonsoft.Json.JsonSerializer.TypeNameHandling" /> is Auto to write out the type name if the type of the value does not match.
            Specifing the type is optional.
            </param>
    </member>
    <member name="M:Newtonsoft.Json.JsonSerializer.Serialize(Newtonsoft.Json.JsonWriter,System.Object)">
      <summary>
            Serializes the specified <see cref="T:System.Object" /> and writes the Json structure
            to a <c>Stream</c> using the specified <see cref="T:Newtonsoft.Json.JsonWriter" />. 
            </summary>
      <param name="jsonWriter">The <see cref="T:Newtonsoft.Json.JsonWriter" /> used to write the Json structure.</param>
      <param name="value">The <see cref="T:System.Object" /> to serialize.</param>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.ReferenceResolver">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Serialization.IReferenceResolver" /> used by the serializer when resolving references.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.Binder">
      <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.SerializationBinder" /> used by the serializer when resolving type names.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.TraceWriter">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Serialization.ITraceWriter" /> used by the serializer when writing trace messages.
            </summary>
      <value>The trace writer.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.TypeNameHandling">
      <summary>
            Gets or sets how type name writing and reading is handled by the serializer.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.TypeNameAssemblyFormat">
      <summary>
            Gets or sets how a type name assembly is written and resolved by the serializer.
            </summary>
      <value>The type name assembly format.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.PreserveReferencesHandling">
      <summary>
            Gets or sets how object references are preserved by the serializer.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.ReferenceLoopHandling">
      <summary>
            Get or set how reference loops (e.g. a class referencing itself) is handled.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.MissingMemberHandling">
      <summary>
            Get or set how missing members (e.g. JSON contains a property that isn't a member on the object) are handled during deserialization.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.NullValueHandling">
      <summary>
            Get or set how null values are handled during serialization and deserialization.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.DefaultValueHandling">
      <summary>
            Get or set how null default are handled during serialization and deserialization.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.ObjectCreationHandling">
      <summary>
            Gets or sets how objects are created during deserialization.
            </summary>
      <value>The object creation handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.ConstructorHandling">
      <summary>
            Gets or sets how constructors are used during deserialization.
            </summary>
      <value>The constructor handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.Converters">
      <summary>
            Gets a collection <see cref="T:Newtonsoft.Json.JsonConverter" /> that will be used during serialization.
            </summary>
      <value>Collection <see cref="T:Newtonsoft.Json.JsonConverter" /> that will be used during serialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.ContractResolver">
      <summary>
            Gets or sets the contract resolver used by the serializer when
            serializing .NET objects to JSON and vice versa.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.Context">
      <summary>
            Gets or sets the <see cref="T:System.Runtime.Serialization.StreamingContext" /> used by the serializer when invoking serialization callback methods.
            </summary>
      <value>The context.</value>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.Formatting">
      <summary>
            Indicates how JSON text output is formatted.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.DateFormatHandling">
      <summary>
            Get or set how dates are written to JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.DateTimeZoneHandling">
      <summary>
            Get or set how <see cref="T:System.DateTime" /> time zones are handling during serialization and deserialization.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.DateParseHandling">
      <summary>
            Get or set how date formatted strings, e.g. "\/Date(1198908717056)\/" and "2012-03-21T05:40Z", are parsed when reading JSON.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.FloatParseHandling">
      <summary>
            Get or set how floating point numbers, e.g. 1.0 and 9.9, are parsed when reading JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.FloatFormatHandling">
      <summary>
            Get or set how special floating point numbers, e.g. <see cref="F:System.Double.NaN" />,
            <see cref="F:System.Double.PositiveInfinity" /> and <see cref="F:System.Double.NegativeInfinity" />,
            are written as JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.StringEscapeHandling">
      <summary>
            Get or set how strings are escaped when writing JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.DateFormatString">
      <summary>
            Get or set how <see cref="T:System.DateTime" /> and <see cref="T:System.DateTimeOffset" /> values are formatting when writing JSON text.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.Culture">
      <summary>
            Gets or sets the culture used when reading JSON. Defaults to <see cref="P:System.Globalization.CultureInfo.InvariantCulture" />.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.MaxDepth">
      <summary>
            Gets or sets the maximum depth allowed when reading JSON. Reading past this depth will throw a <see cref="T:Newtonsoft.Json.JsonReaderException" />.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.JsonSerializer.CheckAdditionalContent">
      <summary>
            Gets a value indicating whether there will be a check for additional JSON content after deserializing an object.
            </summary>
      <value>
        <c>true</c> if there will be a check for additional JSON content after deserializing an object; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="E:Newtonsoft.Json.JsonSerializer.Error">
      <summary>
            Occurs when the <see cref="T:Newtonsoft.Json.JsonSerializer" /> errors during serialization and deserialization.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Linq.Extensions">
      <summary>
            Contains the LINQ to JSON extension methods.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Ancestors``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns a collection of tokens that contains the ancestors of every token in the source collection.
            </summary>
      <typeparam name="T">The type of the objects in source, constrained to <see cref="T:Newtonsoft.Json.Linq.JToken" />.</typeparam>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the ancestors of every node in the source collection.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Descendants``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns a collection of tokens that contains the descendants of every token in the source collection.
            </summary>
      <typeparam name="T">The type of the objects in source, constrained to <see cref="T:Newtonsoft.Json.Linq.JContainer" />.</typeparam>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the descendants of every node in the source collection.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Properties(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JObject})">
      <summary>
            Returns a collection of child properties of every object in the source collection.
            </summary>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JObject" /> that contains the source collection.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JProperty" /> that contains the properties of every object in the source collection.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Values(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken},System.Object)">
      <summary>
            Returns a collection of child values of every object in the source collection with the given key.
            </summary>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <param name="key">The token key.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the values of every node in the source collection with the given key.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Values(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken})">
      <summary>
            Returns a collection of child values of every object in the source collection.
            </summary>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the values of every node in the source collection.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Values``1(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken},System.Object)">
      <summary>
            Returns a collection of converted child values of every object in the source collection with the given key.
            </summary>
      <typeparam name="U">The type to convert the values to.</typeparam>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <param name="key">The token key.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the converted values of every node in the source collection with the given key.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Values``1(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken})">
      <summary>
            Returns a collection of converted child values of every object in the source collection.
            </summary>
      <typeparam name="U">The type to convert the values to.</typeparam>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the converted values of every node in the source collection.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Value``1(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken})">
      <summary>
            Converts the value.
            </summary>
      <typeparam name="U">The type to convert the value to.</typeparam>
      <param name="value">A <see cref="T:Newtonsoft.Json.Linq.JToken" /> cast as a <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
      <returns>A converted value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Value``2(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Converts the value.
            </summary>
      <typeparam name="T">The source collection type.</typeparam>
      <typeparam name="U">The type to convert the value to.</typeparam>
      <param name="value">A <see cref="T:Newtonsoft.Json.Linq.JToken" /> cast as a <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" />.</param>
      <returns>A converted value.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Children``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns a collection of child tokens of every array in the source collection.
            </summary>
      <typeparam name="T">The source collection type.</typeparam>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the values of every node in the source collection.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.Children``2(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns a collection of converted child tokens of every array in the source collection.
            </summary>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <typeparam name="U">The type to convert the values to.</typeparam>
      <typeparam name="T">The source collection type.</typeparam>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the converted values of every node in the source collection.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.AsJEnumerable(System.Collections.Generic.IEnumerable{Newtonsoft.Json.Linq.JToken})">
      <summary>
            Returns the input typed as <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" />.
            </summary>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <returns>The input typed as <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.Extensions.AsJEnumerable``1(System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Returns the input typed as <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" />.
            </summary>
      <typeparam name="T">The source collection type.</typeparam>
      <param name="source">An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> that contains the source collection.</param>
      <returns>The input typed as <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" />.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JContainer">
      <summary>
            Represents a token that can contain other tokens.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.OnAddingNew(System.ComponentModel.AddingNewEventArgs)">
      <summary>
            Raises the <see cref="E:Newtonsoft.Json.Linq.JContainer.AddingNew" /> event.
            </summary>
      <param name="e">The <see cref="T:System.ComponentModel.AddingNewEventArgs" /> instance containing the event data.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.OnListChanged(System.ComponentModel.ListChangedEventArgs)">
      <summary>
            Raises the <see cref="E:Newtonsoft.Json.Linq.JContainer.ListChanged" /> event.
            </summary>
      <param name="e">The <see cref="T:System.ComponentModel.ListChangedEventArgs" /> instance containing the event data.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.OnCollectionChanged(System.Collections.Specialized.NotifyCollectionChangedEventArgs)">
      <summary>
            Raises the <see cref="E:Newtonsoft.Json.Linq.JContainer.CollectionChanged" /> event.
            </summary>
      <param name="e">The <see cref="T:System.Collections.Specialized.NotifyCollectionChangedEventArgs" /> instance containing the event data.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.Children">
      <summary>
            Returns a collection of the child tokens of this token, in document order.
            </summary>
      <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the child tokens of this <see cref="T:Newtonsoft.Json.Linq.JToken" />, in document order.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.Values``1">
      <summary>
            Returns a collection of the child values of this token, in document order.
            </summary>
      <typeparam name="T">The type to convert the values to.</typeparam>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing the child values of this <see cref="T:Newtonsoft.Json.Linq.JToken" />, in document order.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.Descendants">
      <summary>
            Returns a collection of the descendant tokens for this token in document order.
            </summary>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> containing the descendant tokens of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.Add(System.Object)">
      <summary>
            Adds the specified content as children of this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="content">The content to be added.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.AddFirst(System.Object)">
      <summary>
            Adds the specified content as the first children of this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="content">The content to be added.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.CreateWriter">
      <summary>
            Creates an <see cref="T:Newtonsoft.Json.JsonWriter" /> that can be used to add tokens to the <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <returns>An <see cref="T:Newtonsoft.Json.JsonWriter" /> that is ready to have content written to it.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.ReplaceAll(System.Object)">
      <summary>
            Replaces the children nodes of this token with the specified content.
            </summary>
      <param name="content">The content.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JContainer.RemoveAll">
      <summary>
            Removes the child nodes from this token.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JContainer.ChildrenTokens">
      <summary>
            Gets the container's children tokens.
            </summary>
      <value>The container's children tokens.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JContainer.HasValues">
      <summary>
            Gets a value indicating whether this token has child tokens.
            </summary>
      <value>
        <c>true</c> if this token has child values; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JContainer.First">
      <summary>
            Get the first child token of this token.
            </summary>
      <value>
            A <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the first child token of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JContainer.Last">
      <summary>
            Get the last child token of this token.
            </summary>
      <value>
            A <see cref="T:Newtonsoft.Json.Linq.JToken" /> containing the last child token of the <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JContainer.Count">
      <summary>
            Gets the count of child JSON tokens.
            </summary>
      <value>The count of child JSON tokens</value>
    </member>
    <member name="E:Newtonsoft.Json.Linq.JContainer.ListChanged">
      <summary>
            Occurs when the list changes or an item in the list changes.
            </summary>
    </member>
    <member name="E:Newtonsoft.Json.Linq.JContainer.AddingNew">
      <summary>
            Occurs before an item is added to the collection.
            </summary>
    </member>
    <member name="E:Newtonsoft.Json.Linq.JContainer.CollectionChanged">
      <summary>
            Occurs when the items list of the collection has changed, or the collection is reset.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JConstructor">
      <summary>
            Represents a JSON constructor.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JConstructor.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JConstructor.#ctor(Newtonsoft.Json.Linq.JConstructor)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> class from another <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> object.
            </summary>
      <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> object to copy from.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JConstructor.#ctor(System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> class with the specified name and content.
            </summary>
      <param name="name">The constructor name.</param>
      <param name="content">The contents of the constructor.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JConstructor.#ctor(System.String,System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> class with the specified name and content.
            </summary>
      <param name="name">The constructor name.</param>
      <param name="content">The contents of the constructor.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JConstructor.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> class with the specified name.
            </summary>
      <param name="name">The constructor name.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JConstructor.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
      <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JConstructor.Load(Newtonsoft.Json.JsonReader)">
      <summary>
            Loads an <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />. 
            </summary>
      <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JConstructor" />.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JConstructor" /> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.</returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JConstructor.ChildrenTokens">
      <summary>
            Gets the container's children tokens.
            </summary>
      <value>The container's children tokens.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JConstructor.Name">
      <summary>
            Gets or sets the name of this constructor.
            </summary>
      <value>The constructor name.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JConstructor.Type">
      <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <value>The type.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JConstructor.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.</value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JEnumerable`1">
      <summary>
            Represents a collection of <see cref="T:Newtonsoft.Json.Linq.JToken" /> objects.
            </summary>
      <typeparam name="T">The type of token</typeparam>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JEnumerable`1.Empty">
      <summary>
            An empty collection of <see cref="T:Newtonsoft.Json.Linq.JToken" /> objects.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JEnumerable`1.#ctor(System.Collections.Generic.IEnumerable{`0})">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1" /> struct.
            </summary>
      <param name="enumerable">The enumerable.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JEnumerable`1.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JEnumerable`1.Equals(System.Object)">
      <summary>
            Determines whether the specified <see cref="T:System.Object" /> is equal to this instance.
            </summary>
      <param name="obj">The <see cref="T:System.Object" /> to compare with this instance.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:System.Object" /> is equal to this instance; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JEnumerable`1.GetHashCode">
      <summary>
            Returns a hash code for this instance.
            </summary>
      <returns>
            A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. 
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JEnumerable`1.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.IJEnumerable`1" /> with the specified key.
            </summary>
      <value>
      </value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JObject">
      <summary>
            Represents a JSON object.
            </summary>
      <example>
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParse" title="Parsing a JSON Object from Text" />
      </example>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JObject" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.#ctor(Newtonsoft.Json.Linq.JObject)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JObject" /> class from another <see cref="T:Newtonsoft.Json.Linq.JObject" /> object.
            </summary>
      <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JObject" /> object to copy from.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.#ctor(System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JObject" /> class with the specified content.
            </summary>
      <param name="content">The contents of the object.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JObject" /> class with the specified content.
            </summary>
      <param name="content">The contents of the object.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.Properties">
      <summary>
            Gets an <see cref="T:System.Collections.Generic.IEnumerable`1" /> of this object's properties.
            </summary>
      <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1" /> of this object's properties.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.Property(System.String)">
      <summary>
            Gets a <see cref="T:Newtonsoft.Json.Linq.JProperty" /> the specified name.
            </summary>
      <param name="name">The property name.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JProperty" /> with the specified name or null.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.PropertyValues">
      <summary>
            Gets an <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1" /> of this object's property values.
            </summary>
      <returns>An <see cref="T:Newtonsoft.Json.Linq.JEnumerable`1" /> of this object's property values.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.Load(Newtonsoft.Json.JsonReader)">
      <summary>
            Loads an <see cref="T:Newtonsoft.Json.Linq.JObject" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />. 
            </summary>
      <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JObject" />.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JObject" /> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.Parse(System.String)">
      <summary>
            Load a <see cref="T:Newtonsoft.Json.Linq.JObject" /> from a string that contains JSON.
            </summary>
      <param name="json">A <see cref="T:System.String" /> that contains JSON.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JObject" /> populated from the string that contains JSON.</returns>
      <example>
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParse" title="Parsing a JSON Object from Text" />
      </example>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.FromObject(System.Object)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JObject" /> from an object.
            </summary>
      <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JObject" />.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JObject" /> with the values of the specified object</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.FromObject(System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JArray" /> from an object.
            </summary>
      <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JArray" />.</param>
      <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer" /> that will be used to read the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray" /> with the values of the specified object</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
      <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.GetValue(System.String)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified property name.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified property name.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.GetValue(System.String,System.StringComparison)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified property name.
            The exact property name will be searched for first and if no matching property is found then
            the <see cref="T:System.StringComparison" /> will be used to match a property.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="comparison">One of the enumeration values that specifies how the strings will be compared.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified property name.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.TryGetValue(System.String,System.StringComparison,Newtonsoft.Json.Linq.JToken@)">
      <summary>
            Tries to get the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified property name.
            The exact property name will be searched for first and if no matching property is found then
            the <see cref="T:System.StringComparison" /> will be used to match a property.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="value">The value.</param>
      <param name="comparison">One of the enumeration values that specifies how the strings will be compared.</param>
      <returns>true if a value was successfully retrieved; otherwise, false.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.Add(System.String,Newtonsoft.Json.Linq.JToken)">
      <summary>
            Adds the specified property name.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.Remove(System.String)">
      <summary>
            Removes the property with the specified name.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>true if item was successfully removed; otherwise, false.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.TryGetValue(System.String,Newtonsoft.Json.Linq.JToken@)">
      <summary>
            Tries the get value.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <param name="value">The value.</param>
      <returns>true if a value was successfully retrieved; otherwise, false.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.OnPropertyChanged(System.String)">
      <summary>
            Raises the <see cref="E:Newtonsoft.Json.Linq.JObject.PropertyChanged" /> event with the provided arguments.
            </summary>
      <param name="propertyName">Name of the property.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.OnPropertyChanging(System.String)">
      <summary>
            Raises the <see cref="E:Newtonsoft.Json.Linq.JObject.PropertyChanging" /> event with the provided arguments.
            </summary>
      <param name="propertyName">Name of the property.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JObject.GetMetaObject(System.Linq.Expressions.Expression)">
      <summary>
            Returns the <see cref="T:System.Dynamic.DynamicMetaObject" /> responsible for binding operations performed on this object.
            </summary>
      <param name="parameter">The expression tree representation of the runtime value.</param>
      <returns>
            The <see cref="T:System.Dynamic.DynamicMetaObject" /> to bind this object.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JObject.ChildrenTokens">
      <summary>
            Gets the container's children tokens.
            </summary>
      <value>The container's children tokens.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JObject.Type">
      <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <value>The type.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JObject.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JObject.Item(System.String)">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified property name.
            </summary>
      <value>
      </value>
    </member>
    <member name="E:Newtonsoft.Json.Linq.JObject.PropertyChanged">
      <summary>
            Occurs when a property value changes.
            </summary>
    </member>
    <member name="E:Newtonsoft.Json.Linq.JObject.PropertyChanging">
      <summary>
            Occurs when a property value is changing.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JArray">
      <summary>
            Represents a JSON array.
            </summary>
      <example>
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParseArray" title="Parsing a JSON Array from Text" />
      </example>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JArray" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.#ctor(Newtonsoft.Json.Linq.JArray)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JArray" /> class from another <see cref="T:Newtonsoft.Json.Linq.JArray" /> object.
            </summary>
      <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JArray" /> object to copy from.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.#ctor(System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JArray" /> class with the specified content.
            </summary>
      <param name="content">The contents of the array.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.#ctor(System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JArray" /> class with the specified content.
            </summary>
      <param name="content">The contents of the array.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.Load(Newtonsoft.Json.JsonReader)">
      <summary>
            Loads an <see cref="T:Newtonsoft.Json.Linq.JArray" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />. 
            </summary>
      <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JArray" />.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray" /> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.Parse(System.String)">
      <summary>
            Load a <see cref="T:Newtonsoft.Json.Linq.JArray" /> from a string that contains JSON.
            </summary>
      <param name="json">A <see cref="T:System.String" /> that contains JSON.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray" /> populated from the string that contains JSON.</returns>
      <example>
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\LinqToJsonTests.cs" region="LinqToJsonCreateParseArray" title="Parsing a JSON Array from Text" />
      </example>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.FromObject(System.Object)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JArray" /> from an object.
            </summary>
      <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JArray" />.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray" /> with the values of the specified object</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.FromObject(System.Object,Newtonsoft.Json.JsonSerializer)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Linq.JArray" /> from an object.
            </summary>
      <param name="o">The object that will be used to create <see cref="T:Newtonsoft.Json.Linq.JArray" />.</param>
      <param name="jsonSerializer">The <see cref="T:Newtonsoft.Json.JsonSerializer" /> that will be used to read the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JArray" /> with the values of the specified object</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
      <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.IndexOf(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Determines the index of a specific item in the <see cref="T:System.Collections.Generic.IList`1" />.
            </summary>
      <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.IList`1" />.</param>
      <returns>
            The index of <paramref name="item" /> if found in the list; otherwise, -1.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.Insert(System.Int32,Newtonsoft.Json.Linq.JToken)">
      <summary>
            Inserts an item to the <see cref="T:System.Collections.Generic.IList`1" /> at the specified index.
            </summary>
      <param name="index">The zero-based index at which <paramref name="item" /> should be inserted.</param>
      <param name="item">The object to insert into the <see cref="T:System.Collections.Generic.IList`1" />.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.</exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.RemoveAt(System.Int32)">
      <summary>
            Removes the <see cref="T:System.Collections.Generic.IList`1" /> item at the specified index.
            </summary>
      <param name="index">The zero-based index of the item to remove.</param>
      <exception cref="T:System.ArgumentOutOfRangeException">
        <paramref name="index" /> is not a valid index in the <see cref="T:System.Collections.Generic.IList`1" />.</exception>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.IList`1" /> is read-only.</exception>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.GetEnumerator">
      <summary>
            Returns an enumerator that iterates through the collection.
            </summary>
      <returns>
            A <see cref="T:System.Collections.Generic.IEnumerator`1" /> that can be used to iterate through the collection.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.Add(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Adds an item to the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <param name="item">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</exception>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.Clear">
      <summary>
            Removes all items from the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only. </exception>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.Contains(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Determines whether the <see cref="T:System.Collections.Generic.ICollection`1" /> contains a specific value.
            </summary>
      <param name="item">The object to locate in the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
      <returns>
            true if <paramref name="item" /> is found in the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.CopyTo(Newtonsoft.Json.Linq.JToken[],System.Int32)">
      <summary>
            Copies to.
            </summary>
      <param name="array">The array.</param>
      <param name="arrayIndex">Index of the array.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JArray.Remove(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Removes the first occurrence of a specific object from the <see cref="T:System.Collections.Generic.ICollection`1" />.
            </summary>
      <param name="item">The object to remove from the <see cref="T:System.Collections.Generic.ICollection`1" />.</param>
      <returns>
            true if <paramref name="item" /> was successfully removed from the <see cref="T:System.Collections.Generic.ICollection`1" />; otherwise, false. This method also returns false if <paramref name="item" /> is not found in the original <see cref="T:System.Collections.Generic.ICollection`1" />.
            </returns>
      <exception cref="T:System.NotSupportedException">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</exception>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JArray.ChildrenTokens">
      <summary>
            Gets the container's children tokens.
            </summary>
      <value>The container's children tokens.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JArray.Type">
      <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <value>The type.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JArray.Item(System.Object)">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Linq.JToken" /> with the specified key.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JArray.Item(System.Int32)">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Linq.JToken" /> at the specified index.
            </summary>
      <value>
      </value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JArray.IsReadOnly">
      <summary>
            Gets a value indicating whether the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.
            </summary>
      <returns>true if the <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only; otherwise, false.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JTokenReader">
      <summary>
            Represents a reader that provides fast, non-cached, forward-only access to serialized Json data.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenReader.#ctor(Newtonsoft.Json.Linq.JToken)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JTokenReader" /> class.
            </summary>
      <param name="token">The token to read from.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenReader.ReadAsBytes">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:Byte[]" />.
            </summary>
      <returns>
            A <see cref="T:Byte[]" /> or a null reference if the next JSON token is null. This method will return <c>null</c> at the end of an array.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenReader.ReadAsDecimal">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenReader.ReadAsInt32">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenReader.ReadAsString">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.String" />.
            </summary>
      <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenReader.ReadAsDateTime">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.String" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenReader.ReadAsDateTimeOffset">
      <summary>
            Reads the next JSON token from the stream as a <see cref="T:System.Nullable`1" />.
            </summary>
      <returns>A <see cref="T:System.Nullable`1" />. This method will return <c>null</c> at the end of an array.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenReader.Read">
      <summary>
            Reads the next JSON token from the stream.
            </summary>
      <returns>
            true if the next token was read successfully; false if there are no more tokens to read.
            </returns>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JTokenWriter">
      <summary>
            Represents a writer that provides a fast, non-cached, forward-only way of generating Json data.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.#ctor(Newtonsoft.Json.Linq.JContainer)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JTokenWriter" /> class writing to the given <see cref="T:Newtonsoft.Json.Linq.JContainer" />.
            </summary>
      <param name="container">The container being written to.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JTokenWriter" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.Flush">
      <summary>
            Flushes whatever is in the buffer to the underlying streams and also flushes the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.Close">
      <summary>
            Closes this stream and the underlying stream.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteStartObject">
      <summary>
            Writes the beginning of a Json object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteStartArray">
      <summary>
            Writes the beginning of a Json array.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteStartConstructor(System.String)">
      <summary>
            Writes the start of a constructor with the given name.
            </summary>
      <param name="name">The name of the constructor.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteEnd(Newtonsoft.Json.JsonToken)">
      <summary>
            Writes the end.
            </summary>
      <param name="token">The token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WritePropertyName(System.String)">
      <summary>
            Writes the property name of a name/value pair on a Json object.
            </summary>
      <param name="name">The name of the property.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Object)">
      <summary>
            Writes a <see cref="T:System.Object" /> value.
            An error will raised if the value cannot be written as a single JSON token.
            </summary>
      <param name="value">The <see cref="T:System.Object" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteNull">
      <summary>
            Writes a null value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteUndefined">
      <summary>
            Writes an undefined value.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteRaw(System.String)">
      <summary>
            Writes raw JSON.
            </summary>
      <param name="json">The raw JSON to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteComment(System.String)">
      <summary>
            Writes out a comment <code>/*...*/</code> containing the specified text.
            </summary>
      <param name="text">Text to place inside the comment.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.String)">
      <summary>
            Writes a <see cref="T:System.String" /> value.
            </summary>
      <param name="value">The <see cref="T:System.String" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Int32)">
      <summary>
            Writes a <see cref="T:System.Int32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.UInt32)">
      <summary>
            Writes a <see cref="T:System.UInt32" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt32" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Int64)">
      <summary>
            Writes a <see cref="T:System.Int64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.UInt64)">
      <summary>
            Writes a <see cref="T:System.UInt64" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt64" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Single)">
      <summary>
            Writes a <see cref="T:System.Single" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Single" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Double)">
      <summary>
            Writes a <see cref="T:System.Double" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Double" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Boolean)">
      <summary>
            Writes a <see cref="T:System.Boolean" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Boolean" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Int16)">
      <summary>
            Writes a <see cref="T:System.Int16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Int16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.UInt16)">
      <summary>
            Writes a <see cref="T:System.UInt16" /> value.
            </summary>
      <param name="value">The <see cref="T:System.UInt16" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Char)">
      <summary>
            Writes a <see cref="T:System.Char" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Char" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Byte)">
      <summary>
            Writes a <see cref="T:System.Byte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Byte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.SByte)">
      <summary>
            Writes a <see cref="T:System.SByte" /> value.
            </summary>
      <param name="value">The <see cref="T:System.SByte" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Decimal)">
      <summary>
            Writes a <see cref="T:System.Decimal" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Decimal" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.DateTime)">
      <summary>
            Writes a <see cref="T:System.DateTime" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTime" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.DateTimeOffset)">
      <summary>
            Writes a <see cref="T:System.DateTimeOffset" /> value.
            </summary>
      <param name="value">The <see cref="T:System.DateTimeOffset" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Byte[])">
      <summary>
            Writes a <see cref="T:Byte[]" /> value.
            </summary>
      <param name="value">The <see cref="T:Byte[]" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.TimeSpan)">
      <summary>
            Writes a <see cref="T:System.TimeSpan" /> value.
            </summary>
      <param name="value">The <see cref="T:System.TimeSpan" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Guid)">
      <summary>
            Writes a <see cref="T:System.Guid" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Guid" /> value to write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JTokenWriter.WriteValue(System.Uri)">
      <summary>
            Writes a <see cref="T:System.Uri" /> value.
            </summary>
      <param name="value">The <see cref="T:System.Uri" /> value to write.</param>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JTokenWriter.Token">
      <summary>
            Gets the token being writen.
            </summary>
      <value>The token being writen.</value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JProperty">
      <summary>
            Represents a JSON property.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JProperty.#ctor(Newtonsoft.Json.Linq.JProperty)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JProperty" /> class from another <see cref="T:Newtonsoft.Json.Linq.JProperty" /> object.
            </summary>
      <param name="other">A <see cref="T:Newtonsoft.Json.Linq.JProperty" /> object to copy from.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JProperty.#ctor(System.String,System.Object[])">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JProperty" /> class.
            </summary>
      <param name="name">The property name.</param>
      <param name="content">The property content.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JProperty.#ctor(System.String,System.Object)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Linq.JProperty" /> class.
            </summary>
      <param name="name">The property name.</param>
      <param name="content">The property content.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JProperty.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.JsonConverter[])">
      <summary>
            Writes this token to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
      <param name="converters">A collection of <see cref="T:Newtonsoft.Json.JsonConverter" /> which will be used when writing the token.</param>
    </member>
    <member name="M:Newtonsoft.Json.Linq.JProperty.Load(Newtonsoft.Json.JsonReader)">
      <summary>
            Loads an <see cref="T:Newtonsoft.Json.Linq.JProperty" /> from a <see cref="T:Newtonsoft.Json.JsonReader" />. 
            </summary>
      <param name="reader">A <see cref="T:Newtonsoft.Json.JsonReader" /> that will be read for the content of the <see cref="T:Newtonsoft.Json.Linq.JProperty" />.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Linq.JProperty" /> that contains the JSON that was read from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.</returns>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JProperty.ChildrenTokens">
      <summary>
            Gets the container's children tokens.
            </summary>
      <value>The container's children tokens.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JProperty.Name">
      <summary>
            Gets the property name.
            </summary>
      <value>The property name.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JProperty.Value">
      <summary>
            Gets or sets the property value.
            </summary>
      <value>The property value.</value>
    </member>
    <member name="P:Newtonsoft.Json.Linq.JProperty.Type">
      <summary>
            Gets the node type for this <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <value>The type.</value>
    </member>
    <member name="T:Newtonsoft.Json.Linq.JTokenType">
      <summary>
            Specifies the type of token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.None">
      <summary>
            No token type has been set.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Object">
      <summary>
            A JSON object.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Array">
      <summary>
            A JSON array.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Constructor">
      <summary>
            A JSON constructor.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Property">
      <summary>
            A JSON object property.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Comment">
      <summary>
            A comment.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Integer">
      <summary>
            An integer value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Float">
      <summary>
            A float value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.String">
      <summary>
            A string value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Boolean">
      <summary>
            A boolean value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Null">
      <summary>
            A null value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Undefined">
      <summary>
            An undefined value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Date">
      <summary>
            A date value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Raw">
      <summary>
            A raw JSON value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Bytes">
      <summary>
            A collection of bytes value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Guid">
      <summary>
            A Guid value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.Uri">
      <summary>
            A Uri value.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Linq.JTokenType.TimeSpan">
      <summary>
            A TimeSpan value.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Schema.Extensions">
      <summary>
            Contains the JSON schema extension methods.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.Extensions.IsValid(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Schema.JsonSchema)">
      <summary>
            Determines whether the <see cref="T:Newtonsoft.Json.Linq.JToken" /> is valid.
            </summary>
      <param name="source">The source <see cref="T:Newtonsoft.Json.Linq.JToken" /> to test.</param>
      <param name="schema">The schema to test with.</param>
      <returns>
        <c>true</c> if the specified <see cref="T:Newtonsoft.Json.Linq.JToken" /> is valid; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.Extensions.IsValid(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Schema.JsonSchema,System.Collections.Generic.IList{System.String}@)">
      <summary>
            Determines whether the <see cref="T:Newtonsoft.Json.Linq.JToken" /> is valid.
            </summary>
      <param name="source">The source <see cref="T:Newtonsoft.Json.Linq.JToken" /> to test.</param>
      <param name="schema">The schema to test with.</param>
      <param name="errorMessages">When this method returns, contains any error messages generated while validating. </param>
      <returns>
        <c>true</c> if the specified <see cref="T:Newtonsoft.Json.Linq.JToken" /> is valid; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.Extensions.Validate(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Schema.JsonSchema)">
      <summary>
            Validates the specified <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="source">The source <see cref="T:Newtonsoft.Json.Linq.JToken" /> to test.</param>
      <param name="schema">The schema to test with.</param>
    </member>
    <member name="M:Newtonsoft.Json.Schema.Extensions.Validate(Newtonsoft.Json.Linq.JToken,Newtonsoft.Json.Schema.JsonSchema,Newtonsoft.Json.Schema.ValidationEventHandler)">
      <summary>
            Validates the specified <see cref="T:Newtonsoft.Json.Linq.JToken" />.
            </summary>
      <param name="source">The source <see cref="T:Newtonsoft.Json.Linq.JToken" /> to test.</param>
      <param name="schema">The schema to test with.</param>
      <param name="validationEventHandler">The validation event handler.</param>
    </member>
    <member name="T:Newtonsoft.Json.Schema.JsonSchemaException">
      <summary>
            Returns detailed information about the schema exception.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaException.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaException" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaException.#ctor(System.String)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaException" /> class
            with a specified error message.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaException.#ctor(System.String,System.Exception)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaException" /> class
            with a specified error message and a reference to the inner exception that is the cause of this exception.
            </summary>
      <param name="message">The error message that explains the reason for the exception.</param>
      <param name="innerException">The exception that is the cause of the current exception, or a null reference (Nothing in Visual Basic) if no inner exception is specified.</param>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaException" /> class.
            </summary>
      <param name="info">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> that holds the serialized object data about the exception being thrown.</param>
      <param name="context">The <see cref="T:System.Runtime.Serialization.StreamingContext" /> that contains contextual information about the source or destination.</param>
      <exception cref="T:System.ArgumentNullException">The <paramref name="info" /> parameter is null. </exception>
      <exception cref="T:System.Runtime.Serialization.SerializationException">The class name is null or <see cref="P:System.Exception.HResult" /> is zero (0). </exception>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchemaException.LineNumber">
      <summary>
            Gets the line number indicating where the error occurred.
            </summary>
      <value>The line number indicating where the error occurred.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchemaException.LinePosition">
      <summary>
            Gets the line position indicating where the error occurred.
            </summary>
      <value>The line position indicating where the error occurred.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchemaException.Path">
      <summary>
            Gets the path to the JSON where the error occurred.
            </summary>
      <value>The path to the JSON where the error occurred.</value>
    </member>
    <member name="T:Newtonsoft.Json.Schema.JsonSchemaResolver">
      <summary>
            Resolves <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from an id.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaResolver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaResolver" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaResolver.GetSchema(System.String)">
      <summary>
            Gets a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> for the specified reference.
            </summary>
      <param name="reference">The id.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> for the specified reference.</returns>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchemaResolver.LoadedSchemas">
      <summary>
            Gets or sets the loaded schemas.
            </summary>
      <value>The loaded schemas.</value>
    </member>
    <member name="T:Newtonsoft.Json.Schema.UndefinedSchemaIdHandling">
      <summary>
            Specifies undefined schema Id handling options for the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaGenerator" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.UndefinedSchemaIdHandling.None">
      <summary>
            Do not infer a schema Id.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.UndefinedSchemaIdHandling.UseTypeName">
      <summary>
            Use the .NET type name as the schema Id.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.UndefinedSchemaIdHandling.UseAssemblyQualifiedName">
      <summary>
            Use the assembly qualified .NET type name as the schema Id.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Schema.ValidationEventArgs">
      <summary>
            Returns detailed information related to the <see cref="T:Newtonsoft.Json.Schema.ValidationEventHandler" />.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.ValidationEventArgs.Exception">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Schema.JsonSchemaException" /> associated with the validation error.
            </summary>
      <value>The JsonSchemaException associated with the validation error.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.ValidationEventArgs.Path">
      <summary>
            Gets the path of the JSON location where the validation error occurred.
            </summary>
      <value>The path of the JSON location where the validation error occurred.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.ValidationEventArgs.Message">
      <summary>
            Gets the text description corresponding to the validation error.
            </summary>
      <value>The text description.</value>
    </member>
    <member name="T:Newtonsoft.Json.Schema.ValidationEventHandler">
      <summary>
            Represents the callback method that will handle JSON schema validation events and the <see cref="T:Newtonsoft.Json.Schema.ValidationEventArgs" />.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.IContractResolver">
      <summary>
            Used by <see cref="T:Newtonsoft.Json.JsonSerializer" /> to resolves a <see cref="T:Newtonsoft.Json.Serialization.JsonContract" /> for a given <see cref="T:System.Type" />.
            </summary>
      <example>
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeContractResolverObject" title="IContractResolver Class" />
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeContractResolverExample" title="IContractResolver Example" />
      </example>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.IContractResolver.ResolveContract(System.Type)">
      <summary>
            Resolves the contract for a given type.
            </summary>
      <param name="type">The type to resolve a contract for.</param>
      <returns>The contract for a given type.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.DefaultContractResolver">
      <summary>
            Used by <see cref="T:Newtonsoft.Json.JsonSerializer" /> to resolves a <see cref="T:Newtonsoft.Json.Serialization.JsonContract" /> for a given <see cref="T:System.Type" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.DefaultContractResolver" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.#ctor(System.Boolean)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.DefaultContractResolver" /> class.
            </summary>
      <param name="shareCache">
            If set to <c>true</c> the <see cref="T:Newtonsoft.Json.Serialization.DefaultContractResolver" /> will use a cached shared with other resolvers of the same type.
            Sharing the cache will significantly performance because expensive reflection will only happen once but could cause unexpected
            behavior if different instances of the resolver are suppose to produce different results. When set to false it is highly
            recommended to reuse <see cref="T:Newtonsoft.Json.Serialization.DefaultContractResolver" /> instances with the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.ResolveContract(System.Type)">
      <summary>
            Resolves the contract for a given type.
            </summary>
      <param name="type">The type to resolve a contract for.</param>
      <returns>The contract for a given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.GetSerializableMembers(System.Type)">
      <summary>
            Gets the serializable members for the type.
            </summary>
      <param name="objectType">The type to get serializable members for.</param>
      <returns>The serializable members for the type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateObjectContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonObjectContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonObjectContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateConstructorParameters(System.Reflection.ConstructorInfo,Newtonsoft.Json.Serialization.JsonPropertyCollection)">
      <summary>
            Creates the constructor parameters.
            </summary>
      <param name="constructor">The constructor to create properties for.</param>
      <param name="memberProperties">The type's member properties.</param>
      <returns>Properties for the given <see cref="T:System.Reflection.ConstructorInfo" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreatePropertyFromConstructorParameter(Newtonsoft.Json.Serialization.JsonProperty,System.Reflection.ParameterInfo)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> for the given <see cref="T:System.Reflection.ParameterInfo" />.
            </summary>
      <param name="matchingMemberProperty">The matching member property.</param>
      <param name="parameterInfo">The constructor parameter.</param>
      <returns>A created <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> for the given <see cref="T:System.Reflection.ParameterInfo" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.ResolveContractConverter(System.Type)">
      <summary>
            Resolves the default <see cref="T:Newtonsoft.Json.JsonConverter" /> for the contract.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>The contract's default <see cref="T:Newtonsoft.Json.JsonConverter" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateDictionaryContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonDictionaryContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonDictionaryContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateArrayContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonArrayContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonArrayContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreatePrimitiveContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonPrimitiveContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonPrimitiveContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateLinqContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonLinqContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonLinqContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateISerializableContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonISerializableContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonISerializableContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateDynamicContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonDynamicContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonDynamicContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateStringContract(System.Type)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonStringContract" /> for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonStringContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateContract(System.Type)">
      <summary>
            Determines which contract type is created for the given type.
            </summary>
      <param name="objectType">Type of the object.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Serialization.JsonContract" /> for the given type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateProperties(System.Type,Newtonsoft.Json.MemberSerialization)">
      <summary>
            Creates properties for the given <see cref="T:Newtonsoft.Json.Serialization.JsonContract" />.
            </summary>
      <param name="type">The type to create properties for.</param>
            /// <param name="memberSerialization">The member serialization mode for the type.</param><returns>Properties for the given <see cref="T:Newtonsoft.Json.Serialization.JsonContract" />.</returns></member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateMemberValueProvider(System.Reflection.MemberInfo)">
      <summary>
            Creates the <see cref="T:Newtonsoft.Json.Serialization.IValueProvider" /> used by the serializer to get and set values from a member.
            </summary>
      <param name="member">The member.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Serialization.IValueProvider" /> used by the serializer to get and set values from a member.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.CreateProperty(System.Reflection.MemberInfo,Newtonsoft.Json.MemberSerialization)">
      <summary>
            Creates a <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> for the given <see cref="T:System.Reflection.MemberInfo" />.
            </summary>
      <param name="memberSerialization">The member's parent <see cref="T:Newtonsoft.Json.MemberSerialization" />.</param>
      <param name="member">The member to create a <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> for.</param>
      <returns>A created <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> for the given <see cref="T:System.Reflection.MemberInfo" />.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.ResolvePropertyName(System.String)">
      <summary>
            Resolves the name of the property.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>Name of the property.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultContractResolver.GetResolvedPropertyName(System.String)">
      <summary>
            Gets the resolved name of the property.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>Name of the property.</returns>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.DefaultContractResolver.DynamicCodeGeneration">
      <summary>
            Gets a value indicating whether members are being get and set using dynamic code generation.
            This value is determined by the runtime permissions available.
            </summary>
      <value>
        <c>true</c> if using dynamic code generation; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.DefaultContractResolver.DefaultMembersSearchFlags">
      <summary>
            Gets or sets the default members search flags.
            </summary>
      <value>The default members search flags.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.DefaultContractResolver.SerializeCompilerGeneratedMembers">
      <summary>
            Gets or sets a value indicating whether compiler generated members should be serialized.
            </summary>
      <value>
        <c>true</c> if serialized compiler generated members; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.DefaultContractResolver.IgnoreSerializableInterface">
      <summary>
            Gets or sets a value indicating whether to ignore the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface when serializing and deserializing types.
            </summary>
      <value>
        <c>true</c> if the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface will be ignored when serializing and deserializing types; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.DefaultContractResolver.IgnoreSerializableAttribute">
      <summary>
            Gets or sets a value indicating whether to ignore the <see cref="T:System.SerializableAttribute" /> attribute when serializing and deserializing types.
            </summary>
      <value>
        <c>true</c> if the <see cref="T:System.SerializableAttribute" /> attribute will be ignored when serializing and deserializing types; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver">
      <summary>
            Resolves member mappings for a type, camel casing property names.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.CamelCasePropertyNamesContractResolver.ResolvePropertyName(System.String)">
      <summary>
            Resolves the name of the property.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>The property name camel cased.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.DefaultSerializationBinder">
      <summary>
            The default serialization binder used when resolving and loading classes from type names.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultSerializationBinder.BindToType(System.String,System.String)">
      <summary>
            When overridden in a derived class, controls the binding of a serialized object to a type.
            </summary>
      <param name="assemblyName">Specifies the <see cref="T:System.Reflection.Assembly" /> name of the serialized object.</param>
      <param name="typeName">Specifies the <see cref="T:System.Type" /> name of the serialized object.</param>
      <returns>
            The type of the object the formatter creates a new instance of.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.DefaultSerializationBinder.BindToName(System.Type,System.String@,System.String@)">
      <summary>
            When overridden in a derived class, controls the binding of a serialized object to a type.
            </summary>
      <param name="serializedType">The type of the object the formatter creates a new instance of.</param>
      <param name="assemblyName">Specifies the <see cref="T:System.Reflection.Assembly" /> name of the serialized object. </param>
      <param name="typeName">Specifies the <see cref="T:System.Type" /> name of the serialized object. </param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.ErrorContext">
      <summary>
            Provides information surrounding an error.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ErrorContext.Error">
      <summary>
            Gets the error.
            </summary>
      <value>The error.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ErrorContext.OriginalObject">
      <summary>
            Gets the original object that caused the error.
            </summary>
      <value>The original object that caused the error.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ErrorContext.Member">
      <summary>
            Gets the member that caused the error.
            </summary>
      <value>The member that caused the error.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ErrorContext.Path">
      <summary>
            Gets the path of the JSON location where the error occurred.
            </summary>
      <value>The path of the JSON location where the error occurred.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.ErrorContext.Handled">
      <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.ErrorContext" /> is handled.
            </summary>
      <value>
        <c>true</c> if handled; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonArrayContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonArrayContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonArrayContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonArrayContract.CollectionItemType">
      <summary>
            Gets the <see cref="T:System.Type" /> of the collection items.
            </summary>
      <value>The <see cref="T:System.Type" /> of the collection items.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonArrayContract.IsMultidimensionalArray">
      <summary>
            Gets a value indicating whether the collection type is a multidimensional array.
            </summary>
      <value>
        <c>true</c> if the collection type is a multidimensional array; otherwise, <c>false</c>.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.SerializationCallback">
      <summary>
            Handles <see cref="T:Newtonsoft.Json.JsonSerializer" /> serialization callback events.
            </summary>
      <param name="o">The object that raised the callback event.</param>
      <param name="context">The streaming context.</param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.SerializationErrorCallback">
      <summary>
            Handles <see cref="T:Newtonsoft.Json.JsonSerializer" /> serialization error callback events.
            </summary>
      <param name="o">The object that raised the callback event.</param>
      <param name="context">The streaming context.</param>
      <param name="errorContext">The error context.</param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.ExtensionDataSetter">
      <summary>
            Sets extension data for an object during deserialization.
            </summary>
      <param name="o">The object to set extension data on.</param>
      <param name="key">The extension data key.</param>
      <param name="value">The extension data value.</param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.ExtensionDataGetter">
      <summary>
            Gets extension data for an object during serialization.
            </summary>
      <param name="o">The object to set extension data on.</param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonDictionaryContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonDictionaryContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonDictionaryContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonDictionaryContract.PropertyNameResolver">
      <summary>
            Gets or sets the property name resolver.
            </summary>
      <value>The property name resolver.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonDictionaryContract.DictionaryKeyType">
      <summary>
            Gets the <see cref="T:System.Type" /> of the dictionary keys.
            </summary>
      <value>The <see cref="T:System.Type" /> of the dictionary keys.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonDictionaryContract.DictionaryValueType">
      <summary>
            Gets the <see cref="T:System.Type" /> of the dictionary values.
            </summary>
      <value>The <see cref="T:System.Type" /> of the dictionary values.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonProperty">
      <summary>
            Maps a JSON property to a .NET member or constructor parameter.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonProperty.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents this instance.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents this instance.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.PropertyName">
      <summary>
            Gets or sets the name of the property.
            </summary>
      <value>The name of the property.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.DeclaringType">
      <summary>
            Gets or sets the type that declared this property.
            </summary>
      <value>The type that declared this property.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Order">
      <summary>
            Gets or sets the order of serialization and deserialization of a member.
            </summary>
      <value>The numeric order of serialization or deserialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.UnderlyingName">
      <summary>
            Gets or sets the name of the underlying member or parameter.
            </summary>
      <value>The name of the underlying member or parameter.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ValueProvider">
      <summary>
            Gets the <see cref="T:Newtonsoft.Json.Serialization.IValueProvider" /> that will get and set the <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> during serialization.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Serialization.IValueProvider" /> that will get and set the <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> during serialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.PropertyType">
      <summary>
            Gets or sets the type of the property.
            </summary>
      <value>The type of the property.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Converter">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.JsonConverter" /> for the property.
            If set this converter takes presidence over the contract converter for the property type.
            </summary>
      <value>The converter.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.MemberConverter">
      <summary>
            Gets or sets the member converter.
            </summary>
      <value>The member converter.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Ignored">
      <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> is ignored.
            </summary>
      <value>
        <c>true</c> if ignored; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Readable">
      <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> is readable.
            </summary>
      <value>
        <c>true</c> if readable; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Writable">
      <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> is writable.
            </summary>
      <value>
        <c>true</c> if writable; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.HasMemberAttribute">
      <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> has a member attribute.
            </summary>
      <value>
        <c>true</c> if has a member attribute; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.DefaultValue">
      <summary>
            Gets the default value.
            </summary>
      <value>The default value.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.Required">
      <summary>
            Gets or sets a value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> is required.
            </summary>
      <value>A value indicating whether this <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> is required.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.IsReference">
      <summary>
            Gets or sets a value indicating whether this property preserves object references.
            </summary>
      <value>
        <c>true</c> if this instance is reference; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.NullValueHandling">
      <summary>
            Gets or sets the property null value handling.
            </summary>
      <value>The null value handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.DefaultValueHandling">
      <summary>
            Gets or sets the property default value handling.
            </summary>
      <value>The default value handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ReferenceLoopHandling">
      <summary>
            Gets or sets the property reference loop handling.
            </summary>
      <value>The reference loop handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ObjectCreationHandling">
      <summary>
            Gets or sets the property object creation handling.
            </summary>
      <value>The object creation handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.TypeNameHandling">
      <summary>
            Gets or sets or sets the type name handling.
            </summary>
      <value>The type name handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ShouldSerialize">
      <summary>
            Gets or sets a predicate used to determine whether the property should be serialize.
            </summary>
      <value>A predicate used to determine whether the property should be serialize.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.GetIsSpecified">
      <summary>
            Gets or sets a predicate used to determine whether the property should be serialized.
            </summary>
      <value>A predicate used to determine whether the property should be serialized.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.SetIsSpecified">
      <summary>
            Gets or sets an action used to set whether the property has been deserialized.
            </summary>
      <value>An action used to set whether the property has been deserialized.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ItemConverter">
      <summary>
            Gets or sets the converter used when serializing the property's collection items.
            </summary>
      <value>The collection's items converter.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ItemIsReference">
      <summary>
            Gets or sets whether this property's collection items are serialized as a reference.
            </summary>
      <value>Whether this property's collection items are serialized as a reference.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ItemTypeNameHandling">
      <summary>
            Gets or sets the the type name handling used when serializing the property's collection items.
            </summary>
      <value>The collection's items type name handling.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonProperty.ItemReferenceLoopHandling">
      <summary>
            Gets or sets the the reference loop handling used when serializing the property's collection items.
            </summary>
      <value>The collection's items reference loop handling.</value>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonPropertyCollection">
      <summary>
            A collection of <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> objects.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonPropertyCollection.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonPropertyCollection" /> class.
            </summary>
      <param name="type">The type.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonPropertyCollection.GetKeyForItem(Newtonsoft.Json.Serialization.JsonProperty)">
      <summary>
            When implemented in a derived class, extracts the key from the specified element.
            </summary>
      <param name="item">The element from which to extract the key.</param>
      <returns>The key for the specified element.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonPropertyCollection.AddProperty(Newtonsoft.Json.Serialization.JsonProperty)">
      <summary>
            Adds a <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> object.
            </summary>
      <param name="property">The property to add to the collection.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonPropertyCollection.GetClosestMatchProperty(System.String)">
      <summary>
            Gets the closest matching <see cref="T:Newtonsoft.Json.Serialization.JsonProperty" /> object.
            First attempts to get an exact case match of propertyName and then
            a case insensitive match.
            </summary>
      <param name="propertyName">Name of the property.</param>
      <returns>A matching property if found.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonPropertyCollection.GetProperty(System.String,System.StringComparison)">
      <summary>
            Gets a property by property name.
            </summary>
      <param name="propertyName">The name of the property to get.</param>
      <param name="comparisonType">Type property name string comparison.</param>
      <returns>A matching property if found.</returns>
    </member>
    <member name="T:Newtonsoft.Json.MissingMemberHandling">
      <summary>
            Specifies missing member handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.MissingMemberHandling.Ignore">
      <summary>
            Ignore a missing member and do not attempt to deserialize it.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.MissingMemberHandling.Error">
      <summary>
            Throw a <see cref="T:Newtonsoft.Json.JsonSerializationException" /> when a missing member is encountered during deserialization.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.NullValueHandling">
      <summary>
            Specifies null value handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
      <example>
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeNullValueHandlingObject" title="NullValueHandling Class" />
        <code lang="cs" source="..\Src\Newtonsoft.Json.Tests\Documentation\SerializationTests.cs" region="ReducingSerializedJsonSizeNullValueHandlingExample" title="NullValueHandling Ignore Example" />
      </example>
    </member>
    <member name="F:Newtonsoft.Json.NullValueHandling.Include">
      <summary>
            Include null values when serializing and deserializing objects.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.NullValueHandling.Ignore">
      <summary>
            Ignore null values when serializing and deserializing objects.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.ReferenceLoopHandling">
      <summary>
            Specifies reference loop handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ReferenceLoopHandling.Error">
      <summary>
            Throw a <see cref="T:Newtonsoft.Json.JsonSerializationException" /> when a loop is encountered.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ReferenceLoopHandling.Ignore">
      <summary>
            Ignore loop references and do not serialize.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.ReferenceLoopHandling.Serialize">
      <summary>
            Serialize loop references.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Schema.JsonSchema">
      <summary>
            An in-memory representation of a JSON Schema.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.#ctor">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> class.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.Read(Newtonsoft.Json.JsonReader)">
      <summary>
            Reads a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> containing the JSON Schema to read.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> object representing the JSON Schema.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.Read(Newtonsoft.Json.JsonReader,Newtonsoft.Json.Schema.JsonSchemaResolver)">
      <summary>
            Reads a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from the specified <see cref="T:Newtonsoft.Json.JsonReader" />.
            </summary>
      <param name="reader">The <see cref="T:Newtonsoft.Json.JsonReader" /> containing the JSON Schema to read.</param>
      <param name="resolver">The <see cref="T:Newtonsoft.Json.Schema.JsonSchemaResolver" /> to use when resolving schema references.</param>
      <returns>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> object representing the JSON Schema.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.Parse(System.String)">
      <summary>
            Load a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from a string that contains schema JSON.
            </summary>
      <param name="json">A <see cref="T:System.String" /> that contains JSON.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> populated from the string that contains JSON.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.Parse(System.String,Newtonsoft.Json.Schema.JsonSchemaResolver)">
      <summary>
            Parses the specified json.
            </summary>
      <param name="json">The json.</param>
      <param name="resolver">The resolver.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> populated from the string that contains JSON.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.WriteTo(Newtonsoft.Json.JsonWriter)">
      <summary>
            Writes this schema to a <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.WriteTo(Newtonsoft.Json.JsonWriter,Newtonsoft.Json.Schema.JsonSchemaResolver)">
      <summary>
            Writes this schema to a <see cref="T:Newtonsoft.Json.JsonWriter" /> using the specified <see cref="T:Newtonsoft.Json.Schema.JsonSchemaResolver" />.
            </summary>
      <param name="writer">A <see cref="T:Newtonsoft.Json.JsonWriter" /> into which this method will write.</param>
      <param name="resolver">The resolver used.</param>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchema.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> that represents the current <see cref="T:System.Object" />.
            </returns>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Id">
      <summary>
            Gets or sets the id.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Title">
      <summary>
            Gets or sets the title.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Required">
      <summary>
            Gets or sets whether the object is required.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.ReadOnly">
      <summary>
            Gets or sets whether the object is read only.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Hidden">
      <summary>
            Gets or sets whether the object is visible to users.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Transient">
      <summary>
            Gets or sets whether the object is transient.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Description">
      <summary>
            Gets or sets the description of the object.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Type">
      <summary>
            Gets or sets the types of values allowed by the object.
            </summary>
      <value>The type.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Pattern">
      <summary>
            Gets or sets the pattern.
            </summary>
      <value>The pattern.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.MinimumLength">
      <summary>
            Gets or sets the minimum length.
            </summary>
      <value>The minimum length.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.MaximumLength">
      <summary>
            Gets or sets the maximum length.
            </summary>
      <value>The maximum length.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.DivisibleBy">
      <summary>
            Gets or sets a number that the value should be divisble by.
            </summary>
      <value>A number that the value should be divisble by.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Minimum">
      <summary>
            Gets or sets the minimum.
            </summary>
      <value>The minimum.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Maximum">
      <summary>
            Gets or sets the maximum.
            </summary>
      <value>The maximum.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.ExclusiveMinimum">
      <summary>
            Gets or sets a flag indicating whether the value can not equal the number defined by the "minimum" attribute.
            </summary>
      <value>A flag indicating whether the value can not equal the number defined by the "minimum" attribute.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.ExclusiveMaximum">
      <summary>
            Gets or sets a flag indicating whether the value can not equal the number defined by the "maximum" attribute.
            </summary>
      <value>A flag indicating whether the value can not equal the number defined by the "maximum" attribute.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.MinimumItems">
      <summary>
            Gets or sets the minimum number of items.
            </summary>
      <value>The minimum number of items.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.MaximumItems">
      <summary>
            Gets or sets the maximum number of items.
            </summary>
      <value>The maximum number of items.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Items">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of items.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of items.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.PositionalItemsValidation">
      <summary>
            Gets or sets a value indicating whether items in an array are validated using the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> instance at their array position from <see cref="P:Newtonsoft.Json.Schema.JsonSchema.Items" />.
            </summary>
      <value>
        <c>true</c> if items are validated using their array position; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.AdditionalItems">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of additional items.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of additional items.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.AllowAdditionalItems">
      <summary>
            Gets or sets a value indicating whether additional items are allowed.
            </summary>
      <value>
        <c>true</c> if additional items are allowed; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.UniqueItems">
      <summary>
            Gets or sets whether the array items must be unique.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Properties">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of properties.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of properties.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.AdditionalProperties">
      <summary>
            Gets or sets the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of additional properties.
            </summary>
      <value>The <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> of additional properties.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.PatternProperties">
      <summary>
            Gets or sets the pattern properties.
            </summary>
      <value>The pattern properties.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.AllowAdditionalProperties">
      <summary>
            Gets or sets a value indicating whether additional properties are allowed.
            </summary>
      <value>
        <c>true</c> if additional properties are allowed; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Requires">
      <summary>
            Gets or sets the required property if this property is present.
            </summary>
      <value>The required property if this property is present.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Enum">
      <summary>
            Gets or sets the a collection of valid enum values allowed.
            </summary>
      <value>A collection of valid enum values allowed.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Disallow">
      <summary>
            Gets or sets disallowed types.
            </summary>
      <value>The disallow types.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Default">
      <summary>
            Gets or sets the default value.
            </summary>
      <value>The default value.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Extends">
      <summary>
            Gets or sets the collection of <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> that this schema extends.
            </summary>
      <value>The collection of <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> that this schema extends.</value>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchema.Format">
      <summary>
            Gets or sets the format.
            </summary>
      <value>The format.</value>
    </member>
    <member name="T:Newtonsoft.Json.Schema.JsonSchemaGenerator">
      <summary>
            Generates a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from a specified <see cref="T:System.Type" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaGenerator.Generate(System.Type)">
      <summary>
            Generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from the specified type.
            </summary>
      <param name="type">The type to generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> generated from the specified type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaGenerator.Generate(System.Type,Newtonsoft.Json.Schema.JsonSchemaResolver)">
      <summary>
            Generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from the specified type.
            </summary>
      <param name="type">The type to generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from.</param>
      <param name="resolver">The <see cref="T:Newtonsoft.Json.Schema.JsonSchemaResolver" /> used to resolve schema references.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> generated from the specified type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaGenerator.Generate(System.Type,System.Boolean)">
      <summary>
            Generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from the specified type.
            </summary>
      <param name="type">The type to generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from.</param>
      <param name="rootSchemaNullable">Specify whether the generated root <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> will be nullable.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> generated from the specified type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Schema.JsonSchemaGenerator.Generate(System.Type,Newtonsoft.Json.Schema.JsonSchemaResolver,System.Boolean)">
      <summary>
            Generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from the specified type.
            </summary>
      <param name="type">The type to generate a <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> from.</param>
      <param name="resolver">The <see cref="T:Newtonsoft.Json.Schema.JsonSchemaResolver" /> used to resolve schema references.</param>
      <param name="rootSchemaNullable">Specify whether the generated root <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> will be nullable.</param>
      <returns>A <see cref="T:Newtonsoft.Json.Schema.JsonSchema" /> generated from the specified type.</returns>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchemaGenerator.UndefinedSchemaIdHandling">
      <summary>
            Gets or sets how undefined schemas are handled by the serializer.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Schema.JsonSchemaGenerator.ContractResolver">
      <summary>
            Gets or sets the contract resolver.
            </summary>
      <value>The contract resolver.</value>
    </member>
    <member name="T:Newtonsoft.Json.Schema.JsonSchemaType">
      <summary>
            The value types allowed by the <see cref="T:Newtonsoft.Json.Schema.JsonSchema" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.None">
      <summary>
            No type specified.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.String">
      <summary>
            String type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Float">
      <summary>
            Float type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Integer">
      <summary>
            Integer type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Boolean">
      <summary>
            Boolean type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Object">
      <summary>
            Object type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Array">
      <summary>
            Array type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Null">
      <summary>
            Null type.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.Schema.JsonSchemaType.Any">
      <summary>
            Any type.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonObjectContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonObjectContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonObjectContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.MemberSerialization">
      <summary>
            Gets or sets the object member serialization.
            </summary>
      <value>The member object serialization.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.ItemRequired">
      <summary>
            Gets or sets a value that indicates whether the object's properties are required.
            </summary>
      <value>
            	A value indicating whether the object's properties are required.
            </value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.Properties">
      <summary>
            Gets the object's properties.
            </summary>
      <value>The object's properties.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.ConstructorParameters">
      <summary>
            Gets the constructor parameters required for any non-default constructor
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.OverrideConstructor">
      <summary>
            Gets or sets the override constructor used to create the object.
            This is set when a constructor is marked up using the
            JsonConstructor attribute.
            </summary>
      <value>The override constructor.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.ParametrizedConstructor">
      <summary>
            Gets or sets the parametrized constructor used to create the object.
            </summary>
      <value>The parametrized constructor.</value>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.ExtensionDataSetter">
      <summary>
            Gets or sets the extension data setter.
            </summary>
    </member>
    <member name="P:Newtonsoft.Json.Serialization.JsonObjectContract.ExtensionDataGetter">
      <summary>
            Gets or sets the extension data getter.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.JsonStringContract">
      <summary>
            Contract details for a <see cref="T:System.Type" /> used by the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.JsonStringContract.#ctor(System.Type)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.JsonStringContract" /> class.
            </summary>
      <param name="underlyingType">The underlying type for the contract.</param>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.ReflectionValueProvider">
      <summary>
            Get and set values for a <see cref="T:System.Reflection.MemberInfo" /> using reflection.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.ReflectionValueProvider.#ctor(System.Reflection.MemberInfo)">
      <summary>
            Initializes a new instance of the <see cref="T:Newtonsoft.Json.Serialization.ReflectionValueProvider" /> class.
            </summary>
      <param name="memberInfo">The member info.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.ReflectionValueProvider.SetValue(System.Object,System.Object)">
      <summary>
            Sets the value.
            </summary>
      <param name="target">The target to set the value on.</param>
      <param name="value">The value to set on the target.</param>
    </member>
    <member name="M:Newtonsoft.Json.Serialization.ReflectionValueProvider.GetValue(System.Object)">
      <summary>
            Gets the value.
            </summary>
      <param name="target">The target to get the value from.</param>
      <returns>The value.</returns>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.OnErrorAttribute">
      <summary>
            When applied to a method, specifies that the method is called when an error occurs serializing an object.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.DynamicProxyMetaObject`1.CallMethodWithResult(System.String,System.Dynamic.DynamicMetaObjectBinder,System.Linq.Expressions.Expression[],Newtonsoft.Json.Utilities.DynamicProxyMetaObject{`0}.Fallback,Newtonsoft.Json.Utilities.DynamicProxyMetaObject{`0}.Fallback)">
      <summary>
            Helper method for generating a MetaObject which calls a
            specific method on Dynamic that returns a result
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.DynamicProxyMetaObject`1.CallMethodReturnLast(System.String,System.Dynamic.DynamicMetaObjectBinder,System.Linq.Expressions.Expression[],Newtonsoft.Json.Utilities.DynamicProxyMetaObject{`0}.Fallback)">
      <summary>
            Helper method for generating a MetaObject which calls a
            specific method on Dynamic, but uses one of the arguments for
            the result.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.DynamicProxyMetaObject`1.CallMethodNoResult(System.String,System.Dynamic.DynamicMetaObjectBinder,System.Linq.Expressions.Expression[],Newtonsoft.Json.Utilities.DynamicProxyMetaObject{`0}.Fallback)">
      <summary>
            Helper method for generating a MetaObject which calls a
            specific method on Dynamic, but uses one of the arguments for
            the result.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.DynamicProxyMetaObject`1.GetRestrictions">
      <summary>
            Returns a Restrictions object which includes our current restrictions merged
            with a restriction limiting our type
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Serialization.ObjectConstructor`1">
      <summary>
            Represents a method that constructs an object.
            </summary>
      <typeparam name="T">The object type to create.</typeparam>
    </member>
    <member name="T:Newtonsoft.Json.TypeNameHandling">
      <summary>
            Specifies type name handling options for the <see cref="T:Newtonsoft.Json.JsonSerializer" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.TypeNameHandling.None">
      <summary>
            Do not include the .NET type name when serializing types.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.TypeNameHandling.Objects">
      <summary>
            Include the .NET type name when serializing into a JSON object structure.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.TypeNameHandling.Arrays">
      <summary>
            Include the .NET type name when serializing into a JSON array structure.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.TypeNameHandling.All">
      <summary>
            Always include the .NET type name when serializing.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.TypeNameHandling.Auto">
      <summary>
            Include the .NET type name when the type of the object being serialized is not the same as its declared type.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ConvertUtils.Convert(System.Object,System.Globalization.CultureInfo,System.Type)">
      <summary>
            Converts the value to the specified type.
            </summary>
      <param name="initialValue">The value to convert.</param>
      <param name="culture">The culture to use when converting.</param>
      <param name="targetType">The type to convert the value to.</param>
      <returns>The converted type.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ConvertUtils.TryConvert(System.Object,System.Globalization.CultureInfo,System.Type,System.Object@)">
      <summary>
            Converts the value to the specified type.
            </summary>
      <param name="initialValue">The value to convert.</param>
      <param name="culture">The culture to use when converting.</param>
      <param name="targetType">The type to convert the value to.</param>
      <param name="convertedValue">The converted value if the conversion was successful or the default value of <c>T</c> if it failed.</param>
      <returns>
        <c>true</c> if <c>initialValue</c> was converted successfully; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ConvertUtils.ConvertOrCast(System.Object,System.Globalization.CultureInfo,System.Type)">
      <summary>
            Converts the value to the specified type. If the value is unable to be converted, the
            value is checked whether it assignable to the specified type.
            </summary>
      <param name="initialValue">The value to convert.</param>
      <param name="culture">The culture to use when converting.</param>
      <param name="targetType">The type to convert or cast the value to.</param>
      <returns>
            The converted type. If conversion was unsuccessful, the initial value
            is returned if assignable to the target type.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.EnumUtils.GetNamesAndValues``1">
      <summary>
            Gets a dictionary of the names and values of an Enum type.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.EnumUtils.GetNamesAndValues``1(System.Type)">
      <summary>
            Gets a dictionary of the names and values of an Enum type.
            </summary>
      <param name="enumType">The enum type to get names and values for.</param>
      <returns>
      </returns>
    </member>
    <member name="T:Newtonsoft.Json.JsonToken">
      <summary>
            Specifies the type of Json token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.None">
      <summary>
            This is returned by the <see cref="T:Newtonsoft.Json.JsonReader" /> if a <see cref="M:Newtonsoft.Json.JsonReader.Read" /> method has not been called. 
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.StartObject">
      <summary>
            An object start token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.StartArray">
      <summary>
            An array start token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.StartConstructor">
      <summary>
            A constructor start token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.PropertyName">
      <summary>
            An object property name.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Comment">
      <summary>
            A comment.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Raw">
      <summary>
            Raw JSON.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Integer">
      <summary>
            An integer.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Float">
      <summary>
            A float.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.String">
      <summary>
            A string.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Boolean">
      <summary>
            A boolean.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Null">
      <summary>
            A null token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Undefined">
      <summary>
            An undefined token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.EndObject">
      <summary>
            An object end token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.EndArray">
      <summary>
            An array end token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.EndConstructor">
      <summary>
            A constructor end token.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Date">
      <summary>
            A Date.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.JsonToken.Bytes">
      <summary>
            Byte data.
            </summary>
    </member>
    <member name="T:Newtonsoft.Json.Utilities.StringBuffer">
      <summary>
            Builds a string. Unlike StringBuilder this class lets you reuse it's internal buffer.
            </summary>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.CollectionUtils.IsNullOrEmpty``1(System.Collections.Generic.ICollection{``0})">
      <summary>
            Determines whether the collection is null or empty.
            </summary>
      <param name="collection">The collection.</param>
      <returns>
        <c>true</c> if the collection is null or empty; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.CollectionUtils.AddRange``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IEnumerable{``0})">
      <summary>
            Adds the elements of the specified collection to the specified generic IList.
            </summary>
      <param name="initial">The list to add to.</param>
      <param name="collection">The collection of elements to add.</param>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.CollectionUtils.IndexOf``1(System.Collections.Generic.IEnumerable{``0},``0,System.Collections.Generic.IEqualityComparer{``0})">
      <summary>
            Returns the index of the first occurrence in a sequence by using a specified IEqualityComparer.
            </summary>
      <typeparam name="TSource">The type of the elements of source.</typeparam>
      <param name="list">A sequence in which to locate a value.</param>
      <param name="value">The object to locate in the sequence</param>
      <param name="comparer">An equality comparer to compare values.</param>
      <returns>The zero-based index of the first occurrence of value within the entire sequence, if found; otherwise, 1.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.GetCollectionItemType(System.Type)">
      <summary>
            Gets the type of the typed collection's items.
            </summary>
      <param name="type">The type.</param>
      <returns>The type of the typed collection's items.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.GetMemberUnderlyingType(System.Reflection.MemberInfo)">
      <summary>
            Gets the member's underlying type.
            </summary>
      <param name="member">The member.</param>
      <returns>The underlying type of the member.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.IsIndexedProperty(System.Reflection.MemberInfo)">
      <summary>
            Determines whether the member is an indexed property.
            </summary>
      <param name="member">The member.</param>
      <returns>
        <c>true</c> if the member is an indexed property; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.IsIndexedProperty(System.Reflection.PropertyInfo)">
      <summary>
            Determines whether the property is an indexed property.
            </summary>
      <param name="property">The property.</param>
      <returns>
        <c>true</c> if the property is an indexed property; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.GetMemberValue(System.Reflection.MemberInfo,System.Object)">
      <summary>
            Gets the member's value on the object.
            </summary>
      <param name="member">The member.</param>
      <param name="target">The target object.</param>
      <returns>The member's value on the object.</returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.SetMemberValue(System.Reflection.MemberInfo,System.Object,System.Object)">
      <summary>
            Sets the member's value on the target object.
            </summary>
      <param name="member">The member.</param>
      <param name="target">The target.</param>
      <param name="value">The value.</param>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.CanReadMemberValue(System.Reflection.MemberInfo,System.Boolean)">
      <summary>
            Determines whether the specified MemberInfo can be read.
            </summary>
      <param name="member">The MemberInfo to determine whether can be read.</param>
            /// <param name="nonPublic">if set to <c>true</c> then allow the member to be gotten non-publicly.</param><returns><c>true</c> if the specified MemberInfo can be read; otherwise, <c>false</c>.
            </returns></member>
    <member name="M:Newtonsoft.Json.Utilities.ReflectionUtils.CanSetMemberValue(System.Reflection.MemberInfo,System.Boolean,System.Boolean)">
      <summary>
            Determines whether the specified MemberInfo can be set.
            </summary>
      <param name="member">The MemberInfo to determine whether can be set.</param>
      <param name="nonPublic">if set to <c>true</c> then allow the member to be set non-publicly.</param>
      <param name="canSetReadOnly">if set to <c>true</c> then allow the member to be set if read-only.</param>
      <returns>
        <c>true</c> if the specified MemberInfo can be set; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.StringUtils.IsWhiteSpace(System.String)">
      <summary>
            Determines whether the string is all white space. Empty string will return false.
            </summary>
      <param name="s">The string to test whether it is all white space.</param>
      <returns>
        <c>true</c> if the string is all white space; otherwise, <c>false</c>.
            </returns>
    </member>
    <member name="M:Newtonsoft.Json.Utilities.StringUtils.NullEmptyString(System.String)">
      <summary>
            Nulls an empty string.
            </summary>
      <param name="s">The string.</param>
      <returns>Null if the string was null, otherwise the string unchanged.</returns>
    </member>
    <member name="T:Newtonsoft.Json.WriteState">
      <summary>
            Specifies the state of the <see cref="T:Newtonsoft.Json.JsonWriter" />.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.WriteState.Error">
      <summary>
            An exception has been thrown, which has left the <see cref="T:Newtonsoft.Json.JsonWriter" /> in an invalid state.
            You may call the <see cref="M:Newtonsoft.Json.JsonWriter.Close" /> method to put the <see cref="T:Newtonsoft.Json.JsonWriter" /> in the <c>Closed</c> state.
            Any other <see cref="T:Newtonsoft.Json.JsonWriter" /> method calls results in an <see cref="T:System.InvalidOperationException" /> being thrown. 
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.WriteState.Closed">
      <summary>
            The <see cref="M:Newtonsoft.Json.JsonWriter.Close" /> method has been called. 
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.WriteState.Object">
      <summary>
            An object is being written. 
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.WriteState.Array">
      <summary>
            A array is being written.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.WriteState.Constructor">
      <summary>
            A constructor is being written.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.WriteState.Property">
      <summary>
            A property is being written.
            </summary>
    </member>
    <member name="F:Newtonsoft.Json.WriteState.Start">
      <summary>
            A write method has not been called.
            </summary>
    </member>
    <member name="T:DistributedFileSystem.ChunkReplyState">
      <summary>
            Used to classify the different types of ChunkAvailabilityReply in response to a ChunkAvailabilityRequest
            </summary>
    </member>
    <member name="F:DistributedFileSystem.ChunkReplyState.DataIncluded">
      <summary>
            Specifies that data will be included.
            </summary>
    </member>
    <member name="F:DistributedFileSystem.ChunkReplyState.ItemOrChunkNotAvailable">
      <summary>
            The item or requested chunk is not available
            </summary>
    </member>
    <member name="F:DistributedFileSystem.ChunkReplyState.PeerBusy">
      <summary>
            The contacted peer is currently busy, please try again later.
            </summary>
    </member>
    <member name="T:DistributedFileSystem.ChunkAvailabilityRequest">
      <summary>
            Wrapper used for requesting a chunk
            </summary>
    </member>
    <member name="M:DistributedFileSystem.ChunkAvailabilityRequest.#ctor(System.String,System.Byte,NetworkCommsDotNet.ConnectionInfo,System.Int64)">
      <summary>
            Instantiate a new ChunkAvailabilityRequest
            </summary>
      <param name="itemCheckSum">The checksum of the DFS item</param>
      <param name="chunkIndex">The index of the requested chunk</param>
      <param name="peerConnectionInfo">The peer contacted for this request</param>
      <param name="requestNumIndex">The index of this chunk request</param>
    </member>
    <member name="P:DistributedFileSystem.ChunkAvailabilityRequest.ItemCheckSum">
      <summary>
            The checksum of the item being requested
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ChunkAvailabilityRequest.ChunkIndex">
      <summary>
            The index of the requested chunk
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ChunkAvailabilityRequest.RequestNumIndex">
      <summary>
            The index of the request. Each request made by the DFS increments the request counter.
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ChunkAvailabilityRequest.RequestCreationTime">
      <summary>
            The time this request was created
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ChunkAvailabilityRequest.PeerConnectionInfo">
      <summary>
            The peer contacted for this request
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ChunkAvailabilityRequest.RequestIncoming">
      <summary>
            We are currently processing incoming data for this request.
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ChunkAvailabilityRequest.RequestComplete">
      <summary>
            We have received data and this request is complete.
            </summary>
    </member>
    <member name="T:DistributedFileSystem.ChunkAvailabilityReply">
      <summary>
            A wrapper used to reply to a ChunkAvailabilityRequest
            </summary>
    </member>
    <member name="M:DistributedFileSystem.ChunkAvailabilityReply.#ctor(System.String,System.String,System.Byte,DistributedFileSystem.ChunkReplyState)">
      <summary>
            Create an ChunkAvailabilityReply which will not contain the requested data.
            </summary>
      <param name="sourceNetworkIdentifier">The network identifier of the source of this ChunkAvailabilityReply</param>
      <param name="itemCheckSum">The checksum of the DFS item</param>
      <param name="chunkIndex">The chunkIndex of the requested item</param>
      <param name="replyState">A suitable reply state</param>
    </member>
    <member name="M:DistributedFileSystem.ChunkAvailabilityReply.#ctor(NetworkCommsDotNet.Tools.ShortGuid,System.String,System.Byte,System.String)">
      <summary>
            Create an ChunkAvailabilityReply which will precede the requested data.
            </summary>
      <param name="sourceNetworkIdentifier">The network identifier of the source of this ChunkAvailabilityReply</param>
      <param name="itemCheckSum">The checksum of the DFS item</param>
      <param name="chunkIndex">The chunkIndex of the requested item</param>
      <param name="packetIdentifier">The packet identifier used to send the data</param>
    </member>
    <member name="M:DistributedFileSystem.ChunkAvailabilityReply.SetChunkData(System.Byte[])">
      <summary>
            Set the data for this ChunkAvailabilityReply
            </summary>
      <param name="chunkData">The chunk data</param>
    </member>
    <member name="M:DistributedFileSystem.ChunkAvailabilityReply.SetSourceConnectionInfo(NetworkCommsDotNet.ConnectionInfo)">
      <summary>
            Set the connectionInfo associated with the source of this ChunkAvailabilityReply
            </summary>
      <param name="info">The ConnectionInfo associated with the source of this ChunkAvailabilityReply</param>
    </member>
    <member name="P:DistributedFileSystem.ChunkAvailabilityReply.ItemCheckSum">
      <summary>
            The checksum of the item being requested
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ChunkAvailabilityReply.ChunkIndex">
      <summary>
            The index of the requested chunk
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ChunkAvailabilityReply.ReplyState">
      <summary>
            The state of this reply
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ChunkAvailabilityReply.PacketIdentifier">
      <summary>
            The packet identifier used to send the chunk data
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ChunkAvailabilityReply.SourceNetworkIdentifier">
      <summary>
            The network identifier of the peer that generated this ChunkAvailabilityReply
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ChunkAvailabilityReply.SourceConnectionInfo">
      <summary>
            The connectionInfo of the peer that generated this ChunkAvailabilityReply
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ChunkAvailabilityReply.ChunkData">
      <summary>
            The requested data
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ChunkAvailabilityReply.ChunkDataSet">
      <summary>
            True once ChunkData has been set
            </summary>
    </member>
    <member name="T:DistributedFileSystem.ChunkDataWrapper">
      <summary>
            Temporary storage for chunk data which is awaiting corresponding ChunkAvailabilityReply
            </summary>
    </member>
    <member name="M:DistributedFileSystem.ChunkDataWrapper.#ctor(DistributedFileSystem.ChunkAvailabilityReply)">
      <summary>
            Initialise a ChunkDataWrapper when the ChunkAvailabilityReply is received before associated data.
            </summary>
      <param name="chunkAvailabilityReply">The matching ChunkAvailabilityReply</param>
    </member>
    <member name="M:DistributedFileSystem.ChunkDataWrapper.#ctor(System.String,System.Byte[])">
      <summary>
            Initialise a ChunkDataWrapper when the data is received before the associated ChunkAvailabilityReply.
            </summary>
      <param name="packetIdentifier">The packet identifier of the chunk data</param>
      <param name="data">The chunk data</param>
    </member>
    <member name="P:DistributedFileSystem.ChunkDataWrapper.IncomingPacketIdentifier">
      <summary>
            The packet identifier of the chunk data
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ChunkDataWrapper.Data">
      <summary>
            The chunk data
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ChunkDataWrapper.TimeCreated">
      <summary>
            The time this chunk data was received
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ChunkDataWrapper.ChunkAvailabilityReply">
      <summary>
            The ChunkAvailabilityReply associated with this chunk data
            </summary>
    </member>
    <member name="T:DistributedFileSystem.DFS">
      <summary>
            Provides functionality to rapidly distribute large files across a cluster of peers.
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DFS.ChunkRequestTimeoutMS">
      <summary>
            The number of milliseconds after which a chunk request times out.
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DFS.MinChunkSizeInBytes">
      <summary>
            The minimum size of DFS item chunks
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DFS.MaxConcurrentPeerRequests">
      <summary>
            The maximum number of concurrent chunk requests to make to the same peer
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DFS.MaxTotalItemRequests">
      <summary>
            The total number of simultaneous chunk requests for a given item
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DFS.MaxConcurrentLocalItemBuild">
      <summary>
            The maximum number of DFS items that can be built concurrently
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DFS.PeerMaxNumTimeouts">
      <summary>
            The maximum number of times a chunk request can timeout from a peer before it is removed from the swarm
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DFS.PeerBusyTimeoutMS">
      <summary>
            The time in milliseconds after which a peer busy flag is removed
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DFS.PeerBusyNetworkLoadThreshold">
      <summary>
            While the peer network load goes above this value it will always reply with a busy response 
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DFS.ItemBuildTimeoutSecsPerMB">
      <summary>
            The number of seconds to allow per MB when building DFS items
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DFS.swarmedItemsDict">
      <summary>
            Dictionary which contains a cache of the distributed items
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DFS.chunkDataCache">
      <summary>
            Temporary storage for chunk data which is awaiting info.
            This stores data based on the peer guid and packet identifier
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DFS.elapsedTimerThread">
      <summary>
            Runs a background timer which can be used to decide timeouts for item builds
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DFS.linkWorkerThread">
      <summary>
            Linking this DFS to others
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DFS.nullCompressionSRO">
      <summary>
            We keep a reference to sendReceiveOptions which use no data compression in the DFS
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DFS.highPrioReceiveSRO">
      <summary>
            We keep a reference to sendReceiveOptions which use a high Receive priority
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DFS.concurrentNumLinkItems">
      <summary>
            The number of link items to build concurrently
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DFS.BuildTaskFactory">
      <summary>
            A private task factory for assembling new local DFS items. If we use the NetworkComms.TaskFactory we can end up deadlocking and prevent incoming packets from being handled.
            </summary>
    </member>
    <member name="M:DistributedFileSystem.DFS.Initialise(System.Int32,System.Boolean)">
      <summary>
            Initialises the DFS
            </summary>
      <param name="initialPort">The local listen port to use</param>
      <param name="rangeRandomPortFailover">True if a random port should be select if the initialPort is unavailable</param>
    </member>
    <member name="M:DistributedFileSystem.DFS.InitialiseDFSLink(System.String,System.Int32,DistributedFileSystem.DFSLinkMode)">
      <summary>
            Initialises this DFS peer to repeat all items available on the linkTargetIP
            </summary>
      <param name="linkTargetIP">The IPAddress corresponding with the link seed</param>
      <param name="linkTargetPort">The port corresponding with the link seed</param>
      <param name="linkMode">The link mode to be used</param>
    </member>
    <member name="M:DistributedFileSystem.DFS.LinkModeWorker">
      <summary>
            Background worker thread which maintains the link depending on the selected link mode
            </summary>
    </member>
    <member name="M:DistributedFileSystem.DFS.Shutdown">
      <summary>
            Shutdown the DFS. All local DFS items are deleted.
            </summary>
    </member>
    <member name="M:DistributedFileSystem.DFS.ElapsedTimerWorker">
      <summary>
            Runs in the background to estimate the elapsed time of the application.
            We can't use DateTime as elapsed time should not include time during which process was suspended
            </summary>
    </member>
    <member name="M:DistributedFileSystem.DFS.EnableLogging(NetworkCommsDotNet.Tools.ILogger)">
      <summary>
            Enable logging in networkComms using the provided logging adaptor
            </summary>
      <param name="logger">
      </param>
    </member>
    <member name="M:DistributedFileSystem.DFS.DisableLogging">
      <summary>
            Disable logging in networkComms
            </summary>
    </member>
    <member name="M:DistributedFileSystem.DFS.ItemAlreadyInLocalCache(DistributedFileSystem.DistributedItem)">
      <summary>
            Returns true if the provided item is already present within the swarm
            </summary>
      <param name="item">The relevant DFS item</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DFS.ItemAlreadyInLocalCache(System.String)">
      <summary>
            Returns true if an item with a matching itemCheckSum is present within the local cache
            </summary>
      <param name="itemCheckSum">The relevant item MD5 checksum</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DFS.MostRecentlyCompletedItem">
      <summary>
            Returns the most recently completed item in the DFS. Returns null if there are no DFS items.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DFS.GetDistributedItemByChecksum(System.String)">
      <summary>
            Returns the distributed item with a matching itemCheckSum. Returns null if item is not found.
            </summary>
      <param name="itemCheckSum">The item MD5 checksum to match</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DFS.GetDistributedItemByIdentifier(System.String)">
      <summary>
            Returns the distributed item with a matching itemIdentifier. Returns null if item is not found.
            </summary>
      <param name="itemIdentifier">The item identifier to match</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DFS.RemoveItem(System.String,System.Boolean,System.Boolean)">
      <summary>
            Remove an item from the DFS. Possibly swarmWide and with or without a removal broadcast
            </summary>
      <param name="itemCheckSum">The checksum corresponding with the item to remove</param>
      <param name="broadcastRemoval">If true all peers will be notified that we are removing this item.</param>
      <param name="removeSwarmWide">True if this item should be removed swarm wide</param>
    </member>
    <member name="M:DistributedFileSystem.DFS.RemoveAllItemsFromLocalOnly(System.Boolean)">
      <summary>
            Removes all items from local only
            </summary>
      <param name="broadcastRemoval">If true all peers will be notified that we are removing all items.</param>
    </member>
    <member name="M:DistributedFileSystem.DFS.CloseConnectionToCompletedPeers">
      <summary>
            Closes all connections to peers who have completed items
            </summary>
    </member>
    <member name="M:DistributedFileSystem.DFS.RemoveAllItemsFromLocalOnly(System.String,System.Boolean)">
      <summary>
            Remove any items from the DFS with a matching itemTypeStr
            </summary>
      <param name="ItemTypeStr">The item type string to match</param>
      <param name="broadcastRemoval">If true all peers will be notified that we are removing matching items.</param>
    </member>
    <member name="M:DistributedFileSystem.DFS.PushItemToPeer(NetworkCommsDotNet.Connections.Connection,DistributedFileSystem.DistributedItem,System.String)">
      <summary>
            Introduces a new item into the swarm and sends a build command to the originating requester
            </summary>
      <param name="peerConnection">The peer which requested the DFS item</param>
      <param name="itemToDistribute">The item to be distributed</param>
      <param name="completedPacketType">The packet type to use once the item has been fully assembled</param>
    </member>
    <member name="M:DistributedFileSystem.DFS.AddItem(DistributedFileSystem.DistributedItem)">
      <summary>
            Adds a distributed item to the local cache and informs any known peers of the item availability
            </summary>
      <param name="itemToAdd">The item to add</param>
      <returns>The actual item added to the local cache. May not be the provided itemToAdd if an item with the same 
            checksum already existed.</returns>
    </member>
    <member name="M:DistributedFileSystem.DFS.CheckForSharedItems(System.String,System.Int32)">
      <summary>
            Communicates with the provided peer to see if any item swarms can be linked. This is a single link event, 
            possibly use InitialiseDFSLink() for a maintained link.
            </summary>
      <param name="peerIP">The IPAddress of the peer</param>
      <param name="peerPort">The port of the peer</param>
    </member>
    <member name="M:DistributedFileSystem.DFS.AllLocalDFSItemKeys(System.Boolean)">
      <summary>
            Returns all item MD5 checksums for DFS items
            </summary>
      <param name="completeItemsOnly">If true only returns checksums for completed items</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DFS.AllLocalDFSItemsWithBuildTime(System.Boolean)">
      <summary>
            Returns a dictionary of DFS items along with corresponding ItemBuildCompleted times
            </summary>
      <param name="completeItemsOnly">If true only returns information for completed items</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DFS.CheckForChunkDataCacheTimeouts">
      <summary>
            Flick through the chunk data cache and remove any items that have timed out
            </summary>
    </member>
    <member name="M:DistributedFileSystem.DFS.DFSConnectionShutdown(NetworkCommsDotNet.Connections.Connection)">
      <summary>
            If a connection is disconnected we want to make sure we handle it within the DFS
            </summary>
      <param name="connection">
      </param>
    </member>
    <member name="M:DistributedFileSystem.DFS.KnownPeersRequest(NetworkCommsDotNet.PacketHeader,NetworkCommsDotNet.Connections.Connection,System.String)">
      <summary>
            UDP - Used by a client when requesting a list of known peers
            </summary>
      <param name="packetHeader">
      </param>
      <param name="connection">
      </param>
      <param name="itemCheckSum">
      </param>
    </member>
    <member name="M:DistributedFileSystem.DFS.KnownPeersUpdate(NetworkCommsDotNet.PacketHeader,NetworkCommsDotNet.Connections.Connection,DistributedFileSystem.KnownPeerEndPoints)">
      <summary>
            UDP - The response to a DFS_KnownPeersRequest
            </summary>
      <param name="packetHeader">
      </param>
      <param name="connection">
      </param>
      <param name="peerList">
      </param>
    </member>
    <member name="M:DistributedFileSystem.DFS.IncomingLocalItemBuild(NetworkCommsDotNet.PacketHeader,NetworkCommsDotNet.Connections.Connection,DistributedFileSystem.ItemAssemblyConfig)">
      <summary>
            TCP - Received by this DFS if a server is telling this instance to build a local file
            </summary>
      <param name="packetHeader">
      </param>
      <param name="connection">
      </param>
      <param name="assemblyConfig">
      </param>
    </member>
    <member name="M:DistributedFileSystem.DFS.RequestLocalItemBuilds(NetworkCommsDotNet.PacketHeader,NetworkCommsDotNet.Connections.Connection,System.String[])">
      <summary>
            TCP - A remote peer has request a push of the provided itemCheckSums. This method is used primarily when in repeater mode
            </summary>
      <param name="packetHeader">
      </param>
      <param name="connection">
      </param>
      <param name="itemCheckSums">
      </param>
    </member>
    <member name="M:DistributedFileSystem.DFS.IncomingChunkInterestRequest(NetworkCommsDotNet.PacketHeader,NetworkCommsDotNet.Connections.Connection,DistributedFileSystem.ChunkAvailabilityRequest)">
      <summary>
            UDP - Received when a peer request a chunk
            </summary>
      <param name="packetHeader">
      </param>
      <param name="connection">
      </param>
      <param name="incomingRequest">
      </param>
    </member>
    <member name="M:DistributedFileSystem.DFS.IncomingChunkInterestReplyData(NetworkCommsDotNet.PacketHeader,NetworkCommsDotNet.Connections.Connection,System.Byte[])">
      <summary>
            TCP - Received when a peer sends us the data portion of a chunk possibly following a request
            </summary>
      <param name="packetHeader">
      </param>
      <param name="connection">
      </param>
      <param name="incomingData">
      </param>
    </member>
    <member name="M:DistributedFileSystem.DFS.IncomingChunkInterestReplyInfo(NetworkCommsDotNet.PacketHeader,NetworkCommsDotNet.Connections.Connection,DistributedFileSystem.ChunkAvailabilityReply)">
      <summary>
            UDP and TCP - Received when a peer sends us a chunk data information possibly following a request
            </summary>
      <param name="packetHeader">
      </param>
      <param name="connection">
      </param>
      <param name="incomingReply">
      </param>
    </member>
    <member name="M:DistributedFileSystem.DFS.IncomingPeerChunkAvailabilityUpdate(NetworkCommsDotNet.PacketHeader,NetworkCommsDotNet.Connections.Connection,DistributedFileSystem.PeerChunkAvailabilityUpdate)">
      <summary>
            UDP - A remote peer is announcing that it has an updated availability of chunks
            </summary>
      <param name="packetHeader">
      </param>
      <param name="connection">
      </param>
      <param name="updateDetails">
      </param>
    </member>
    <member name="M:DistributedFileSystem.DFS.IncomingChunkAvailabilityRequest(NetworkCommsDotNet.PacketHeader,NetworkCommsDotNet.Connections.Connection,System.String)">
      <summary>
            UDP - A remote peer is requesting chunk availability for this local peer
            </summary>
      <param name="packetHeader">
      </param>
      <param name="connection">
      </param>
      <param name="itemCheckSum">
      </param>
    </member>
    <member name="M:DistributedFileSystem.DFS.IncomingItemRemovalUpdate(NetworkCommsDotNet.PacketHeader,NetworkCommsDotNet.Connections.Connection,DistributedFileSystem.ItemRemovalUpdate)">
      <summary>
            UDP - A remote peer is informing us that they no longer have an item
            </summary>
      <param name="packetHeader">
      </param>
      <param name="connection">
      </param>
      <param name="itemRemovalUpdate">
      </param>
    </member>
    <member name="M:DistributedFileSystem.DFS.IncomingRemoteItemLinkRequest(NetworkCommsDotNet.PacketHeader,NetworkCommsDotNet.Connections.Connection,DistributedFileSystem.DFSLinkRequest)">
      <summary>
            TCP - A remote peer is trying to link DFS items
            </summary>
      <param name="packetHeader">
      </param>
      <param name="connection">
      </param>
      <param name="linkRequestData">
      </param>
    </member>
    <member name="P:DistributedFileSystem.DFS.DFSInitialised">
      <summary>
            True if the DFS has been initialised
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DFS.MinTargetLocalPort">
      <summary>
            The minimum port number that will be used when initialising the DFS
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DFS.MaxTargetLocalPort">
      <summary>
            The maximum port number that will be used when initialising the DFS
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DFS.ValidateEachChunkMD5">
      <summary>
            If true ensures all DFS items include chunk MD5 list. Also on build clients will validate the chunk MD5
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DFS.ElapsedExecutionSeconds">
      <summary>
            The number of seconds since the initialisation of the DFS. Used as an internal timer, rather than DateTime.Now, to 
            ensure builds do not time out when a suspended process is restarted.
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DFS.IsLinked">
      <summary>
            True if this DFS is linked with another peer
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DFS.LinkMode">
      <summary>
            The link mode being used
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DFS.TotalNumReturnedChunkRequests">
      <summary>
            The total number of completed chunk requests across all DFS items
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DFS.TotalNumRequestedChunks">
      <summary>
            The total number of chunks requests by the local DFS
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DFS.Logger">
      <summary>
            Access the networkComms logger externally. Allows logging from external sources
            </summary>
    </member>
    <member name="T:DistributedFileSystem.DistributedItem">
      <summary>
            An item that is distributed using the DFS
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DistributedItem.itemBuildTrackerDict">
      <summary>
            Used to track chunk requests. Key is chunkIndex and value is the request made
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DistributedItem.chunkDataToIntegrateQueue">
      <summary>
            Contains chunk data that is waiting to be integrated
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DistributedItem.itemBuildWait">
      <summary>
            Events used during build to sync threads
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DistributedItem.ItemClosed">
      <summary>
            True if this item has been closed. Can be used externally to cancel an AssembleItem.
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DistributedItem.itemLocker">
      <summary>
            Item specified locker
            </summary>
    </member>
    <member name="M:DistributedFileSystem.DistributedItem.#ctor(System.String,System.String,System.IO.Stream,System.Collections.Generic.List{NetworkCommsDotNet.ConnectionInfo},DistributedFileSystem.DataBuildMode,System.Boolean,System.Int32)">
      <summary>
            Instantiate a new DFS item which is complete.
            </summary>
      <param name="itemTypeStr">A category string which can be used to group distributed items together.</param>
      <param name="itemIdentifier">A unique identifier for this item, usually a file name</param>
      <param name="itemData">A stream containing the data for this item</param>
      <param name="seedConnectionInfoList">A list of connecitonInfo corresponding to peers that will act as seeds</param>
      <param name="itemBuildMode">The build mode to be used for distributing this item, i.e. memory or disk, as a single continuous stream or blocks</param>
      <param name="enableChunkChecksum">If true checkSums will be validated for each chunk before it is integrated. Reduces the performance of the DFS.</param>
      <param name="itemBuildCascadeDepth">The cascade depth to use when building this item. Default is 1</param>
    </member>
    <member name="M:DistributedFileSystem.DistributedItem.#ctor(DistributedFileSystem.ItemAssemblyConfig)">
      <summary>
            Instantiate a new DFS item which needs to be built.
            </summary>
      <param name="assemblyConfig">An ItemAssemblyConfig containing the necessary bootstrap information.</param>
    </member>
    <member name="M:DistributedFileSystem.DistributedItem.ToString">
      <summary>
            Returns ItemTypeStr + ItemIdentifier
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DistributedItem.UpdateBuildTarget(DistributedFileSystem.DataBuildMode)">
      <summary>
            Updates the ItemBuildTarget
            </summary>
      <param name="newDataBuildMode">The new DataBuildMode to use</param>
    </member>
    <member name="M:DistributedFileSystem.DistributedItem.IncrementPushCount">
      <summary>
            Increments the item push count.
            </summary>
    </member>
    <member name="M:DistributedFileSystem.DistributedItem.AddBuildLogLine(System.String)">
      <summary>
            Add the provided string to the build log of this item
            </summary>
      <param name="newLine">
      </param>
    </member>
    <member name="M:DistributedFileSystem.DistributedItem.BuildLog">
      <summary>
            Get the current build log for this DFS item
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DistributedItem.AssembleItem(System.Int32)">
      <summary>
            Assemble this DFS item using the swarm
            </summary>
      <param name="assembleTimeoutSecs">The maximum time to allow to build this item before throwing a timeout exception.</param>
    </member>
    <member name="M:DistributedFileSystem.DistributedItem.HandleIncomingChunkReply(DistributedFileSystem.ChunkAvailabilityReply)">
      <summary>
            Handle an incoming chunk reply
            </summary>
      <param name="incomingReply">The ChunkAvailabilityReply to handle</param>
    </member>
    <member name="M:DistributedFileSystem.DistributedItem.ChunkAvailableLocally(System.Byte)">
      <summary>
            Returns true if the requested chunk is available locally
            </summary>
      <param name="chunkIndex">The chunk index to check</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DistributedItem.GetCompletedItemStream">
      <summary>
            Returns a streamSendWrapper that contains the entire item
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DistributedItem.GetCompletedItemBytes">
      <summary>
            Once the item has been fully assembled the completed bytes can be access via this method.
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DistributedItem.GetChunkDataStream(System.Byte)">
      <summary>
            Returns a StreamSendWrapper corresponding to the requested chunkIndex.
            </summary>
      <param name="chunkIndex">The desired chunk index data</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DistributedItem.LocalItemValid">
      <summary>
            Returns true if the item data validates correctly
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DistributedItem.LocalItemComplete">
      <summary>
            Returns true once all chunks have been received and the item has been validated
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DistributedItem.Dispose">
      <summary>
            Dispose of this DFS item
            </summary>
    </member>
    <member name="M:DistributedFileSystem.DistributedItem.Load(System.String,System.IO.Stream,System.Collections.Generic.List{NetworkCommsDotNet.ConnectionInfo})">
      <summary>
            Load the specified distributed item. Does not add the .DFSItem extension to the fileName
            </summary>
      <param name="fileName">The DFS item to load</param>
      <param name="itemDataStream">The DFS item data</param>
      <param name="seedConnectionInfoList">The connecitonInfo corresponding with potential seeds</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DistributedItem.Save(System.String)">
      <summary>
            Save this distributed item (not including item data), adds .DFSItem extension, using the provided filename.
            </summary>
      <param name="fileName">The filename to use</param>
    </member>
    <member name="P:DistributedFileSystem.DistributedItem.ItemIdentifier">
      <summary>
            A unique string identifier for this DFS item. Usually a filename.
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DistributedItem.ItemTypeStr">
      <summary>
            A category for this DFS item. Allowed items to be grouped by item type.
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DistributedItem.ItemBuildCascadeDepth">
      <summary>
            The cascade depth to use when building this item. Default is 1
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DistributedItem.ItemBuildCompleted">
      <summary>
            The DateTime this DFS item was successfully built.
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DistributedItem.SwarmChunkAvailability">
      <summary>
            Contains a record of which peers have which chunks of this DFS item
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DistributedItem.Data">
      <summary>
            The data for this distributed item
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DistributedItem.TotalChunkSupplyCount">
      <summary>
            The total number of chunks pushed to peers
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DistributedItem.PushCount">
      <summary>
            The total number of times this item has been pushed.
            </summary>
    </member>
    <member name="T:DistributedFileSystem.ShuffleList">
      <summary>
            A utility class used to randomly shuffle a list of type T
            </summary>
    </member>
    <member name="M:DistributedFileSystem.ShuffleList.Shuffle``1(System.Collections.Generic.IList{``0})">
      <summary>
            Randomly shuffle list
            </summary>
      <typeparam name="T">The type of list</typeparam>
      <param name="list">The list to shuffle</param>
      <returns>The shuffled list</returns>
    </member>
    <member name="T:DistributedFileSystem.PositionLength">
      <summary>
            Wrapper used to segment a DFS item data into chunks
            </summary>
    </member>
    <member name="F:DistributedFileSystem.PositionLength.Position">
      <summary>
            The start position in bytes of this chunk
            </summary>
    </member>
    <member name="F:DistributedFileSystem.PositionLength.Length">
      <summary>
            The number of bytes of this chunk
            </summary>
    </member>
    <member name="M:DistributedFileSystem.PositionLength.#ctor(System.Int32,System.Int32)">
      <summary>
            Initialise a new PositionLength struct
            </summary>
      <param name="position">The start position in bytes of this chunk</param>
      <param name="length">The number of bytes of this chunk</param>
    </member>
    <member name="T:DistributedFileSystem.DistributedItemData">
      <summary>
            Manages the respective data for a distributed item
            </summary>
    </member>
    <member name="M:DistributedFileSystem.DistributedItemData.#ctor">
      <summary>
            Private constructor for deserialisation
            </summary>
    </member>
    <member name="M:DistributedFileSystem.DistributedItemData.#ctor(System.String,DistributedFileSystem.DataBuildMode,System.IO.Stream,System.Boolean)">
      <summary>
            Initialise the item data using an existing stream. If the build mode is to blocks the itemDataStream is broken into chunks.
            </summary>
      <param name="itemIdentifier">
      </param>
      <param name="dataBuildMode">
      </param>
      <param name="itemDataStream">
      </param>
      <param name="enableChunkChecksum">
      </param>
    </member>
    <member name="M:DistributedFileSystem.DistributedItemData.#ctor(DistributedFileSystem.DataBuildMode,System.Collections.Generic.Dictionary{System.Int32,System.IO.Stream},System.Boolean)">
      <summary>
            Initialise the item data using existing chunk streams. Build mode must be to blocks.
            </summary>
      <param name="dataBuildMode">
      </param>
      <param name="itemDataStreams">
      </param>
      <param name="enableChunkChecksum">
      </param>
    </member>
    <member name="M:DistributedFileSystem.DistributedItemData.#ctor(DistributedFileSystem.ItemAssemblyConfig)">
      <summary>
            Initialise the item data from an assembly config
            </summary>
      <param name="assemblyConfig">
      </param>
    </member>
    <member name="M:DistributedFileSystem.DistributedItemData.SetData(System.String,System.IO.Stream)">
      <summary>
            Sets the item data using the provided data stream. Useful for setting data after deserialisation
            </summary>
      <param name="itemIdentifier">
      </param>
      <param name="itemDataStream">
      </param>
    </member>
    <member name="M:DistributedFileSystem.DistributedItemData.InitialiseChunkPositionLengthDict">
      <summary>
            Calculates the corresponding chunk positions and lengths when this item is deserialised
            </summary>
    </member>
    <member name="M:DistributedFileSystem.DistributedItemData.BuildChunkCheckSums">
      <summary>
            Uses the loaded stream and builds individual chunk checksums
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DistributedItemData.MD5">
      <summary>
            Return the MD5 of the whole item data
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DistributedItemData.MD5(System.Int32)">
      <summary>
            Return the MD5 of the specified chunk
            </summary>
      <param name="chunkIndex">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DistributedItemData.Write(System.Int32,System.Byte[])">
      <summary>
            Writes the provided buffer to the data starting at the provided position within the item data
            </summary>
      <param name="chunkIndex">
      </param>
      <param name="chunkData">
      </param>
    </member>
    <member name="M:DistributedFileSystem.DistributedItemData.CopyTo(System.IO.Stream)">
      <summary>
            Copies data specified by start and length properties from internal stream to the provided stream.
            </summary>
      <param name="destinationStream">The destination stream for the item data</param>
    </member>
    <member name="M:DistributedFileSystem.DistributedItemData.GetChunkStream(System.Int32)">
      <summary>
            Return a StreamSendWrapper corresponding with the desired chunk
            </summary>
      <param name="chunkIndex">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DistributedItemData.UpdateBuildTarget(DistributedFileSystem.DataBuildMode)">
      <summary>
            Updates the ItemBuildTarget
            </summary>
      <param name="newDataBuildMode">The new DataBuildMode to use</param>
    </member>
    <member name="M:DistributedFileSystem.DistributedItemData.ToArray">
      <summary>
            Returns data for the entire item as byte[]
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DistributedItemData.GetDataAsSingleStream">
      <summary>
            Get a single threadsafe stream containing all item data
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.DistributedItemData.Dispose(System.Boolean)">
      <summary>
            Disposes the internal stream. If <see cref="P:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.DiposeInnerStreamOnDispose" /> is false, forceDispose
            must be true to dispose of the internal stream.
            </summary>
      <param name="forceDispose">If true the internal stream will be disposed regardless of <see cref="P:NetworkCommsDotNet.Tools.StreamTools.ThreadSafeStream.DiposeInnerStreamOnDispose" /> value.</param>
    </member>
    <member name="P:DistributedFileSystem.DistributedItemData.CompleteDataCheckSum">
      <summary>
            The MD5 checksum for the completed data. Used to validate a completed build.
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DistributedItemData.ChunkCheckSums">
      <summary>
            Optional MD5 checksums for individual chunks. Useful for debugging build issues.
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DistributedItemData.TotalNumChunks">
      <summary>
            Total number of chunks for this item
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DistributedItemData.ChunkSizeInBytes">
      <summary>
            Maximum size of each chunk in bytes. The final chunk may be less than this value.
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DistributedItemData.ItemBytesLength">
      <summary>
            Total item size in bytes.
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DistributedItemData.DataBuildMode">
      <summary>
            The build mode describing how the item should be built, i.e. memory or disk, as a single stream of multiple blocks
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DistributedItemData.ChunkPositionLengthDict">
      <summary>
            The chunk positions and lengths. Key is chunkIndex.
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DistributedItemData.CompleteDataStream">
      <summary>
            The stream containing the item chunk data
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DistributedItemData.ChunkDataStreams">
      <summary>
            An array of streams that contain the item chunk data. Each index is a matches the 
            corresponding chunk index.
            </summary>
    </member>
    <member name="T:DistributedFileSystem.ItemAssemblyConfig">
      <summary>
            Provides all the information a new peer requires in order to build the DFS item
            </summary>
    </member>
    <member name="M:DistributedFileSystem.ItemAssemblyConfig.#ctor">
      <summary>
            Private constructor for serialisation.
            </summary>
    </member>
    <member name="M:DistributedFileSystem.ItemAssemblyConfig.#ctor(DistributedFileSystem.DistributedItem,System.String)">
      <summary>
            Instantiate a new ItemAssemblyConfig
            </summary>
      <param name="itemToDistribute">The DFS item for which this ItemAssemblyConfig should be created.</param>
      <param name="completedPacketType">The packet type to use once the item has been fully assembled</param>
    </member>
    <member name="P:DistributedFileSystem.ItemAssemblyConfig.SwarmChunkAvailabilityBytes">
      <summary>
            The serialised SwarmChunkAvailability 
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ItemAssemblyConfig.TotalNumChunks">
      <summary>
            Total number of chunks in this DFS item
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ItemAssemblyConfig.ChunkSizeInBytes">
      <summary>
            Maximum size of each chunk in bytes. The final chunk may be less than this value.
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ItemAssemblyConfig.TotalItemSizeInBytes">
      <summary>
            Total item size in bytes
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ItemAssemblyConfig.CompleteDataCheckSum">
      <summary>
            MD5 checksum of assembled item. Used for validating a completed build
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ItemAssemblyConfig.ChunkCheckSums">
      <summary>
            Optional MD5 checksums for individual chunks.
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ItemAssemblyConfig.CompletedPacketType">
      <summary>
            The packet type to use once the item has been fully assembled
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ItemAssemblyConfig.ItemBuildCascadeDepth">
      <summary>
            The cascade depth to use when building this item. Default is 1
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ItemAssemblyConfig.ItemTypeStr">
      <summary>
            A category string which can be used to group distributed items together
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ItemAssemblyConfig.ItemBuildMode">
      <summary>
            Build mode determines how the item should be built, i.e. memory or disk as a single stream or multiple blocks
            </summary>
    </member>
    <member name="P:DistributedFileSystem.ItemAssemblyConfig.ItemIdentifier">
      <summary>
            A unique identifier for this item, usually a file name
            </summary>
    </member>
    <member name="T:DistributedFileSystem.DataBuildMode">
      <summary>
            Describes where a distributed item should be stored during and after being assembled
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DataBuildMode.Memory_Single">
      <summary>
            Build the item to a single continuous memory stream. Requires sufficient memory during build.
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DataBuildMode.Memory_Blocks">
      <summary>
            Build the item to an array of memory streams. More high performance as reduces locking during build. Requires sufficient memory during build.
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DataBuildMode.Disk_Single">
      <summary>
            Build the item to the local application directory as a single file stream.
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DataBuildMode.Disk_Blocks">
      <summary>
            Build the item to the local application directory as an array of file streams. More high performance as reduces locking.
            </summary>
    </member>
    <member name="T:DistributedFileSystem.DFSLinkMode">
      <summary>
            The link mode to use
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DFSLinkMode.LinkOnly">
      <summary>
            Only items existing at both ends are linked
            </summary>
    </member>
    <member name="F:DistributedFileSystem.DFSLinkMode.LinkAndRepeat">
      <summary>
            All items existing on the target peer are retrieved and held locally. Any items already on local will be linked.
            </summary>
    </member>
    <member name="T:DistributedFileSystem.DFSLinkRequest">
      <summary>
            A wrapper used when requesting link items
            </summary>
    </member>
    <member name="M:DistributedFileSystem.DFSLinkRequest.#ctor(System.Collections.Generic.Dictionary{System.String,System.DateTime},System.Boolean)">
      <summary>
            Create an item link request
            </summary>
      <param name="availableItems">The available DFS items. Key is itemCheckSum. Value is Item.ItemBuildCompleted</param>
      <param name="linkRequestReply">True if this DFSLinkRequest is the originating or reply linkRequest</param>
    </member>
    <member name="P:DistributedFileSystem.DFSLinkRequest.LinkRequestReply">
      <summary>
            If this linkRequest object has been sent in reply to a linkRequest this boolean is true
            </summary>
    </member>
    <member name="P:DistributedFileSystem.DFSLinkRequest.AvailableItems">
      <summary>
            The DFS items which can possibly be linked
            </summary>
    </member>
    <member name="T:DistributedFileSystem.PeerChunkAvailabilityUpdate">
      <summary>
            Object passed around peers to keep everyone updated.
            </summary>
    </member>
    <member name="M:DistributedFileSystem.PeerChunkAvailabilityUpdate.#ctor(System.String,System.String,DistributedFileSystem.ChunkFlags)">
      <summary>
            Instantiate a new PeerChunkAvailabilityUpdate
            </summary>
      <param name="sourceNetworkIdentifier">The source network identifier</param>
      <param name="itemCheckSum">The related DFS item checksum</param>
      <param name="chunkFlags">The chunk availability flags </param>
    </member>
    <member name="P:DistributedFileSystem.PeerChunkAvailabilityUpdate.ItemCheckSum">
      <summary>
            The related DFS item checksum
            </summary>
    </member>
    <member name="P:DistributedFileSystem.PeerChunkAvailabilityUpdate.ChunkFlags">
      <summary>
            The chunk availability flags 
            </summary>
    </member>
    <member name="P:DistributedFileSystem.PeerChunkAvailabilityUpdate.SourceNetworkIdentifier">
      <summary>
            The source network identifier
            </summary>
    </member>
    <member name="T:DistributedFileSystem.LongBitCount">
      <summary>
            Utility class used to count the number of set bits in a ulong
            </summary>
    </member>
    <member name="M:DistributedFileSystem.LongBitCount.CountBits(System.UInt64)">
      <summary>
            Returns the number of bits set to 1 in a ulong
            </summary>
      <param name="inputLong">The ulong to count</param>
      <returns>
      </returns>
    </member>
    <member name="T:DistributedFileSystem.ChunkFlags">
      <summary>
            Provides a 256 length bit flag 
            </summary>
    </member>
    <member name="M:DistributedFileSystem.ChunkFlags.#ctor(System.Byte)">
      <summary>
            Initialises the ChunkFlags. The initial state is typically 0 or totalNumChunks
            </summary>
      <param name="intialState">The initial state of the ChunkFlags</param>
    </member>
    <member name="M:DistributedFileSystem.ChunkFlags.FlagSet(System.Byte)">
      <summary>
            Returns true if the provided chunk is available. Zero indexed from least significant bit.
            </summary>
      <param name="chunkIndex">The chunk index flag to check</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.ChunkFlags.SetFlag(System.Byte,System.Boolean)">
      <summary>
            Sets the bit flag to 1 which corresponds with the provided chunk index. Zero indexed from least significant bit.
            </summary>
      <param name="chunkIndex">The chunk index to set</param>
      <param name="state">The state of the flag</param>
    </member>
    <member name="M:DistributedFileSystem.ChunkFlags.UpdateFlags(DistributedFileSystem.ChunkFlags)">
      <summary>
            Updates local chunk flags with those provided.
            </summary>
      <param name="latestChunkFlags">The new chunk flags</param>
    </member>
    <member name="M:DistributedFileSystem.ChunkFlags.AllFlagsSet(System.Byte)">
      <summary>
            Returns true if all bit flags up to the provided uptoChunkIndexInclusive are set to true
            </summary>
      <param name="uptoChunkIndexInclusive">The chunk index up to which the flags should be checked</param>
    </member>
    <member name="M:DistributedFileSystem.ChunkFlags.NumCompletedChunks">
      <summary>
            Returns the number of completed chunk
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.ChunkFlags.ClearAllFlags">
      <summary>
            Sets all chunk flags to unset.
            </summary>
    </member>
    <member name="T:DistributedFileSystem.PeerInfo">
      <summary>
            Wrapper class which contains all of the information, for a single peer, for single distributed item. A peer has a single
            known chunk availability and identifier but multiple possible IPEndPoints.
            </summary>
    </member>
    <member name="F:DistributedFileSystem.PeerInfo.IPEndPointBusyAnnounceTimeDict">
      <summary>
            Used to maintain peer status
            </summary>
    </member>
    <member name="M:DistributedFileSystem.PeerInfo.#ctor(System.Collections.Generic.List{NetworkCommsDotNet.ConnectionInfo},DistributedFileSystem.ChunkFlags,System.Boolean)">
      <summary>
            Initialise a new PeerInfo
            </summary>
      <param name="peerConnectionInfo">All ConnectionInfos corresponding with this peer</param>
      <param name="peerChunkFlags">The initial ChunkFlags for this peer</param>
      <param name="superPeer">True if this is a SuperPeer</param>
    </member>
    <member name="M:DistributedFileSystem.PeerInfo.HasAtleastOneOnlineIPEndPoint">
      <summary>
            Returns true if this peer has at least one on line ipEndPoint
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.PeerInfo.IsPeerIPEndPointOnline(NetworkCommsDotNet.Tools.ShortGuid,System.Net.IPEndPoint)">
      <summary>
            Returns true if the specified peer has the specified IPEndPoint online.
            </summary>
      <param name="networkIdentifier">The network identifier of the peer to check</param>
      <param name="peerIPEndPoint">The IPEndPoint of the peer to check</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.PeerInfo.SetPeerIPEndPointOnlineStatus(NetworkCommsDotNet.Tools.ShortGuid,System.Net.IPEndPoint,System.Boolean)">
      <summary>
            Update the provided peer IPEndPoint online status
            </summary>
      <param name="networkIdentifier">The network identifier of the relevant peer</param>
      <param name="peerIPEndPoint">The relevant IPEndPoint</param>
      <param name="onlineStatus">The new online status</param>
    </member>
    <member name="M:DistributedFileSystem.PeerInfo.IsPeerIPEndPointBusy(NetworkCommsDotNet.Tools.ShortGuid,System.Net.IPEndPoint)">
      <summary>
            Returns the current busy status of the requested peer IPEndPoint
            </summary>
      <param name="networkIdentifier">The network identifier of the relevant peer</param>
      <param name="peerIPEndPoint">The relevant IPEndPoint</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.PeerInfo.SetPeerIPEndPointBusyStatus(NetworkCommsDotNet.Tools.ShortGuid,System.Net.IPEndPoint,System.Boolean)">
      <summary>
            Update the provided peer IPEndPoint busy status
            </summary>
      <param name="networkIdentifier">The network identifier of the relevant peer</param>
      <param name="peerIPEndPoint">The relevant IPEndPoint</param>
      <param name="busyStatus">The new peer busy status</param>
    </member>
    <member name="M:DistributedFileSystem.PeerInfo.CheckAllIPEndPointBusyFlags(System.Int32)">
      <summary>
            Clear any busy flags set for the IPEndPoints of this peer if they are older than the provided MS
            </summary>
      <param name="msSinceBusyToClear">Milliseconds since busy flag was set to clear</param>
    </member>
    <member name="M:DistributedFileSystem.PeerInfo.GetCurrentTimeoutCount(NetworkCommsDotNet.Tools.ShortGuid,System.Net.IPEndPoint)">
      <summary>
            Return the current timeout count value.
            </summary>
      <param name="networkIdentifier">The network identifier of the relevant peer</param>
      <param name="peerIPEndPoint">The relevant IPEndPoint</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.PeerInfo.GetNewTimeoutCount(NetworkCommsDotNet.Tools.ShortGuid,System.Net.IPEndPoint)">
      <summary>
            Returns the new timeout count value after incrementing the timeout count.
            </summary>
      <param name="networkIdentifier">The network identifier of the relevant peer</param>
      <param name="peerIPEndPoint">The relevant IPEndPoint</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.PeerInfo.GetConnectionInfo">
      <summary>
            Returns a new list containing all peer ConnectionInfos
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.PeerInfo.RemovePeerIPEndPoint(NetworkCommsDotNet.Tools.ShortGuid,System.Net.IPEndPoint)">
      <summary>
            Removes the provided connectionInfo from all internal dictionaries. Returns true if connectionInfo exists, otherwise false
            </summary>
      <param name="networkIdentifier">The network identifier of the relevant peer</param>
      <param name="peerIPEndPoint">The relevant IPEndPoint</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.PeerInfo.RemovePeerIPEndPoint(NetworkCommsDotNet.ConnectionInfo)">
      <summary>
            Removes the provided connectionInfo from all internal dictionaries. Returns true if connectionInfo exists, otherwise false
            </summary>
      <param name="connectionInfo">The connectionInfo to remove</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.PeerInfo.AddPeerIPEndPoint(NetworkCommsDotNet.Tools.ShortGuid,System.Net.IPEndPoint)">
      <summary>
            Add new IPEndPoint for a peer. Returns true if successfully added, otherwise false.
            </summary>
      <param name="networkIdentifier">The network identifier of the relevant peer</param>
      <param name="peerIPEndPoint">The relevant IPEndPoint</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.PeerInfo.PeerContainsIPEndPoint(NetworkCommsDotNet.Tools.ShortGuid,System.Net.IPEndPoint)">
      <summary>
            Returns true if the provided IPEndPoint exists for this peer
            </summary>
      <param name="networkIdentifier">The network identifier of the relevant peer</param>
      <param name="peerIPEndPoint">The relevant IPEndPoint</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.PeerInfo.ValidateNetworkIdentifier(NetworkCommsDotNet.ConnectionInfo)">
      <summary>
            A private method which checks the provided network identifier with that expected.
            </summary>
      <param name="connectionInfo">
      </param>
    </member>
    <member name="M:DistributedFileSystem.PeerInfo.ToString">
      <summary>
            Returns a clean descriptor for this PeerInfo
            </summary>
      <returns>
      </returns>
    </member>
    <member name="P:DistributedFileSystem.PeerInfo.PeerNetworkIdentifier">
      <summary>
            Identifies this peer info
            </summary>
    </member>
    <member name="P:DistributedFileSystem.PeerInfo.PeerChunkFlags">
      <summary>
            The chunk availability for this peer.
            </summary>
    </member>
    <member name="P:DistributedFileSystem.PeerInfo.SuperPeer">
      <summary>
            For now the only extra info we want. A superPeer is generally busier network wise and should be contacted last for data.
            </summary>
    </member>
    <member name="P:DistributedFileSystem.PeerInfo.PeerConnectionInfo">
      <summary>
            All ConnectionInfos corresponding with this peer
            </summary>
    </member>
    <member name="P:DistributedFileSystem.PeerInfo._peerConnectionInfoSerialized">
      <summary>
            Protobuf cannot serialize ConnectionInfo so we provide a backing field and use the ProtoBeforeSerialization and ProtoAfterSerialization methodology to serialize by hand
            </summary>
    </member>
    <member name="P:DistributedFileSystem.PeerInfo.NumberOfConnectionInfos">
      <summary>
            Returns PeerConnectionInfo.Count
            </summary>
    </member>
    <member name="T:DistributedFileSystem.SwarmChunkAvailability">
      <summary>
            Wrapper class which contains all of the information, for all peers, for a single distributed item.
            </summary>
    </member>
    <member name="F:DistributedFileSystem.SwarmChunkAvailability.peerAvailabilityByNetworkIdentifierDict">
      <summary>
            Our primary list of peerInfo which is keyed on networkIdentifier
            </summary>
    </member>
    <member name="F:DistributedFileSystem.SwarmChunkAvailability.peerEndPointToNetworkIdentifier">
      <summary>
            An index for peers based on IPEndPoints. Key represents a conversion 
            from IPEndPoint.ToString() to network identifier
            </summary>
    </member>
    <member name="F:DistributedFileSystem.SwarmChunkAvailability.alivePeersReceivedEvent">
      <summary>
            Triggered when first peer is recorded as being alive
            </summary>
    </member>
    <member name="F:DistributedFileSystem.SwarmChunkAvailability.peerLocker">
      <summary>
            A thread sync root
            </summary>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.#ctor">
      <summary>
            Blank constructor used for serialisation
            </summary>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.#ctor(System.Collections.Generic.List{NetworkCommsDotNet.ConnectionInfo},System.Byte)">
      <summary>
            Creates a new instance of SwarmChunkAvailability
            </summary>
      <param name="sourceConnectionInfoList">A list of sources. Possibly multiple peers each with multiple IPEndPoints.</param>
      <param name="totalNumChunks">The total number of chunks in the associated DFS item, used for initialising peer chunkflags</param>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.CachedNonLocalChunkExistences(System.Byte,System.Collections.Generic.Dictionary{NetworkCommsDotNet.ConnectionInfo,DistributedFileSystem.PeerInfo}@)">
      <summary>
            Builds a dictionary of chunk availability throughout the current swarm for chunks we don't have locally. Keys are chunkIndex, peer network identifier, and peer total chunk count
            </summary>
      <param name="totalChunksInItem">The total number of chunks in this item</param>
      <param name="nonLocalPeerAvailability">A quick reference dictionary for matching ConnectionInfo with PeerInfo</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.SetIPEndPointBusy(NetworkCommsDotNet.Tools.ShortGuid,System.Net.IPEndPoint)">
      <summary>
            Set the provided peer IPEndPoint busy status to busy
            </summary>
      <param name="networkIdentifier">The network identifier of the relevant peer</param>
      <param name="peerIPEndPoint">The relevant IPEndPoint</param>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.IPEndPointBusy(NetworkCommsDotNet.Tools.ShortGuid,System.Net.IPEndPoint)">
      <summary>
            Get the provided peer IPEndPoint busy status
            </summary>
      <param name="networkIdentifier">The network identifier of the relevant peer</param>
      <param name="peerIPEndPoint">The relevant IPEndPoint</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.SetIPEndPointOffline(NetworkCommsDotNet.Tools.ShortGuid,System.Net.IPEndPoint)">
      <summary>
            Set the provided peer IPEndPoint as offline
            </summary>
      <param name="networkIdentifier">The network identifier of the relevant peer</param>
      <param name="peerIPEndPoint">The relevant IPEndPoint</param>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.IPEndPointOnline(NetworkCommsDotNet.Tools.ShortGuid,System.Net.IPEndPoint)">
      <summary>
            Get the provided peer IPEndPoint online status
            </summary>
      <param name="networkIdentifier">The network identifier of the relevant peer</param>
      <param name="peerIPEndPoint">The relevant IPEndPoint</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.PeerExistsInSwarm(NetworkCommsDotNet.Tools.ShortGuid)">
      <summary>
            Returns true if a peer with the provided networkIdentifier exists in this SwarmChunkAvailability
            </summary>
      <param name="networkIdentifier">The network identifier of the relevant peer</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.PeerExistsInSwarm(System.Net.IPEndPoint)">
      <summary>
            Returns true if a peer with the provided IPEndPoint exists in the swarm
            </summary>
      <param name="peerIPEndPoint">The relevant IPEndPoint</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.PeerHasChunk(NetworkCommsDotNet.Tools.ShortGuid,System.Byte)">
      <summary>
            Returns true if the specified peer has the specified chunkIndex.
            </summary>
      <param name="networkIdentifier">The network identifier of the relevant peer</param>
      <param name="chunkIndex">The desired chunkIndex</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.PeerIsComplete(NetworkCommsDotNet.Tools.ShortGuid,System.Byte)">
      <summary>
            Returns true if a peer has a complete copy of the DFS item
            </summary>
      <param name="networkIdentifier">The network identifier of the relevant peer</param>
      <param name="totalNumChunks">The total number of chunks in this item</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.PeerIsSuperPeer(NetworkCommsDotNet.Tools.ShortGuid)">
      <summary>
            Returns true if the specified peer is a super peer
            </summary>
      <param name="networkIdentifier">The network identifier of the relevant peer</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.GetNewTimeoutCount(NetworkCommsDotNet.Tools.ShortGuid,System.Net.IPEndPoint)">
      <summary>
            Returns the new timeout count value after incrementing the timeout count for the provided peer IPEndPoint.
            </summary>
      <param name="networkIdentifier">The network identifier of the relevant peer</param>
      <param name="peerIPEndPoint">The relevant IPEndPoint</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.RemovePeerIPEndPointFromSwarm(NetworkCommsDotNet.Tools.ShortGuid,System.Net.IPEndPoint,System.Boolean)">
      <summary>
            Deletes knowledge of a peer IPEndPoint from our local swarm chunk availability. 
            If peerEndPoint.Address is IPAddress.Any then the entire peer will be deleted. 
            </summary>
      <param name="networkIdentifier">The network identifier of the relevant peer</param>
      <param name="peerEndPoint">The relevant IPEndPoint</param>
      <param name="forceRemoveWholePeer">If true every IPEndPoint is removed for the provided network identifier</param>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.AddOrUpdateCachedPeerChunkFlags(NetworkCommsDotNet.ConnectionInfo,DistributedFileSystem.ChunkFlags,System.Boolean,System.Boolean)">
      <summary>
            Adds or updates a peer to the local availability list. Useful for when a peer informs us of an updated availability.
            </summary>
      <param name="connectionInfo">The connectionInfo of the remote peer</param>
      <param name="latestChunkFlags">The new chunk flags</param>
      <param name="superPeer">True if this peer is a superPeer</param>
      <param name="setIPEndPointOnline">Set the relevant IPEndPoint online as a result of updating chunk flags</param>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.RemoveOldPeerAtEndPoint(NetworkCommsDotNet.Tools.ShortGuid,System.Net.IPEndPoint)">
      <summary>
            Removes any peers which have the same endPoint as the provided currentActivePeerEndPoint except one with matching currentActivePeerIdentifier
            </summary>
      <param name="currentActivePeerIdentifier">The NetworkIdenfier of the known active peer</param>
      <param name="currentActivePeerEndPoint">The endPoint of the known active peer</param>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.SetLocalChunkFlag(System.Byte,System.Boolean)">
      <summary>
            Sets our local availability
            </summary>
      <param name="chunkIndex">The chunk index flag to update</param>
      <param name="setAvailable">The availability of the provided chunk</param>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.UpdatePeerAvailability(System.String,System.Int32,System.Int32,System.Action{System.String})">
      <summary>
            Update the chunk availability by contacting all existing peers. If a cascade depth greater than 1 is 
            provided will also contact each peers peers.
            </summary>
      <param name="itemCheckSum">The checksum associated with this item. This will be used when contacting other peers
            for an update.</param>
      <param name="cascadeDepth">The depth of the update cascade. 0 - Contact only known peers for an update. 1 - Contact
            known peers and retrieve their known peers as well. &gt;1 - Not implemented.</param>
      <param name="responseWaitMS">The maximum time to wait for the first update reply to be received before continuing.</param>
      <param name="buildLog">An optional build log that can be updated with the progress of this method.</param>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.ChunkHealthMetric(System.Byte,System.Byte)">
      <summary>
            Metric used to determine the health of a chunk and whether swarm will benefit from a broadcasted update. A value 
            greater than 1 signifies a healthy chunk availability.
            </summary>
      <param name="chunkIndex">The relevant chunk index</param>
      <param name="totalNumChunks">The total number of chunks in this item</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.RecordLocalChunkCompletion(System.Byte)">
      <summary>
            Records a chunk as available for the local peer
            </summary>
      <param name="chunkIndex">The relevant chunkIndex</param>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.BroadcastLocalAvailability(System.String)">
      <summary>
            Updates all peers in the swarm that we have updated a chunk
            </summary>
      <param name="itemCheckSum">The checksum associated with this item</param>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.CloseConnectionsToCompletedPeers(System.Byte)">
      <summary>
            Closes established connections with completed peers as they are now redundant.
            </summary>
      <param name="totalNumChunks">The total number of chunks in this item</param>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.PeerContactAllowed(NetworkCommsDotNet.Tools.ShortGuid,System.Net.IPEndPoint,System.Boolean)">
      <summary>
            Single method for determining if contact can be made with the request peer.
            Prevents loop back contact via matching identifier and currentLocalListenEndPoints.
            Finally uses the DFS.AllowedPeerIPS and DFS.DisallowedPeerIPS if set.
            </summary>
      <param name="peerIdentifier">The relevant network identifier</param>
      <param name="peerEndPoint">The relevant IPEndPoint</param>
      <param name="superPeer">True if this peer is a super peer</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.PeerChunkAvailability(NetworkCommsDotNet.Tools.ShortGuid)">
      <summary>
            Returns the chunk flag availability of the requested peer.
            </summary>
      <param name="peerIdentifier">The relevant network identifier</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.BroadcastItemRemoval(System.String,System.Boolean)">
      <summary>
            Broadcast to all known peers that the local DFS is removing the specified item.
            </summary>
      <param name="itemCheckSum">The checksum associated with this item</param>
      <param name="removeSwarmWide">True if the item should be removed by all peers, swarm wide</param>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.NumPeersInSwarm(System.Boolean)">
      <summary>
            The number of peers in this swarm
            </summary>
      <param name="excludeSuperPeers">True if super peers should be excluded from the count.</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.NumCompletePeersInSwarm(System.Byte,System.Boolean)">
      <summary>
            The number of complete peers in this swarm.
            </summary>
      <param name="totalItemChunks">The total number of chunks in this item</param>
      <param name="excludeSuperPeers">True if super peers should be excluded from the count.</param>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.AllPeerIdentifiers">
      <summary>
            Returns an array containing the network identifiers of every peer in this swarm
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.AllPeerEndPoints">
      <summary>
            Returns an array containing all known peer endpoints in the format locaIP:port
            </summary>
      <returns>
      </returns>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.ClearAllLocalAvailabilityFlags">
      <summary>
            Clear all chunk availability flags for the local peer
            </summary>
    </member>
    <member name="M:DistributedFileSystem.SwarmChunkAvailability.ThreadSafeSerialise">
      <summary>
            Serialise this swarm chunk availability in a thread safe manner
            </summary>
      <returns>
      </returns>
    </member>
    <member name="T:DistributedFileSystem.KnownPeerEndPoints">
      <summary>
            A wrapper classed used to inform remote peers of our known peers
            </summary>
    </member>
    <member name="M:DistributedFileSystem.KnownPeerEndPoints.#ctor(System.String,System.String[])">
      <summary>
            Initialise a new KnownPeerEndPoints
            </summary>
      <param name="itemCheckSum">The checksum identifier for the included peer end points.</param>
      <param name="knownPeerEndPoints">All known IPEndPoints for this item</param>
    </member>
    <member name="P:DistributedFileSystem.KnownPeerEndPoints.ItemChecksm">
      <summary>
            The checksum identifier for the included peer end points.
            </summary>
    </member>
    <member name="P:DistributedFileSystem.KnownPeerEndPoints.PeerEndPoints">
      <summary>
            All known IPEndPoints for this item
            </summary>
    </member>
    <member name="T:RemoteProcedureCalls.IRPCProxy">
      <summary>
            Interface for the RPC proxy generated on the client side. All RPC objects returned from Client.CreateRPCProxyTo{X} implement this interface
            </summary>
    </member>
    <member name="P:RemoteProcedureCalls.IRPCProxy.ImplementedInterface">
      <summary>
            The interface the proxy implements
            </summary>
    </member>
    <member name="P:RemoteProcedureCalls.IRPCProxy.ServerInstanceID">
      <summary>
            The server generated object id for the remote instance
            </summary>
    </member>
    <member name="P:RemoteProcedureCalls.IRPCProxy.ServerConnection">
      <summary>
            The NetworkComms.Net connection associated wth the proxy
            </summary>
    </member>
    <member name="P:RemoteProcedureCalls.IRPCProxy.SendReceiveOptions">
      <summary>
            The send receive options used when communicating with the server
            </summary>
    </member>
    <member name="P:RemoteProcedureCalls.IRPCProxy.RPCTimeout">
      <summary>
            The timeout for all RPC calls made with this proxy in ms
            </summary>
    </member>
    <member name="P:RemoteProcedureCalls.IRPCProxy.IsDisposed">
      <summary>
            Gets a value indicating whether the <see cref="T:RemoteProcedureCalls.IRPCProxy" /> has been disposed of
            </summary>
    </member>
    <member name="T:RemoteProcedureCalls.Client">
      <summary>
            Provides functions for managing proxy classes to remote objects client side
            </summary>
    </member>
    <member name="T:RemoteProcedureCalls.Client.CachedRPCKey">
      <summary>
            Struct that helps store the cached RPC objects
            </summary>
    </member>
    <member name="T:RemoteProcedureCalls.Client.Cache`1">
      <summary>
            Funky class used for dynamically creating the proxy
            </summary>
      <typeparam name="I">
      </typeparam>
    </member>
    <member name="M:RemoteProcedureCalls.Client.CreateProxyToPrivateInstance``1(NetworkCommsDotNet.Connections.Connection,System.String,System.String@,NetworkCommsDotNet.SendReceiveOptions)">
      <summary>
            Creates a remote proxy instance for the desired interface with the specified server and object identifier.  Instance is private to this client in the sense that no one else can
            use the instance on the server unless they have the instanceId returned by this method
            </summary>
      <typeparam name="I">The interface to use for the proxy</typeparam>
      <param name="connection">The connection over which to perform remote procedure calls</param>
      <param name="instanceName">The object identifier to use for this proxy</param>
      <param name="instanceId">Outputs the instance Id uniquely identifying this object on the server.  Can be used to re-establish connection to object if connection is dropped</param>
      <param name="options">SendRecieve options to use</param>
      <returns>A proxy class for the interface I allowing remote procedure calls</returns>
    </member>
    <member name="M:RemoteProcedureCalls.Client.CreateProxyToPublicNamedInstance``1(NetworkCommsDotNet.Connections.Connection,System.String,System.String@,NetworkCommsDotNet.SendReceiveOptions)">
      <summary>
            Creates a remote proxy instance for the desired interface with the specified server and object identifier.  Instance is public in sense that any client can use specified name to make 
            calls on the same server side object 
            </summary>
      <typeparam name="I">The interface to use for the proxy</typeparam>
      <param name="connection">The connection over which to perform remote procedure calls</param>
      <param name="instanceName">The name specified server side to identify object to create proxy to</param>
      <param name="instanceId">Outputs the instance Id uniquely identifying this object on the server.  Can be used to re-establish connection to object if connection is dropped</param>
      <param name="options">SendRecieve options to use</param>
      <returns>A proxy class for the interface I allowing remote procedure calls</returns>
    </member>
    <member name="M:RemoteProcedureCalls.Client.CreateProxyToIdInstance``1(NetworkCommsDotNet.Connections.Connection,System.String,NetworkCommsDotNet.SendReceiveOptions)">
      <summary>
            Creates a remote proxy to an object with a specific identifier implementing the supplied interface with the specified server
            </summary>
      <typeparam name="I">The interface to use for the proxy</typeparam>
      <param name="connection">The connection over which to perform remote procedure calls</param>
      <param name="instanceId">Unique identifier for the instance on the server</param>
      <param name="options">SendRecieve options to use</param>
      <returns>A proxy class for the interface T allowing remote procedure calls</returns>
    </member>
    <member name="M:RemoteProcedureCalls.Client.RemoteCallClient(RemoteProcedureCalls.IRPCProxy,System.String,System.Object[])">
      <summary>
            Private method for simplifying the remote procedure call.  I don't want to write this in IL!!
            </summary>
      <param name="clientObject">
      </param>
      <param name="functionToCall">
      </param>
      <param name="args">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:RemoteProcedureCalls.Client.DestroyRPCClient(RemoteProcedureCalls.IRPCProxy)">
      <summary>
            Causes the provided <see cref="T:RemoteProcedureCalls.IRPCProxy" /> instance to be disposed
            </summary>
      <param name="clientObject">The <see cref="T:RemoteProcedureCalls.IRPCProxy" /> to dispose</param>
    </member>
    <member name="P:RemoteProcedureCalls.Client.DefaultRPCTimeout">
      <summary>
            The default timeout period in ms for new RPC proxies. Default value is 1000ms 
            </summary>
    </member>
    <member name="P:RemoteProcedureCalls.Client.RPCInitialisationTimeout">
      <summary>
            The timeout period allowed for creating new RPC proxies
            </summary>
    </member>
    <member name="T:RemoteProcedureCalls.RPCException">
      <summary>
            An error occured during an RPC (Remote Procedure Call) exchange.
            </summary>
    </member>
    <member name="M:RemoteProcedureCalls.RPCException.#ctor(System.String)">
      <summary>
            Create a new instance of RPCException
            </summary>
      <param name="msg">A string containing useful information regarding the error</param>
    </member>
    <member name="T:RemoteProcedureCalls.Server">
      <summary>
            Contains methods for managing objects server side which allow Remote Procedure Calls
            </summary>
    </member>
    <member name="M:RemoteProcedureCalls.Server.GetInstanceId(System.String)">
      <summary>
            Helper method for calculating instance ids
            </summary>
      <param name="input">
      </param>
      <returns>
      </returns>
    </member>
    <member name="M:RemoteProcedureCalls.Server.RegisterTypeForPrivateRemoteCall``2(System.Int32)">
      <summary>
            Registers a type for private RPC whereby each client generates it's own private instances on the server
            </summary>
      <typeparam name="T">The type of object to create new instances of for RPC.  Must implement I</typeparam>
      <typeparam name="I">Interface that should be provided for RPC</typeparam>
      <param name="timeout">If specified each RPC object created will be destroyed if it is unused for a time, in ms, specified by timeout</param>
    </member>
    <member name="M:RemoteProcedureCalls.Server.RegisterInstanceForPublicRemoteCall``2(``0,System.String)">
      <summary>
            Registers a specfic object instance, with the supplied name, for RPC
            </summary>
      <typeparam name="T">The type of the object to register. Must implement I</typeparam>
      <typeparam name="I">The interface to be provided for RPC</typeparam>
      <param name="instance">Instance to register for RPC</param>
      <param name="instanceName">Name of the instance to be used by clients for RPC</param>
    </member>
    <member name="M:RemoteProcedureCalls.Server.RemovePrivateRPCObjectType``2">
      <summary>
            Removes all private RPC objects for the specified interface type.  Stops listenning for new RPC instance connections
            </summary>
      <typeparam name="T">Object type that implements the specified interface I</typeparam>
      <typeparam name="I">Interface that is being implemented for RPC calls</typeparam>
    </member>
    <member name="M:RemoteProcedureCalls.Server.RemovePublicRPCObject(System.Object)">
      <summary>
            Disables RPC calls for the supplied named public object supplied
            </summary>
      <param name="instance">Instance to disable RPC for</param>
    </member>
    <member name="M:RemoteProcedureCalls.Server.ShutdownAllRPC">
      <summary>
            Removes all public and private RPC objects and removes all related packet handlers from NetworkComms
            </summary>
    </member>
    <member name="T:RemoteProcedureCalls.RemoteCallWrapper">
      <summary>
            Wrapper class used for serialisation when running functions remotely
            </summary>
    </member>
    <member name="T:RemoteProcedureCalls.RPCArgumentBase">
      <summary>
            Cheeky base class used in order to allow us to send an array of objects using Protobuf-net
            </summary>
    </member>
    <member name="T:RemoteProcedureCalls.RPCArgument`1">
      <summary>
            Cheeky derived class used in order to allow us to send an array of objects using Protobuf-net
            </summary>
    </member>
  </members>
</doc>