using UnityEngine;

namespace SEE.Layout
{
    /// <summary>
    /// A factory for circle game objects.
    /// </summary>
    public class CircleFactory : NodeFactory
    {
        private Material material;

        public static Color DefaultColor = Color.white;

        public CircleFactory()
        {
            material = new Material(Materials.DefaultMaterial());
            material.color = DefaultColor;
        }

        public override GameObject NewBlock()
        {
            GameObject result = new GameObject();
            AttachCircleLine(result, 0.5f, 0.1f * Unit(), Color.white);
            return result;
        }

        private void AttachCircleLine(GameObject circle, float radius, float lineWidth, Color color)
        {
            // Number of line segments constituting the circle
            const int segments = 360;

            LineRenderer line = circle.AddComponent<LineRenderer>();

            LineFactory.SetDefaults(line);
            LineFactory.SetColor(line, color);
            LineFactory.SetWidth(line, lineWidth);

            // We want to set the points of the circle lines relative to the game object.
            line.useWorldSpace = false;
            // All circles lines have the same material to reduce the number of drawing calls.
            line.sharedMaterial = material;

            line.positionCount = segments + 1;
            const int pointCount = segments + 1; // add extra point to make startpoint and endpoint the same to close the circle
            Vector3[] points = new Vector3[pointCount];

            for (int i = 0; i < pointCount; i++)
            {
                float rad = Mathf.Deg2Rad * (i * 360f / segments);
                points[i] = new Vector3(Mathf.Sin(rad) * radius, 0, Mathf.Cos(rad) * radius);
            }
            line.SetPositions(points);
        }

        /// <summary>
        /// Returns the size of the block generated by this factory.
        /// Precondition: The given block must have been generated by this factory.
        /// </summary>
        /// <param name="block">block whose size is to be returned</param>
        /// <returns>size of the block</returns>
        public override Vector3 GetSize(GameObject block)
        {
            // Nodes represented by cubes have a renderer from which we can derive the
            // extent.
            Renderer renderer = block.GetComponent<Renderer>();
            if (renderer != null)
            {
                // IMPORTANT NOTE: For some unknown strange reason, the extent of circles
                // is actually double the actual space it consumes. That is why we devide
                // it by two here.
                return renderer.bounds.size / 2.0f;
            }
            else
            {
                Debug.LogErrorFormat("Node {0} (tag: {1}) without renderer.\n", block.name, block.tag);
                return Vector3.one;
            }
        }
    }
}