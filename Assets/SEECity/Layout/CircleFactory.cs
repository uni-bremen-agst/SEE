using UnityEngine;

namespace SEE.Layout
{
    /// <summary>
    /// A factory for circle game objects.
    /// </summary>
    public class CircleFactory : InnerNodeFactory
    {
        // The material we use for the circle lines.
        private Material material;

        // The default color for circle lines.
        public static Color DefaultColor = Color.blue;

        public CircleFactory()
        {
            material = new Material(Materials.DefaultMaterial());
            material.color = DefaultColor;
        }

        private const float defaultLineWidth = 0.1f;

        private const float defaultRadius = 0.5f;

        public override GameObject NewBlock()
        {
            GameObject result = new GameObject();
            AttachCircleLine(result, defaultRadius, defaultLineWidth * Unit(), DefaultColor);
            return result;
        }

        /// <summary>
        /// Sets the width of lines drawn for the given object.
        /// 
        /// Precondition: circle must have been created by this factory and must contain
        /// a LineRenderer component.
        /// </summary>
        /// <param name="circle">game object to be drawn with different line width</param>
        /// <param name="lineWidth">new width of the lines</param>
        /// <summary>
        public override void SetLineWidth(GameObject circle, float lineWidth)
        {
            LineRenderer line = circle.GetComponent<LineRenderer>();
            LineFactory.SetWidth(line, lineWidth);
        }

        /// <summary>
        /// Attaches a circle line on given circle object.
        /// </summary>
        /// <param name="circle">object to which to attach the circle line</param>
        /// <param name="radius">radius of the circle</param>
        /// <param name="lineWidth">width of the circle line</param>
        /// <param name="color">color of the circle line</param>
        private void AttachCircleLine(GameObject circle, float radius, float lineWidth, Color color)
        {
            // Number of line segments constituting the circle
            const int segments = 360;

            LineRenderer line = circle.AddComponent<LineRenderer>();

            LineFactory.SetDefaults(line);
            LineFactory.SetColor(line, color);
            LineFactory.SetWidth(line, lineWidth);

            // We want to set the points of the circle lines relative to the game object.
            // If the containing object moves, the line renderer should move along with it.
            line.useWorldSpace = false;

            // All circles lines have the same material to reduce the number of drawing calls.
            line.sharedMaterial = material;

            line.positionCount = segments + 1;
            const int pointCount = segments + 1; // add extra point to make startpoint and endpoint the same to close the circle
            Vector3[] points = new Vector3[pointCount];

            for (int i = 0; i < pointCount; i++)
            {
                float rad = Mathf.Deg2Rad * (i * 360f / segments);
                points[i] = new Vector3(Mathf.Sin(rad) * radius, 0, Mathf.Cos(rad) * radius);
            }
            line.SetPositions(points);
        }

        /// <summary>
        /// Returns the size of the game object generated by this factory.
        /// Precondition: The given game object must have been generated by this factory.
        /// </summary>
        /// <param name="gameObject">game object whose size is to be returned</param>
        /// <returns>size of the block</returns>
        public override Vector3 GetSize(GameObject gameObject)
        {
            // Nodes represented by cubes have a renderer from which we can derive the
            // extent.
            Renderer renderer = gameObject.GetComponent<Renderer>();
            if (renderer != null)
            {
                // IMPORTANT NOTE: For some unknown strange reason, the extent of circles
                // is actually double the actual space it consumes. That is why we devide
                // it by two here.
                return renderer.bounds.size / 2.0f;
            }
            else
            {
                Debug.LogErrorFormat("Node {0} (tag: {1}) without renderer.\n", gameObject.name, gameObject.tag);
                return Vector3.one;
            }
        }
    }
}