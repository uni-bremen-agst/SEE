using UnityEngine;

namespace SEE.GO
{
    /// <summary>
    /// A factory for visual representations of graph nodes in the scene.
    /// 
    /// A game object created by this factory has -- as every other game
    /// object -- a scale (width X, height Y, depth Z), which can be 
    /// set and manipulated by this factory. Clients of a node factory
    /// should not retrieve or set these attributes themselves using Unity's own
    /// API, thus, should not use transform.localScale or renderer.bounds.size
    /// and the like. The reason for that is that the intent of NodeFactory
    /// to abstract from the differences of the kinds of game objects we use
    /// for leaf nodes, namely, Cubes and CScape buildings. The latter have
    /// their own idea of scaling and size, which differs from the normal
    /// Unity way.
    /// 
    /// In addition to scale, a node can have another kind of visual attribute
    /// that is offered by a node factory. Concretely, Cubes offer a color gradient
    /// and CScape buildings different styles of buildings. As a shared
    /// term that abstracts from those concrete styles, we call this attribute
    /// Style.
    /// </summary>
    public abstract class NodeFactory
    {
        /// <summary>
        /// Creates and returns a new block representation of a graph node.
        /// The interpretation of the given <paramref name="style"/> depends upon 
        /// the subclasses. It can be used to specify a visual property of the 
        /// objects such as the color. The allowed range of a style index depends 
        /// upon the  subclasses, too, but must be in [0, NumberOfStyles()-1].
        /// </summary>
        /// <param name="style">specifies an additional visual style parameter of 
        /// the object</param>
        /// <returns>new block representation</returns>
        public abstract GameObject NewBlock(int style = 0);

        /// <summary>
        /// The number of styles offered. A style index must be in the range
        /// [0, NumberOfStyles()-1].
        /// </summary>
        /// <returns>number of materials offered</returns>
        public abstract int NumberOfStyles();

        /// <summary>
        /// The length unit of a block representation in Unity measures.
        /// </summary>
        public float Unit
        {
            get => unit;
            set => unit = value;
        }

        /// <summary>
        /// The length unit of a block representation in Unity measures.
        /// </summary>
        protected float unit = 1.0f;

        /// <summary>
        /// Returns the size of the block generated by this factory in Unity units.
        /// Precondition: The given block must have been generated by this factory.
        /// </summary>
        /// <param name="block">block whose size is to be returned</param>
        /// <returns>size of the block</returns>
        public virtual Vector3 GetSize(GameObject block)
        {
            // Nodes represented by cubes have a renderer from which we can derive the
            // extent.
            Renderer renderer = block.GetComponent<Renderer>();
            if (renderer != null)
            {
                return renderer.bounds.size;
            }
            else
            {
                Debug.LogErrorFormat("Node {0} (tag: {1}) without renderer.\n", block.name, block.tag);
                return Vector3.one;
            }
        }

        /// <summary>
        /// Sets the size (its scale) of the given block by the given size. Note: The unit of 
        /// size is Unity units.
        /// Precondition: The given block must have been generated by this factory.
        /// </summary>
        /// <param name="block">block to be scaled</param>
        /// <param name="size">new size</param>
        public virtual void SetSize(GameObject block, Vector3 size)
        {
            block.transform.localScale = size;
        }

        /// <summary>
        /// Sets the width of the object (x axis) to the given value in Unity units.
        /// </summary>
        /// <param name="block">block to be adjusted</param>
        /// <param name="value">new value for width</param>
        public virtual void SetWidth(GameObject block, float value)
        {
            block.transform.localScale = new Vector3(value, block.transform.localScale.y, block.transform.localScale.z);
        }

        /// <summary>
        /// Sets the height of the object (y axis) to the given value in Unity units.
        /// </summary>
        /// <param name="block">block to be adjusted</param>
        /// <param name="value">new value for height</param>
        public virtual void SetHeight(GameObject block, float value)
        {
            block.transform.localScale = new Vector3(block.transform.localScale.x, value, block.transform.localScale.z);
        }

        /// <summary>
        /// Sets the depth of the object (y axis) to the given value in Unity units.
        /// </summary>
        /// <param name="block">block to be adjusted</param>
        /// <param name="value">new value for depth</param>
        public virtual void SetDepth(GameObject block, float value)
        {
            block.transform.localScale = new Vector3(block.transform.localScale.x, block.transform.localScale.y, value);
        }

        /// <summary>
        /// Sets the position of the current block. The given position is
        /// interpreted as the center (x,z) of the block on the ground (y).
        /// </summary>
        /// <param name="block">block to be positioned</param>
        /// <param name="position">where to position the block (its center) on the ground y</param>
        public virtual void SetGroundPosition(GameObject block, Vector3 position)
        {
            Vector3 extent = GetSize(block) / 2.0f;
            block.transform.position = new Vector3(position.x, position.y + extent.y, position.z);
        }

        /// <summary>
        /// Sets the local position of the current block within its parent object.
        /// The given position is interpreted as the center (x,z) of the block on the ground (y).
        /// </summary>
        /// <param name="block">block to be positioned</param>
        /// <param name="position">where to position the block (its center)</param>
        public virtual void SetLocalGroundPosition(GameObject block, Vector3 position)
        {
            Vector3 extent = GetSize(block) / 2.0f;
            block.transform.localPosition = new Vector3(position.x, position.y + extent.y, position.z);
        }

        /// <summary>
        /// Returns the center of the roof of the given block.
        /// </summary>
        /// <param name="block">block for which to determine the roof position</param>
        /// <returns>roof position</returns>
        public virtual Vector3 Roof(GameObject block)
        {
            Vector3 result = block.transform.position;
            result.y += GetSize(block).y / 2.0f;
            return result;
        }

        /// <summary>
        /// Returns the center of the ground of a block.
        /// </summary>
        /// <param name="block">block for which to determine the ground position</param>
        /// <returns>ground position</returns>
        public virtual Vector3 Ground(GameObject block)
        {
            Vector3 result = block.transform.position;
            result.y -= GetSize(block).y / 2.0f;
            return result;
        }

        /// <summary>
        /// The center position of the block in world space.
        /// </summary>
        /// <param name="block">block for which to retrieve the center position</param>
        /// <returns>center position of the block in world space</returns>
        public virtual Vector3 GetCenterPosition(GameObject block)
        {
            // The center position in Unity is normally its transform.position
            // (as opposed to CScape buildings).
            return block.transform.position;
        }

        /// <summary>
        /// Rotates the given object by the given degree along the y axis (i.e., relative to the ground).
        /// </summary>
        /// <param name="gameNode">object to be rotated</param>
        /// <param name="degree">degree of rotation</param>
        public virtual void Rotate(GameObject block, float degree)
        {
            Quaternion rotation = Quaternion.Euler(0, degree, 0);
            block.transform.rotation = rotation;
        }

        /// <summary>
        /// Sets the style as the given <paramref name="style"/> 
        /// for <paramref name="block"/>. The value used will be clamped
        /// in [0, NumberOfStyles()-1].
        /// </summary>
        /// <param name="style">the index of the requested material</param>
        public abstract void SetStyle(GameObject block, int style);
    }
}
