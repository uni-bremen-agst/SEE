//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.9.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from CypherParser.g4 by ANTLR 4.9.2

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.9.2")]
[System.CLSCompliant(false)]
public partial class CypherParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		SPACE=1, SINGLE_LINE_COMMENT=2, MULTI_LINE_COMMENT=3, DECIMAL_DOUBLE=4, 
		UNSIGNED_DECIMAL_INTEGER=5, UNSIGNED_HEX_INTEGER=6, UNSIGNED_OCTAL_INTEGER=7, 
		STRING_LITERAL1=8, STRING_LITERAL2=9, ESCAPED_SYMBOLIC_NAME=10, ACCESS=11, 
		ACTIVE=12, ADD=13, ADMIN=14, ADMINISTRATOR=15, ALIAS=16, ALIASES=17, ALL_SHORTEST_PATHS=18, 
		ALL=19, ALLREDUCE=20, ALTER=21, AND=22, ANY=23, ARRAY=24, AS=25, ASC=26, 
		ASCENDING=27, ASSIGN=28, AT=29, AUTH=30, BAR=31, BINDINGS=32, BOOL=33, 
		BOOLEAN=34, BOOSTED=35, BOTH=36, BREAK=37, BUILT=38, BY=39, CALL=40, CASCADE=41, 
		CASE=42, CHANGE=43, CIDR=44, COLLECT=45, COLON=46, COLONCOLON=47, COMMA=48, 
		COMMAND=49, COMMANDS=50, COMPOSITE=51, CONCURRENT=52, CONSTRAINT=53, CONSTRAINTS=54, 
		CONTAINS=55, COPY=56, CONTINUE=57, COSINE=58, COUNT=59, CREATE=60, CREDENTIAL=61, 
		CSV=62, CURRENT=63, CYPHER=64, DATA=65, DATABASE=66, DATABASES=67, DATE=68, 
		DATETIME=69, DBMS=70, DEALLOCATE=71, DEFAULT=72, DEFINED=73, DELETE=74, 
		DENY=75, DESC=76, DESCENDING=77, DESTROY=78, DETACH=79, DIFFERENT=80, 
		DOLLAR=81, DISTINCT=82, DIVIDE=83, DOT=84, DOT_METRIC=85, DOTDOT=86, DOUBLEBAR=87, 
		DRIVER=88, DROP=89, DRYRUN=90, DUMP=91, DURATION=92, EACH=93, EDGE=94, 
		ENABLE=95, ELEMENT=96, ELEMENTS=97, ELSE=98, ENCRYPTED=99, EUCLIDEAN=100, 
		EUCLIDEAN_SQUARED=101, END=102, ENDS=103, EQ=104, EXECUTABLE=105, EXECUTE=106, 
		EXIST=107, EXISTENCE=108, EXISTS=109, ERROR=110, FAIL=111, FALSE=112, 
		FIELDTERMINATOR=113, FILTER=114, FINISH=115, FLOAT=116, FLOAT64=117, FLOAT32=118, 
		FOR=119, FOREACH=120, FORWARDING=121, FROM=122, FULLTEXT=123, FUNCTION=124, 
		FUNCTIONS=125, GE=126, GRANT=127, GRAPH=128, GRAPHS=129, GROUP=130, GROUPS=131, 
		GT=132, HAMMING=133, HEADERS=134, HOME=135, ID=136, IF=137, IMPERSONATE=138, 
		IMMUTABLE=139, IN=140, INDEX=141, INDEXES=142, INF=143, INFINITY=144, 
		INSERT=145, INT=146, INT64=147, INT32=148, INT16=149, INT8=150, INTEGER=151, 
		INTEGER64=152, INTEGER32=153, INTEGER16=154, INTEGER8=155, IS=156, JOIN=157, 
		KEY=158, LABEL=159, LABELS=160, AMPERSAND=161, EXCLAMATION_MARK=162, LANGUAGE=163, 
		LBRACKET=164, LCURLY=165, LE=166, LEADING=167, LET=168, LIMITROWS=169, 
		LIST=170, LOAD=171, LOCAL=172, LOOKUP=173, LPAREN=174, LT=175, MANAGEMENT=176, 
		MANHATTAN=177, MAP=178, MATCH=179, MERGE=180, MINUS=181, PERCENT=182, 
		IMPLIES=183, INVALID_NEQ=184, NEQ=185, NAME=186, NAMES=187, NAN=188, NFC=189, 
		NFD=190, NFKC=191, NFKD=192, NEW=193, NEXT=194, NODE=195, NODETACH=196, 
		NODES=197, NONE=198, NORMALIZE=199, NORMALIZED=200, NOT=201, NOTHING=202, 
		NOWAIT=203, NULL=204, OF=205, OFFSET=206, OIDC=207, ON=208, ONLY=209, 
		OPTIONAL=210, OPTIONS=211, OPTION=212, OR=213, ORDER=214, PASSWORD=215, 
		PASSWORDS=216, PATH=217, PATHS=218, PLAINTEXT=219, PLUS=220, PLUSEQUAL=221, 
		POINT=222, POPULATED=223, POW=224, PRIMARY=225, PRIMARIES=226, PRIVILEGE=227, 
		PRIVILEGES=228, PROCEDURE=229, PROCEDURES=230, PROPERTIES=231, PROPERTY=232, 
		PROVIDER=233, PROVIDERS=234, QUESTION=235, RANGE=236, RBRACKET=237, RCURLY=238, 
		READ=239, REALLOCATE=240, REDUCE=241, RENAME=242, REGEQ=243, REL=244, 
		RELATIONSHIP=245, RELATIONSHIPS=246, REMOVE=247, REPEATABLE=248, REPLACE=249, 
		REPLICA=250, REPLICAS=251, REPORT=252, REQUIRE=253, REQUIRED=254, RESTRICT=255, 
		RETRY=256, RETURN=257, REVOKE=258, ROLE=259, ROLES=260, ROW=261, ROWS=262, 
		RPAREN=263, SCAN=264, SEC=265, SECOND=266, SECONDARY=267, SECONDARIES=268, 
		SECONDS=269, SEEK=270, SEMICOLON=271, SERVER=272, SERVERS=273, SET=274, 
		SETTING=275, SETTINGS=276, SHARD=277, SHARDS=278, SHORTEST_PATH=279, SHORTEST=280, 
		SHOW=281, SIGNED=282, SINGLE=283, SKIPROWS=284, START=285, STARTS=286, 
		STATUS=287, STOP=288, STRING=289, SUPPORTED=290, SUSPENDED=291, TARGET=292, 
		TERMINATE=293, TEXT=294, THEN=295, TIME=296, TIMES=297, TIMESTAMP=298, 
		TIMEZONE=299, TO=300, TOPOLOGY=301, TRAILING=302, TRANSACTION=303, TRANSACTIONS=304, 
		TRAVERSE=305, TRIM=306, TRUE=307, TYPE=308, TYPED=309, TYPES=310, UNION=311, 
		UNIQUE=312, UNIQUENESS=313, UNWIND=314, URL=315, USE=316, USER=317, USERS=318, 
		USING=319, VALUE=320, VARCHAR=321, VECTOR=322, VECTOR_DISTANCE=323, VECTOR_NORM=324, 
		VERTEX=325, WAIT=326, WHEN=327, WHERE=328, WITH=329, WITHOUT=330, WRITE=331, 
		XOR=332, YIELD=333, ZONE=334, ZONED=335, IDENTIFIER=336, EXTENDED_IDENTIFIER=337, 
		ARROW_LINE=338, ARROW_LEFT_HEAD=339, ARROW_RIGHT_HEAD=340, ErrorChar=341;
	public const int
		RULE_statements = 0, RULE_statement = 1, RULE_nextStatement = 2, RULE_regularQuery = 3, 
		RULE_union = 4, RULE_when = 5, RULE_whenBranch = 6, RULE_elseBranch = 7, 
		RULE_singleQuery = 8, RULE_clause = 9, RULE_useClause = 10, RULE_graphReference = 11, 
		RULE_finishClause = 12, RULE_returnClause = 13, RULE_returnBody = 14, 
		RULE_returnItem = 15, RULE_returnItems = 16, RULE_orderItem = 17, RULE_ascToken = 18, 
		RULE_descToken = 19, RULE_orderBy = 20, RULE_skip = 21, RULE_limit = 22, 
		RULE_whereClause = 23, RULE_withClause = 24, RULE_createClause = 25, RULE_insertClause = 26, 
		RULE_setClause = 27, RULE_setItem = 28, RULE_removeClause = 29, RULE_removeItem = 30, 
		RULE_deleteClause = 31, RULE_matchClause = 32, RULE_matchMode = 33, RULE_hint = 34, 
		RULE_mergeClause = 35, RULE_mergeAction = 36, RULE_filterClause = 37, 
		RULE_unwindClause = 38, RULE_letClause = 39, RULE_letItem = 40, RULE_callClause = 41, 
		RULE_procedureName = 42, RULE_procedureArgument = 43, RULE_procedureResultItem = 44, 
		RULE_loadCSVClause = 45, RULE_foreachClause = 46, RULE_subqueryClause = 47, 
		RULE_subqueryScope = 48, RULE_subqueryInTransactionsParameters = 49, RULE_subqueryInTransactionsBatchParameters = 50, 
		RULE_subqueryInTransactionsErrorParameters = 51, RULE_subqueryInTransactionsRetryParameters = 52, 
		RULE_subqueryInTransactionsReportParameters = 53, RULE_orderBySkipLimitClause = 54, 
		RULE_patternList = 55, RULE_insertPatternList = 56, RULE_pattern = 57, 
		RULE_insertPattern = 58, RULE_quantifier = 59, RULE_anonymousPattern = 60, 
		RULE_shortestPathPattern = 61, RULE_patternElement = 62, RULE_selector = 63, 
		RULE_nonNegativeIntegerSpecification = 64, RULE_groupToken = 65, RULE_pathToken = 66, 
		RULE_pathPatternNonEmpty = 67, RULE_nodePattern = 68, RULE_insertNodePattern = 69, 
		RULE_parenthesizedPath = 70, RULE_nodeLabels = 71, RULE_nodeLabelsIs = 72, 
		RULE_dynamicExpression = 73, RULE_dynamicAnyAllExpression = 74, RULE_dynamicLabelType = 75, 
		RULE_labelType = 76, RULE_relType = 77, RULE_labelOrRelType = 78, RULE_properties = 79, 
		RULE_relationshipPattern = 80, RULE_insertRelationshipPattern = 81, RULE_leftArrow = 82, 
		RULE_arrowLine = 83, RULE_rightArrow = 84, RULE_pathLength = 85, RULE_labelExpression = 86, 
		RULE_labelExpression4 = 87, RULE_labelExpression3 = 88, RULE_labelExpression2 = 89, 
		RULE_labelExpression1 = 90, RULE_insertNodeLabelExpression = 91, RULE_insertRelationshipLabelExpression = 92, 
		RULE_expression = 93, RULE_expression11 = 94, RULE_expression10 = 95, 
		RULE_expression9 = 96, RULE_expression8 = 97, RULE_expression7 = 98, RULE_comparisonExpression6 = 99, 
		RULE_normalForm = 100, RULE_expression6 = 101, RULE_expression5 = 102, 
		RULE_expression4 = 103, RULE_expression3 = 104, RULE_expression2 = 105, 
		RULE_postFix = 106, RULE_property = 107, RULE_dynamicProperty = 108, RULE_propertyExpression = 109, 
		RULE_dynamicPropertyExpression = 110, RULE_expression1 = 111, RULE_literal = 112, 
		RULE_caseExpression = 113, RULE_caseAlternative = 114, RULE_extendedCaseExpression = 115, 
		RULE_extendedCaseAlternative = 116, RULE_extendedWhen = 117, RULE_listComprehension = 118, 
		RULE_patternComprehension = 119, RULE_reduceExpression = 120, RULE_allReduceExpression = 121, 
		RULE_allReduceExpressionValidArguments = 122, RULE_allReduceExpressionInvalidArguments = 123, 
		RULE_listItemsPredicate = 124, RULE_normalizeFunction = 125, RULE_vectorFunction = 126, 
		RULE_vectorDistanceFunction = 127, RULE_vectorNormFunction = 128, RULE_vectorDistanceMetric = 129, 
		RULE_vectorNormDistanceMetric = 130, RULE_trimFunction = 131, RULE_patternExpression = 132, 
		RULE_shortestPathExpression = 133, RULE_parenthesizedExpression = 134, 
		RULE_mapProjection = 135, RULE_mapProjectionElement = 136, RULE_countStar = 137, 
		RULE_existsExpression = 138, RULE_countExpression = 139, RULE_collectExpression = 140, 
		RULE_numberLiteral = 141, RULE_signedIntegerLiteral = 142, RULE_listLiteral = 143, 
		RULE_propertyKeyName = 144, RULE_parameter = 145, RULE_parameterName = 146, 
		RULE_functionInvocation = 147, RULE_functionArgument = 148, RULE_functionName = 149, 
		RULE_namespace = 150, RULE_variable = 151, RULE_nonEmptyNameList = 152, 
		RULE_type = 153, RULE_typePart = 154, RULE_typeName = 155, RULE_typeNullability = 156, 
		RULE_typeListSuffix = 157, RULE_vectorCoordinateType = 158, RULE_command = 159, 
		RULE_createCommand = 160, RULE_alterCommand = 161, RULE_dropCommand = 162, 
		RULE_showCommand = 163, RULE_showCommandYield = 164, RULE_yieldItem = 165, 
		RULE_yieldSkip = 166, RULE_yieldLimit = 167, RULE_yieldClause = 168, RULE_commandOptions = 169, 
		RULE_terminateCommand = 170, RULE_composableCommandClauses = 171, RULE_composableShowCommandClauses = 172, 
		RULE_showIndexCommand = 173, RULE_showIndexType = 174, RULE_showIndexesEnd = 175, 
		RULE_showConstraintCommand = 176, RULE_showConstraintEntity = 177, RULE_constraintExistType = 178, 
		RULE_showConstraintsEnd = 179, RULE_showCurrentGraphTypeCommand = 180, 
		RULE_showProcedures = 181, RULE_showFunctions = 182, RULE_functionToken = 183, 
		RULE_executableBy = 184, RULE_showFunctionsType = 185, RULE_showTransactions = 186, 
		RULE_terminateTransactions = 187, RULE_showSettings = 188, RULE_settingToken = 189, 
		RULE_namesAndClauses = 190, RULE_stringsOrExpression = 191, RULE_commandNodePattern = 192, 
		RULE_commandRelPattern = 193, RULE_createConstraint = 194, RULE_constraintType = 195, 
		RULE_dropConstraint = 196, RULE_createIndex = 197, RULE_createIndex_ = 198, 
		RULE_createFulltextIndex = 199, RULE_fulltextNodePattern = 200, RULE_fulltextRelPattern = 201, 
		RULE_createLookupIndex = 202, RULE_lookupIndexNodePattern = 203, RULE_lookupIndexRelPattern = 204, 
		RULE_dropIndex = 205, RULE_propertyList = 206, RULE_enclosedPropertyList = 207, 
		RULE_alterCurrentGraphType = 208, RULE_graphTypeSpecification = 209, RULE_graphTypeDropSpecification = 210, 
		RULE_graphTypeSpecificationBody = 211, RULE_graphTypeDropSpecificationBody = 212, 
		RULE_graphTypeElement = 213, RULE_graphTypeDropElement = 214, RULE_nodeTypeInlineConstraintList = 215, 
		RULE_edgeTypeInlineConstraintList = 216, RULE_implies = 217, RULE_nodeTypeSpecification = 218, 
		RULE_impliedLabelSet = 219, RULE_identifyingLabel = 220, RULE_nodeTypeReference = 221, 
		RULE_nodeTypeAliasReference = 222, RULE_nodeTypeInSituReference = 223, 
		RULE_edgeTypeSpecification = 224, RULE_arcTypePointingRight = 225, RULE_identifyingRelationship = 226, 
		RULE_edgeTypeReference = 227, RULE_edgeTypeAliasReference = 228, RULE_edgeTypeInSituReference = 229, 
		RULE_propertyTypeList = 230, RULE_propertyType = 231, RULE_propertyTypeInlineConstraint = 232, 
		RULE_typed = 233, RULE_constraintSpecification = 234, RULE_renameCommand = 235, 
		RULE_grantCommand = 236, RULE_denyCommand = 237, RULE_revokeCommand = 238, 
		RULE_userNames = 239, RULE_roleNames = 240, RULE_roleToken = 241, RULE_enableServerCommand = 242, 
		RULE_alterServer = 243, RULE_renameServer = 244, RULE_dropServer = 245, 
		RULE_showServers = 246, RULE_allocationCommand = 247, RULE_deallocateDatabaseFromServers = 248, 
		RULE_reallocateDatabases = 249, RULE_createRole = 250, RULE_dropRole = 251, 
		RULE_renameRole = 252, RULE_showRoles = 253, RULE_grantRole = 254, RULE_revokeRole = 255, 
		RULE_createUser = 256, RULE_dropUser = 257, RULE_renameUser = 258, RULE_alterCurrentUser = 259, 
		RULE_alterUser = 260, RULE_removeNamedProvider = 261, RULE_password = 262, 
		RULE_passwordOnly = 263, RULE_passwordExpression = 264, RULE_passwordChangeRequired = 265, 
		RULE_userStatus = 266, RULE_homeDatabase = 267, RULE_setAuthClause = 268, 
		RULE_userAuthAttribute = 269, RULE_showUsers = 270, RULE_showCurrentUser = 271, 
		RULE_showSupportedPrivileges = 272, RULE_showPrivileges = 273, RULE_showRolePrivileges = 274, 
		RULE_showUserPrivileges = 275, RULE_privilegeAsCommand = 276, RULE_privilegeToken = 277, 
		RULE_privilege = 278, RULE_allPrivilege = 279, RULE_allPrivilegeType = 280, 
		RULE_allPrivilegeTarget = 281, RULE_createPrivilege = 282, RULE_createPrivilegeForDatabase = 283, 
		RULE_createNodePrivilegeToken = 284, RULE_createRelPrivilegeToken = 285, 
		RULE_createPropertyPrivilegeToken = 286, RULE_actionForDBMS = 287, RULE_dropPrivilege = 288, 
		RULE_loadPrivilege = 289, RULE_showPrivilege = 290, RULE_setPrivilege = 291, 
		RULE_passwordToken = 292, RULE_removePrivilege = 293, RULE_writePrivilege = 294, 
		RULE_databasePrivilege = 295, RULE_dbmsPrivilege = 296, RULE_dbmsPrivilegeExecute = 297, 
		RULE_adminToken = 298, RULE_procedureToken = 299, RULE_indexToken = 300, 
		RULE_constraintToken = 301, RULE_transactionToken = 302, RULE_userQualifier = 303, 
		RULE_executeFunctionQualifier = 304, RULE_executeProcedureQualifier = 305, 
		RULE_settingQualifier = 306, RULE_globs = 307, RULE_glob = 308, RULE_globRecursive = 309, 
		RULE_globPart = 310, RULE_qualifiedGraphPrivileges = 311, RULE_labelsResource = 312, 
		RULE_propertiesResource = 313, RULE_nonEmptyStringList = 314, RULE_graphQualifier = 315, 
		RULE_graphQualifierToken = 316, RULE_relToken = 317, RULE_elementToken = 318, 
		RULE_nodeToken = 319, RULE_databaseScope = 320, RULE_graphScope = 321, 
		RULE_createCompositeDatabase = 322, RULE_createDatabase = 323, RULE_shards = 324, 
		RULE_graphShard = 325, RULE_propertyShard = 326, RULE_topology = 327, 
		RULE_primaryTopology = 328, RULE_primaryToken = 329, RULE_secondaryTopology = 330, 
		RULE_secondaryToken = 331, RULE_replicaToken = 332, RULE_defaultLanguageSpecification = 333, 
		RULE_dropDatabase = 334, RULE_aliasAction = 335, RULE_alterDatabase = 336, 
		RULE_alterDatabaseAccess = 337, RULE_alterDatabaseTopology = 338, RULE_alterDatabaseOption = 339, 
		RULE_alterGraphShard = 340, RULE_alterPropertyShards = 341, RULE_alterReplicaTopology = 342, 
		RULE_startDatabase = 343, RULE_stopDatabase = 344, RULE_waitClause = 345, 
		RULE_secondsToken = 346, RULE_showDatabase = 347, RULE_aliasName = 348, 
		RULE_aliasTargetName = 349, RULE_createAlias = 350, RULE_remoteTargetConnectionCredentials = 351, 
		RULE_dropAlias = 352, RULE_alterAlias = 353, RULE_alterAliasTarget = 354, 
		RULE_alterAliasUser = 355, RULE_alterAliasPassword = 356, RULE_alterAliasDriver = 357, 
		RULE_alterAliasProperties = 358, RULE_showAliases = 359, RULE_symbolicNameOrStringParameter = 360, 
		RULE_commandNameExpression = 361, RULE_symbolicNameOrStringParameterList = 362, 
		RULE_symbolicAliasNameList = 363, RULE_symbolicAliasNameOrParameter = 364, 
		RULE_symbolicAliasName = 365, RULE_stringListLiteral = 366, RULE_stringList = 367, 
		RULE_stringLiteral = 368, RULE_stringOrParameterExpression = 369, RULE_stringOrParameter = 370, 
		RULE_uIntOrIntParameter = 371, RULE_mapOrParameter = 372, RULE_map = 373, 
		RULE_symbolicVariableNameString = 374, RULE_escapedSymbolicVariableNameString = 375, 
		RULE_unescapedSymbolicVariableNameString = 376, RULE_symbolicNameString = 377, 
		RULE_escapedSymbolicNameString = 378, RULE_unescapedSymbolicNameString = 379, 
		RULE_unescapedSymbolicNameString_ = 380, RULE_endOfFile = 381;
	public static readonly string[] ruleNames = {
		"statements", "statement", "nextStatement", "regularQuery", "union", "when", 
		"whenBranch", "elseBranch", "singleQuery", "clause", "useClause", "graphReference", 
		"finishClause", "returnClause", "returnBody", "returnItem", "returnItems", 
		"orderItem", "ascToken", "descToken", "orderBy", "skip", "limit", "whereClause", 
		"withClause", "createClause", "insertClause", "setClause", "setItem", 
		"removeClause", "removeItem", "deleteClause", "matchClause", "matchMode", 
		"hint", "mergeClause", "mergeAction", "filterClause", "unwindClause", 
		"letClause", "letItem", "callClause", "procedureName", "procedureArgument", 
		"procedureResultItem", "loadCSVClause", "foreachClause", "subqueryClause", 
		"subqueryScope", "subqueryInTransactionsParameters", "subqueryInTransactionsBatchParameters", 
		"subqueryInTransactionsErrorParameters", "subqueryInTransactionsRetryParameters", 
		"subqueryInTransactionsReportParameters", "orderBySkipLimitClause", "patternList", 
		"insertPatternList", "pattern", "insertPattern", "quantifier", "anonymousPattern", 
		"shortestPathPattern", "patternElement", "selector", "nonNegativeIntegerSpecification", 
		"groupToken", "pathToken", "pathPatternNonEmpty", "nodePattern", "insertNodePattern", 
		"parenthesizedPath", "nodeLabels", "nodeLabelsIs", "dynamicExpression", 
		"dynamicAnyAllExpression", "dynamicLabelType", "labelType", "relType", 
		"labelOrRelType", "properties", "relationshipPattern", "insertRelationshipPattern", 
		"leftArrow", "arrowLine", "rightArrow", "pathLength", "labelExpression", 
		"labelExpression4", "labelExpression3", "labelExpression2", "labelExpression1", 
		"insertNodeLabelExpression", "insertRelationshipLabelExpression", "expression", 
		"expression11", "expression10", "expression9", "expression8", "expression7", 
		"comparisonExpression6", "normalForm", "expression6", "expression5", "expression4", 
		"expression3", "expression2", "postFix", "property", "dynamicProperty", 
		"propertyExpression", "dynamicPropertyExpression", "expression1", "literal", 
		"caseExpression", "caseAlternative", "extendedCaseExpression", "extendedCaseAlternative", 
		"extendedWhen", "listComprehension", "patternComprehension", "reduceExpression", 
		"allReduceExpression", "allReduceExpressionValidArguments", "allReduceExpressionInvalidArguments", 
		"listItemsPredicate", "normalizeFunction", "vectorFunction", "vectorDistanceFunction", 
		"vectorNormFunction", "vectorDistanceMetric", "vectorNormDistanceMetric", 
		"trimFunction", "patternExpression", "shortestPathExpression", "parenthesizedExpression", 
		"mapProjection", "mapProjectionElement", "countStar", "existsExpression", 
		"countExpression", "collectExpression", "numberLiteral", "signedIntegerLiteral", 
		"listLiteral", "propertyKeyName", "parameter", "parameterName", "functionInvocation", 
		"functionArgument", "functionName", "namespace", "variable", "nonEmptyNameList", 
		"type", "typePart", "typeName", "typeNullability", "typeListSuffix", "vectorCoordinateType", 
		"command", "createCommand", "alterCommand", "dropCommand", "showCommand", 
		"showCommandYield", "yieldItem", "yieldSkip", "yieldLimit", "yieldClause", 
		"commandOptions", "terminateCommand", "composableCommandClauses", "composableShowCommandClauses", 
		"showIndexCommand", "showIndexType", "showIndexesEnd", "showConstraintCommand", 
		"showConstraintEntity", "constraintExistType", "showConstraintsEnd", "showCurrentGraphTypeCommand", 
		"showProcedures", "showFunctions", "functionToken", "executableBy", "showFunctionsType", 
		"showTransactions", "terminateTransactions", "showSettings", "settingToken", 
		"namesAndClauses", "stringsOrExpression", "commandNodePattern", "commandRelPattern", 
		"createConstraint", "constraintType", "dropConstraint", "createIndex", 
		"createIndex_", "createFulltextIndex", "fulltextNodePattern", "fulltextRelPattern", 
		"createLookupIndex", "lookupIndexNodePattern", "lookupIndexRelPattern", 
		"dropIndex", "propertyList", "enclosedPropertyList", "alterCurrentGraphType", 
		"graphTypeSpecification", "graphTypeDropSpecification", "graphTypeSpecificationBody", 
		"graphTypeDropSpecificationBody", "graphTypeElement", "graphTypeDropElement", 
		"nodeTypeInlineConstraintList", "edgeTypeInlineConstraintList", "implies", 
		"nodeTypeSpecification", "impliedLabelSet", "identifyingLabel", "nodeTypeReference", 
		"nodeTypeAliasReference", "nodeTypeInSituReference", "edgeTypeSpecification", 
		"arcTypePointingRight", "identifyingRelationship", "edgeTypeReference", 
		"edgeTypeAliasReference", "edgeTypeInSituReference", "propertyTypeList", 
		"propertyType", "propertyTypeInlineConstraint", "typed", "constraintSpecification", 
		"renameCommand", "grantCommand", "denyCommand", "revokeCommand", "userNames", 
		"roleNames", "roleToken", "enableServerCommand", "alterServer", "renameServer", 
		"dropServer", "showServers", "allocationCommand", "deallocateDatabaseFromServers", 
		"reallocateDatabases", "createRole", "dropRole", "renameRole", "showRoles", 
		"grantRole", "revokeRole", "createUser", "dropUser", "renameUser", "alterCurrentUser", 
		"alterUser", "removeNamedProvider", "password", "passwordOnly", "passwordExpression", 
		"passwordChangeRequired", "userStatus", "homeDatabase", "setAuthClause", 
		"userAuthAttribute", "showUsers", "showCurrentUser", "showSupportedPrivileges", 
		"showPrivileges", "showRolePrivileges", "showUserPrivileges", "privilegeAsCommand", 
		"privilegeToken", "privilege", "allPrivilege", "allPrivilegeType", "allPrivilegeTarget", 
		"createPrivilege", "createPrivilegeForDatabase", "createNodePrivilegeToken", 
		"createRelPrivilegeToken", "createPropertyPrivilegeToken", "actionForDBMS", 
		"dropPrivilege", "loadPrivilege", "showPrivilege", "setPrivilege", "passwordToken", 
		"removePrivilege", "writePrivilege", "databasePrivilege", "dbmsPrivilege", 
		"dbmsPrivilegeExecute", "adminToken", "procedureToken", "indexToken", 
		"constraintToken", "transactionToken", "userQualifier", "executeFunctionQualifier", 
		"executeProcedureQualifier", "settingQualifier", "globs", "glob", "globRecursive", 
		"globPart", "qualifiedGraphPrivileges", "labelsResource", "propertiesResource", 
		"nonEmptyStringList", "graphQualifier", "graphQualifierToken", "relToken", 
		"elementToken", "nodeToken", "databaseScope", "graphScope", "createCompositeDatabase", 
		"createDatabase", "shards", "graphShard", "propertyShard", "topology", 
		"primaryTopology", "primaryToken", "secondaryTopology", "secondaryToken", 
		"replicaToken", "defaultLanguageSpecification", "dropDatabase", "aliasAction", 
		"alterDatabase", "alterDatabaseAccess", "alterDatabaseTopology", "alterDatabaseOption", 
		"alterGraphShard", "alterPropertyShards", "alterReplicaTopology", "startDatabase", 
		"stopDatabase", "waitClause", "secondsToken", "showDatabase", "aliasName", 
		"aliasTargetName", "createAlias", "remoteTargetConnectionCredentials", 
		"dropAlias", "alterAlias", "alterAliasTarget", "alterAliasUser", "alterAliasPassword", 
		"alterAliasDriver", "alterAliasProperties", "showAliases", "symbolicNameOrStringParameter", 
		"commandNameExpression", "symbolicNameOrStringParameterList", "symbolicAliasNameList", 
		"symbolicAliasNameOrParameter", "symbolicAliasName", "stringListLiteral", 
		"stringList", "stringLiteral", "stringOrParameterExpression", "stringOrParameter", 
		"uIntOrIntParameter", "mapOrParameter", "map", "symbolicVariableNameString", 
		"escapedSymbolicVariableNameString", "unescapedSymbolicVariableNameString", 
		"symbolicNameString", "escapedSymbolicNameString", "unescapedSymbolicNameString", 
		"unescapedSymbolicNameString_", "endOfFile"
	};

	private static readonly string[] _LiteralNames = {
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, "'|'", null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, "':'", "'::'", 
		"','", null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, "'$'", null, "'/'", 
		"'.'", null, "'..'", "'||'", null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, "'='", null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, "'>='", null, null, null, null, 
		null, "'>'", null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, "'&'", "'!'", null, "'['", "'{'", 
		"'<='", null, null, null, null, null, null, null, "'('", "'<'", null, 
		null, null, null, null, "'-'", "'%'", null, "'!='", "'<>'", null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, "'+'", "'+='", null, null, 
		"'^'", null, null, null, null, null, null, null, null, null, null, "'?'", 
		null, "']'", "'}'", null, null, null, null, "'=~'", null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, "')'", null, null, null, null, null, null, null, 
		"';'", null, null, null, null, null, null, null, null, null, null, null, 
		null, null, null, null, null, null, null, null, null, null, null, null, 
		null, null, "'*'"
	};
	private static readonly string[] _SymbolicNames = {
		null, "SPACE", "SINGLE_LINE_COMMENT", "MULTI_LINE_COMMENT", "DECIMAL_DOUBLE", 
		"UNSIGNED_DECIMAL_INTEGER", "UNSIGNED_HEX_INTEGER", "UNSIGNED_OCTAL_INTEGER", 
		"STRING_LITERAL1", "STRING_LITERAL2", "ESCAPED_SYMBOLIC_NAME", "ACCESS", 
		"ACTIVE", "ADD", "ADMIN", "ADMINISTRATOR", "ALIAS", "ALIASES", "ALL_SHORTEST_PATHS", 
		"ALL", "ALLREDUCE", "ALTER", "AND", "ANY", "ARRAY", "AS", "ASC", "ASCENDING", 
		"ASSIGN", "AT", "AUTH", "BAR", "BINDINGS", "BOOL", "BOOLEAN", "BOOSTED", 
		"BOTH", "BREAK", "BUILT", "BY", "CALL", "CASCADE", "CASE", "CHANGE", "CIDR", 
		"COLLECT", "COLON", "COLONCOLON", "COMMA", "COMMAND", "COMMANDS", "COMPOSITE", 
		"CONCURRENT", "CONSTRAINT", "CONSTRAINTS", "CONTAINS", "COPY", "CONTINUE", 
		"COSINE", "COUNT", "CREATE", "CREDENTIAL", "CSV", "CURRENT", "CYPHER", 
		"DATA", "DATABASE", "DATABASES", "DATE", "DATETIME", "DBMS", "DEALLOCATE", 
		"DEFAULT", "DEFINED", "DELETE", "DENY", "DESC", "DESCENDING", "DESTROY", 
		"DETACH", "DIFFERENT", "DOLLAR", "DISTINCT", "DIVIDE", "DOT", "DOT_METRIC", 
		"DOTDOT", "DOUBLEBAR", "DRIVER", "DROP", "DRYRUN", "DUMP", "DURATION", 
		"EACH", "EDGE", "ENABLE", "ELEMENT", "ELEMENTS", "ELSE", "ENCRYPTED", 
		"EUCLIDEAN", "EUCLIDEAN_SQUARED", "END", "ENDS", "EQ", "EXECUTABLE", "EXECUTE", 
		"EXIST", "EXISTENCE", "EXISTS", "ERROR", "FAIL", "FALSE", "FIELDTERMINATOR", 
		"FILTER", "FINISH", "FLOAT", "FLOAT64", "FLOAT32", "FOR", "FOREACH", "FORWARDING", 
		"FROM", "FULLTEXT", "FUNCTION", "FUNCTIONS", "GE", "GRANT", "GRAPH", "GRAPHS", 
		"GROUP", "GROUPS", "GT", "HAMMING", "HEADERS", "HOME", "ID", "IF", "IMPERSONATE", 
		"IMMUTABLE", "IN", "INDEX", "INDEXES", "INF", "INFINITY", "INSERT", "INT", 
		"INT64", "INT32", "INT16", "INT8", "INTEGER", "INTEGER64", "INTEGER32", 
		"INTEGER16", "INTEGER8", "IS", "JOIN", "KEY", "LABEL", "LABELS", "AMPERSAND", 
		"EXCLAMATION_MARK", "LANGUAGE", "LBRACKET", "LCURLY", "LE", "LEADING", 
		"LET", "LIMITROWS", "LIST", "LOAD", "LOCAL", "LOOKUP", "LPAREN", "LT", 
		"MANAGEMENT", "MANHATTAN", "MAP", "MATCH", "MERGE", "MINUS", "PERCENT", 
		"IMPLIES", "INVALID_NEQ", "NEQ", "NAME", "NAMES", "NAN", "NFC", "NFD", 
		"NFKC", "NFKD", "NEW", "NEXT", "NODE", "NODETACH", "NODES", "NONE", "NORMALIZE", 
		"NORMALIZED", "NOT", "NOTHING", "NOWAIT", "NULL", "OF", "OFFSET", "OIDC", 
		"ON", "ONLY", "OPTIONAL", "OPTIONS", "OPTION", "OR", "ORDER", "PASSWORD", 
		"PASSWORDS", "PATH", "PATHS", "PLAINTEXT", "PLUS", "PLUSEQUAL", "POINT", 
		"POPULATED", "POW", "PRIMARY", "PRIMARIES", "PRIVILEGE", "PRIVILEGES", 
		"PROCEDURE", "PROCEDURES", "PROPERTIES", "PROPERTY", "PROVIDER", "PROVIDERS", 
		"QUESTION", "RANGE", "RBRACKET", "RCURLY", "READ", "REALLOCATE", "REDUCE", 
		"RENAME", "REGEQ", "REL", "RELATIONSHIP", "RELATIONSHIPS", "REMOVE", "REPEATABLE", 
		"REPLACE", "REPLICA", "REPLICAS", "REPORT", "REQUIRE", "REQUIRED", "RESTRICT", 
		"RETRY", "RETURN", "REVOKE", "ROLE", "ROLES", "ROW", "ROWS", "RPAREN", 
		"SCAN", "SEC", "SECOND", "SECONDARY", "SECONDARIES", "SECONDS", "SEEK", 
		"SEMICOLON", "SERVER", "SERVERS", "SET", "SETTING", "SETTINGS", "SHARD", 
		"SHARDS", "SHORTEST_PATH", "SHORTEST", "SHOW", "SIGNED", "SINGLE", "SKIPROWS", 
		"START", "STARTS", "STATUS", "STOP", "STRING", "SUPPORTED", "SUSPENDED", 
		"TARGET", "TERMINATE", "TEXT", "THEN", "TIME", "TIMES", "TIMESTAMP", "TIMEZONE", 
		"TO", "TOPOLOGY", "TRAILING", "TRANSACTION", "TRANSACTIONS", "TRAVERSE", 
		"TRIM", "TRUE", "TYPE", "TYPED", "TYPES", "UNION", "UNIQUE", "UNIQUENESS", 
		"UNWIND", "URL", "USE", "USER", "USERS", "USING", "VALUE", "VARCHAR", 
		"VECTOR", "VECTOR_DISTANCE", "VECTOR_NORM", "VERTEX", "WAIT", "WHEN", 
		"WHERE", "WITH", "WITHOUT", "WRITE", "XOR", "YIELD", "ZONE", "ZONED", 
		"IDENTIFIER", "EXTENDED_IDENTIFIER", "ARROW_LINE", "ARROW_LEFT_HEAD", 
		"ARROW_RIGHT_HEAD", "ErrorChar"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "CypherParser.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return new string(_serializedATN); } }

	static CypherParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public CypherParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public CypherParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class StatementsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(CypherParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] SEMICOLON() { return GetTokens(CypherParser.SEMICOLON); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEMICOLON(int i) {
			return GetToken(CypherParser.SEMICOLON, i);
		}
		public StatementsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statements; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatements(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementsContext statements() {
		StatementsContext _localctx = new StatementsContext(Context, State);
		EnterRule(_localctx, 0, RULE_statements);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 764;
			statement();
			State = 769;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,0,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 765;
					Match(SEMICOLON);
					State = 766;
					statement();
					}
					} 
				}
				State = 771;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,0,Context);
			}
			State = 773;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SEMICOLON) {
				{
				State = 772;
				Match(SEMICOLON);
				}
			}

			State = 775;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public CommandContext command() {
			return GetRuleContext<CommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NextStatementContext nextStatement() {
			return GetRuleContext<NextStatementContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 2, RULE_statement);
		try {
			State = 779;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,2,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 777;
				command();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 778;
				nextStatement();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NextStatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RegularQueryContext[] regularQuery() {
			return GetRuleContexts<RegularQueryContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public RegularQueryContext regularQuery(int i) {
			return GetRuleContext<RegularQueryContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] NEXT() { return GetTokens(CypherParser.NEXT); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEXT(int i) {
			return GetToken(CypherParser.NEXT, i);
		}
		public NextStatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nextStatement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNextStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NextStatementContext nextStatement() {
		NextStatementContext _localctx = new NextStatementContext(Context, State);
		EnterRule(_localctx, 4, RULE_nextStatement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 781;
			regularQuery();
			State = 786;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==NEXT) {
				{
				{
				State = 782;
				Match(NEXT);
				State = 783;
				regularQuery();
				}
				}
				State = 788;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RegularQueryContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public UnionContext union() {
			return GetRuleContext<UnionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhenContext when() {
			return GetRuleContext<WhenContext>(0);
		}
		public RegularQueryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_regularQuery; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRegularQuery(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RegularQueryContext regularQuery() {
		RegularQueryContext _localctx = new RegularQueryContext(Context, State);
		EnterRule(_localctx, 6, RULE_regularQuery);
		try {
			State = 791;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CALL:
			case CREATE:
			case DELETE:
			case DETACH:
			case FILTER:
			case FINISH:
			case FOREACH:
			case INSERT:
			case LCURLY:
			case LET:
			case LIMITROWS:
			case LOAD:
			case MATCH:
			case MERGE:
			case NODETACH:
			case OFFSET:
			case OPTIONAL:
			case ORDER:
			case REMOVE:
			case RETURN:
			case SET:
			case SKIPROWS:
			case UNWIND:
			case USE:
			case WITH:
				EnterOuterAlt(_localctx, 1);
				{
				State = 789;
				union();
				}
				break;
			case WHEN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 790;
				when();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SingleQueryContext[] singleQuery() {
			return GetRuleContexts<SingleQueryContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SingleQueryContext singleQuery(int i) {
			return GetRuleContext<SingleQueryContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] UNION() { return GetTokens(CypherParser.UNION); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNION(int i) {
			return GetToken(CypherParser.UNION, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] ALL() { return GetTokens(CypherParser.ALL); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL(int i) {
			return GetToken(CypherParser.ALL, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] DISTINCT() { return GetTokens(CypherParser.DISTINCT); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISTINCT(int i) {
			return GetToken(CypherParser.DISTINCT, i);
		}
		public UnionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_union; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnion(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnionContext union() {
		UnionContext _localctx = new UnionContext(Context, State);
		EnterRule(_localctx, 8, RULE_union);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 793;
			singleQuery();
			State = 801;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==UNION) {
				{
				{
				State = 794;
				Match(UNION);
				State = 796;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ALL || _la==DISTINCT) {
					{
					State = 795;
					_la = TokenStream.LA(1);
					if ( !(_la==ALL || _la==DISTINCT) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 798;
				singleQuery();
				}
				}
				State = 803;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public WhenBranchContext[] whenBranch() {
			return GetRuleContexts<WhenBranchContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhenBranchContext whenBranch(int i) {
			return GetRuleContext<WhenBranchContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElseBranchContext elseBranch() {
			return GetRuleContext<ElseBranchContext>(0);
		}
		public WhenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_when; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhen(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhenContext when() {
		WhenContext _localctx = new WhenContext(Context, State);
		EnterRule(_localctx, 10, RULE_when);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 805;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 804;
				whenBranch();
				}
				}
				State = 807;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			State = 810;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 809;
				elseBranch();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhenBranchContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(CypherParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(CypherParser.THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SingleQueryContext singleQuery() {
			return GetRuleContext<SingleQueryContext>(0);
		}
		public WhenBranchContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whenBranch; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhenBranch(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhenBranchContext whenBranch() {
		WhenBranchContext _localctx = new WhenBranchContext(Context, State);
		EnterRule(_localctx, 12, RULE_whenBranch);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 812;
			Match(WHEN);
			State = 813;
			expression();
			State = 814;
			Match(THEN);
			State = 815;
			singleQuery();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElseBranchContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(CypherParser.ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SingleQueryContext singleQuery() {
			return GetRuleContext<SingleQueryContext>(0);
		}
		public ElseBranchContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elseBranch; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElseBranch(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElseBranchContext elseBranch() {
		ElseBranchContext _localctx = new ElseBranchContext(Context, State);
		EnterRule(_localctx, 14, RULE_elseBranch);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 817;
			Match(ELSE);
			State = 818;
			singleQuery();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SingleQueryContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ClauseContext[] clause() {
			return GetRuleContexts<ClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ClauseContext clause(int i) {
			return GetRuleContext<ClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CypherParser.LCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NextStatementContext nextStatement() {
			return GetRuleContext<NextStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CypherParser.RCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UseClauseContext useClause() {
			return GetRuleContext<UseClauseContext>(0);
		}
		public SingleQueryContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_singleQuery; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSingleQuery(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SingleQueryContext singleQuery() {
		SingleQueryContext _localctx = new SingleQueryContext(Context, State);
		EnterRule(_localctx, 16, RULE_singleQuery);
		int _la;
		try {
			State = 832;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,11,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 821;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 820;
					clause();
					}
					}
					State = 823;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==CALL || _la==CREATE || ((((_la - 74)) & ~0x3f) == 0 && ((1L << (_la - 74)) & ((1L << (DELETE - 74)) | (1L << (DETACH - 74)) | (1L << (FILTER - 74)) | (1L << (FINISH - 74)) | (1L << (FOREACH - 74)))) != 0) || ((((_la - 145)) & ~0x3f) == 0 && ((1L << (_la - 145)) & ((1L << (INSERT - 145)) | (1L << (LET - 145)) | (1L << (LIMITROWS - 145)) | (1L << (LOAD - 145)) | (1L << (MATCH - 145)) | (1L << (MERGE - 145)) | (1L << (NODETACH - 145)) | (1L << (OFFSET - 145)))) != 0) || ((((_la - 210)) & ~0x3f) == 0 && ((1L << (_la - 210)) & ((1L << (OPTIONAL - 210)) | (1L << (ORDER - 210)) | (1L << (REMOVE - 210)) | (1L << (RETURN - 210)))) != 0) || ((((_la - 274)) & ~0x3f) == 0 && ((1L << (_la - 274)) & ((1L << (SET - 274)) | (1L << (SKIPROWS - 274)) | (1L << (UNWIND - 274)) | (1L << (USE - 274)) | (1L << (WITH - 274)))) != 0) );
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 826;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==USE) {
					{
					State = 825;
					useClause();
					}
				}

				State = 828;
				Match(LCURLY);
				State = 829;
				nextStatement();
				State = 830;
				Match(RCURLY);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public UseClauseContext useClause() {
			return GetRuleContext<UseClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FinishClauseContext finishClause() {
			return GetRuleContext<FinishClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReturnClauseContext returnClause() {
			return GetRuleContext<ReturnClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateClauseContext createClause() {
			return GetRuleContext<CreateClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InsertClauseContext insertClause() {
			return GetRuleContext<InsertClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeleteClauseContext deleteClause() {
			return GetRuleContext<DeleteClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SetClauseContext setClause() {
			return GetRuleContext<SetClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RemoveClauseContext removeClause() {
			return GetRuleContext<RemoveClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MatchClauseContext matchClause() {
			return GetRuleContext<MatchClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MergeClauseContext mergeClause() {
			return GetRuleContext<MergeClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WithClauseContext withClause() {
			return GetRuleContext<WithClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FilterClauseContext filterClause() {
			return GetRuleContext<FilterClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnwindClauseContext unwindClause() {
			return GetRuleContext<UnwindClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LetClauseContext letClause() {
			return GetRuleContext<LetClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CallClauseContext callClause() {
			return GetRuleContext<CallClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryClauseContext subqueryClause() {
			return GetRuleContext<SubqueryClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoadCSVClauseContext loadCSVClause() {
			return GetRuleContext<LoadCSVClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ForeachClauseContext foreachClause() {
			return GetRuleContext<ForeachClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OrderBySkipLimitClauseContext orderBySkipLimitClause() {
			return GetRuleContext<OrderBySkipLimitClauseContext>(0);
		}
		public ClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_clause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ClauseContext clause() {
		ClauseContext _localctx = new ClauseContext(Context, State);
		EnterRule(_localctx, 18, RULE_clause);
		try {
			State = 853;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,12,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 834;
				useClause();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 835;
				finishClause();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 836;
				returnClause();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 837;
				createClause();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 838;
				insertClause();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 839;
				deleteClause();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 840;
				setClause();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 841;
				removeClause();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 842;
				matchClause();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 843;
				mergeClause();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 844;
				withClause();
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 845;
				filterClause();
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 846;
				unwindClause();
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 847;
				letClause();
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 848;
				callClause();
				}
				break;
			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 849;
				subqueryClause();
				}
				break;
			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 850;
				loadCSVClause();
				}
				break;
			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 851;
				foreachClause();
				}
				break;
			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 852;
				orderBySkipLimitClause();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UseClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USE() { return GetToken(CypherParser.USE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GraphReferenceContext graphReference() {
			return GetRuleContext<GraphReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GRAPH() { return GetToken(CypherParser.GRAPH, 0); }
		public UseClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_useClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUseClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UseClauseContext useClause() {
		UseClauseContext _localctx = new UseClauseContext(Context, State);
		EnterRule(_localctx, 20, RULE_useClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 855;
			Match(USE);
			State = 857;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,13,Context) ) {
			case 1:
				{
				State = 856;
				Match(GRAPH);
				}
				break;
			}
			State = 859;
			graphReference();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GraphReferenceContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GraphReferenceContext graphReference() {
			return GetRuleContext<GraphReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionInvocationContext functionInvocation() {
			return GetRuleContext<FunctionInvocationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicAliasNameContext symbolicAliasName() {
			return GetRuleContext<SymbolicAliasNameContext>(0);
		}
		public GraphReferenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_graphReference; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGraphReference(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GraphReferenceContext graphReference() {
		GraphReferenceContext _localctx = new GraphReferenceContext(Context, State);
		EnterRule(_localctx, 22, RULE_graphReference);
		try {
			State = 867;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,14,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 861;
				Match(LPAREN);
				State = 862;
				graphReference();
				State = 863;
				Match(RPAREN);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 865;
				functionInvocation();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 866;
				symbolicAliasName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FinishClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FINISH() { return GetToken(CypherParser.FINISH, 0); }
		public FinishClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_finishClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFinishClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FinishClauseContext finishClause() {
		FinishClauseContext _localctx = new FinishClauseContext(Context, State);
		EnterRule(_localctx, 24, RULE_finishClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 869;
			Match(FINISH);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReturnClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(CypherParser.RETURN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ReturnBodyContext returnBody() {
			return GetRuleContext<ReturnBodyContext>(0);
		}
		public ReturnClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_returnClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturnClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReturnClauseContext returnClause() {
		ReturnClauseContext _localctx = new ReturnClauseContext(Context, State);
		EnterRule(_localctx, 26, RULE_returnClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 871;
			Match(RETURN);
			State = 872;
			returnBody();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReturnBodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ReturnItemsContext returnItems() {
			return GetRuleContext<ReturnItemsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OrderByContext orderBy() {
			return GetRuleContext<OrderByContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SkipContext skip() {
			return GetRuleContext<SkipContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LimitContext limit() {
			return GetRuleContext<LimitContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISTINCT() { return GetToken(CypherParser.DISTINCT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(CypherParser.ALL, 0); }
		public ReturnBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_returnBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturnBody(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReturnBodyContext returnBody() {
		ReturnBodyContext _localctx = new ReturnBodyContext(Context, State);
		EnterRule(_localctx, 28, RULE_returnBody);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 875;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,15,Context) ) {
			case 1:
				{
				State = 874;
				_la = TokenStream.LA(1);
				if ( !(_la==ALL || _la==DISTINCT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			State = 877;
			returnItems();
			State = 879;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,16,Context) ) {
			case 1:
				{
				State = 878;
				orderBy();
				}
				break;
			}
			State = 882;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,17,Context) ) {
			case 1:
				{
				State = 881;
				skip();
				}
				break;
			}
			State = 885;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,18,Context) ) {
			case 1:
				{
				State = 884;
				limit();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReturnItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(CypherParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		public ReturnItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_returnItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturnItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReturnItemContext returnItem() {
		ReturnItemContext _localctx = new ReturnItemContext(Context, State);
		EnterRule(_localctx, 30, RULE_returnItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 887;
			expression();
			State = 890;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 888;
				Match(AS);
				State = 889;
				variable();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReturnItemsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMES() { return GetToken(CypherParser.TIMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ReturnItemContext[] returnItem() {
			return GetRuleContexts<ReturnItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReturnItemContext returnItem(int i) {
			return GetRuleContext<ReturnItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public ReturnItemsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_returnItems; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReturnItems(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReturnItemsContext returnItems() {
		ReturnItemsContext _localctx = new ReturnItemsContext(Context, State);
		EnterRule(_localctx, 32, RULE_returnItems);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 894;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TIMES:
				{
				State = 892;
				Match(TIMES);
				}
				break;
			case DECIMAL_DOUBLE:
			case UNSIGNED_DECIMAL_INTEGER:
			case UNSIGNED_HEX_INTEGER:
			case UNSIGNED_OCTAL_INTEGER:
			case STRING_LITERAL1:
			case STRING_LITERAL2:
			case ESCAPED_SYMBOLIC_NAME:
			case ACCESS:
			case ACTIVE:
			case ADD:
			case ADMIN:
			case ADMINISTRATOR:
			case ALIAS:
			case ALIASES:
			case ALL_SHORTEST_PATHS:
			case ALL:
			case ALLREDUCE:
			case ALTER:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASCENDING:
			case ASSIGN:
			case AT:
			case AUTH:
			case BINDINGS:
			case BOOL:
			case BOOLEAN:
			case BOOSTED:
			case BOTH:
			case BREAK:
			case BUILT:
			case BY:
			case CALL:
			case CASCADE:
			case CASE:
			case CHANGE:
			case CIDR:
			case COLLECT:
			case COMMAND:
			case COMMANDS:
			case COMPOSITE:
			case CONCURRENT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONTAINS:
			case COPY:
			case CONTINUE:
			case COSINE:
			case COUNT:
			case CREATE:
			case CREDENTIAL:
			case CSV:
			case CURRENT:
			case CYPHER:
			case DATA:
			case DATABASE:
			case DATABASES:
			case DATE:
			case DATETIME:
			case DBMS:
			case DEALLOCATE:
			case DEFAULT:
			case DEFINED:
			case DELETE:
			case DENY:
			case DESC:
			case DESCENDING:
			case DESTROY:
			case DETACH:
			case DIFFERENT:
			case DOLLAR:
			case DISTINCT:
			case DOT_METRIC:
			case DRIVER:
			case DROP:
			case DRYRUN:
			case DUMP:
			case DURATION:
			case EACH:
			case EDGE:
			case ENABLE:
			case ELEMENT:
			case ELEMENTS:
			case ELSE:
			case ENCRYPTED:
			case EUCLIDEAN:
			case EUCLIDEAN_SQUARED:
			case END:
			case ENDS:
			case EXECUTABLE:
			case EXECUTE:
			case EXIST:
			case EXISTENCE:
			case EXISTS:
			case ERROR:
			case FAIL:
			case FALSE:
			case FIELDTERMINATOR:
			case FILTER:
			case FINISH:
			case FLOAT:
			case FLOAT64:
			case FLOAT32:
			case FOR:
			case FOREACH:
			case FORWARDING:
			case FROM:
			case FULLTEXT:
			case FUNCTION:
			case FUNCTIONS:
			case GRANT:
			case GRAPH:
			case GRAPHS:
			case GROUP:
			case GROUPS:
			case HAMMING:
			case HEADERS:
			case HOME:
			case ID:
			case IF:
			case IMPERSONATE:
			case IMMUTABLE:
			case IN:
			case INDEX:
			case INDEXES:
			case INF:
			case INFINITY:
			case INSERT:
			case INT:
			case INT64:
			case INT32:
			case INT16:
			case INT8:
			case INTEGER:
			case INTEGER64:
			case INTEGER32:
			case INTEGER16:
			case INTEGER8:
			case IS:
			case JOIN:
			case KEY:
			case LABEL:
			case LABELS:
			case LANGUAGE:
			case LBRACKET:
			case LCURLY:
			case LEADING:
			case LET:
			case LIMITROWS:
			case LIST:
			case LOAD:
			case LOCAL:
			case LOOKUP:
			case LPAREN:
			case MANAGEMENT:
			case MANHATTAN:
			case MAP:
			case MATCH:
			case MERGE:
			case MINUS:
			case IMPLIES:
			case NAME:
			case NAMES:
			case NAN:
			case NFC:
			case NFD:
			case NFKC:
			case NFKD:
			case NEW:
			case NEXT:
			case NODE:
			case NODETACH:
			case NODES:
			case NONE:
			case NORMALIZE:
			case NORMALIZED:
			case NOT:
			case NOTHING:
			case NOWAIT:
			case NULL:
			case OF:
			case OFFSET:
			case OIDC:
			case ON:
			case ONLY:
			case OPTIONAL:
			case OPTIONS:
			case OPTION:
			case OR:
			case ORDER:
			case PASSWORD:
			case PASSWORDS:
			case PATH:
			case PATHS:
			case PLAINTEXT:
			case PLUS:
			case POINT:
			case POPULATED:
			case PRIMARY:
			case PRIMARIES:
			case PRIVILEGE:
			case PRIVILEGES:
			case PROCEDURE:
			case PROCEDURES:
			case PROPERTIES:
			case PROPERTY:
			case PROVIDER:
			case PROVIDERS:
			case RANGE:
			case READ:
			case REALLOCATE:
			case REDUCE:
			case RENAME:
			case REL:
			case RELATIONSHIP:
			case RELATIONSHIPS:
			case REMOVE:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case REPLICAS:
			case REPORT:
			case REQUIRE:
			case REQUIRED:
			case RESTRICT:
			case RETRY:
			case RETURN:
			case REVOKE:
			case ROLE:
			case ROLES:
			case ROW:
			case ROWS:
			case SCAN:
			case SEC:
			case SECOND:
			case SECONDARY:
			case SECONDARIES:
			case SECONDS:
			case SEEK:
			case SERVER:
			case SERVERS:
			case SET:
			case SETTING:
			case SETTINGS:
			case SHARD:
			case SHARDS:
			case SHORTEST_PATH:
			case SHORTEST:
			case SHOW:
			case SIGNED:
			case SINGLE:
			case SKIPROWS:
			case START:
			case STARTS:
			case STATUS:
			case STOP:
			case STRING:
			case SUPPORTED:
			case SUSPENDED:
			case TARGET:
			case TERMINATE:
			case TEXT:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE:
			case TO:
			case TOPOLOGY:
			case TRAILING:
			case TRANSACTION:
			case TRANSACTIONS:
			case TRAVERSE:
			case TRIM:
			case TRUE:
			case TYPE:
			case TYPED:
			case TYPES:
			case UNION:
			case UNIQUE:
			case UNIQUENESS:
			case UNWIND:
			case URL:
			case USE:
			case USER:
			case USERS:
			case USING:
			case VALUE:
			case VARCHAR:
			case VECTOR:
			case VECTOR_DISTANCE:
			case VECTOR_NORM:
			case VERTEX:
			case WAIT:
			case WHEN:
			case WHERE:
			case WITH:
			case WITHOUT:
			case WRITE:
			case XOR:
			case YIELD:
			case ZONE:
			case ZONED:
			case IDENTIFIER:
				{
				State = 893;
				returnItem();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 900;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 896;
				Match(COMMA);
				State = 897;
				returnItem();
				}
				}
				State = 902;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrderItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AscTokenContext ascToken() {
			return GetRuleContext<AscTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DescTokenContext descToken() {
			return GetRuleContext<DescTokenContext>(0);
		}
		public OrderItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orderItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrderItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OrderItemContext orderItem() {
		OrderItemContext _localctx = new OrderItemContext(Context, State);
		EnterRule(_localctx, 34, RULE_orderItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 903;
			expression();
			State = 906;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ASC:
			case ASCENDING:
				{
				State = 904;
				ascToken();
				}
				break;
			case DESC:
			case DESCENDING:
				{
				State = 905;
				descToken();
				}
				break;
			case Eof:
			case CALL:
			case COMMA:
			case CREATE:
			case DELETE:
			case DETACH:
			case ELSE:
			case FILTER:
			case FINISH:
			case FOREACH:
			case INSERT:
			case LET:
			case LIMITROWS:
			case LOAD:
			case MATCH:
			case MERGE:
			case NEXT:
			case NODETACH:
			case OFFSET:
			case OPTIONAL:
			case ORDER:
			case RCURLY:
			case REMOVE:
			case RETURN:
			case RPAREN:
			case SEMICOLON:
			case SET:
			case SHOW:
			case SKIPROWS:
			case TERMINATE:
			case UNION:
			case UNWIND:
			case USE:
			case WHEN:
			case WHERE:
			case WITH:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AscTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASC() { return GetToken(CypherParser.ASC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASCENDING() { return GetToken(CypherParser.ASCENDING, 0); }
		public AscTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_ascToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAscToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AscTokenContext ascToken() {
		AscTokenContext _localctx = new AscTokenContext(Context, State);
		EnterRule(_localctx, 36, RULE_ascToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 908;
			_la = TokenStream.LA(1);
			if ( !(_la==ASC || _la==ASCENDING) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DescTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DESC() { return GetToken(CypherParser.DESC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DESCENDING() { return GetToken(CypherParser.DESCENDING, 0); }
		public DescTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_descToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDescToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DescTokenContext descToken() {
		DescTokenContext _localctx = new DescTokenContext(Context, State);
		EnterRule(_localctx, 38, RULE_descToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 910;
			_la = TokenStream.LA(1);
			if ( !(_la==DESC || _la==DESCENDING) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrderByContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORDER() { return GetToken(CypherParser.ORDER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(CypherParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public OrderItemContext[] orderItem() {
			return GetRuleContexts<OrderItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public OrderItemContext orderItem(int i) {
			return GetRuleContext<OrderItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public OrderByContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orderBy; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrderBy(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OrderByContext orderBy() {
		OrderByContext _localctx = new OrderByContext(Context, State);
		EnterRule(_localctx, 40, RULE_orderBy);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 912;
			Match(ORDER);
			State = 913;
			Match(BY);
			State = 914;
			orderItem();
			State = 919;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 915;
				Match(COMMA);
				State = 916;
				orderItem();
				}
				}
				State = 921;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SkipContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OFFSET() { return GetToken(CypherParser.OFFSET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SKIPROWS() { return GetToken(CypherParser.SKIPROWS, 0); }
		public SkipContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_skip; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSkip(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SkipContext skip() {
		SkipContext _localctx = new SkipContext(Context, State);
		EnterRule(_localctx, 42, RULE_skip);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 922;
			_la = TokenStream.LA(1);
			if ( !(_la==OFFSET || _la==SKIPROWS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 923;
			expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LimitContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIMITROWS() { return GetToken(CypherParser.LIMITROWS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public LimitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_limit; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLimit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LimitContext limit() {
		LimitContext _localctx = new LimitContext(Context, State);
		EnterRule(_localctx, 44, RULE_limit);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 925;
			Match(LIMITROWS);
			State = 926;
			expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WhereClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHERE() { return GetToken(CypherParser.WHERE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public WhereClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_whereClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhereClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WhereClauseContext whereClause() {
		WhereClauseContext _localctx = new WhereClauseContext(Context, State);
		EnterRule(_localctx, 46, RULE_whereClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 928;
			Match(WHERE);
			State = 929;
			expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WithClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(CypherParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ReturnBodyContext returnBody() {
			return GetRuleContext<ReturnBodyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public WithClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_withClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWithClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WithClauseContext withClause() {
		WithClauseContext _localctx = new WithClauseContext(Context, State);
		EnterRule(_localctx, 48, RULE_withClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 931;
			Match(WITH);
			State = 932;
			returnBody();
			State = 934;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 933;
				whereClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CREATE() { return GetToken(CypherParser.CREATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PatternListContext patternList() {
			return GetRuleContext<PatternListContext>(0);
		}
		public CreateClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateClauseContext createClause() {
		CreateClauseContext _localctx = new CreateClauseContext(Context, State);
		EnterRule(_localctx, 50, RULE_createClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 936;
			Match(CREATE);
			State = 937;
			patternList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InsertClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSERT() { return GetToken(CypherParser.INSERT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public InsertPatternListContext insertPatternList() {
			return GetRuleContext<InsertPatternListContext>(0);
		}
		public InsertClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insertClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInsertClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InsertClauseContext insertClause() {
		InsertClauseContext _localctx = new InsertClauseContext(Context, State);
		EnterRule(_localctx, 52, RULE_insertClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 939;
			Match(INSERT);
			State = 940;
			insertPatternList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(CypherParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SetItemContext[] setItem() {
			return GetRuleContexts<SetItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SetItemContext setItem(int i) {
			return GetRuleContext<SetItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public SetClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SetClauseContext setClause() {
		SetClauseContext _localctx = new SetClauseContext(Context, State);
		EnterRule(_localctx, 54, RULE_setClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 942;
			Match(SET);
			State = 943;
			setItem();
			State = 948;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 944;
				Match(COMMA);
				State = 945;
				setItem();
				}
				}
				State = 950;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetItemContext : ParserRuleContext {
		public SetItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setItem; } }
	 
		public SetItemContext() { }
		public virtual void CopyFrom(SetItemContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class SetPropContext : SetItemContext {
		[System.Diagnostics.DebuggerNonUserCode] public PropertyExpressionContext propertyExpression() {
			return GetRuleContext<PropertyExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQ() { return GetToken(CypherParser.EQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public SetPropContext(SetItemContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetProp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AddPropContext : SetItemContext {
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUSEQUAL() { return GetToken(CypherParser.PLUSEQUAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public AddPropContext(SetItemContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAddProp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SetDynamicPropContext : SetItemContext {
		[System.Diagnostics.DebuggerNonUserCode] public DynamicPropertyExpressionContext dynamicPropertyExpression() {
			return GetRuleContext<DynamicPropertyExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQ() { return GetToken(CypherParser.EQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public SetDynamicPropContext(SetItemContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetDynamicProp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SetPropsContext : SetItemContext {
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQ() { return GetToken(CypherParser.EQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public SetPropsContext(SetItemContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetProps(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SetLabelsContext : SetItemContext {
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NodeLabelsContext nodeLabels() {
			return GetRuleContext<NodeLabelsContext>(0);
		}
		public SetLabelsContext(SetItemContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetLabels(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class SetLabelsIsContext : SetItemContext {
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NodeLabelsIsContext nodeLabelsIs() {
			return GetRuleContext<NodeLabelsIsContext>(0);
		}
		public SetLabelsIsContext(SetItemContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetLabelsIs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SetItemContext setItem() {
		SetItemContext _localctx = new SetItemContext(Context, State);
		EnterRule(_localctx, 56, RULE_setItem);
		try {
			State = 973;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,26,Context) ) {
			case 1:
				_localctx = new SetPropContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 951;
				propertyExpression();
				State = 952;
				Match(EQ);
				State = 953;
				expression();
				}
				break;
			case 2:
				_localctx = new SetDynamicPropContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 955;
				dynamicPropertyExpression();
				State = 956;
				Match(EQ);
				State = 957;
				expression();
				}
				break;
			case 3:
				_localctx = new SetPropsContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 959;
				variable();
				State = 960;
				Match(EQ);
				State = 961;
				expression();
				}
				break;
			case 4:
				_localctx = new AddPropContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 963;
				variable();
				State = 964;
				Match(PLUSEQUAL);
				State = 965;
				expression();
				}
				break;
			case 5:
				_localctx = new SetLabelsContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 967;
				variable();
				State = 968;
				nodeLabels();
				}
				break;
			case 6:
				_localctx = new SetLabelsIsContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 970;
				variable();
				State = 971;
				nodeLabelsIs();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RemoveClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REMOVE() { return GetToken(CypherParser.REMOVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RemoveItemContext[] removeItem() {
			return GetRuleContexts<RemoveItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public RemoveItemContext removeItem(int i) {
			return GetRuleContext<RemoveItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public RemoveClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_removeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRemoveClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RemoveClauseContext removeClause() {
		RemoveClauseContext _localctx = new RemoveClauseContext(Context, State);
		EnterRule(_localctx, 58, RULE_removeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 975;
			Match(REMOVE);
			State = 976;
			removeItem();
			State = 981;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 977;
				Match(COMMA);
				State = 978;
				removeItem();
				}
				}
				State = 983;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RemoveItemContext : ParserRuleContext {
		public RemoveItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_removeItem; } }
	 
		public RemoveItemContext() { }
		public virtual void CopyFrom(RemoveItemContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class RemoveLabelsIsContext : RemoveItemContext {
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NodeLabelsIsContext nodeLabelsIs() {
			return GetRuleContext<NodeLabelsIsContext>(0);
		}
		public RemoveLabelsIsContext(RemoveItemContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRemoveLabelsIs(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RemoveDynamicPropContext : RemoveItemContext {
		[System.Diagnostics.DebuggerNonUserCode] public DynamicPropertyExpressionContext dynamicPropertyExpression() {
			return GetRuleContext<DynamicPropertyExpressionContext>(0);
		}
		public RemoveDynamicPropContext(RemoveItemContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRemoveDynamicProp(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RemoveLabelsContext : RemoveItemContext {
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NodeLabelsContext nodeLabels() {
			return GetRuleContext<NodeLabelsContext>(0);
		}
		public RemoveLabelsContext(RemoveItemContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRemoveLabels(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RemovePropContext : RemoveItemContext {
		[System.Diagnostics.DebuggerNonUserCode] public PropertyExpressionContext propertyExpression() {
			return GetRuleContext<PropertyExpressionContext>(0);
		}
		public RemovePropContext(RemoveItemContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRemoveProp(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RemoveItemContext removeItem() {
		RemoveItemContext _localctx = new RemoveItemContext(Context, State);
		EnterRule(_localctx, 60, RULE_removeItem);
		try {
			State = 992;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,28,Context) ) {
			case 1:
				_localctx = new RemovePropContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 984;
				propertyExpression();
				}
				break;
			case 2:
				_localctx = new RemoveDynamicPropContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 985;
				dynamicPropertyExpression();
				}
				break;
			case 3:
				_localctx = new RemoveLabelsContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 986;
				variable();
				State = 987;
				nodeLabels();
				}
				break;
			case 4:
				_localctx = new RemoveLabelsIsContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 989;
				variable();
				State = 990;
				nodeLabelsIs();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeleteClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DELETE() { return GetToken(CypherParser.DELETE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DETACH() { return GetToken(CypherParser.DETACH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NODETACH() { return GetToken(CypherParser.NODETACH, 0); }
		public DeleteClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_deleteClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeleteClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeleteClauseContext deleteClause() {
		DeleteClauseContext _localctx = new DeleteClauseContext(Context, State);
		EnterRule(_localctx, 62, RULE_deleteClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 995;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DETACH || _la==NODETACH) {
				{
				State = 994;
				_la = TokenStream.LA(1);
				if ( !(_la==DETACH || _la==NODETACH) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 997;
			Match(DELETE);
			State = 998;
			expression();
			State = 1003;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 999;
				Match(COMMA);
				State = 1000;
				expression();
				}
				}
				State = 1005;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MATCH() { return GetToken(CypherParser.MATCH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PatternListContext patternList() {
			return GetRuleContext<PatternListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPTIONAL() { return GetToken(CypherParser.OPTIONAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public MatchModeContext matchMode() {
			return GetRuleContext<MatchModeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public HintContext[] hint() {
			return GetRuleContexts<HintContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public HintContext hint(int i) {
			return GetRuleContext<HintContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public MatchClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchClauseContext matchClause() {
		MatchClauseContext _localctx = new MatchClauseContext(Context, State);
		EnterRule(_localctx, 64, RULE_matchClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1007;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OPTIONAL) {
				{
				State = 1006;
				Match(OPTIONAL);
				}
			}

			State = 1009;
			Match(MATCH);
			State = 1011;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,32,Context) ) {
			case 1:
				{
				State = 1010;
				matchMode();
				}
				break;
			}
			State = 1013;
			patternList();
			State = 1017;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==USING) {
				{
				{
				State = 1014;
				hint();
				}
				}
				State = 1019;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1021;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 1020;
				whereClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MatchModeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REPEATABLE() { return GetToken(CypherParser.REPEATABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELEMENT() { return GetToken(CypherParser.ELEMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELEMENTS() { return GetToken(CypherParser.ELEMENTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BINDINGS() { return GetToken(CypherParser.BINDINGS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIFFERENT() { return GetToken(CypherParser.DIFFERENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELATIONSHIP() { return GetToken(CypherParser.RELATIONSHIP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELATIONSHIPS() { return GetToken(CypherParser.RELATIONSHIPS, 0); }
		public MatchModeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_matchMode; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMatchMode(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MatchModeContext matchMode() {
		MatchModeContext _localctx = new MatchModeContext(Context, State);
		EnterRule(_localctx, 66, RULE_matchMode);
		try {
			State = 1039;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case REPEATABLE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1023;
				Match(REPEATABLE);
				State = 1029;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ELEMENT:
					{
					State = 1024;
					Match(ELEMENT);
					State = 1026;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,35,Context) ) {
					case 1:
						{
						State = 1025;
						Match(BINDINGS);
						}
						break;
					}
					}
					break;
				case ELEMENTS:
					{
					State = 1028;
					Match(ELEMENTS);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case DIFFERENT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1031;
				Match(DIFFERENT);
				State = 1037;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case RELATIONSHIP:
					{
					State = 1032;
					Match(RELATIONSHIP);
					State = 1034;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,37,Context) ) {
					case 1:
						{
						State = 1033;
						Match(BINDINGS);
						}
						break;
					}
					}
					break;
				case RELATIONSHIPS:
					{
					State = 1036;
					Match(RELATIONSHIPS);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HintContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(CypherParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JOIN() { return GetToken(CypherParser.JOIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(CypherParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NonEmptyNameListContext nonEmptyNameList() {
			return GetRuleContext<NonEmptyNameListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SCAN() { return GetToken(CypherParser.SCAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LabelOrRelTypeContext labelOrRelType() {
			return GetRuleContext<LabelOrRelTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(CypherParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TEXT() { return GetToken(CypherParser.TEXT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RANGE() { return GetToken(CypherParser.RANGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode POINT() { return GetToken(CypherParser.POINT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEEK() { return GetToken(CypherParser.SEEK, 0); }
		public HintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_hint; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HintContext hint() {
		HintContext _localctx = new HintContext(Context, State);
		EnterRule(_localctx, 68, RULE_hint);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1041;
			Match(USING);
			State = 1067;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INDEX:
			case POINT:
			case RANGE:
			case TEXT:
				{
				{
				State = 1049;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case INDEX:
					{
					State = 1042;
					Match(INDEX);
					}
					break;
				case TEXT:
					{
					State = 1043;
					Match(TEXT);
					State = 1044;
					Match(INDEX);
					}
					break;
				case RANGE:
					{
					State = 1045;
					Match(RANGE);
					State = 1046;
					Match(INDEX);
					}
					break;
				case POINT:
					{
					State = 1047;
					Match(POINT);
					State = 1048;
					Match(INDEX);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1052;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,41,Context) ) {
				case 1:
					{
					State = 1051;
					Match(SEEK);
					}
					break;
				}
				State = 1054;
				variable();
				State = 1055;
				labelOrRelType();
				State = 1056;
				Match(LPAREN);
				State = 1057;
				nonEmptyNameList();
				State = 1058;
				Match(RPAREN);
				}
				}
				break;
			case JOIN:
				{
				State = 1060;
				Match(JOIN);
				State = 1061;
				Match(ON);
				State = 1062;
				nonEmptyNameList();
				}
				break;
			case SCAN:
				{
				State = 1063;
				Match(SCAN);
				State = 1064;
				variable();
				State = 1065;
				labelOrRelType();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MERGE() { return GetToken(CypherParser.MERGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PatternContext pattern() {
			return GetRuleContext<PatternContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MergeActionContext[] mergeAction() {
			return GetRuleContexts<MergeActionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MergeActionContext mergeAction(int i) {
			return GetRuleContext<MergeActionContext>(i);
		}
		public MergeClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMergeClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MergeClauseContext mergeClause() {
		MergeClauseContext _localctx = new MergeClauseContext(Context, State);
		EnterRule(_localctx, 70, RULE_mergeClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1069;
			Match(MERGE);
			State = 1070;
			pattern();
			State = 1074;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ON) {
				{
				{
				State = 1071;
				mergeAction();
				}
				}
				State = 1076;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MergeActionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(CypherParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SetClauseContext setClause() {
			return GetRuleContext<SetClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MATCH() { return GetToken(CypherParser.MATCH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CREATE() { return GetToken(CypherParser.CREATE, 0); }
		public MergeActionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mergeAction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMergeAction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MergeActionContext mergeAction() {
		MergeActionContext _localctx = new MergeActionContext(Context, State);
		EnterRule(_localctx, 72, RULE_mergeAction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1077;
			Match(ON);
			State = 1078;
			_la = TokenStream.LA(1);
			if ( !(_la==CREATE || _la==MATCH) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1079;
			setClause();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FilterClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FILTER() { return GetToken(CypherParser.FILTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHERE() { return GetToken(CypherParser.WHERE, 0); }
		public FilterClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_filterClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFilterClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FilterClauseContext filterClause() {
		FilterClauseContext _localctx = new FilterClauseContext(Context, State);
		EnterRule(_localctx, 74, RULE_filterClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1081;
			Match(FILTER);
			State = 1083;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,44,Context) ) {
			case 1:
				{
				State = 1082;
				Match(WHERE);
				}
				break;
			}
			State = 1085;
			expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnwindClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNWIND() { return GetToken(CypherParser.UNWIND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(CypherParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		public UnwindClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unwindClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnwindClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnwindClauseContext unwindClause() {
		UnwindClauseContext _localctx = new UnwindClauseContext(Context, State);
		EnterRule(_localctx, 76, RULE_unwindClause);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1087;
			Match(UNWIND);
			State = 1088;
			expression();
			State = 1089;
			Match(AS);
			State = 1090;
			variable();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LetClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LET() { return GetToken(CypherParser.LET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LetItemContext[] letItem() {
			return GetRuleContexts<LetItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LetItemContext letItem(int i) {
			return GetRuleContext<LetItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public LetClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_letClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLetClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LetClauseContext letClause() {
		LetClauseContext _localctx = new LetClauseContext(Context, State);
		EnterRule(_localctx, 78, RULE_letClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1092;
			Match(LET);
			State = 1093;
			letItem();
			State = 1098;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1094;
				Match(COMMA);
				State = 1095;
				letItem();
				}
				}
				State = 1100;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LetItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQ() { return GetToken(CypherParser.EQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public LetItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_letItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLetItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LetItemContext letItem() {
		LetItemContext _localctx = new LetItemContext(Context, State);
		EnterRule(_localctx, 80, RULE_letItem);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1101;
			variable();
			State = 1102;
			Match(EQ);
			State = 1103;
			expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CallClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CALL() { return GetToken(CypherParser.CALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureNameContext procedureName() {
			return GetRuleContext<ProcedureNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPTIONAL() { return GetToken(CypherParser.OPTIONAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode YIELD() { return GetToken(CypherParser.YIELD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMES() { return GetToken(CypherParser.TIMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureResultItemContext[] procedureResultItem() {
			return GetRuleContexts<ProcedureResultItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureResultItemContext procedureResultItem(int i) {
			return GetRuleContext<ProcedureResultItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureArgumentContext[] procedureArgument() {
			return GetRuleContexts<ProcedureArgumentContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureArgumentContext procedureArgument(int i) {
			return GetRuleContext<ProcedureArgumentContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public CallClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_callClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCallClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CallClauseContext callClause() {
		CallClauseContext _localctx = new CallClauseContext(Context, State);
		EnterRule(_localctx, 82, RULE_callClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1106;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OPTIONAL) {
				{
				State = 1105;
				Match(OPTIONAL);
				}
			}

			State = 1108;
			Match(CALL);
			State = 1109;
			procedureName();
			State = 1122;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 1110;
				Match(LPAREN);
				State = 1119;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << DECIMAL_DOUBLE) | (1L << UNSIGNED_DECIMAL_INTEGER) | (1L << UNSIGNED_HEX_INTEGER) | (1L << UNSIGNED_OCTAL_INTEGER) | (1L << STRING_LITERAL1) | (1L << STRING_LITERAL2) | (1L << ESCAPED_SYMBOLIC_NAME) | (1L << ACCESS) | (1L << ACTIVE) | (1L << ADD) | (1L << ADMIN) | (1L << ADMINISTRATOR) | (1L << ALIAS) | (1L << ALIASES) | (1L << ALL_SHORTEST_PATHS) | (1L << ALL) | (1L << ALLREDUCE) | (1L << ALTER) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASCENDING) | (1L << ASSIGN) | (1L << AT) | (1L << AUTH) | (1L << BINDINGS) | (1L << BOOL) | (1L << BOOLEAN) | (1L << BOOSTED) | (1L << BOTH) | (1L << BREAK) | (1L << BUILT) | (1L << BY) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CHANGE) | (1L << CIDR) | (1L << COLLECT) | (1L << COMMAND) | (1L << COMMANDS) | (1L << COMPOSITE) | (1L << CONCURRENT) | (1L << CONSTRAINT) | (1L << CONSTRAINTS) | (1L << CONTAINS) | (1L << COPY) | (1L << CONTINUE) | (1L << COSINE) | (1L << COUNT) | (1L << CREATE) | (1L << CREDENTIAL) | (1L << CSV) | (1L << CURRENT))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CYPHER - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATABASES - 64)) | (1L << (DATE - 64)) | (1L << (DATETIME - 64)) | (1L << (DBMS - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFINED - 64)) | (1L << (DELETE - 64)) | (1L << (DENY - 64)) | (1L << (DESC - 64)) | (1L << (DESCENDING - 64)) | (1L << (DESTROY - 64)) | (1L << (DETACH - 64)) | (1L << (DIFFERENT - 64)) | (1L << (DOLLAR - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOT_METRIC - 64)) | (1L << (DRIVER - 64)) | (1L << (DROP - 64)) | (1L << (DRYRUN - 64)) | (1L << (DUMP - 64)) | (1L << (DURATION - 64)) | (1L << (EACH - 64)) | (1L << (EDGE - 64)) | (1L << (ENABLE - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELEMENTS - 64)) | (1L << (ELSE - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (EUCLIDEAN - 64)) | (1L << (EUCLIDEAN_SQUARED - 64)) | (1L << (END - 64)) | (1L << (ENDS - 64)) | (1L << (EXECUTABLE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXIST - 64)) | (1L << (EXISTENCE - 64)) | (1L << (EXISTS - 64)) | (1L << (ERROR - 64)) | (1L << (FAIL - 64)) | (1L << (FALSE - 64)) | (1L << (FIELDTERMINATOR - 64)) | (1L << (FILTER - 64)) | (1L << (FINISH - 64)) | (1L << (FLOAT - 64)) | (1L << (FLOAT64 - 64)) | (1L << (FLOAT32 - 64)) | (1L << (FOR - 64)) | (1L << (FOREACH - 64)) | (1L << (FORWARDING - 64)) | (1L << (FROM - 64)) | (1L << (FULLTEXT - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GRANT - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (GRAPH - 128)) | (1L << (GRAPHS - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPS - 128)) | (1L << (HAMMING - 128)) | (1L << (HEADERS - 128)) | (1L << (HOME - 128)) | (1L << (ID - 128)) | (1L << (IF - 128)) | (1L << (IMPERSONATE - 128)) | (1L << (IMMUTABLE - 128)) | (1L << (IN - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXES - 128)) | (1L << (INF - 128)) | (1L << (INFINITY - 128)) | (1L << (INSERT - 128)) | (1L << (INT - 128)) | (1L << (INT64 - 128)) | (1L << (INT32 - 128)) | (1L << (INT16 - 128)) | (1L << (INT8 - 128)) | (1L << (INTEGER - 128)) | (1L << (INTEGER64 - 128)) | (1L << (INTEGER32 - 128)) | (1L << (INTEGER16 - 128)) | (1L << (INTEGER8 - 128)) | (1L << (IS - 128)) | (1L << (JOIN - 128)) | (1L << (KEY - 128)) | (1L << (LABEL - 128)) | (1L << (LABELS - 128)) | (1L << (LANGUAGE - 128)) | (1L << (LBRACKET - 128)) | (1L << (LCURLY - 128)) | (1L << (LEADING - 128)) | (1L << (LET - 128)) | (1L << (LIMITROWS - 128)) | (1L << (LIST - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOOKUP - 128)) | (1L << (LPAREN - 128)) | (1L << (MANAGEMENT - 128)) | (1L << (MANHATTAN - 128)) | (1L << (MAP - 128)) | (1L << (MATCH - 128)) | (1L << (MERGE - 128)) | (1L << (MINUS - 128)) | (1L << (IMPLIES - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NAN - 128)) | (1L << (NFC - 128)) | (1L << (NFD - 128)) | (1L << (NFKC - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (NFKD - 192)) | (1L << (NEW - 192)) | (1L << (NEXT - 192)) | (1L << (NODE - 192)) | (1L << (NODETACH - 192)) | (1L << (NODES - 192)) | (1L << (NONE - 192)) | (1L << (NORMALIZE - 192)) | (1L << (NORMALIZED - 192)) | (1L << (NOT - 192)) | (1L << (NOTHING - 192)) | (1L << (NOWAIT - 192)) | (1L << (NULL - 192)) | (1L << (OF - 192)) | (1L << (OFFSET - 192)) | (1L << (OIDC - 192)) | (1L << (ON - 192)) | (1L << (ONLY - 192)) | (1L << (OPTIONAL - 192)) | (1L << (OPTIONS - 192)) | (1L << (OPTION - 192)) | (1L << (OR - 192)) | (1L << (ORDER - 192)) | (1L << (PASSWORD - 192)) | (1L << (PASSWORDS - 192)) | (1L << (PATH - 192)) | (1L << (PATHS - 192)) | (1L << (PLAINTEXT - 192)) | (1L << (PLUS - 192)) | (1L << (POINT - 192)) | (1L << (POPULATED - 192)) | (1L << (PRIMARY - 192)) | (1L << (PRIMARIES - 192)) | (1L << (PRIVILEGE - 192)) | (1L << (PRIVILEGES - 192)) | (1L << (PROCEDURE - 192)) | (1L << (PROCEDURES - 192)) | (1L << (PROPERTIES - 192)) | (1L << (PROPERTY - 192)) | (1L << (PROVIDER - 192)) | (1L << (PROVIDERS - 192)) | (1L << (RANGE - 192)) | (1L << (READ - 192)) | (1L << (REALLOCATE - 192)) | (1L << (REDUCE - 192)) | (1L << (RENAME - 192)) | (1L << (REL - 192)) | (1L << (RELATIONSHIP - 192)) | (1L << (RELATIONSHIPS - 192)) | (1L << (REMOVE - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (REPLICAS - 192)) | (1L << (REPORT - 192)) | (1L << (REQUIRE - 192)) | (1L << (REQUIRED - 192)) | (1L << (RESTRICT - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (RETRY - 256)) | (1L << (RETURN - 256)) | (1L << (REVOKE - 256)) | (1L << (ROLE - 256)) | (1L << (ROLES - 256)) | (1L << (ROW - 256)) | (1L << (ROWS - 256)) | (1L << (SCAN - 256)) | (1L << (SEC - 256)) | (1L << (SECOND - 256)) | (1L << (SECONDARY - 256)) | (1L << (SECONDARIES - 256)) | (1L << (SECONDS - 256)) | (1L << (SEEK - 256)) | (1L << (SERVER - 256)) | (1L << (SERVERS - 256)) | (1L << (SET - 256)) | (1L << (SETTING - 256)) | (1L << (SETTINGS - 256)) | (1L << (SHARD - 256)) | (1L << (SHARDS - 256)) | (1L << (SHORTEST_PATH - 256)) | (1L << (SHORTEST - 256)) | (1L << (SHOW - 256)) | (1L << (SIGNED - 256)) | (1L << (SINGLE - 256)) | (1L << (SKIPROWS - 256)) | (1L << (START - 256)) | (1L << (STARTS - 256)) | (1L << (STATUS - 256)) | (1L << (STOP - 256)) | (1L << (STRING - 256)) | (1L << (SUPPORTED - 256)) | (1L << (SUSPENDED - 256)) | (1L << (TARGET - 256)) | (1L << (TERMINATE - 256)) | (1L << (TEXT - 256)) | (1L << (THEN - 256)) | (1L << (TIME - 256)) | (1L << (TIMESTAMP - 256)) | (1L << (TIMEZONE - 256)) | (1L << (TO - 256)) | (1L << (TOPOLOGY - 256)) | (1L << (TRAILING - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSACTIONS - 256)) | (1L << (TRAVERSE - 256)) | (1L << (TRIM - 256)) | (1L << (TRUE - 256)) | (1L << (TYPE - 256)) | (1L << (TYPED - 256)) | (1L << (TYPES - 256)) | (1L << (UNION - 256)) | (1L << (UNIQUE - 256)) | (1L << (UNIQUENESS - 256)) | (1L << (UNWIND - 256)) | (1L << (URL - 256)) | (1L << (USE - 256)) | (1L << (USER - 256)) | (1L << (USERS - 256)) | (1L << (USING - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (VALUE - 320)) | (1L << (VARCHAR - 320)) | (1L << (VECTOR - 320)) | (1L << (VECTOR_DISTANCE - 320)) | (1L << (VECTOR_NORM - 320)) | (1L << (VERTEX - 320)) | (1L << (WAIT - 320)) | (1L << (WHEN - 320)) | (1L << (WHERE - 320)) | (1L << (WITH - 320)) | (1L << (WITHOUT - 320)) | (1L << (WRITE - 320)) | (1L << (XOR - 320)) | (1L << (YIELD - 320)) | (1L << (ZONE - 320)) | (1L << (ZONED - 320)) | (1L << (IDENTIFIER - 320)))) != 0)) {
					{
					State = 1111;
					procedureArgument();
					State = 1116;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 1112;
						Match(COMMA);
						State = 1113;
						procedureArgument();
						}
						}
						State = 1118;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
				}

				State = 1121;
				Match(RPAREN);
				}
			}

			State = 1139;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==YIELD) {
				{
				State = 1124;
				Match(YIELD);
				State = 1137;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case TIMES:
					{
					State = 1125;
					Match(TIMES);
					}
					break;
				case ESCAPED_SYMBOLIC_NAME:
				case ACCESS:
				case ACTIVE:
				case ADD:
				case ADMIN:
				case ADMINISTRATOR:
				case ALIAS:
				case ALIASES:
				case ALL_SHORTEST_PATHS:
				case ALL:
				case ALLREDUCE:
				case ALTER:
				case AND:
				case ANY:
				case ARRAY:
				case AS:
				case ASC:
				case ASCENDING:
				case ASSIGN:
				case AT:
				case AUTH:
				case BINDINGS:
				case BOOL:
				case BOOLEAN:
				case BOOSTED:
				case BOTH:
				case BREAK:
				case BUILT:
				case BY:
				case CALL:
				case CASCADE:
				case CASE:
				case CHANGE:
				case CIDR:
				case COLLECT:
				case COMMAND:
				case COMMANDS:
				case COMPOSITE:
				case CONCURRENT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONTAINS:
				case COPY:
				case CONTINUE:
				case COSINE:
				case COUNT:
				case CREATE:
				case CREDENTIAL:
				case CSV:
				case CURRENT:
				case CYPHER:
				case DATA:
				case DATABASE:
				case DATABASES:
				case DATE:
				case DATETIME:
				case DBMS:
				case DEALLOCATE:
				case DEFAULT:
				case DEFINED:
				case DELETE:
				case DENY:
				case DESC:
				case DESCENDING:
				case DESTROY:
				case DETACH:
				case DIFFERENT:
				case DISTINCT:
				case DOT_METRIC:
				case DRIVER:
				case DROP:
				case DRYRUN:
				case DUMP:
				case DURATION:
				case EACH:
				case EDGE:
				case ENABLE:
				case ELEMENT:
				case ELEMENTS:
				case ELSE:
				case ENCRYPTED:
				case EUCLIDEAN:
				case EUCLIDEAN_SQUARED:
				case END:
				case ENDS:
				case EXECUTABLE:
				case EXECUTE:
				case EXIST:
				case EXISTENCE:
				case EXISTS:
				case ERROR:
				case FAIL:
				case FALSE:
				case FIELDTERMINATOR:
				case FILTER:
				case FINISH:
				case FLOAT:
				case FLOAT64:
				case FLOAT32:
				case FOR:
				case FOREACH:
				case FORWARDING:
				case FROM:
				case FULLTEXT:
				case FUNCTION:
				case FUNCTIONS:
				case GRANT:
				case GRAPH:
				case GRAPHS:
				case GROUP:
				case GROUPS:
				case HAMMING:
				case HEADERS:
				case HOME:
				case ID:
				case IF:
				case IMPERSONATE:
				case IMMUTABLE:
				case IN:
				case INDEX:
				case INDEXES:
				case INF:
				case INFINITY:
				case INSERT:
				case INT:
				case INT64:
				case INT32:
				case INT16:
				case INT8:
				case INTEGER:
				case INTEGER64:
				case INTEGER32:
				case INTEGER16:
				case INTEGER8:
				case IS:
				case JOIN:
				case KEY:
				case LABEL:
				case LABELS:
				case LANGUAGE:
				case LEADING:
				case LET:
				case LIMITROWS:
				case LIST:
				case LOAD:
				case LOCAL:
				case LOOKUP:
				case MANAGEMENT:
				case MANHATTAN:
				case MAP:
				case MATCH:
				case MERGE:
				case IMPLIES:
				case NAME:
				case NAMES:
				case NAN:
				case NFC:
				case NFD:
				case NFKC:
				case NFKD:
				case NEW:
				case NEXT:
				case NODE:
				case NODETACH:
				case NODES:
				case NONE:
				case NORMALIZE:
				case NORMALIZED:
				case NOT:
				case NOTHING:
				case NOWAIT:
				case NULL:
				case OF:
				case OFFSET:
				case OIDC:
				case ON:
				case ONLY:
				case OPTIONAL:
				case OPTIONS:
				case OPTION:
				case OR:
				case ORDER:
				case PASSWORD:
				case PASSWORDS:
				case PATH:
				case PATHS:
				case PLAINTEXT:
				case POINT:
				case POPULATED:
				case PRIMARY:
				case PRIMARIES:
				case PRIVILEGE:
				case PRIVILEGES:
				case PROCEDURE:
				case PROCEDURES:
				case PROPERTIES:
				case PROPERTY:
				case PROVIDER:
				case PROVIDERS:
				case RANGE:
				case READ:
				case REALLOCATE:
				case REDUCE:
				case RENAME:
				case REL:
				case RELATIONSHIP:
				case RELATIONSHIPS:
				case REMOVE:
				case REPEATABLE:
				case REPLACE:
				case REPLICA:
				case REPLICAS:
				case REPORT:
				case REQUIRE:
				case REQUIRED:
				case RESTRICT:
				case RETRY:
				case RETURN:
				case REVOKE:
				case ROLE:
				case ROLES:
				case ROW:
				case ROWS:
				case SCAN:
				case SEC:
				case SECOND:
				case SECONDARY:
				case SECONDARIES:
				case SECONDS:
				case SEEK:
				case SERVER:
				case SERVERS:
				case SET:
				case SETTING:
				case SETTINGS:
				case SHARD:
				case SHARDS:
				case SHORTEST_PATH:
				case SHORTEST:
				case SHOW:
				case SIGNED:
				case SINGLE:
				case SKIPROWS:
				case START:
				case STARTS:
				case STATUS:
				case STOP:
				case STRING:
				case SUPPORTED:
				case SUSPENDED:
				case TARGET:
				case TERMINATE:
				case TEXT:
				case THEN:
				case TIME:
				case TIMESTAMP:
				case TIMEZONE:
				case TO:
				case TOPOLOGY:
				case TRAILING:
				case TRANSACTION:
				case TRANSACTIONS:
				case TRAVERSE:
				case TRIM:
				case TRUE:
				case TYPE:
				case TYPED:
				case TYPES:
				case UNION:
				case UNIQUE:
				case UNIQUENESS:
				case UNWIND:
				case URL:
				case USE:
				case USER:
				case USERS:
				case USING:
				case VALUE:
				case VARCHAR:
				case VECTOR:
				case VECTOR_DISTANCE:
				case VECTOR_NORM:
				case VERTEX:
				case WAIT:
				case WHEN:
				case WHERE:
				case WITH:
				case WITHOUT:
				case WRITE:
				case XOR:
				case YIELD:
				case ZONE:
				case ZONED:
				case IDENTIFIER:
					{
					State = 1126;
					procedureResultItem();
					State = 1131;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==COMMA) {
						{
						{
						State = 1127;
						Match(COMMA);
						State = 1128;
						procedureResultItem();
						}
						}
						State = 1133;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					State = 1135;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==WHERE) {
						{
						State = 1134;
						whereClause();
						}
					}

					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NamespaceContext @namespace() {
			return GetRuleContext<NamespaceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString() {
			return GetRuleContext<SymbolicNameStringContext>(0);
		}
		public ProcedureNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcedureName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureNameContext procedureName() {
		ProcedureNameContext _localctx = new ProcedureNameContext(Context, State);
		EnterRule(_localctx, 84, RULE_procedureName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1141;
			@namespace();
			State = 1142;
			symbolicNameString();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureArgumentContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public ProcedureArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureArgument; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcedureArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureArgumentContext procedureArgument() {
		ProcedureArgumentContext _localctx = new ProcedureArgumentContext(Context, State);
		EnterRule(_localctx, 86, RULE_procedureArgument);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1144;
			expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureResultItemContext : ParserRuleContext {
		public VariableContext yieldItemName;
		public VariableContext yieldItemAlias;
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext[] variable() {
			return GetRuleContexts<VariableContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable(int i) {
			return GetRuleContext<VariableContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(CypherParser.AS, 0); }
		public ProcedureResultItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureResultItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcedureResultItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureResultItemContext procedureResultItem() {
		ProcedureResultItemContext _localctx = new ProcedureResultItemContext(Context, State);
		EnterRule(_localctx, 88, RULE_procedureResultItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1146;
			_localctx.yieldItemName = variable();
			State = 1149;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 1147;
				Match(AS);
				State = 1148;
				_localctx.yieldItemAlias = variable();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoadCSVClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOAD() { return GetToken(CypherParser.LOAD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CSV() { return GetToken(CypherParser.CSV, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FROM() { return GetToken(CypherParser.FROM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(CypherParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(CypherParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HEADERS() { return GetToken(CypherParser.HEADERS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIELDTERMINATOR() { return GetToken(CypherParser.FIELDTERMINATOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StringLiteralContext stringLiteral() {
			return GetRuleContext<StringLiteralContext>(0);
		}
		public LoadCSVClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loadCSVClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoadCSVClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LoadCSVClauseContext loadCSVClause() {
		LoadCSVClauseContext _localctx = new LoadCSVClauseContext(Context, State);
		EnterRule(_localctx, 90, RULE_loadCSVClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1151;
			Match(LOAD);
			State = 1152;
			Match(CSV);
			State = 1155;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 1153;
				Match(WITH);
				State = 1154;
				Match(HEADERS);
				}
			}

			State = 1157;
			Match(FROM);
			State = 1158;
			expression();
			State = 1159;
			Match(AS);
			State = 1160;
			variable();
			State = 1163;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==FIELDTERMINATOR) {
				{
				State = 1161;
				Match(FIELDTERMINATOR);
				State = 1162;
				stringLiteral();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ForeachClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOREACH() { return GetToken(CypherParser.FOREACH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(CypherParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BAR() { return GetToken(CypherParser.BAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ClauseContext[] clause() {
			return GetRuleContexts<ClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ClauseContext clause(int i) {
			return GetRuleContext<ClauseContext>(i);
		}
		public ForeachClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_foreachClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitForeachClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ForeachClauseContext foreachClause() {
		ForeachClauseContext _localctx = new ForeachClauseContext(Context, State);
		EnterRule(_localctx, 92, RULE_foreachClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1165;
			Match(FOREACH);
			State = 1166;
			Match(LPAREN);
			State = 1167;
			variable();
			State = 1168;
			Match(IN);
			State = 1169;
			expression();
			State = 1170;
			Match(BAR);
			State = 1172;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 1171;
				clause();
				}
				}
				State = 1174;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==CALL || _la==CREATE || ((((_la - 74)) & ~0x3f) == 0 && ((1L << (_la - 74)) & ((1L << (DELETE - 74)) | (1L << (DETACH - 74)) | (1L << (FILTER - 74)) | (1L << (FINISH - 74)) | (1L << (FOREACH - 74)))) != 0) || ((((_la - 145)) & ~0x3f) == 0 && ((1L << (_la - 145)) & ((1L << (INSERT - 145)) | (1L << (LET - 145)) | (1L << (LIMITROWS - 145)) | (1L << (LOAD - 145)) | (1L << (MATCH - 145)) | (1L << (MERGE - 145)) | (1L << (NODETACH - 145)) | (1L << (OFFSET - 145)))) != 0) || ((((_la - 210)) & ~0x3f) == 0 && ((1L << (_la - 210)) & ((1L << (OPTIONAL - 210)) | (1L << (ORDER - 210)) | (1L << (REMOVE - 210)) | (1L << (RETURN - 210)))) != 0) || ((((_la - 274)) & ~0x3f) == 0 && ((1L << (_la - 274)) & ((1L << (SET - 274)) | (1L << (SKIPROWS - 274)) | (1L << (UNWIND - 274)) | (1L << (USE - 274)) | (1L << (WITH - 274)))) != 0) );
			State = 1176;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubqueryClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CALL() { return GetToken(CypherParser.CALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CypherParser.LCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NextStatementContext nextStatement() {
			return GetRuleContext<NextStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CypherParser.RCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPTIONAL() { return GetToken(CypherParser.OPTIONAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryScopeContext subqueryScope() {
			return GetRuleContext<SubqueryScopeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryInTransactionsParametersContext subqueryInTransactionsParameters() {
			return GetRuleContext<SubqueryInTransactionsParametersContext>(0);
		}
		public SubqueryClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subqueryClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubqueryClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubqueryClauseContext subqueryClause() {
		SubqueryClauseContext _localctx = new SubqueryClauseContext(Context, State);
		EnterRule(_localctx, 94, RULE_subqueryClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1179;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OPTIONAL) {
				{
				State = 1178;
				Match(OPTIONAL);
				}
			}

			State = 1181;
			Match(CALL);
			State = 1183;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LPAREN) {
				{
				State = 1182;
				subqueryScope();
				}
			}

			State = 1185;
			Match(LCURLY);
			State = 1186;
			nextStatement();
			State = 1187;
			Match(RCURLY);
			State = 1189;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IN) {
				{
				State = 1188;
				subqueryInTransactionsParameters();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubqueryScopeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMES() { return GetToken(CypherParser.TIMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext[] variable() {
			return GetRuleContexts<VariableContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable(int i) {
			return GetRuleContext<VariableContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public SubqueryScopeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subqueryScope; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubqueryScope(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubqueryScopeContext subqueryScope() {
		SubqueryScopeContext _localctx = new SubqueryScopeContext(Context, State);
		EnterRule(_localctx, 96, RULE_subqueryScope);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1191;
			Match(LPAREN);
			State = 1201;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TIMES:
				{
				State = 1192;
				Match(TIMES);
				}
				break;
			case ESCAPED_SYMBOLIC_NAME:
			case ACCESS:
			case ACTIVE:
			case ADD:
			case ADMIN:
			case ADMINISTRATOR:
			case ALIAS:
			case ALIASES:
			case ALL_SHORTEST_PATHS:
			case ALL:
			case ALLREDUCE:
			case ALTER:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASCENDING:
			case ASSIGN:
			case AT:
			case AUTH:
			case BINDINGS:
			case BOOL:
			case BOOLEAN:
			case BOOSTED:
			case BOTH:
			case BREAK:
			case BUILT:
			case BY:
			case CALL:
			case CASCADE:
			case CASE:
			case CHANGE:
			case CIDR:
			case COLLECT:
			case COMMAND:
			case COMMANDS:
			case COMPOSITE:
			case CONCURRENT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONTAINS:
			case COPY:
			case CONTINUE:
			case COSINE:
			case COUNT:
			case CREATE:
			case CREDENTIAL:
			case CSV:
			case CURRENT:
			case CYPHER:
			case DATA:
			case DATABASE:
			case DATABASES:
			case DATE:
			case DATETIME:
			case DBMS:
			case DEALLOCATE:
			case DEFAULT:
			case DEFINED:
			case DELETE:
			case DENY:
			case DESC:
			case DESCENDING:
			case DESTROY:
			case DETACH:
			case DIFFERENT:
			case DISTINCT:
			case DOT_METRIC:
			case DRIVER:
			case DROP:
			case DRYRUN:
			case DUMP:
			case DURATION:
			case EACH:
			case EDGE:
			case ENABLE:
			case ELEMENT:
			case ELEMENTS:
			case ELSE:
			case ENCRYPTED:
			case EUCLIDEAN:
			case EUCLIDEAN_SQUARED:
			case END:
			case ENDS:
			case EXECUTABLE:
			case EXECUTE:
			case EXIST:
			case EXISTENCE:
			case EXISTS:
			case ERROR:
			case FAIL:
			case FALSE:
			case FIELDTERMINATOR:
			case FILTER:
			case FINISH:
			case FLOAT:
			case FLOAT64:
			case FLOAT32:
			case FOR:
			case FOREACH:
			case FORWARDING:
			case FROM:
			case FULLTEXT:
			case FUNCTION:
			case FUNCTIONS:
			case GRANT:
			case GRAPH:
			case GRAPHS:
			case GROUP:
			case GROUPS:
			case HAMMING:
			case HEADERS:
			case HOME:
			case ID:
			case IF:
			case IMPERSONATE:
			case IMMUTABLE:
			case IN:
			case INDEX:
			case INDEXES:
			case INF:
			case INFINITY:
			case INSERT:
			case INT:
			case INT64:
			case INT32:
			case INT16:
			case INT8:
			case INTEGER:
			case INTEGER64:
			case INTEGER32:
			case INTEGER16:
			case INTEGER8:
			case IS:
			case JOIN:
			case KEY:
			case LABEL:
			case LABELS:
			case LANGUAGE:
			case LEADING:
			case LET:
			case LIMITROWS:
			case LIST:
			case LOAD:
			case LOCAL:
			case LOOKUP:
			case MANAGEMENT:
			case MANHATTAN:
			case MAP:
			case MATCH:
			case MERGE:
			case IMPLIES:
			case NAME:
			case NAMES:
			case NAN:
			case NFC:
			case NFD:
			case NFKC:
			case NFKD:
			case NEW:
			case NEXT:
			case NODE:
			case NODETACH:
			case NODES:
			case NONE:
			case NORMALIZE:
			case NORMALIZED:
			case NOT:
			case NOTHING:
			case NOWAIT:
			case NULL:
			case OF:
			case OFFSET:
			case OIDC:
			case ON:
			case ONLY:
			case OPTIONAL:
			case OPTIONS:
			case OPTION:
			case OR:
			case ORDER:
			case PASSWORD:
			case PASSWORDS:
			case PATH:
			case PATHS:
			case PLAINTEXT:
			case POINT:
			case POPULATED:
			case PRIMARY:
			case PRIMARIES:
			case PRIVILEGE:
			case PRIVILEGES:
			case PROCEDURE:
			case PROCEDURES:
			case PROPERTIES:
			case PROPERTY:
			case PROVIDER:
			case PROVIDERS:
			case RANGE:
			case READ:
			case REALLOCATE:
			case REDUCE:
			case RENAME:
			case REL:
			case RELATIONSHIP:
			case RELATIONSHIPS:
			case REMOVE:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case REPLICAS:
			case REPORT:
			case REQUIRE:
			case REQUIRED:
			case RESTRICT:
			case RETRY:
			case RETURN:
			case REVOKE:
			case ROLE:
			case ROLES:
			case ROW:
			case ROWS:
			case SCAN:
			case SEC:
			case SECOND:
			case SECONDARY:
			case SECONDARIES:
			case SECONDS:
			case SEEK:
			case SERVER:
			case SERVERS:
			case SET:
			case SETTING:
			case SETTINGS:
			case SHARD:
			case SHARDS:
			case SHORTEST_PATH:
			case SHORTEST:
			case SHOW:
			case SIGNED:
			case SINGLE:
			case SKIPROWS:
			case START:
			case STARTS:
			case STATUS:
			case STOP:
			case STRING:
			case SUPPORTED:
			case SUSPENDED:
			case TARGET:
			case TERMINATE:
			case TEXT:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE:
			case TO:
			case TOPOLOGY:
			case TRAILING:
			case TRANSACTION:
			case TRANSACTIONS:
			case TRAVERSE:
			case TRIM:
			case TRUE:
			case TYPE:
			case TYPED:
			case TYPES:
			case UNION:
			case UNIQUE:
			case UNIQUENESS:
			case UNWIND:
			case URL:
			case USE:
			case USER:
			case USERS:
			case USING:
			case VALUE:
			case VARCHAR:
			case VECTOR:
			case VECTOR_DISTANCE:
			case VECTOR_NORM:
			case VERTEX:
			case WAIT:
			case WHEN:
			case WHERE:
			case WITH:
			case WITHOUT:
			case WRITE:
			case XOR:
			case YIELD:
			case ZONE:
			case ZONED:
			case IDENTIFIER:
				{
				State = 1193;
				variable();
				State = 1198;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 1194;
					Match(COMMA);
					State = 1195;
					variable();
					}
					}
					State = 1200;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case RPAREN:
				break;
			default:
				break;
			}
			State = 1203;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubqueryInTransactionsParametersContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(CypherParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRANSACTIONS() { return GetToken(CypherParser.TRANSACTIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONCURRENT() { return GetToken(CypherParser.CONCURRENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryInTransactionsBatchParametersContext[] subqueryInTransactionsBatchParameters() {
			return GetRuleContexts<SubqueryInTransactionsBatchParametersContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryInTransactionsBatchParametersContext subqueryInTransactionsBatchParameters(int i) {
			return GetRuleContext<SubqueryInTransactionsBatchParametersContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryInTransactionsErrorParametersContext[] subqueryInTransactionsErrorParameters() {
			return GetRuleContexts<SubqueryInTransactionsErrorParametersContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryInTransactionsErrorParametersContext subqueryInTransactionsErrorParameters(int i) {
			return GetRuleContext<SubqueryInTransactionsErrorParametersContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryInTransactionsReportParametersContext[] subqueryInTransactionsReportParameters() {
			return GetRuleContexts<SubqueryInTransactionsReportParametersContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryInTransactionsReportParametersContext subqueryInTransactionsReportParameters(int i) {
			return GetRuleContext<SubqueryInTransactionsReportParametersContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public SubqueryInTransactionsParametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subqueryInTransactionsParameters; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubqueryInTransactionsParameters(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubqueryInTransactionsParametersContext subqueryInTransactionsParameters() {
		SubqueryInTransactionsParametersContext _localctx = new SubqueryInTransactionsParametersContext(Context, State);
		EnterRule(_localctx, 98, RULE_subqueryInTransactionsParameters);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1205;
			Match(IN);
			State = 1210;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,64,Context) ) {
			case 1:
				{
				State = 1207;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,63,Context) ) {
				case 1:
					{
					State = 1206;
					expression();
					}
					break;
				}
				State = 1209;
				Match(CONCURRENT);
				}
				break;
			}
			State = 1212;
			Match(TRANSACTIONS);
			State = 1218;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (((((_la - 205)) & ~0x3f) == 0 && ((1L << (_la - 205)) & ((1L << (OF - 205)) | (1L << (ON - 205)) | (1L << (REPORT - 205)))) != 0)) {
				{
				State = 1216;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case OF:
					{
					State = 1213;
					subqueryInTransactionsBatchParameters();
					}
					break;
				case ON:
					{
					State = 1214;
					subqueryInTransactionsErrorParameters();
					}
					break;
				case REPORT:
					{
					State = 1215;
					subqueryInTransactionsReportParameters();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 1220;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubqueryInTransactionsBatchParametersContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(CypherParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(CypherParser.ROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWS() { return GetToken(CypherParser.ROWS, 0); }
		public SubqueryInTransactionsBatchParametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subqueryInTransactionsBatchParameters; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubqueryInTransactionsBatchParameters(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubqueryInTransactionsBatchParametersContext subqueryInTransactionsBatchParameters() {
		SubqueryInTransactionsBatchParametersContext _localctx = new SubqueryInTransactionsBatchParametersContext(Context, State);
		EnterRule(_localctx, 100, RULE_subqueryInTransactionsBatchParameters);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1221;
			Match(OF);
			State = 1222;
			expression();
			State = 1223;
			_la = TokenStream.LA(1);
			if ( !(_la==ROW || _la==ROWS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubqueryInTransactionsErrorParametersContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(CypherParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR() { return GetToken(CypherParser.ERROR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETRY() { return GetToken(CypherParser.RETRY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SubqueryInTransactionsRetryParametersContext subqueryInTransactionsRetryParameters() {
			return GetRuleContext<SubqueryInTransactionsRetryParametersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(CypherParser.THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTINUE() { return GetToken(CypherParser.CONTINUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BREAK() { return GetToken(CypherParser.BREAK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FAIL() { return GetToken(CypherParser.FAIL, 0); }
		public SubqueryInTransactionsErrorParametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subqueryInTransactionsErrorParameters; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubqueryInTransactionsErrorParameters(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubqueryInTransactionsErrorParametersContext subqueryInTransactionsErrorParameters() {
		SubqueryInTransactionsErrorParametersContext _localctx = new SubqueryInTransactionsErrorParametersContext(Context, State);
		EnterRule(_localctx, 102, RULE_subqueryInTransactionsErrorParameters);
		int _la;
		try {
			State = 1238;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,69,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1225;
				Match(ON);
				State = 1226;
				Match(ERROR);
				State = 1227;
				Match(RETRY);
				State = 1229;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,67,Context) ) {
				case 1:
					{
					State = 1228;
					subqueryInTransactionsRetryParameters();
					}
					break;
				}
				State = 1233;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==THEN) {
					{
					State = 1231;
					Match(THEN);
					State = 1232;
					_la = TokenStream.LA(1);
					if ( !(_la==BREAK || _la==CONTINUE || _la==FAIL) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1235;
				Match(ON);
				State = 1236;
				Match(ERROR);
				State = 1237;
				_la = TokenStream.LA(1);
				if ( !(_la==BREAK || _la==CONTINUE || _la==FAIL) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubqueryInTransactionsRetryParametersContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SecondsTokenContext secondsToken() {
			return GetRuleContext<SecondsTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(CypherParser.FOR, 0); }
		public SubqueryInTransactionsRetryParametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subqueryInTransactionsRetryParameters; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubqueryInTransactionsRetryParameters(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubqueryInTransactionsRetryParametersContext subqueryInTransactionsRetryParameters() {
		SubqueryInTransactionsRetryParametersContext _localctx = new SubqueryInTransactionsRetryParametersContext(Context, State);
		EnterRule(_localctx, 104, RULE_subqueryInTransactionsRetryParameters);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1241;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,70,Context) ) {
			case 1:
				{
				State = 1240;
				Match(FOR);
				}
				break;
			}
			State = 1243;
			expression();
			State = 1244;
			secondsToken();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SubqueryInTransactionsReportParametersContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REPORT() { return GetToken(CypherParser.REPORT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATUS() { return GetToken(CypherParser.STATUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(CypherParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		public SubqueryInTransactionsReportParametersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_subqueryInTransactionsReportParameters; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSubqueryInTransactionsReportParameters(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SubqueryInTransactionsReportParametersContext subqueryInTransactionsReportParameters() {
		SubqueryInTransactionsReportParametersContext _localctx = new SubqueryInTransactionsReportParametersContext(Context, State);
		EnterRule(_localctx, 106, RULE_subqueryInTransactionsReportParameters);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1246;
			Match(REPORT);
			State = 1247;
			Match(STATUS);
			State = 1248;
			Match(AS);
			State = 1249;
			variable();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class OrderBySkipLimitClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public OrderByContext orderBy() {
			return GetRuleContext<OrderByContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SkipContext skip() {
			return GetRuleContext<SkipContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LimitContext limit() {
			return GetRuleContext<LimitContext>(0);
		}
		public OrderBySkipLimitClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_orderBySkipLimitClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOrderBySkipLimitClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public OrderBySkipLimitClauseContext orderBySkipLimitClause() {
		OrderBySkipLimitClauseContext _localctx = new OrderBySkipLimitClauseContext(Context, State);
		EnterRule(_localctx, 108, RULE_orderBySkipLimitClause);
		try {
			State = 1263;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ORDER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1251;
				orderBy();
				State = 1253;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,71,Context) ) {
				case 1:
					{
					State = 1252;
					skip();
					}
					break;
				}
				State = 1256;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,72,Context) ) {
				case 1:
					{
					State = 1255;
					limit();
					}
					break;
				}
				}
				break;
			case OFFSET:
			case SKIPROWS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1258;
				skip();
				State = 1260;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,73,Context) ) {
				case 1:
					{
					State = 1259;
					limit();
					}
					break;
				}
				}
				break;
			case LIMITROWS:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1262;
				limit();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PatternListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PatternContext[] pattern() {
			return GetRuleContexts<PatternContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PatternContext pattern(int i) {
			return GetRuleContext<PatternContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public PatternListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_patternList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPatternList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PatternListContext patternList() {
		PatternListContext _localctx = new PatternListContext(Context, State);
		EnterRule(_localctx, 110, RULE_patternList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1265;
			pattern();
			State = 1270;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1266;
				Match(COMMA);
				State = 1267;
				pattern();
				}
				}
				State = 1272;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InsertPatternListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public InsertPatternContext[] insertPattern() {
			return GetRuleContexts<InsertPatternContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public InsertPatternContext insertPattern(int i) {
			return GetRuleContext<InsertPatternContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public InsertPatternListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insertPatternList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInsertPatternList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InsertPatternListContext insertPatternList() {
		InsertPatternListContext _localctx = new InsertPatternListContext(Context, State);
		EnterRule(_localctx, 112, RULE_insertPatternList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1273;
			insertPattern();
			State = 1278;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1274;
				Match(COMMA);
				State = 1275;
				insertPattern();
				}
				}
				State = 1280;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PatternContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AnonymousPatternContext anonymousPattern() {
			return GetRuleContext<AnonymousPatternContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQ() { return GetToken(CypherParser.EQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SelectorContext selector() {
			return GetRuleContext<SelectorContext>(0);
		}
		public PatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pattern; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPattern(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PatternContext pattern() {
		PatternContext _localctx = new PatternContext(Context, State);
		EnterRule(_localctx, 114, RULE_pattern);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1284;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,77,Context) ) {
			case 1:
				{
				State = 1281;
				variable();
				State = 1282;
				Match(EQ);
				}
				break;
			}
			State = 1287;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL || _la==ANY || _la==SHORTEST) {
				{
				State = 1286;
				selector();
				}
			}

			State = 1289;
			anonymousPattern();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InsertPatternContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public InsertNodePatternContext[] insertNodePattern() {
			return GetRuleContexts<InsertNodePatternContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public InsertNodePatternContext insertNodePattern(int i) {
			return GetRuleContext<InsertNodePatternContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString() {
			return GetRuleContext<SymbolicNameStringContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQ() { return GetToken(CypherParser.EQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public InsertRelationshipPatternContext[] insertRelationshipPattern() {
			return GetRuleContexts<InsertRelationshipPatternContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public InsertRelationshipPatternContext insertRelationshipPattern(int i) {
			return GetRuleContext<InsertRelationshipPatternContext>(i);
		}
		public InsertPatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insertPattern; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInsertPattern(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InsertPatternContext insertPattern() {
		InsertPatternContext _localctx = new InsertPatternContext(Context, State);
		EnterRule(_localctx, 116, RULE_insertPattern);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1294;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ESCAPED_SYMBOLIC_NAME) | (1L << ACCESS) | (1L << ACTIVE) | (1L << ADD) | (1L << ADMIN) | (1L << ADMINISTRATOR) | (1L << ALIAS) | (1L << ALIASES) | (1L << ALL_SHORTEST_PATHS) | (1L << ALL) | (1L << ALLREDUCE) | (1L << ALTER) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASCENDING) | (1L << ASSIGN) | (1L << AT) | (1L << AUTH) | (1L << BINDINGS) | (1L << BOOL) | (1L << BOOLEAN) | (1L << BOOSTED) | (1L << BOTH) | (1L << BREAK) | (1L << BUILT) | (1L << BY) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CHANGE) | (1L << CIDR) | (1L << COLLECT) | (1L << COMMAND) | (1L << COMMANDS) | (1L << COMPOSITE) | (1L << CONCURRENT) | (1L << CONSTRAINT) | (1L << CONSTRAINTS) | (1L << CONTAINS) | (1L << COPY) | (1L << CONTINUE) | (1L << COSINE) | (1L << COUNT) | (1L << CREATE) | (1L << CREDENTIAL) | (1L << CSV) | (1L << CURRENT))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CYPHER - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATABASES - 64)) | (1L << (DATE - 64)) | (1L << (DATETIME - 64)) | (1L << (DBMS - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFINED - 64)) | (1L << (DELETE - 64)) | (1L << (DENY - 64)) | (1L << (DESC - 64)) | (1L << (DESCENDING - 64)) | (1L << (DESTROY - 64)) | (1L << (DETACH - 64)) | (1L << (DIFFERENT - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOT_METRIC - 64)) | (1L << (DRIVER - 64)) | (1L << (DROP - 64)) | (1L << (DRYRUN - 64)) | (1L << (DUMP - 64)) | (1L << (DURATION - 64)) | (1L << (EACH - 64)) | (1L << (EDGE - 64)) | (1L << (ENABLE - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELEMENTS - 64)) | (1L << (ELSE - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (EUCLIDEAN - 64)) | (1L << (EUCLIDEAN_SQUARED - 64)) | (1L << (END - 64)) | (1L << (ENDS - 64)) | (1L << (EXECUTABLE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXIST - 64)) | (1L << (EXISTENCE - 64)) | (1L << (EXISTS - 64)) | (1L << (ERROR - 64)) | (1L << (FAIL - 64)) | (1L << (FALSE - 64)) | (1L << (FIELDTERMINATOR - 64)) | (1L << (FILTER - 64)) | (1L << (FINISH - 64)) | (1L << (FLOAT - 64)) | (1L << (FLOAT64 - 64)) | (1L << (FLOAT32 - 64)) | (1L << (FOR - 64)) | (1L << (FOREACH - 64)) | (1L << (FORWARDING - 64)) | (1L << (FROM - 64)) | (1L << (FULLTEXT - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GRANT - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (GRAPH - 128)) | (1L << (GRAPHS - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPS - 128)) | (1L << (HAMMING - 128)) | (1L << (HEADERS - 128)) | (1L << (HOME - 128)) | (1L << (ID - 128)) | (1L << (IF - 128)) | (1L << (IMPERSONATE - 128)) | (1L << (IMMUTABLE - 128)) | (1L << (IN - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXES - 128)) | (1L << (INF - 128)) | (1L << (INFINITY - 128)) | (1L << (INSERT - 128)) | (1L << (INT - 128)) | (1L << (INT64 - 128)) | (1L << (INT32 - 128)) | (1L << (INT16 - 128)) | (1L << (INT8 - 128)) | (1L << (INTEGER - 128)) | (1L << (INTEGER64 - 128)) | (1L << (INTEGER32 - 128)) | (1L << (INTEGER16 - 128)) | (1L << (INTEGER8 - 128)) | (1L << (IS - 128)) | (1L << (JOIN - 128)) | (1L << (KEY - 128)) | (1L << (LABEL - 128)) | (1L << (LABELS - 128)) | (1L << (LANGUAGE - 128)) | (1L << (LEADING - 128)) | (1L << (LET - 128)) | (1L << (LIMITROWS - 128)) | (1L << (LIST - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOOKUP - 128)) | (1L << (MANAGEMENT - 128)) | (1L << (MANHATTAN - 128)) | (1L << (MAP - 128)) | (1L << (MATCH - 128)) | (1L << (MERGE - 128)) | (1L << (IMPLIES - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NAN - 128)) | (1L << (NFC - 128)) | (1L << (NFD - 128)) | (1L << (NFKC - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (NFKD - 192)) | (1L << (NEW - 192)) | (1L << (NEXT - 192)) | (1L << (NODE - 192)) | (1L << (NODETACH - 192)) | (1L << (NODES - 192)) | (1L << (NONE - 192)) | (1L << (NORMALIZE - 192)) | (1L << (NORMALIZED - 192)) | (1L << (NOT - 192)) | (1L << (NOTHING - 192)) | (1L << (NOWAIT - 192)) | (1L << (NULL - 192)) | (1L << (OF - 192)) | (1L << (OFFSET - 192)) | (1L << (OIDC - 192)) | (1L << (ON - 192)) | (1L << (ONLY - 192)) | (1L << (OPTIONAL - 192)) | (1L << (OPTIONS - 192)) | (1L << (OPTION - 192)) | (1L << (OR - 192)) | (1L << (ORDER - 192)) | (1L << (PASSWORD - 192)) | (1L << (PASSWORDS - 192)) | (1L << (PATH - 192)) | (1L << (PATHS - 192)) | (1L << (PLAINTEXT - 192)) | (1L << (POINT - 192)) | (1L << (POPULATED - 192)) | (1L << (PRIMARY - 192)) | (1L << (PRIMARIES - 192)) | (1L << (PRIVILEGE - 192)) | (1L << (PRIVILEGES - 192)) | (1L << (PROCEDURE - 192)) | (1L << (PROCEDURES - 192)) | (1L << (PROPERTIES - 192)) | (1L << (PROPERTY - 192)) | (1L << (PROVIDER - 192)) | (1L << (PROVIDERS - 192)) | (1L << (RANGE - 192)) | (1L << (READ - 192)) | (1L << (REALLOCATE - 192)) | (1L << (REDUCE - 192)) | (1L << (RENAME - 192)) | (1L << (REL - 192)) | (1L << (RELATIONSHIP - 192)) | (1L << (RELATIONSHIPS - 192)) | (1L << (REMOVE - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (REPLICAS - 192)) | (1L << (REPORT - 192)) | (1L << (REQUIRE - 192)) | (1L << (REQUIRED - 192)) | (1L << (RESTRICT - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (RETRY - 256)) | (1L << (RETURN - 256)) | (1L << (REVOKE - 256)) | (1L << (ROLE - 256)) | (1L << (ROLES - 256)) | (1L << (ROW - 256)) | (1L << (ROWS - 256)) | (1L << (SCAN - 256)) | (1L << (SEC - 256)) | (1L << (SECOND - 256)) | (1L << (SECONDARY - 256)) | (1L << (SECONDARIES - 256)) | (1L << (SECONDS - 256)) | (1L << (SEEK - 256)) | (1L << (SERVER - 256)) | (1L << (SERVERS - 256)) | (1L << (SET - 256)) | (1L << (SETTING - 256)) | (1L << (SETTINGS - 256)) | (1L << (SHARD - 256)) | (1L << (SHARDS - 256)) | (1L << (SHORTEST_PATH - 256)) | (1L << (SHORTEST - 256)) | (1L << (SHOW - 256)) | (1L << (SIGNED - 256)) | (1L << (SINGLE - 256)) | (1L << (SKIPROWS - 256)) | (1L << (START - 256)) | (1L << (STARTS - 256)) | (1L << (STATUS - 256)) | (1L << (STOP - 256)) | (1L << (STRING - 256)) | (1L << (SUPPORTED - 256)) | (1L << (SUSPENDED - 256)) | (1L << (TARGET - 256)) | (1L << (TERMINATE - 256)) | (1L << (TEXT - 256)) | (1L << (THEN - 256)) | (1L << (TIME - 256)) | (1L << (TIMESTAMP - 256)) | (1L << (TIMEZONE - 256)) | (1L << (TO - 256)) | (1L << (TOPOLOGY - 256)) | (1L << (TRAILING - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSACTIONS - 256)) | (1L << (TRAVERSE - 256)) | (1L << (TRIM - 256)) | (1L << (TRUE - 256)) | (1L << (TYPE - 256)) | (1L << (TYPED - 256)) | (1L << (TYPES - 256)) | (1L << (UNION - 256)) | (1L << (UNIQUE - 256)) | (1L << (UNIQUENESS - 256)) | (1L << (UNWIND - 256)) | (1L << (URL - 256)) | (1L << (USE - 256)) | (1L << (USER - 256)) | (1L << (USERS - 256)) | (1L << (USING - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (VALUE - 320)) | (1L << (VARCHAR - 320)) | (1L << (VECTOR - 320)) | (1L << (VECTOR_DISTANCE - 320)) | (1L << (VECTOR_NORM - 320)) | (1L << (VERTEX - 320)) | (1L << (WAIT - 320)) | (1L << (WHEN - 320)) | (1L << (WHERE - 320)) | (1L << (WITH - 320)) | (1L << (WITHOUT - 320)) | (1L << (WRITE - 320)) | (1L << (XOR - 320)) | (1L << (YIELD - 320)) | (1L << (ZONE - 320)) | (1L << (ZONED - 320)) | (1L << (IDENTIFIER - 320)))) != 0)) {
				{
				State = 1291;
				symbolicNameString();
				State = 1292;
				Match(EQ);
				}
			}

			State = 1296;
			insertNodePattern();
			State = 1302;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==LT || _la==MINUS || _la==ARROW_LINE || _la==ARROW_LEFT_HEAD) {
				{
				{
				State = 1297;
				insertRelationshipPattern();
				State = 1298;
				insertNodePattern();
				}
				}
				State = 1304;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QuantifierContext : ParserRuleContext {
		public IToken from;
		public IToken to;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CypherParser.LCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] UNSIGNED_DECIMAL_INTEGER() { return GetTokens(CypherParser.UNSIGNED_DECIMAL_INTEGER); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNSIGNED_DECIMAL_INTEGER(int i) {
			return GetToken(CypherParser.UNSIGNED_DECIMAL_INTEGER, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CypherParser.RCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(CypherParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS() { return GetToken(CypherParser.PLUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMES() { return GetToken(CypherParser.TIMES, 0); }
		public QuantifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_quantifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQuantifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QuantifierContext quantifier() {
		QuantifierContext _localctx = new QuantifierContext(Context, State);
		EnterRule(_localctx, 118, RULE_quantifier);
		int _la;
		try {
			State = 1319;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,83,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1305;
				Match(LCURLY);
				State = 1306;
				Match(UNSIGNED_DECIMAL_INTEGER);
				State = 1307;
				Match(RCURLY);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1308;
				Match(LCURLY);
				State = 1310;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==UNSIGNED_DECIMAL_INTEGER) {
					{
					State = 1309;
					_localctx.from = Match(UNSIGNED_DECIMAL_INTEGER);
					}
				}

				State = 1312;
				Match(COMMA);
				State = 1314;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==UNSIGNED_DECIMAL_INTEGER) {
					{
					State = 1313;
					_localctx.to = Match(UNSIGNED_DECIMAL_INTEGER);
					}
				}

				State = 1316;
				Match(RCURLY);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1317;
				Match(PLUS);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1318;
				Match(TIMES);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AnonymousPatternContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ShortestPathPatternContext shortestPathPattern() {
			return GetRuleContext<ShortestPathPatternContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PatternElementContext patternElement() {
			return GetRuleContext<PatternElementContext>(0);
		}
		public AnonymousPatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_anonymousPattern; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAnonymousPattern(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AnonymousPatternContext anonymousPattern() {
		AnonymousPatternContext _localctx = new AnonymousPatternContext(Context, State);
		EnterRule(_localctx, 120, RULE_anonymousPattern);
		try {
			State = 1323;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALL_SHORTEST_PATHS:
			case SHORTEST_PATH:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1321;
				shortestPathPattern();
				}
				break;
			case LPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1322;
				patternElement();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShortestPathPatternContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PatternElementContext patternElement() {
			return GetRuleContext<PatternElementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHORTEST_PATH() { return GetToken(CypherParser.SHORTEST_PATH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL_SHORTEST_PATHS() { return GetToken(CypherParser.ALL_SHORTEST_PATHS, 0); }
		public ShortestPathPatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shortestPathPattern; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShortestPathPattern(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShortestPathPatternContext shortestPathPattern() {
		ShortestPathPatternContext _localctx = new ShortestPathPatternContext(Context, State);
		EnterRule(_localctx, 122, RULE_shortestPathPattern);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1325;
			_la = TokenStream.LA(1);
			if ( !(_la==ALL_SHORTEST_PATHS || _la==SHORTEST_PATH) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1326;
			Match(LPAREN);
			State = 1327;
			patternElement();
			State = 1328;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PatternElementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NodePatternContext[] nodePattern() {
			return GetRuleContexts<NodePatternContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public NodePatternContext nodePattern(int i) {
			return GetRuleContext<NodePatternContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParenthesizedPathContext[] parenthesizedPath() {
			return GetRuleContexts<ParenthesizedPathContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParenthesizedPathContext parenthesizedPath(int i) {
			return GetRuleContext<ParenthesizedPathContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RelationshipPatternContext[] relationshipPattern() {
			return GetRuleContexts<RelationshipPatternContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public RelationshipPatternContext relationshipPattern(int i) {
			return GetRuleContext<RelationshipPatternContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public QuantifierContext[] quantifier() {
			return GetRuleContexts<QuantifierContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public QuantifierContext quantifier(int i) {
			return GetRuleContext<QuantifierContext>(i);
		}
		public PatternElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_patternElement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPatternElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PatternElementContext patternElement() {
		PatternElementContext _localctx = new PatternElementContext(Context, State);
		EnterRule(_localctx, 124, RULE_patternElement);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1343;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 1343;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,87,Context) ) {
				case 1:
					{
					State = 1330;
					nodePattern();
					State = 1339;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					while (_la==LT || _la==MINUS || _la==ARROW_LINE || _la==ARROW_LEFT_HEAD) {
						{
						{
						State = 1331;
						relationshipPattern();
						State = 1333;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==LCURLY || _la==PLUS || _la==TIMES) {
							{
							State = 1332;
							quantifier();
							}
						}

						State = 1335;
						nodePattern();
						}
						}
						State = 1341;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
					}
					}
					break;
				case 2:
					{
					State = 1342;
					parenthesizedPath();
					}
					break;
				}
				}
				State = 1345;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==LPAREN );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SelectorContext : ParserRuleContext {
		public SelectorContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_selector; } }
	 
		public SelectorContext() { }
		public virtual void CopyFrom(SelectorContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class AllShortestPathContext : SelectorContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(CypherParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHORTEST() { return GetToken(CypherParser.SHORTEST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PathTokenContext pathToken() {
			return GetRuleContext<PathTokenContext>(0);
		}
		public AllShortestPathContext(SelectorContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAllShortestPath(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AnyPathContext : SelectorContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANY() { return GetToken(CypherParser.ANY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NonNegativeIntegerSpecificationContext nonNegativeIntegerSpecification() {
			return GetRuleContext<NonNegativeIntegerSpecificationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PathTokenContext pathToken() {
			return GetRuleContext<PathTokenContext>(0);
		}
		public AnyPathContext(SelectorContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAnyPath(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShortestGroupContext : SelectorContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHORTEST() { return GetToken(CypherParser.SHORTEST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GroupTokenContext groupToken() {
			return GetRuleContext<GroupTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NonNegativeIntegerSpecificationContext nonNegativeIntegerSpecification() {
			return GetRuleContext<NonNegativeIntegerSpecificationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PathTokenContext pathToken() {
			return GetRuleContext<PathTokenContext>(0);
		}
		public ShortestGroupContext(SelectorContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShortestGroup(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AnyShortestPathContext : SelectorContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANY() { return GetToken(CypherParser.ANY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHORTEST() { return GetToken(CypherParser.SHORTEST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PathTokenContext pathToken() {
			return GetRuleContext<PathTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NonNegativeIntegerSpecificationContext nonNegativeIntegerSpecification() {
			return GetRuleContext<NonNegativeIntegerSpecificationContext>(0);
		}
		public AnyShortestPathContext(SelectorContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAnyShortestPath(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class AllPathContext : SelectorContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(CypherParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PathTokenContext pathToken() {
			return GetRuleContext<PathTokenContext>(0);
		}
		public AllPathContext(SelectorContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAllPath(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SelectorContext selector() {
		SelectorContext _localctx = new SelectorContext(Context, State);
		EnterRule(_localctx, 126, RULE_selector);
		int _la;
		try {
			State = 1381;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,97,Context) ) {
			case 1:
				_localctx = new AnyShortestPathContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1347;
				Match(ANY);
				State = 1348;
				Match(SHORTEST);
				State = 1350;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PATH || _la==PATHS) {
					{
					State = 1349;
					pathToken();
					}
				}

				}
				break;
			case 2:
				_localctx = new AllShortestPathContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1352;
				Match(ALL);
				State = 1353;
				Match(SHORTEST);
				State = 1355;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PATH || _la==PATHS) {
					{
					State = 1354;
					pathToken();
					}
				}

				}
				break;
			case 3:
				_localctx = new AnyPathContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1357;
				Match(ANY);
				State = 1359;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==UNSIGNED_DECIMAL_INTEGER || _la==DOLLAR) {
					{
					State = 1358;
					nonNegativeIntegerSpecification();
					}
				}

				State = 1362;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PATH || _la==PATHS) {
					{
					State = 1361;
					pathToken();
					}
				}

				}
				break;
			case 4:
				_localctx = new AllPathContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 1364;
				Match(ALL);
				State = 1366;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PATH || _la==PATHS) {
					{
					State = 1365;
					pathToken();
					}
				}

				}
				break;
			case 5:
				_localctx = new ShortestGroupContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 1368;
				Match(SHORTEST);
				State = 1370;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==UNSIGNED_DECIMAL_INTEGER || _la==DOLLAR) {
					{
					State = 1369;
					nonNegativeIntegerSpecification();
					}
				}

				State = 1373;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PATH || _la==PATHS) {
					{
					State = 1372;
					pathToken();
					}
				}

				State = 1375;
				groupToken();
				}
				break;
			case 6:
				_localctx = new AnyShortestPathContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 1376;
				Match(SHORTEST);
				State = 1377;
				nonNegativeIntegerSpecification();
				State = 1379;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PATH || _la==PATHS) {
					{
					State = 1378;
					pathToken();
					}
				}

				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NonNegativeIntegerSpecificationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNSIGNED_DECIMAL_INTEGER() { return GetToken(CypherParser.UNSIGNED_DECIMAL_INTEGER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParameterContext parameter() {
			return GetRuleContext<ParameterContext>(0);
		}
		public NonNegativeIntegerSpecificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nonNegativeIntegerSpecification; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNonNegativeIntegerSpecification(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NonNegativeIntegerSpecificationContext nonNegativeIntegerSpecification() {
		NonNegativeIntegerSpecificationContext _localctx = new NonNegativeIntegerSpecificationContext(Context, State);
		EnterRule(_localctx, 128, RULE_nonNegativeIntegerSpecification);
		try {
			State = 1385;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UNSIGNED_DECIMAL_INTEGER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1383;
				Match(UNSIGNED_DECIMAL_INTEGER);
				}
				break;
			case DOLLAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1384;
				parameter("INTEGER");
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GroupTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GROUP() { return GetToken(CypherParser.GROUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GROUPS() { return GetToken(CypherParser.GROUPS, 0); }
		public GroupTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_groupToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGroupToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GroupTokenContext groupToken() {
		GroupTokenContext _localctx = new GroupTokenContext(Context, State);
		EnterRule(_localctx, 130, RULE_groupToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1387;
			_la = TokenStream.LA(1);
			if ( !(_la==GROUP || _la==GROUPS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PathTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PATH() { return GetToken(CypherParser.PATH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PATHS() { return GetToken(CypherParser.PATHS, 0); }
		public PathTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pathToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPathToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PathTokenContext pathToken() {
		PathTokenContext _localctx = new PathTokenContext(Context, State);
		EnterRule(_localctx, 132, RULE_pathToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1389;
			_la = TokenStream.LA(1);
			if ( !(_la==PATH || _la==PATHS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PathPatternNonEmptyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NodePatternContext[] nodePattern() {
			return GetRuleContexts<NodePatternContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public NodePatternContext nodePattern(int i) {
			return GetRuleContext<NodePatternContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RelationshipPatternContext[] relationshipPattern() {
			return GetRuleContexts<RelationshipPatternContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public RelationshipPatternContext relationshipPattern(int i) {
			return GetRuleContext<RelationshipPatternContext>(i);
		}
		public PathPatternNonEmptyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pathPatternNonEmpty; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPathPatternNonEmpty(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PathPatternNonEmptyContext pathPatternNonEmpty() {
		PathPatternNonEmptyContext _localctx = new PathPatternNonEmptyContext(Context, State);
		EnterRule(_localctx, 134, RULE_pathPatternNonEmpty);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1391;
			nodePattern();
			State = 1395;
			ErrorHandler.Sync(this);
			_alt = 1;
			do {
				switch (_alt) {
				case 1:
					{
					{
					State = 1392;
					relationshipPattern();
					State = 1393;
					nodePattern();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1397;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,99,Context);
			} while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NodePatternContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHERE() { return GetToken(CypherParser.WHERE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LabelExpressionContext labelExpression() {
			return GetRuleContext<LabelExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropertiesContext properties() {
			return GetRuleContext<PropertiesContext>(0);
		}
		public NodePatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nodePattern; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNodePattern(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NodePatternContext nodePattern() {
		NodePatternContext _localctx = new NodePatternContext(Context, State);
		EnterRule(_localctx, 136, RULE_nodePattern);
		int _la;
		try {
			State = 1419;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,104,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1399;
				Match(LPAREN);
				State = 1400;
				Match(WHERE);
				State = 1401;
				expression();
				State = 1402;
				Match(RPAREN);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1404;
				Match(LPAREN);
				State = 1406;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,100,Context) ) {
				case 1:
					{
					State = 1405;
					variable();
					}
					break;
				}
				State = 1409;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLON || _la==IS) {
					{
					State = 1408;
					labelExpression();
					}
				}

				State = 1412;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DOLLAR || _la==LCURLY) {
					{
					State = 1411;
					properties();
					}
				}

				State = 1416;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHERE) {
					{
					State = 1414;
					Match(WHERE);
					State = 1415;
					expression();
					}
				}

				State = 1418;
				Match(RPAREN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InsertNodePatternContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHERE() { return GetToken(CypherParser.WHERE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public InsertNodeLabelExpressionContext insertNodeLabelExpression() {
			return GetRuleContext<InsertNodeLabelExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MapContext map() {
			return GetRuleContext<MapContext>(0);
		}
		public InsertNodePatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insertNodePattern; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInsertNodePattern(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InsertNodePatternContext insertNodePattern() {
		InsertNodePatternContext _localctx = new InsertNodePatternContext(Context, State);
		EnterRule(_localctx, 138, RULE_insertNodePattern);
		int _la;
		try {
			State = 1437;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,108,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1421;
				Match(LPAREN);
				State = 1422;
				Match(WHERE);
				State = 1423;
				expression();
				State = 1424;
				Match(RPAREN);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1426;
				Match(LPAREN);
				State = 1428;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,105,Context) ) {
				case 1:
					{
					State = 1427;
					variable();
					}
					break;
				}
				State = 1431;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLON || _la==IS) {
					{
					State = 1430;
					insertNodeLabelExpression();
					}
				}

				State = 1434;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LCURLY) {
					{
					State = 1433;
					map();
					}
				}

				State = 1436;
				Match(RPAREN);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParenthesizedPathContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PatternContext pattern() {
			return GetRuleContext<PatternContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHERE() { return GetToken(CypherParser.WHERE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public QuantifierContext quantifier() {
			return GetRuleContext<QuantifierContext>(0);
		}
		public ParenthesizedPathContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parenthesizedPath; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesizedPath(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParenthesizedPathContext parenthesizedPath() {
		ParenthesizedPathContext _localctx = new ParenthesizedPathContext(Context, State);
		EnterRule(_localctx, 140, RULE_parenthesizedPath);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1439;
			Match(LPAREN);
			State = 1440;
			pattern();
			State = 1443;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 1441;
				Match(WHERE);
				State = 1442;
				expression();
				}
			}

			State = 1445;
			Match(RPAREN);
			State = 1447;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LCURLY || _la==PLUS || _la==TIMES) {
				{
				State = 1446;
				quantifier();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NodeLabelsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LabelTypeContext[] labelType() {
			return GetRuleContexts<LabelTypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LabelTypeContext labelType(int i) {
			return GetRuleContext<LabelTypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DynamicLabelTypeContext[] dynamicLabelType() {
			return GetRuleContexts<DynamicLabelTypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DynamicLabelTypeContext dynamicLabelType(int i) {
			return GetRuleContext<DynamicLabelTypeContext>(i);
		}
		public NodeLabelsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nodeLabels; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNodeLabels(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NodeLabelsContext nodeLabels() {
		NodeLabelsContext _localctx = new NodeLabelsContext(Context, State);
		EnterRule(_localctx, 142, RULE_nodeLabels);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1451;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 1451;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,111,Context) ) {
				case 1:
					{
					State = 1449;
					labelType();
					}
					break;
				case 2:
					{
					State = 1450;
					dynamicLabelType();
					}
					break;
				}
				}
				State = 1453;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==COLON );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NodeLabelsIsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(CypherParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString() {
			return GetRuleContext<SymbolicNameStringContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DynamicExpressionContext dynamicExpression() {
			return GetRuleContext<DynamicExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LabelTypeContext[] labelType() {
			return GetRuleContexts<LabelTypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LabelTypeContext labelType(int i) {
			return GetRuleContext<LabelTypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DynamicLabelTypeContext[] dynamicLabelType() {
			return GetRuleContexts<DynamicLabelTypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DynamicLabelTypeContext dynamicLabelType(int i) {
			return GetRuleContext<DynamicLabelTypeContext>(i);
		}
		public NodeLabelsIsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nodeLabelsIs; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNodeLabelsIs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NodeLabelsIsContext nodeLabelsIs() {
		NodeLabelsIsContext _localctx = new NodeLabelsIsContext(Context, State);
		EnterRule(_localctx, 144, RULE_nodeLabelsIs);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1455;
			Match(IS);
			State = 1458;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ESCAPED_SYMBOLIC_NAME:
			case ACCESS:
			case ACTIVE:
			case ADD:
			case ADMIN:
			case ADMINISTRATOR:
			case ALIAS:
			case ALIASES:
			case ALL_SHORTEST_PATHS:
			case ALL:
			case ALLREDUCE:
			case ALTER:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASCENDING:
			case ASSIGN:
			case AT:
			case AUTH:
			case BINDINGS:
			case BOOL:
			case BOOLEAN:
			case BOOSTED:
			case BOTH:
			case BREAK:
			case BUILT:
			case BY:
			case CALL:
			case CASCADE:
			case CASE:
			case CHANGE:
			case CIDR:
			case COLLECT:
			case COMMAND:
			case COMMANDS:
			case COMPOSITE:
			case CONCURRENT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONTAINS:
			case COPY:
			case CONTINUE:
			case COSINE:
			case COUNT:
			case CREATE:
			case CREDENTIAL:
			case CSV:
			case CURRENT:
			case CYPHER:
			case DATA:
			case DATABASE:
			case DATABASES:
			case DATE:
			case DATETIME:
			case DBMS:
			case DEALLOCATE:
			case DEFAULT:
			case DEFINED:
			case DELETE:
			case DENY:
			case DESC:
			case DESCENDING:
			case DESTROY:
			case DETACH:
			case DIFFERENT:
			case DISTINCT:
			case DOT_METRIC:
			case DRIVER:
			case DROP:
			case DRYRUN:
			case DUMP:
			case DURATION:
			case EACH:
			case EDGE:
			case ENABLE:
			case ELEMENT:
			case ELEMENTS:
			case ELSE:
			case ENCRYPTED:
			case EUCLIDEAN:
			case EUCLIDEAN_SQUARED:
			case END:
			case ENDS:
			case EXECUTABLE:
			case EXECUTE:
			case EXIST:
			case EXISTENCE:
			case EXISTS:
			case ERROR:
			case FAIL:
			case FALSE:
			case FIELDTERMINATOR:
			case FILTER:
			case FINISH:
			case FLOAT:
			case FLOAT64:
			case FLOAT32:
			case FOR:
			case FOREACH:
			case FORWARDING:
			case FROM:
			case FULLTEXT:
			case FUNCTION:
			case FUNCTIONS:
			case GRANT:
			case GRAPH:
			case GRAPHS:
			case GROUP:
			case GROUPS:
			case HAMMING:
			case HEADERS:
			case HOME:
			case ID:
			case IF:
			case IMPERSONATE:
			case IMMUTABLE:
			case IN:
			case INDEX:
			case INDEXES:
			case INF:
			case INFINITY:
			case INSERT:
			case INT:
			case INT64:
			case INT32:
			case INT16:
			case INT8:
			case INTEGER:
			case INTEGER64:
			case INTEGER32:
			case INTEGER16:
			case INTEGER8:
			case IS:
			case JOIN:
			case KEY:
			case LABEL:
			case LABELS:
			case LANGUAGE:
			case LEADING:
			case LET:
			case LIMITROWS:
			case LIST:
			case LOAD:
			case LOCAL:
			case LOOKUP:
			case MANAGEMENT:
			case MANHATTAN:
			case MAP:
			case MATCH:
			case MERGE:
			case IMPLIES:
			case NAME:
			case NAMES:
			case NAN:
			case NFC:
			case NFD:
			case NFKC:
			case NFKD:
			case NEW:
			case NEXT:
			case NODE:
			case NODETACH:
			case NODES:
			case NONE:
			case NORMALIZE:
			case NORMALIZED:
			case NOT:
			case NOTHING:
			case NOWAIT:
			case NULL:
			case OF:
			case OFFSET:
			case OIDC:
			case ON:
			case ONLY:
			case OPTIONAL:
			case OPTIONS:
			case OPTION:
			case OR:
			case ORDER:
			case PASSWORD:
			case PASSWORDS:
			case PATH:
			case PATHS:
			case PLAINTEXT:
			case POINT:
			case POPULATED:
			case PRIMARY:
			case PRIMARIES:
			case PRIVILEGE:
			case PRIVILEGES:
			case PROCEDURE:
			case PROCEDURES:
			case PROPERTIES:
			case PROPERTY:
			case PROVIDER:
			case PROVIDERS:
			case RANGE:
			case READ:
			case REALLOCATE:
			case REDUCE:
			case RENAME:
			case REL:
			case RELATIONSHIP:
			case RELATIONSHIPS:
			case REMOVE:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case REPLICAS:
			case REPORT:
			case REQUIRE:
			case REQUIRED:
			case RESTRICT:
			case RETRY:
			case RETURN:
			case REVOKE:
			case ROLE:
			case ROLES:
			case ROW:
			case ROWS:
			case SCAN:
			case SEC:
			case SECOND:
			case SECONDARY:
			case SECONDARIES:
			case SECONDS:
			case SEEK:
			case SERVER:
			case SERVERS:
			case SET:
			case SETTING:
			case SETTINGS:
			case SHARD:
			case SHARDS:
			case SHORTEST_PATH:
			case SHORTEST:
			case SHOW:
			case SIGNED:
			case SINGLE:
			case SKIPROWS:
			case START:
			case STARTS:
			case STATUS:
			case STOP:
			case STRING:
			case SUPPORTED:
			case SUSPENDED:
			case TARGET:
			case TERMINATE:
			case TEXT:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE:
			case TO:
			case TOPOLOGY:
			case TRAILING:
			case TRANSACTION:
			case TRANSACTIONS:
			case TRAVERSE:
			case TRIM:
			case TRUE:
			case TYPE:
			case TYPED:
			case TYPES:
			case UNION:
			case UNIQUE:
			case UNIQUENESS:
			case UNWIND:
			case URL:
			case USE:
			case USER:
			case USERS:
			case USING:
			case VALUE:
			case VARCHAR:
			case VECTOR:
			case VECTOR_DISTANCE:
			case VECTOR_NORM:
			case VERTEX:
			case WAIT:
			case WHEN:
			case WHERE:
			case WITH:
			case WITHOUT:
			case WRITE:
			case XOR:
			case YIELD:
			case ZONE:
			case ZONED:
			case IDENTIFIER:
				{
				State = 1456;
				symbolicNameString();
				}
				break;
			case DOLLAR:
				{
				State = 1457;
				dynamicExpression();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 1464;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COLON) {
				{
				State = 1462;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,114,Context) ) {
				case 1:
					{
					State = 1460;
					labelType();
					}
					break;
				case 2:
					{
					State = 1461;
					dynamicLabelType();
					}
					break;
				}
				}
				State = 1466;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DynamicExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOLLAR() { return GetToken(CypherParser.DOLLAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		public DynamicExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dynamicExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDynamicExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DynamicExpressionContext dynamicExpression() {
		DynamicExpressionContext _localctx = new DynamicExpressionContext(Context, State);
		EnterRule(_localctx, 146, RULE_dynamicExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1467;
			Match(DOLLAR);
			State = 1468;
			Match(LPAREN);
			State = 1469;
			expression();
			State = 1470;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DynamicAnyAllExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOLLAR() { return GetToken(CypherParser.DOLLAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(CypherParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANY() { return GetToken(CypherParser.ANY, 0); }
		public DynamicAnyAllExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dynamicAnyAllExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDynamicAnyAllExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DynamicAnyAllExpressionContext dynamicAnyAllExpression() {
		DynamicAnyAllExpressionContext _localctx = new DynamicAnyAllExpressionContext(Context, State);
		EnterRule(_localctx, 148, RULE_dynamicAnyAllExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1472;
			Match(DOLLAR);
			State = 1474;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL || _la==ANY) {
				{
				State = 1473;
				_la = TokenStream.LA(1);
				if ( !(_la==ALL || _la==ANY) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 1476;
			Match(LPAREN);
			State = 1477;
			expression();
			State = 1478;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DynamicLabelTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(CypherParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DynamicExpressionContext dynamicExpression() {
			return GetRuleContext<DynamicExpressionContext>(0);
		}
		public DynamicLabelTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dynamicLabelType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDynamicLabelType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DynamicLabelTypeContext dynamicLabelType() {
		DynamicLabelTypeContext _localctx = new DynamicLabelTypeContext(Context, State);
		EnterRule(_localctx, 150, RULE_dynamicLabelType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1480;
			Match(COLON);
			State = 1481;
			dynamicExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabelTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(CypherParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString() {
			return GetRuleContext<SymbolicNameStringContext>(0);
		}
		public LabelTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_labelType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabelType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LabelTypeContext labelType() {
		LabelTypeContext _localctx = new LabelTypeContext(Context, State);
		EnterRule(_localctx, 152, RULE_labelType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1483;
			Match(COLON);
			State = 1484;
			symbolicNameString();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RelTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(CypherParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString() {
			return GetRuleContext<SymbolicNameStringContext>(0);
		}
		public RelTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RelTypeContext relType() {
		RelTypeContext _localctx = new RelTypeContext(Context, State);
		EnterRule(_localctx, 154, RULE_relType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1486;
			Match(COLON);
			State = 1487;
			symbolicNameString();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabelOrRelTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(CypherParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString() {
			return GetRuleContext<SymbolicNameStringContext>(0);
		}
		public LabelOrRelTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_labelOrRelType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabelOrRelType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LabelOrRelTypeContext labelOrRelType() {
		LabelOrRelTypeContext _localctx = new LabelOrRelTypeContext(Context, State);
		EnterRule(_localctx, 156, RULE_labelOrRelType);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1489;
			Match(COLON);
			State = 1490;
			symbolicNameString();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public MapContext map() {
			return GetRuleContext<MapContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParameterContext parameter() {
			return GetRuleContext<ParameterContext>(0);
		}
		public PropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_properties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProperties(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertiesContext properties() {
		PropertiesContext _localctx = new PropertiesContext(Context, State);
		EnterRule(_localctx, 158, RULE_properties);
		try {
			State = 1494;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LCURLY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1492;
				map();
				}
				break;
			case DOLLAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1493;
				parameter("ANY");
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RelationshipPatternContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ArrowLineContext[] arrowLine() {
			return GetRuleContexts<ArrowLineContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArrowLineContext arrowLine(int i) {
			return GetRuleContext<ArrowLineContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LeftArrowContext leftArrow() {
			return GetRuleContext<LeftArrowContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CypherParser.LBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHERE() { return GetToken(CypherParser.WHERE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CypherParser.RBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RightArrowContext rightArrow() {
			return GetRuleContext<RightArrowContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LabelExpressionContext labelExpression() {
			return GetRuleContext<LabelExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PathLengthContext pathLength() {
			return GetRuleContext<PathLengthContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropertiesContext properties() {
			return GetRuleContext<PropertiesContext>(0);
		}
		public RelationshipPatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relationshipPattern; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelationshipPattern(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RelationshipPatternContext relationshipPattern() {
		RelationshipPatternContext _localctx = new RelationshipPatternContext(Context, State);
		EnterRule(_localctx, 160, RULE_relationshipPattern);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1497;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LT || _la==ARROW_LEFT_HEAD) {
				{
				State = 1496;
				leftArrow();
				}
			}

			State = 1499;
			arrowLine();
			State = 1523;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,124,Context) ) {
			case 1:
				{
				State = 1500;
				Match(LBRACKET);
				State = 1501;
				Match(WHERE);
				State = 1502;
				expression();
				State = 1503;
				Match(RBRACKET);
				}
				break;
			case 2:
				{
				State = 1505;
				Match(LBRACKET);
				State = 1507;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,119,Context) ) {
				case 1:
					{
					State = 1506;
					variable();
					}
					break;
				}
				State = 1510;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COLON || _la==IS) {
					{
					State = 1509;
					labelExpression();
					}
				}

				State = 1513;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==TIMES) {
					{
					State = 1512;
					pathLength();
					}
				}

				State = 1516;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DOLLAR || _la==LCURLY) {
					{
					State = 1515;
					properties();
					}
				}

				State = 1520;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHERE) {
					{
					State = 1518;
					Match(WHERE);
					State = 1519;
					expression();
					}
				}

				State = 1522;
				Match(RBRACKET);
				}
				break;
			}
			State = 1525;
			arrowLine();
			State = 1527;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==GT || _la==ARROW_RIGHT_HEAD) {
				{
				State = 1526;
				rightArrow();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InsertRelationshipPatternContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ArrowLineContext[] arrowLine() {
			return GetRuleContexts<ArrowLineContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArrowLineContext arrowLine(int i) {
			return GetRuleContext<ArrowLineContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CypherParser.LBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHERE() { return GetToken(CypherParser.WHERE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CypherParser.RBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public InsertRelationshipLabelExpressionContext insertRelationshipLabelExpression() {
			return GetRuleContext<InsertRelationshipLabelExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LeftArrowContext leftArrow() {
			return GetRuleContext<LeftArrowContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RightArrowContext rightArrow() {
			return GetRuleContext<RightArrowContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MapContext map() {
			return GetRuleContext<MapContext>(0);
		}
		public InsertRelationshipPatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insertRelationshipPattern; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInsertRelationshipPattern(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InsertRelationshipPatternContext insertRelationshipPattern() {
		InsertRelationshipPatternContext _localctx = new InsertRelationshipPatternContext(Context, State);
		EnterRule(_localctx, 162, RULE_insertRelationshipPattern);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1530;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LT || _la==ARROW_LEFT_HEAD) {
				{
				State = 1529;
				leftArrow();
				}
			}

			State = 1532;
			arrowLine();
			State = 1548;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,129,Context) ) {
			case 1:
				{
				State = 1533;
				Match(LBRACKET);
				State = 1534;
				Match(WHERE);
				State = 1535;
				expression();
				State = 1536;
				Match(RBRACKET);
				}
				break;
			case 2:
				{
				State = 1538;
				Match(LBRACKET);
				State = 1540;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,127,Context) ) {
				case 1:
					{
					State = 1539;
					variable();
					}
					break;
				}
				State = 1542;
				insertRelationshipLabelExpression();
				State = 1544;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LCURLY) {
					{
					State = 1543;
					map();
					}
				}

				State = 1546;
				Match(RBRACKET);
				}
				break;
			}
			State = 1550;
			arrowLine();
			State = 1552;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==GT || _la==ARROW_RIGHT_HEAD) {
				{
				State = 1551;
				rightArrow();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LeftArrowContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LT() { return GetToken(CypherParser.LT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ARROW_LEFT_HEAD() { return GetToken(CypherParser.ARROW_LEFT_HEAD, 0); }
		public LeftArrowContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_leftArrow; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLeftArrow(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LeftArrowContext leftArrow() {
		LeftArrowContext _localctx = new LeftArrowContext(Context, State);
		EnterRule(_localctx, 164, RULE_leftArrow);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1554;
			_la = TokenStream.LA(1);
			if ( !(_la==LT || _la==ARROW_LEFT_HEAD) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArrowLineContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ARROW_LINE() { return GetToken(CypherParser.ARROW_LINE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(CypherParser.MINUS, 0); }
		public ArrowLineContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arrowLine; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArrowLine(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArrowLineContext arrowLine() {
		ArrowLineContext _localctx = new ArrowLineContext(Context, State);
		EnterRule(_localctx, 166, RULE_arrowLine);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1556;
			_la = TokenStream.LA(1);
			if ( !(_la==MINUS || _la==ARROW_LINE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RightArrowContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GT() { return GetToken(CypherParser.GT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ARROW_RIGHT_HEAD() { return GetToken(CypherParser.ARROW_RIGHT_HEAD, 0); }
		public RightArrowContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_rightArrow; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRightArrow(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RightArrowContext rightArrow() {
		RightArrowContext _localctx = new RightArrowContext(Context, State);
		EnterRule(_localctx, 168, RULE_rightArrow);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1558;
			_la = TokenStream.LA(1);
			if ( !(_la==GT || _la==ARROW_RIGHT_HEAD) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PathLengthContext : ParserRuleContext {
		public IToken from;
		public IToken to;
		public IToken single;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMES() { return GetToken(CypherParser.TIMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOTDOT() { return GetToken(CypherParser.DOTDOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] UNSIGNED_DECIMAL_INTEGER() { return GetTokens(CypherParser.UNSIGNED_DECIMAL_INTEGER); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNSIGNED_DECIMAL_INTEGER(int i) {
			return GetToken(CypherParser.UNSIGNED_DECIMAL_INTEGER, i);
		}
		public PathLengthContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_pathLength; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPathLength(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PathLengthContext pathLength() {
		PathLengthContext _localctx = new PathLengthContext(Context, State);
		EnterRule(_localctx, 170, RULE_pathLength);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1560;
			Match(TIMES);
			State = 1569;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,133,Context) ) {
			case 1:
				{
				State = 1562;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==UNSIGNED_DECIMAL_INTEGER) {
					{
					State = 1561;
					_localctx.from = Match(UNSIGNED_DECIMAL_INTEGER);
					}
				}

				State = 1564;
				Match(DOTDOT);
				State = 1566;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==UNSIGNED_DECIMAL_INTEGER) {
					{
					State = 1565;
					_localctx.to = Match(UNSIGNED_DECIMAL_INTEGER);
					}
				}

				}
				break;
			case 2:
				{
				State = 1568;
				_localctx.single = Match(UNSIGNED_DECIMAL_INTEGER);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabelExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LabelExpression4Context labelExpression4() {
			return GetRuleContext<LabelExpression4Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(CypherParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(CypherParser.IS, 0); }
		public LabelExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_labelExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabelExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LabelExpressionContext labelExpression() {
		LabelExpressionContext _localctx = new LabelExpressionContext(Context, State);
		EnterRule(_localctx, 172, RULE_labelExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1571;
			_la = TokenStream.LA(1);
			if ( !(_la==COLON || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1572;
			labelExpression4();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabelExpression4Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LabelExpression3Context[] labelExpression3() {
			return GetRuleContexts<LabelExpression3Context>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LabelExpression3Context labelExpression3(int i) {
			return GetRuleContext<LabelExpression3Context>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] BAR() { return GetTokens(CypherParser.BAR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BAR(int i) {
			return GetToken(CypherParser.BAR, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COLON() { return GetTokens(CypherParser.COLON); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON(int i) {
			return GetToken(CypherParser.COLON, i);
		}
		public LabelExpression4Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_labelExpression4; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabelExpression4(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LabelExpression4Context labelExpression4() {
		LabelExpression4Context _localctx = new LabelExpression4Context(Context, State);
		EnterRule(_localctx, 174, RULE_labelExpression4);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1574;
			labelExpression3();
			State = 1582;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,135,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1575;
					Match(BAR);
					State = 1577;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COLON) {
						{
						State = 1576;
						Match(COLON);
						}
					}

					State = 1579;
					labelExpression3();
					}
					} 
				}
				State = 1584;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,135,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabelExpression3Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LabelExpression2Context[] labelExpression2() {
			return GetRuleContexts<LabelExpression2Context>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public LabelExpression2Context labelExpression2(int i) {
			return GetRuleContext<LabelExpression2Context>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] AMPERSAND() { return GetTokens(CypherParser.AMPERSAND); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AMPERSAND(int i) {
			return GetToken(CypherParser.AMPERSAND, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COLON() { return GetTokens(CypherParser.COLON); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON(int i) {
			return GetToken(CypherParser.COLON, i);
		}
		public LabelExpression3Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_labelExpression3; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabelExpression3(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LabelExpression3Context labelExpression3() {
		LabelExpression3Context _localctx = new LabelExpression3Context(Context, State);
		EnterRule(_localctx, 176, RULE_labelExpression3);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1585;
			labelExpression2();
			State = 1590;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COLON || _la==AMPERSAND) {
				{
				{
				State = 1586;
				_la = TokenStream.LA(1);
				if ( !(_la==COLON || _la==AMPERSAND) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1587;
				labelExpression2();
				}
				}
				State = 1592;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabelExpression2Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LabelExpression1Context labelExpression1() {
			return GetRuleContext<LabelExpression1Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] EXCLAMATION_MARK() { return GetTokens(CypherParser.EXCLAMATION_MARK); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCLAMATION_MARK(int i) {
			return GetToken(CypherParser.EXCLAMATION_MARK, i);
		}
		public LabelExpression2Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_labelExpression2; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabelExpression2(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LabelExpression2Context labelExpression2() {
		LabelExpression2Context _localctx = new LabelExpression2Context(Context, State);
		EnterRule(_localctx, 178, RULE_labelExpression2);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1596;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==EXCLAMATION_MARK) {
				{
				{
				State = 1593;
				Match(EXCLAMATION_MARK);
				}
				}
				State = 1598;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1599;
			labelExpression1();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabelExpression1Context : ParserRuleContext {
		public LabelExpression1Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_labelExpression1; } }
	 
		public LabelExpression1Context() { }
		public virtual void CopyFrom(LabelExpression1Context context) {
			base.CopyFrom(context);
		}
	}
	public partial class AnyLabelContext : LabelExpression1Context {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENT() { return GetToken(CypherParser.PERCENT, 0); }
		public AnyLabelContext(LabelExpression1Context context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAnyLabel(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DynamicLabelContext : LabelExpression1Context {
		[System.Diagnostics.DebuggerNonUserCode] public DynamicAnyAllExpressionContext dynamicAnyAllExpression() {
			return GetRuleContext<DynamicAnyAllExpressionContext>(0);
		}
		public DynamicLabelContext(LabelExpression1Context context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDynamicLabel(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LabelNameContext : LabelExpression1Context {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString() {
			return GetRuleContext<SymbolicNameStringContext>(0);
		}
		public LabelNameContext(LabelExpression1Context context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabelName(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ParenthesizedLabelExpressionContext : LabelExpression1Context {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LabelExpression4Context labelExpression4() {
			return GetRuleContext<LabelExpression4Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		public ParenthesizedLabelExpressionContext(LabelExpression1Context context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesizedLabelExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LabelExpression1Context labelExpression1() {
		LabelExpression1Context _localctx = new LabelExpression1Context(Context, State);
		EnterRule(_localctx, 180, RULE_labelExpression1);
		try {
			State = 1608;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LPAREN:
				_localctx = new ParenthesizedLabelExpressionContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1601;
				Match(LPAREN);
				State = 1602;
				labelExpression4();
				State = 1603;
				Match(RPAREN);
				}
				break;
			case PERCENT:
				_localctx = new AnyLabelContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1605;
				Match(PERCENT);
				}
				break;
			case DOLLAR:
				_localctx = new DynamicLabelContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1606;
				dynamicAnyAllExpression();
				}
				break;
			case ESCAPED_SYMBOLIC_NAME:
			case ACCESS:
			case ACTIVE:
			case ADD:
			case ADMIN:
			case ADMINISTRATOR:
			case ALIAS:
			case ALIASES:
			case ALL_SHORTEST_PATHS:
			case ALL:
			case ALLREDUCE:
			case ALTER:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASCENDING:
			case ASSIGN:
			case AT:
			case AUTH:
			case BINDINGS:
			case BOOL:
			case BOOLEAN:
			case BOOSTED:
			case BOTH:
			case BREAK:
			case BUILT:
			case BY:
			case CALL:
			case CASCADE:
			case CASE:
			case CHANGE:
			case CIDR:
			case COLLECT:
			case COMMAND:
			case COMMANDS:
			case COMPOSITE:
			case CONCURRENT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONTAINS:
			case COPY:
			case CONTINUE:
			case COSINE:
			case COUNT:
			case CREATE:
			case CREDENTIAL:
			case CSV:
			case CURRENT:
			case CYPHER:
			case DATA:
			case DATABASE:
			case DATABASES:
			case DATE:
			case DATETIME:
			case DBMS:
			case DEALLOCATE:
			case DEFAULT:
			case DEFINED:
			case DELETE:
			case DENY:
			case DESC:
			case DESCENDING:
			case DESTROY:
			case DETACH:
			case DIFFERENT:
			case DISTINCT:
			case DOT_METRIC:
			case DRIVER:
			case DROP:
			case DRYRUN:
			case DUMP:
			case DURATION:
			case EACH:
			case EDGE:
			case ENABLE:
			case ELEMENT:
			case ELEMENTS:
			case ELSE:
			case ENCRYPTED:
			case EUCLIDEAN:
			case EUCLIDEAN_SQUARED:
			case END:
			case ENDS:
			case EXECUTABLE:
			case EXECUTE:
			case EXIST:
			case EXISTENCE:
			case EXISTS:
			case ERROR:
			case FAIL:
			case FALSE:
			case FIELDTERMINATOR:
			case FILTER:
			case FINISH:
			case FLOAT:
			case FLOAT64:
			case FLOAT32:
			case FOR:
			case FOREACH:
			case FORWARDING:
			case FROM:
			case FULLTEXT:
			case FUNCTION:
			case FUNCTIONS:
			case GRANT:
			case GRAPH:
			case GRAPHS:
			case GROUP:
			case GROUPS:
			case HAMMING:
			case HEADERS:
			case HOME:
			case ID:
			case IF:
			case IMPERSONATE:
			case IMMUTABLE:
			case IN:
			case INDEX:
			case INDEXES:
			case INF:
			case INFINITY:
			case INSERT:
			case INT:
			case INT64:
			case INT32:
			case INT16:
			case INT8:
			case INTEGER:
			case INTEGER64:
			case INTEGER32:
			case INTEGER16:
			case INTEGER8:
			case IS:
			case JOIN:
			case KEY:
			case LABEL:
			case LABELS:
			case LANGUAGE:
			case LEADING:
			case LET:
			case LIMITROWS:
			case LIST:
			case LOAD:
			case LOCAL:
			case LOOKUP:
			case MANAGEMENT:
			case MANHATTAN:
			case MAP:
			case MATCH:
			case MERGE:
			case IMPLIES:
			case NAME:
			case NAMES:
			case NAN:
			case NFC:
			case NFD:
			case NFKC:
			case NFKD:
			case NEW:
			case NEXT:
			case NODE:
			case NODETACH:
			case NODES:
			case NONE:
			case NORMALIZE:
			case NORMALIZED:
			case NOT:
			case NOTHING:
			case NOWAIT:
			case NULL:
			case OF:
			case OFFSET:
			case OIDC:
			case ON:
			case ONLY:
			case OPTIONAL:
			case OPTIONS:
			case OPTION:
			case OR:
			case ORDER:
			case PASSWORD:
			case PASSWORDS:
			case PATH:
			case PATHS:
			case PLAINTEXT:
			case POINT:
			case POPULATED:
			case PRIMARY:
			case PRIMARIES:
			case PRIVILEGE:
			case PRIVILEGES:
			case PROCEDURE:
			case PROCEDURES:
			case PROPERTIES:
			case PROPERTY:
			case PROVIDER:
			case PROVIDERS:
			case RANGE:
			case READ:
			case REALLOCATE:
			case REDUCE:
			case RENAME:
			case REL:
			case RELATIONSHIP:
			case RELATIONSHIPS:
			case REMOVE:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case REPLICAS:
			case REPORT:
			case REQUIRE:
			case REQUIRED:
			case RESTRICT:
			case RETRY:
			case RETURN:
			case REVOKE:
			case ROLE:
			case ROLES:
			case ROW:
			case ROWS:
			case SCAN:
			case SEC:
			case SECOND:
			case SECONDARY:
			case SECONDARIES:
			case SECONDS:
			case SEEK:
			case SERVER:
			case SERVERS:
			case SET:
			case SETTING:
			case SETTINGS:
			case SHARD:
			case SHARDS:
			case SHORTEST_PATH:
			case SHORTEST:
			case SHOW:
			case SIGNED:
			case SINGLE:
			case SKIPROWS:
			case START:
			case STARTS:
			case STATUS:
			case STOP:
			case STRING:
			case SUPPORTED:
			case SUSPENDED:
			case TARGET:
			case TERMINATE:
			case TEXT:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE:
			case TO:
			case TOPOLOGY:
			case TRAILING:
			case TRANSACTION:
			case TRANSACTIONS:
			case TRAVERSE:
			case TRIM:
			case TRUE:
			case TYPE:
			case TYPED:
			case TYPES:
			case UNION:
			case UNIQUE:
			case UNIQUENESS:
			case UNWIND:
			case URL:
			case USE:
			case USER:
			case USERS:
			case USING:
			case VALUE:
			case VARCHAR:
			case VECTOR:
			case VECTOR_DISTANCE:
			case VECTOR_NORM:
			case VERTEX:
			case WAIT:
			case WHEN:
			case WHERE:
			case WITH:
			case WITHOUT:
			case WRITE:
			case XOR:
			case YIELD:
			case ZONE:
			case ZONED:
			case IDENTIFIER:
				_localctx = new LabelNameContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 1607;
				symbolicNameString();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InsertNodeLabelExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext[] symbolicNameString() {
			return GetRuleContexts<SymbolicNameStringContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString(int i) {
			return GetRuleContext<SymbolicNameStringContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COLON() { return GetTokens(CypherParser.COLON); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON(int i) {
			return GetToken(CypherParser.COLON, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(CypherParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] AMPERSAND() { return GetTokens(CypherParser.AMPERSAND); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AMPERSAND(int i) {
			return GetToken(CypherParser.AMPERSAND, i);
		}
		public InsertNodeLabelExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insertNodeLabelExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInsertNodeLabelExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InsertNodeLabelExpressionContext insertNodeLabelExpression() {
		InsertNodeLabelExpressionContext _localctx = new InsertNodeLabelExpressionContext(Context, State);
		EnterRule(_localctx, 182, RULE_insertNodeLabelExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1610;
			_la = TokenStream.LA(1);
			if ( !(_la==COLON || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1611;
			symbolicNameString();
			State = 1616;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COLON || _la==AMPERSAND) {
				{
				{
				State = 1612;
				_la = TokenStream.LA(1);
				if ( !(_la==COLON || _la==AMPERSAND) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1613;
				symbolicNameString();
				}
				}
				State = 1618;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class InsertRelationshipLabelExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString() {
			return GetRuleContext<SymbolicNameStringContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(CypherParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(CypherParser.IS, 0); }
		public InsertRelationshipLabelExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_insertRelationshipLabelExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitInsertRelationshipLabelExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public InsertRelationshipLabelExpressionContext insertRelationshipLabelExpression() {
		InsertRelationshipLabelExpressionContext _localctx = new InsertRelationshipLabelExpressionContext(Context, State);
		EnterRule(_localctx, 184, RULE_insertRelationshipLabelExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1619;
			_la = TokenStream.LA(1);
			if ( !(_la==COLON || _la==IS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1620;
			symbolicNameString();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Expression11Context[] expression11() {
			return GetRuleContexts<Expression11Context>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Expression11Context expression11(int i) {
			return GetRuleContext<Expression11Context>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] OR() { return GetTokens(CypherParser.OR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR(int i) {
			return GetToken(CypherParser.OR, i);
		}
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		ExpressionContext _localctx = new ExpressionContext(Context, State);
		EnterRule(_localctx, 186, RULE_expression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1622;
			expression11();
			State = 1627;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==OR) {
				{
				{
				State = 1623;
				Match(OR);
				State = 1624;
				expression11();
				}
				}
				State = 1629;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expression11Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Expression10Context[] expression10() {
			return GetRuleContexts<Expression10Context>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Expression10Context expression10(int i) {
			return GetRuleContext<Expression10Context>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] XOR() { return GetTokens(CypherParser.XOR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XOR(int i) {
			return GetToken(CypherParser.XOR, i);
		}
		public Expression11Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression11; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression11(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Expression11Context expression11() {
		Expression11Context _localctx = new Expression11Context(Context, State);
		EnterRule(_localctx, 188, RULE_expression11);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1630;
			expression10();
			State = 1635;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==XOR) {
				{
				{
				State = 1631;
				Match(XOR);
				State = 1632;
				expression10();
				}
				}
				State = 1637;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expression10Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Expression9Context[] expression9() {
			return GetRuleContexts<Expression9Context>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Expression9Context expression9(int i) {
			return GetRuleContext<Expression9Context>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] AND() { return GetTokens(CypherParser.AND); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND(int i) {
			return GetToken(CypherParser.AND, i);
		}
		public Expression10Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression10; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression10(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Expression10Context expression10() {
		Expression10Context _localctx = new Expression10Context(Context, State);
		EnterRule(_localctx, 190, RULE_expression10);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1638;
			expression9();
			State = 1643;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==AND) {
				{
				{
				State = 1639;
				Match(AND);
				State = 1640;
				expression9();
				}
				}
				State = 1645;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expression9Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Expression8Context expression8() {
			return GetRuleContext<Expression8Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] NOT() { return GetTokens(CypherParser.NOT); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT(int i) {
			return GetToken(CypherParser.NOT, i);
		}
		public Expression9Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression9; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression9(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Expression9Context expression9() {
		Expression9Context _localctx = new Expression9Context(Context, State);
		EnterRule(_localctx, 192, RULE_expression9);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 1649;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,143,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 1646;
					Match(NOT);
					}
					} 
				}
				State = 1651;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,143,Context);
			}
			State = 1652;
			expression8();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expression8Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Expression7Context[] expression7() {
			return GetRuleContexts<Expression7Context>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Expression7Context expression7(int i) {
			return GetRuleContext<Expression7Context>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] EQ() { return GetTokens(CypherParser.EQ); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQ(int i) {
			return GetToken(CypherParser.EQ, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] INVALID_NEQ() { return GetTokens(CypherParser.INVALID_NEQ); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INVALID_NEQ(int i) {
			return GetToken(CypherParser.INVALID_NEQ, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] NEQ() { return GetTokens(CypherParser.NEQ); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEQ(int i) {
			return GetToken(CypherParser.NEQ, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LE() { return GetTokens(CypherParser.LE); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LE(int i) {
			return GetToken(CypherParser.LE, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] GE() { return GetTokens(CypherParser.GE); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GE(int i) {
			return GetToken(CypherParser.GE, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LT() { return GetTokens(CypherParser.LT); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LT(int i) {
			return GetToken(CypherParser.LT, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] GT() { return GetTokens(CypherParser.GT); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GT(int i) {
			return GetToken(CypherParser.GT, i);
		}
		public Expression8Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression8; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression8(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Expression8Context expression8() {
		Expression8Context _localctx = new Expression8Context(Context, State);
		EnterRule(_localctx, 194, RULE_expression8);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1654;
			expression7();
			State = 1659;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (((((_la - 104)) & ~0x3f) == 0 && ((1L << (_la - 104)) & ((1L << (EQ - 104)) | (1L << (GE - 104)) | (1L << (GT - 104)) | (1L << (LE - 104)))) != 0) || ((((_la - 175)) & ~0x3f) == 0 && ((1L << (_la - 175)) & ((1L << (LT - 175)) | (1L << (INVALID_NEQ - 175)) | (1L << (NEQ - 175)))) != 0)) {
				{
				{
				State = 1655;
				_la = TokenStream.LA(1);
				if ( !(((((_la - 104)) & ~0x3f) == 0 && ((1L << (_la - 104)) & ((1L << (EQ - 104)) | (1L << (GE - 104)) | (1L << (GT - 104)) | (1L << (LE - 104)))) != 0) || ((((_la - 175)) & ~0x3f) == 0 && ((1L << (_la - 175)) & ((1L << (LT - 175)) | (1L << (INVALID_NEQ - 175)) | (1L << (NEQ - 175)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1656;
				expression7();
				}
				}
				State = 1661;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expression7Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Expression6Context expression6() {
			return GetRuleContext<Expression6Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComparisonExpression6Context comparisonExpression6() {
			return GetRuleContext<ComparisonExpression6Context>(0);
		}
		public Expression7Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression7; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression7(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Expression7Context expression7() {
		Expression7Context _localctx = new Expression7Context(Context, State);
		EnterRule(_localctx, 196, RULE_expression7);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1662;
			expression6();
			State = 1664;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << COLON) | (1L << COLONCOLON) | (1L << CONTAINS))) != 0) || ((((_la - 103)) & ~0x3f) == 0 && ((1L << (_la - 103)) & ((1L << (ENDS - 103)) | (1L << (IN - 103)) | (1L << (IS - 103)))) != 0) || _la==REGEQ || _la==STARTS) {
				{
				State = 1663;
				comparisonExpression6();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComparisonExpression6Context : ParserRuleContext {
		public ComparisonExpression6Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_comparisonExpression6; } }
	 
		public ComparisonExpression6Context() { }
		public virtual void CopyFrom(ComparisonExpression6Context context) {
			base.CopyFrom(context);
		}
	}
	public partial class TypeComparisonContext : ComparisonExpression6Context {
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(CypherParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLONCOLON() { return GetToken(CypherParser.COLONCOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPED() { return GetToken(CypherParser.TYPED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(CypherParser.NOT, 0); }
		public TypeComparisonContext(ComparisonExpression6Context context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeComparison(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StringAndListComparisonContext : ComparisonExpression6Context {
		[System.Diagnostics.DebuggerNonUserCode] public Expression6Context expression6() {
			return GetRuleContext<Expression6Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REGEQ() { return GetToken(CypherParser.REGEQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STARTS() { return GetToken(CypherParser.STARTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(CypherParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENDS() { return GetToken(CypherParser.ENDS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTAINS() { return GetToken(CypherParser.CONTAINS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(CypherParser.IN, 0); }
		public StringAndListComparisonContext(ComparisonExpression6Context context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStringAndListComparison(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NormalFormComparisonContext : ComparisonExpression6Context {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(CypherParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NORMALIZED() { return GetToken(CypherParser.NORMALIZED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(CypherParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NormalFormContext normalForm() {
			return GetRuleContext<NormalFormContext>(0);
		}
		public NormalFormComparisonContext(ComparisonExpression6Context context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNormalFormComparison(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class LabelComparisonContext : ComparisonExpression6Context {
		[System.Diagnostics.DebuggerNonUserCode] public LabelExpressionContext labelExpression() {
			return GetRuleContext<LabelExpressionContext>(0);
		}
		public LabelComparisonContext(ComparisonExpression6Context context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabelComparison(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class NullComparisonContext : ComparisonExpression6Context {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(CypherParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(CypherParser.NULL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(CypherParser.NOT, 0); }
		public NullComparisonContext(ComparisonExpression6Context context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNullComparison(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ComparisonExpression6Context comparisonExpression6() {
		ComparisonExpression6Context _localctx = new ComparisonExpression6Context(Context, State);
		EnterRule(_localctx, 198, RULE_comparisonExpression6);
		int _la;
		try {
			State = 1699;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,152,Context) ) {
			case 1:
				_localctx = new StringAndListComparisonContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1673;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case REGEQ:
					{
					State = 1666;
					Match(REGEQ);
					}
					break;
				case STARTS:
					{
					State = 1667;
					Match(STARTS);
					State = 1668;
					Match(WITH);
					}
					break;
				case ENDS:
					{
					State = 1669;
					Match(ENDS);
					State = 1670;
					Match(WITH);
					}
					break;
				case CONTAINS:
					{
					State = 1671;
					Match(CONTAINS);
					}
					break;
				case IN:
					{
					State = 1672;
					Match(IN);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1675;
				expression6();
				}
				break;
			case 2:
				_localctx = new NullComparisonContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1676;
				Match(IS);
				State = 1678;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 1677;
					Match(NOT);
					}
				}

				State = 1680;
				Match(NULL);
				}
				break;
			case 3:
				_localctx = new TypeComparisonContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1687;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case IS:
					{
					State = 1681;
					Match(IS);
					State = 1683;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==NOT) {
						{
						State = 1682;
						Match(NOT);
						}
					}

					State = 1685;
					_la = TokenStream.LA(1);
					if ( !(_la==COLONCOLON || _la==TYPED) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				case COLONCOLON:
					{
					State = 1686;
					Match(COLONCOLON);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 1689;
				type();
				}
				break;
			case 4:
				_localctx = new NormalFormComparisonContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 1690;
				Match(IS);
				State = 1692;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==NOT) {
					{
					State = 1691;
					Match(NOT);
					}
				}

				State = 1695;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 189)) & ~0x3f) == 0 && ((1L << (_la - 189)) & ((1L << (NFC - 189)) | (1L << (NFD - 189)) | (1L << (NFKC - 189)) | (1L << (NFKD - 189)))) != 0)) {
					{
					State = 1694;
					normalForm();
					}
				}

				State = 1697;
				Match(NORMALIZED);
				}
				break;
			case 5:
				_localctx = new LabelComparisonContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 1698;
				labelExpression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NormalFormContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NFC() { return GetToken(CypherParser.NFC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NFD() { return GetToken(CypherParser.NFD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NFKC() { return GetToken(CypherParser.NFKC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NFKD() { return GetToken(CypherParser.NFKD, 0); }
		public NormalFormContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_normalForm; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNormalForm(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NormalFormContext normalForm() {
		NormalFormContext _localctx = new NormalFormContext(Context, State);
		EnterRule(_localctx, 200, RULE_normalForm);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1701;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 189)) & ~0x3f) == 0 && ((1L << (_la - 189)) & ((1L << (NFC - 189)) | (1L << (NFD - 189)) | (1L << (NFKC - 189)) | (1L << (NFKD - 189)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expression6Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Expression5Context[] expression5() {
			return GetRuleContexts<Expression5Context>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Expression5Context expression5(int i) {
			return GetRuleContext<Expression5Context>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] PLUS() { return GetTokens(CypherParser.PLUS); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS(int i) {
			return GetToken(CypherParser.PLUS, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] MINUS() { return GetTokens(CypherParser.MINUS); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS(int i) {
			return GetToken(CypherParser.MINUS, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] DOUBLEBAR() { return GetTokens(CypherParser.DOUBLEBAR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOUBLEBAR(int i) {
			return GetToken(CypherParser.DOUBLEBAR, i);
		}
		public Expression6Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression6; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression6(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Expression6Context expression6() {
		Expression6Context _localctx = new Expression6Context(Context, State);
		EnterRule(_localctx, 202, RULE_expression6);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1703;
			expression5();
			State = 1708;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DOUBLEBAR || _la==MINUS || _la==PLUS) {
				{
				{
				State = 1704;
				_la = TokenStream.LA(1);
				if ( !(_la==DOUBLEBAR || _la==MINUS || _la==PLUS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1705;
				expression5();
				}
				}
				State = 1710;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expression5Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Expression4Context[] expression4() {
			return GetRuleContexts<Expression4Context>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Expression4Context expression4(int i) {
			return GetRuleContext<Expression4Context>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] TIMES() { return GetTokens(CypherParser.TIMES); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMES(int i) {
			return GetToken(CypherParser.TIMES, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] DIVIDE() { return GetTokens(CypherParser.DIVIDE); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIVIDE(int i) {
			return GetToken(CypherParser.DIVIDE, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] PERCENT() { return GetTokens(CypherParser.PERCENT); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PERCENT(int i) {
			return GetToken(CypherParser.PERCENT, i);
		}
		public Expression5Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression5; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression5(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Expression5Context expression5() {
		Expression5Context _localctx = new Expression5Context(Context, State);
		EnterRule(_localctx, 204, RULE_expression5);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1711;
			expression4();
			State = 1716;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DIVIDE || _la==PERCENT || _la==TIMES) {
				{
				{
				State = 1712;
				_la = TokenStream.LA(1);
				if ( !(_la==DIVIDE || _la==PERCENT || _la==TIMES) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1713;
				expression4();
				}
				}
				State = 1718;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expression4Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Expression3Context[] expression3() {
			return GetRuleContexts<Expression3Context>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Expression3Context expression3(int i) {
			return GetRuleContext<Expression3Context>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] POW() { return GetTokens(CypherParser.POW); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode POW(int i) {
			return GetToken(CypherParser.POW, i);
		}
		public Expression4Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression4; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression4(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Expression4Context expression4() {
		Expression4Context _localctx = new Expression4Context(Context, State);
		EnterRule(_localctx, 206, RULE_expression4);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1719;
			expression3();
			State = 1724;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==POW) {
				{
				{
				State = 1720;
				Match(POW);
				State = 1721;
				expression3();
				}
				}
				State = 1726;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expression3Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Expression2Context expression2() {
			return GetRuleContext<Expression2Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLUS() { return GetToken(CypherParser.PLUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(CypherParser.MINUS, 0); }
		public Expression3Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression3; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression3(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Expression3Context expression3() {
		Expression3Context _localctx = new Expression3Context(Context, State);
		EnterRule(_localctx, 208, RULE_expression3);
		int _la;
		try {
			State = 1730;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,156,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1727;
				expression2();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1728;
				_la = TokenStream.LA(1);
				if ( !(_la==MINUS || _la==PLUS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1729;
				expression2();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expression2Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Expression1Context expression1() {
			return GetRuleContext<Expression1Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PostFixContext[] postFix() {
			return GetRuleContexts<PostFixContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PostFixContext postFix(int i) {
			return GetRuleContext<PostFixContext>(i);
		}
		public Expression2Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression2; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression2(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Expression2Context expression2() {
		Expression2Context _localctx = new Expression2Context(Context, State);
		EnterRule(_localctx, 210, RULE_expression2);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1732;
			expression1();
			State = 1736;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DOT || _la==LBRACKET) {
				{
				{
				State = 1733;
				postFix();
				}
				}
				State = 1738;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PostFixContext : ParserRuleContext {
		public PostFixContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_postFix; } }
	 
		public PostFixContext() { }
		public virtual void CopyFrom(PostFixContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class IndexPostfixContext : PostFixContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CypherParser.LBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CypherParser.RBRACKET, 0); }
		public IndexPostfixContext(PostFixContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexPostfix(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class PropertyPostfixContext : PostFixContext {
		[System.Diagnostics.DebuggerNonUserCode] public PropertyContext property() {
			return GetRuleContext<PropertyContext>(0);
		}
		public PropertyPostfixContext(PostFixContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertyPostfix(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RangePostfixContext : PostFixContext {
		public ExpressionContext fromExp;
		public ExpressionContext toExp;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CypherParser.LBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOTDOT() { return GetToken(CypherParser.DOTDOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CypherParser.RBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public RangePostfixContext(PostFixContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRangePostfix(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PostFixContext postFix() {
		PostFixContext _localctx = new PostFixContext(Context, State);
		EnterRule(_localctx, 212, RULE_postFix);
		int _la;
		try {
			State = 1753;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,160,Context) ) {
			case 1:
				_localctx = new PropertyPostfixContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1739;
				property();
				}
				break;
			case 2:
				_localctx = new IndexPostfixContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1740;
				Match(LBRACKET);
				State = 1741;
				expression();
				State = 1742;
				Match(RBRACKET);
				}
				break;
			case 3:
				_localctx = new RangePostfixContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1744;
				Match(LBRACKET);
				State = 1746;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << DECIMAL_DOUBLE) | (1L << UNSIGNED_DECIMAL_INTEGER) | (1L << UNSIGNED_HEX_INTEGER) | (1L << UNSIGNED_OCTAL_INTEGER) | (1L << STRING_LITERAL1) | (1L << STRING_LITERAL2) | (1L << ESCAPED_SYMBOLIC_NAME) | (1L << ACCESS) | (1L << ACTIVE) | (1L << ADD) | (1L << ADMIN) | (1L << ADMINISTRATOR) | (1L << ALIAS) | (1L << ALIASES) | (1L << ALL_SHORTEST_PATHS) | (1L << ALL) | (1L << ALLREDUCE) | (1L << ALTER) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASCENDING) | (1L << ASSIGN) | (1L << AT) | (1L << AUTH) | (1L << BINDINGS) | (1L << BOOL) | (1L << BOOLEAN) | (1L << BOOSTED) | (1L << BOTH) | (1L << BREAK) | (1L << BUILT) | (1L << BY) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CHANGE) | (1L << CIDR) | (1L << COLLECT) | (1L << COMMAND) | (1L << COMMANDS) | (1L << COMPOSITE) | (1L << CONCURRENT) | (1L << CONSTRAINT) | (1L << CONSTRAINTS) | (1L << CONTAINS) | (1L << COPY) | (1L << CONTINUE) | (1L << COSINE) | (1L << COUNT) | (1L << CREATE) | (1L << CREDENTIAL) | (1L << CSV) | (1L << CURRENT))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CYPHER - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATABASES - 64)) | (1L << (DATE - 64)) | (1L << (DATETIME - 64)) | (1L << (DBMS - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFINED - 64)) | (1L << (DELETE - 64)) | (1L << (DENY - 64)) | (1L << (DESC - 64)) | (1L << (DESCENDING - 64)) | (1L << (DESTROY - 64)) | (1L << (DETACH - 64)) | (1L << (DIFFERENT - 64)) | (1L << (DOLLAR - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOT_METRIC - 64)) | (1L << (DRIVER - 64)) | (1L << (DROP - 64)) | (1L << (DRYRUN - 64)) | (1L << (DUMP - 64)) | (1L << (DURATION - 64)) | (1L << (EACH - 64)) | (1L << (EDGE - 64)) | (1L << (ENABLE - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELEMENTS - 64)) | (1L << (ELSE - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (EUCLIDEAN - 64)) | (1L << (EUCLIDEAN_SQUARED - 64)) | (1L << (END - 64)) | (1L << (ENDS - 64)) | (1L << (EXECUTABLE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXIST - 64)) | (1L << (EXISTENCE - 64)) | (1L << (EXISTS - 64)) | (1L << (ERROR - 64)) | (1L << (FAIL - 64)) | (1L << (FALSE - 64)) | (1L << (FIELDTERMINATOR - 64)) | (1L << (FILTER - 64)) | (1L << (FINISH - 64)) | (1L << (FLOAT - 64)) | (1L << (FLOAT64 - 64)) | (1L << (FLOAT32 - 64)) | (1L << (FOR - 64)) | (1L << (FOREACH - 64)) | (1L << (FORWARDING - 64)) | (1L << (FROM - 64)) | (1L << (FULLTEXT - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GRANT - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (GRAPH - 128)) | (1L << (GRAPHS - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPS - 128)) | (1L << (HAMMING - 128)) | (1L << (HEADERS - 128)) | (1L << (HOME - 128)) | (1L << (ID - 128)) | (1L << (IF - 128)) | (1L << (IMPERSONATE - 128)) | (1L << (IMMUTABLE - 128)) | (1L << (IN - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXES - 128)) | (1L << (INF - 128)) | (1L << (INFINITY - 128)) | (1L << (INSERT - 128)) | (1L << (INT - 128)) | (1L << (INT64 - 128)) | (1L << (INT32 - 128)) | (1L << (INT16 - 128)) | (1L << (INT8 - 128)) | (1L << (INTEGER - 128)) | (1L << (INTEGER64 - 128)) | (1L << (INTEGER32 - 128)) | (1L << (INTEGER16 - 128)) | (1L << (INTEGER8 - 128)) | (1L << (IS - 128)) | (1L << (JOIN - 128)) | (1L << (KEY - 128)) | (1L << (LABEL - 128)) | (1L << (LABELS - 128)) | (1L << (LANGUAGE - 128)) | (1L << (LBRACKET - 128)) | (1L << (LCURLY - 128)) | (1L << (LEADING - 128)) | (1L << (LET - 128)) | (1L << (LIMITROWS - 128)) | (1L << (LIST - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOOKUP - 128)) | (1L << (LPAREN - 128)) | (1L << (MANAGEMENT - 128)) | (1L << (MANHATTAN - 128)) | (1L << (MAP - 128)) | (1L << (MATCH - 128)) | (1L << (MERGE - 128)) | (1L << (MINUS - 128)) | (1L << (IMPLIES - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NAN - 128)) | (1L << (NFC - 128)) | (1L << (NFD - 128)) | (1L << (NFKC - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (NFKD - 192)) | (1L << (NEW - 192)) | (1L << (NEXT - 192)) | (1L << (NODE - 192)) | (1L << (NODETACH - 192)) | (1L << (NODES - 192)) | (1L << (NONE - 192)) | (1L << (NORMALIZE - 192)) | (1L << (NORMALIZED - 192)) | (1L << (NOT - 192)) | (1L << (NOTHING - 192)) | (1L << (NOWAIT - 192)) | (1L << (NULL - 192)) | (1L << (OF - 192)) | (1L << (OFFSET - 192)) | (1L << (OIDC - 192)) | (1L << (ON - 192)) | (1L << (ONLY - 192)) | (1L << (OPTIONAL - 192)) | (1L << (OPTIONS - 192)) | (1L << (OPTION - 192)) | (1L << (OR - 192)) | (1L << (ORDER - 192)) | (1L << (PASSWORD - 192)) | (1L << (PASSWORDS - 192)) | (1L << (PATH - 192)) | (1L << (PATHS - 192)) | (1L << (PLAINTEXT - 192)) | (1L << (PLUS - 192)) | (1L << (POINT - 192)) | (1L << (POPULATED - 192)) | (1L << (PRIMARY - 192)) | (1L << (PRIMARIES - 192)) | (1L << (PRIVILEGE - 192)) | (1L << (PRIVILEGES - 192)) | (1L << (PROCEDURE - 192)) | (1L << (PROCEDURES - 192)) | (1L << (PROPERTIES - 192)) | (1L << (PROPERTY - 192)) | (1L << (PROVIDER - 192)) | (1L << (PROVIDERS - 192)) | (1L << (RANGE - 192)) | (1L << (READ - 192)) | (1L << (REALLOCATE - 192)) | (1L << (REDUCE - 192)) | (1L << (RENAME - 192)) | (1L << (REL - 192)) | (1L << (RELATIONSHIP - 192)) | (1L << (RELATIONSHIPS - 192)) | (1L << (REMOVE - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (REPLICAS - 192)) | (1L << (REPORT - 192)) | (1L << (REQUIRE - 192)) | (1L << (REQUIRED - 192)) | (1L << (RESTRICT - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (RETRY - 256)) | (1L << (RETURN - 256)) | (1L << (REVOKE - 256)) | (1L << (ROLE - 256)) | (1L << (ROLES - 256)) | (1L << (ROW - 256)) | (1L << (ROWS - 256)) | (1L << (SCAN - 256)) | (1L << (SEC - 256)) | (1L << (SECOND - 256)) | (1L << (SECONDARY - 256)) | (1L << (SECONDARIES - 256)) | (1L << (SECONDS - 256)) | (1L << (SEEK - 256)) | (1L << (SERVER - 256)) | (1L << (SERVERS - 256)) | (1L << (SET - 256)) | (1L << (SETTING - 256)) | (1L << (SETTINGS - 256)) | (1L << (SHARD - 256)) | (1L << (SHARDS - 256)) | (1L << (SHORTEST_PATH - 256)) | (1L << (SHORTEST - 256)) | (1L << (SHOW - 256)) | (1L << (SIGNED - 256)) | (1L << (SINGLE - 256)) | (1L << (SKIPROWS - 256)) | (1L << (START - 256)) | (1L << (STARTS - 256)) | (1L << (STATUS - 256)) | (1L << (STOP - 256)) | (1L << (STRING - 256)) | (1L << (SUPPORTED - 256)) | (1L << (SUSPENDED - 256)) | (1L << (TARGET - 256)) | (1L << (TERMINATE - 256)) | (1L << (TEXT - 256)) | (1L << (THEN - 256)) | (1L << (TIME - 256)) | (1L << (TIMESTAMP - 256)) | (1L << (TIMEZONE - 256)) | (1L << (TO - 256)) | (1L << (TOPOLOGY - 256)) | (1L << (TRAILING - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSACTIONS - 256)) | (1L << (TRAVERSE - 256)) | (1L << (TRIM - 256)) | (1L << (TRUE - 256)) | (1L << (TYPE - 256)) | (1L << (TYPED - 256)) | (1L << (TYPES - 256)) | (1L << (UNION - 256)) | (1L << (UNIQUE - 256)) | (1L << (UNIQUENESS - 256)) | (1L << (UNWIND - 256)) | (1L << (URL - 256)) | (1L << (USE - 256)) | (1L << (USER - 256)) | (1L << (USERS - 256)) | (1L << (USING - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (VALUE - 320)) | (1L << (VARCHAR - 320)) | (1L << (VECTOR - 320)) | (1L << (VECTOR_DISTANCE - 320)) | (1L << (VECTOR_NORM - 320)) | (1L << (VERTEX - 320)) | (1L << (WAIT - 320)) | (1L << (WHEN - 320)) | (1L << (WHERE - 320)) | (1L << (WITH - 320)) | (1L << (WITHOUT - 320)) | (1L << (WRITE - 320)) | (1L << (XOR - 320)) | (1L << (YIELD - 320)) | (1L << (ZONE - 320)) | (1L << (ZONED - 320)) | (1L << (IDENTIFIER - 320)))) != 0)) {
					{
					State = 1745;
					((RangePostfixContext)_localctx).fromExp = expression();
					}
				}

				State = 1748;
				Match(DOTDOT);
				State = 1750;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << DECIMAL_DOUBLE) | (1L << UNSIGNED_DECIMAL_INTEGER) | (1L << UNSIGNED_HEX_INTEGER) | (1L << UNSIGNED_OCTAL_INTEGER) | (1L << STRING_LITERAL1) | (1L << STRING_LITERAL2) | (1L << ESCAPED_SYMBOLIC_NAME) | (1L << ACCESS) | (1L << ACTIVE) | (1L << ADD) | (1L << ADMIN) | (1L << ADMINISTRATOR) | (1L << ALIAS) | (1L << ALIASES) | (1L << ALL_SHORTEST_PATHS) | (1L << ALL) | (1L << ALLREDUCE) | (1L << ALTER) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASCENDING) | (1L << ASSIGN) | (1L << AT) | (1L << AUTH) | (1L << BINDINGS) | (1L << BOOL) | (1L << BOOLEAN) | (1L << BOOSTED) | (1L << BOTH) | (1L << BREAK) | (1L << BUILT) | (1L << BY) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CHANGE) | (1L << CIDR) | (1L << COLLECT) | (1L << COMMAND) | (1L << COMMANDS) | (1L << COMPOSITE) | (1L << CONCURRENT) | (1L << CONSTRAINT) | (1L << CONSTRAINTS) | (1L << CONTAINS) | (1L << COPY) | (1L << CONTINUE) | (1L << COSINE) | (1L << COUNT) | (1L << CREATE) | (1L << CREDENTIAL) | (1L << CSV) | (1L << CURRENT))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CYPHER - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATABASES - 64)) | (1L << (DATE - 64)) | (1L << (DATETIME - 64)) | (1L << (DBMS - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFINED - 64)) | (1L << (DELETE - 64)) | (1L << (DENY - 64)) | (1L << (DESC - 64)) | (1L << (DESCENDING - 64)) | (1L << (DESTROY - 64)) | (1L << (DETACH - 64)) | (1L << (DIFFERENT - 64)) | (1L << (DOLLAR - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOT_METRIC - 64)) | (1L << (DRIVER - 64)) | (1L << (DROP - 64)) | (1L << (DRYRUN - 64)) | (1L << (DUMP - 64)) | (1L << (DURATION - 64)) | (1L << (EACH - 64)) | (1L << (EDGE - 64)) | (1L << (ENABLE - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELEMENTS - 64)) | (1L << (ELSE - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (EUCLIDEAN - 64)) | (1L << (EUCLIDEAN_SQUARED - 64)) | (1L << (END - 64)) | (1L << (ENDS - 64)) | (1L << (EXECUTABLE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXIST - 64)) | (1L << (EXISTENCE - 64)) | (1L << (EXISTS - 64)) | (1L << (ERROR - 64)) | (1L << (FAIL - 64)) | (1L << (FALSE - 64)) | (1L << (FIELDTERMINATOR - 64)) | (1L << (FILTER - 64)) | (1L << (FINISH - 64)) | (1L << (FLOAT - 64)) | (1L << (FLOAT64 - 64)) | (1L << (FLOAT32 - 64)) | (1L << (FOR - 64)) | (1L << (FOREACH - 64)) | (1L << (FORWARDING - 64)) | (1L << (FROM - 64)) | (1L << (FULLTEXT - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GRANT - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (GRAPH - 128)) | (1L << (GRAPHS - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPS - 128)) | (1L << (HAMMING - 128)) | (1L << (HEADERS - 128)) | (1L << (HOME - 128)) | (1L << (ID - 128)) | (1L << (IF - 128)) | (1L << (IMPERSONATE - 128)) | (1L << (IMMUTABLE - 128)) | (1L << (IN - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXES - 128)) | (1L << (INF - 128)) | (1L << (INFINITY - 128)) | (1L << (INSERT - 128)) | (1L << (INT - 128)) | (1L << (INT64 - 128)) | (1L << (INT32 - 128)) | (1L << (INT16 - 128)) | (1L << (INT8 - 128)) | (1L << (INTEGER - 128)) | (1L << (INTEGER64 - 128)) | (1L << (INTEGER32 - 128)) | (1L << (INTEGER16 - 128)) | (1L << (INTEGER8 - 128)) | (1L << (IS - 128)) | (1L << (JOIN - 128)) | (1L << (KEY - 128)) | (1L << (LABEL - 128)) | (1L << (LABELS - 128)) | (1L << (LANGUAGE - 128)) | (1L << (LBRACKET - 128)) | (1L << (LCURLY - 128)) | (1L << (LEADING - 128)) | (1L << (LET - 128)) | (1L << (LIMITROWS - 128)) | (1L << (LIST - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOOKUP - 128)) | (1L << (LPAREN - 128)) | (1L << (MANAGEMENT - 128)) | (1L << (MANHATTAN - 128)) | (1L << (MAP - 128)) | (1L << (MATCH - 128)) | (1L << (MERGE - 128)) | (1L << (MINUS - 128)) | (1L << (IMPLIES - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NAN - 128)) | (1L << (NFC - 128)) | (1L << (NFD - 128)) | (1L << (NFKC - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (NFKD - 192)) | (1L << (NEW - 192)) | (1L << (NEXT - 192)) | (1L << (NODE - 192)) | (1L << (NODETACH - 192)) | (1L << (NODES - 192)) | (1L << (NONE - 192)) | (1L << (NORMALIZE - 192)) | (1L << (NORMALIZED - 192)) | (1L << (NOT - 192)) | (1L << (NOTHING - 192)) | (1L << (NOWAIT - 192)) | (1L << (NULL - 192)) | (1L << (OF - 192)) | (1L << (OFFSET - 192)) | (1L << (OIDC - 192)) | (1L << (ON - 192)) | (1L << (ONLY - 192)) | (1L << (OPTIONAL - 192)) | (1L << (OPTIONS - 192)) | (1L << (OPTION - 192)) | (1L << (OR - 192)) | (1L << (ORDER - 192)) | (1L << (PASSWORD - 192)) | (1L << (PASSWORDS - 192)) | (1L << (PATH - 192)) | (1L << (PATHS - 192)) | (1L << (PLAINTEXT - 192)) | (1L << (PLUS - 192)) | (1L << (POINT - 192)) | (1L << (POPULATED - 192)) | (1L << (PRIMARY - 192)) | (1L << (PRIMARIES - 192)) | (1L << (PRIVILEGE - 192)) | (1L << (PRIVILEGES - 192)) | (1L << (PROCEDURE - 192)) | (1L << (PROCEDURES - 192)) | (1L << (PROPERTIES - 192)) | (1L << (PROPERTY - 192)) | (1L << (PROVIDER - 192)) | (1L << (PROVIDERS - 192)) | (1L << (RANGE - 192)) | (1L << (READ - 192)) | (1L << (REALLOCATE - 192)) | (1L << (REDUCE - 192)) | (1L << (RENAME - 192)) | (1L << (REL - 192)) | (1L << (RELATIONSHIP - 192)) | (1L << (RELATIONSHIPS - 192)) | (1L << (REMOVE - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (REPLICAS - 192)) | (1L << (REPORT - 192)) | (1L << (REQUIRE - 192)) | (1L << (REQUIRED - 192)) | (1L << (RESTRICT - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (RETRY - 256)) | (1L << (RETURN - 256)) | (1L << (REVOKE - 256)) | (1L << (ROLE - 256)) | (1L << (ROLES - 256)) | (1L << (ROW - 256)) | (1L << (ROWS - 256)) | (1L << (SCAN - 256)) | (1L << (SEC - 256)) | (1L << (SECOND - 256)) | (1L << (SECONDARY - 256)) | (1L << (SECONDARIES - 256)) | (1L << (SECONDS - 256)) | (1L << (SEEK - 256)) | (1L << (SERVER - 256)) | (1L << (SERVERS - 256)) | (1L << (SET - 256)) | (1L << (SETTING - 256)) | (1L << (SETTINGS - 256)) | (1L << (SHARD - 256)) | (1L << (SHARDS - 256)) | (1L << (SHORTEST_PATH - 256)) | (1L << (SHORTEST - 256)) | (1L << (SHOW - 256)) | (1L << (SIGNED - 256)) | (1L << (SINGLE - 256)) | (1L << (SKIPROWS - 256)) | (1L << (START - 256)) | (1L << (STARTS - 256)) | (1L << (STATUS - 256)) | (1L << (STOP - 256)) | (1L << (STRING - 256)) | (1L << (SUPPORTED - 256)) | (1L << (SUSPENDED - 256)) | (1L << (TARGET - 256)) | (1L << (TERMINATE - 256)) | (1L << (TEXT - 256)) | (1L << (THEN - 256)) | (1L << (TIME - 256)) | (1L << (TIMESTAMP - 256)) | (1L << (TIMEZONE - 256)) | (1L << (TO - 256)) | (1L << (TOPOLOGY - 256)) | (1L << (TRAILING - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSACTIONS - 256)) | (1L << (TRAVERSE - 256)) | (1L << (TRIM - 256)) | (1L << (TRUE - 256)) | (1L << (TYPE - 256)) | (1L << (TYPED - 256)) | (1L << (TYPES - 256)) | (1L << (UNION - 256)) | (1L << (UNIQUE - 256)) | (1L << (UNIQUENESS - 256)) | (1L << (UNWIND - 256)) | (1L << (URL - 256)) | (1L << (USE - 256)) | (1L << (USER - 256)) | (1L << (USERS - 256)) | (1L << (USING - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (VALUE - 320)) | (1L << (VARCHAR - 320)) | (1L << (VECTOR - 320)) | (1L << (VECTOR_DISTANCE - 320)) | (1L << (VECTOR_NORM - 320)) | (1L << (VERTEX - 320)) | (1L << (WAIT - 320)) | (1L << (WHEN - 320)) | (1L << (WHERE - 320)) | (1L << (WITH - 320)) | (1L << (WITHOUT - 320)) | (1L << (WRITE - 320)) | (1L << (XOR - 320)) | (1L << (YIELD - 320)) | (1L << (ZONE - 320)) | (1L << (ZONED - 320)) | (1L << (IDENTIFIER - 320)))) != 0)) {
					{
					State = 1749;
					((RangePostfixContext)_localctx).toExp = expression();
					}
				}

				State = 1752;
				Match(RBRACKET);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(CypherParser.DOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropertyKeyNameContext propertyKeyName() {
			return GetRuleContext<PropertyKeyNameContext>(0);
		}
		public PropertyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_property; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProperty(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertyContext property() {
		PropertyContext _localctx = new PropertyContext(Context, State);
		EnterRule(_localctx, 214, RULE_property);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1755;
			Match(DOT);
			State = 1756;
			propertyKeyName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DynamicPropertyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CypherParser.LBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CypherParser.RBRACKET, 0); }
		public DynamicPropertyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dynamicProperty; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDynamicProperty(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DynamicPropertyContext dynamicProperty() {
		DynamicPropertyContext _localctx = new DynamicPropertyContext(Context, State);
		EnterRule(_localctx, 216, RULE_dynamicProperty);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1758;
			Match(LBRACKET);
			State = 1759;
			expression();
			State = 1760;
			Match(RBRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertyExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Expression1Context expression1() {
			return GetRuleContext<Expression1Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropertyContext[] property() {
			return GetRuleContexts<PropertyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropertyContext property(int i) {
			return GetRuleContext<PropertyContext>(i);
		}
		public PropertyExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertyExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertyExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertyExpressionContext propertyExpression() {
		PropertyExpressionContext _localctx = new PropertyExpressionContext(Context, State);
		EnterRule(_localctx, 218, RULE_propertyExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1762;
			expression1();
			State = 1764;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 1763;
				property();
				}
				}
				State = 1766;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==DOT );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DynamicPropertyExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Expression1Context expression1() {
			return GetRuleContext<Expression1Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DynamicPropertyContext dynamicProperty() {
			return GetRuleContext<DynamicPropertyContext>(0);
		}
		public DynamicPropertyExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dynamicPropertyExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDynamicPropertyExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DynamicPropertyExpressionContext dynamicPropertyExpression() {
		DynamicPropertyExpressionContext _localctx = new DynamicPropertyExpressionContext(Context, State);
		EnterRule(_localctx, 220, RULE_dynamicPropertyExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1768;
			expression1();
			State = 1769;
			dynamicProperty();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Expression1Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LiteralContext literal() {
			return GetRuleContext<LiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParameterContext parameter() {
			return GetRuleContext<ParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CaseExpressionContext caseExpression() {
			return GetRuleContext<CaseExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExtendedCaseExpressionContext extendedCaseExpression() {
			return GetRuleContext<ExtendedCaseExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CountStarContext countStar() {
			return GetRuleContext<CountStarContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExistsExpressionContext existsExpression() {
			return GetRuleContext<ExistsExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CountExpressionContext countExpression() {
			return GetRuleContext<CountExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CollectExpressionContext collectExpression() {
			return GetRuleContext<CollectExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MapProjectionContext mapProjection() {
			return GetRuleContext<MapProjectionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ListComprehensionContext listComprehension() {
			return GetRuleContext<ListComprehensionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ListLiteralContext listLiteral() {
			return GetRuleContext<ListLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PatternComprehensionContext patternComprehension() {
			return GetRuleContext<PatternComprehensionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReduceExpressionContext reduceExpression() {
			return GetRuleContext<ReduceExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AllReduceExpressionContext allReduceExpression() {
			return GetRuleContext<AllReduceExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ListItemsPredicateContext listItemsPredicate() {
			return GetRuleContext<ListItemsPredicateContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NormalizeFunctionContext normalizeFunction() {
			return GetRuleContext<NormalizeFunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VectorFunctionContext vectorFunction() {
			return GetRuleContext<VectorFunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VectorDistanceFunctionContext vectorDistanceFunction() {
			return GetRuleContext<VectorDistanceFunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VectorNormFunctionContext vectorNormFunction() {
			return GetRuleContext<VectorNormFunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TrimFunctionContext trimFunction() {
			return GetRuleContext<TrimFunctionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PatternExpressionContext patternExpression() {
			return GetRuleContext<PatternExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShortestPathExpressionContext shortestPathExpression() {
			return GetRuleContext<ShortestPathExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParenthesizedExpressionContext parenthesizedExpression() {
			return GetRuleContext<ParenthesizedExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionInvocationContext functionInvocation() {
			return GetRuleContext<FunctionInvocationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		public Expression1Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression1; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression1(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Expression1Context expression1() {
		Expression1Context _localctx = new Expression1Context(Context, State);
		EnterRule(_localctx, 222, RULE_expression1);
		try {
			State = 1796;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,162,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1771;
				literal();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1772;
				parameter("ANY");
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 1773;
				caseExpression();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 1774;
				extendedCaseExpression();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 1775;
				countStar();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 1776;
				existsExpression();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 1777;
				countExpression();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 1778;
				collectExpression();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 1779;
				mapProjection();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 1780;
				listComprehension();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 1781;
				listLiteral();
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 1782;
				patternComprehension();
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 1783;
				reduceExpression();
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 1784;
				allReduceExpression();
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 1785;
				listItemsPredicate();
				}
				break;
			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 1786;
				normalizeFunction();
				}
				break;
			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 1787;
				vectorFunction();
				}
				break;
			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 1788;
				vectorDistanceFunction();
				}
				break;
			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 1789;
				vectorNormFunction();
				}
				break;
			case 20:
				EnterOuterAlt(_localctx, 20);
				{
				State = 1790;
				trimFunction();
				}
				break;
			case 21:
				EnterOuterAlt(_localctx, 21);
				{
				State = 1791;
				patternExpression();
				}
				break;
			case 22:
				EnterOuterAlt(_localctx, 22);
				{
				State = 1792;
				shortestPathExpression();
				}
				break;
			case 23:
				EnterOuterAlt(_localctx, 23);
				{
				State = 1793;
				parenthesizedExpression();
				}
				break;
			case 24:
				EnterOuterAlt(_localctx, 24);
				{
				State = 1794;
				functionInvocation();
				}
				break;
			case 25:
				EnterOuterAlt(_localctx, 25);
				{
				State = 1795;
				variable();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LiteralContext : ParserRuleContext {
		public LiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_literal; } }
	 
		public LiteralContext() { }
		public virtual void CopyFrom(LiteralContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class NummericLiteralContext : LiteralContext {
		[System.Diagnostics.DebuggerNonUserCode] public NumberLiteralContext numberLiteral() {
			return GetRuleContext<NumberLiteralContext>(0);
		}
		public NummericLiteralContext(LiteralContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNummericLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class BooleanLiteralContext : LiteralContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUE() { return GetToken(CypherParser.TRUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FALSE() { return GetToken(CypherParser.FALSE, 0); }
		public BooleanLiteralContext(LiteralContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitBooleanLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class KeywordLiteralContext : LiteralContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INF() { return GetToken(CypherParser.INF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INFINITY() { return GetToken(CypherParser.INFINITY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NAN() { return GetToken(CypherParser.NAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(CypherParser.NULL, 0); }
		public KeywordLiteralContext(LiteralContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitKeywordLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class OtherLiteralContext : LiteralContext {
		[System.Diagnostics.DebuggerNonUserCode] public MapContext map() {
			return GetRuleContext<MapContext>(0);
		}
		public OtherLiteralContext(LiteralContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitOtherLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class StringsLiteralContext : LiteralContext {
		[System.Diagnostics.DebuggerNonUserCode] public StringLiteralContext stringLiteral() {
			return GetRuleContext<StringLiteralContext>(0);
		}
		public StringsLiteralContext(LiteralContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStringsLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LiteralContext literal() {
		LiteralContext _localctx = new LiteralContext(Context, State);
		EnterRule(_localctx, 224, RULE_literal);
		try {
			State = 1807;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DECIMAL_DOUBLE:
			case UNSIGNED_DECIMAL_INTEGER:
			case UNSIGNED_HEX_INTEGER:
			case UNSIGNED_OCTAL_INTEGER:
			case MINUS:
				_localctx = new NummericLiteralContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1798;
				numberLiteral();
				}
				break;
			case STRING_LITERAL1:
			case STRING_LITERAL2:
				_localctx = new StringsLiteralContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1799;
				stringLiteral();
				}
				break;
			case LCURLY:
				_localctx = new OtherLiteralContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1800;
				map();
				}
				break;
			case TRUE:
				_localctx = new BooleanLiteralContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 1801;
				Match(TRUE);
				}
				break;
			case FALSE:
				_localctx = new BooleanLiteralContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 1802;
				Match(FALSE);
				}
				break;
			case INF:
				_localctx = new KeywordLiteralContext(_localctx);
				EnterOuterAlt(_localctx, 6);
				{
				State = 1803;
				Match(INF);
				}
				break;
			case INFINITY:
				_localctx = new KeywordLiteralContext(_localctx);
				EnterOuterAlt(_localctx, 7);
				{
				State = 1804;
				Match(INFINITY);
				}
				break;
			case NAN:
				_localctx = new KeywordLiteralContext(_localctx);
				EnterOuterAlt(_localctx, 8);
				{
				State = 1805;
				Match(NAN);
				}
				break;
			case NULL:
				_localctx = new KeywordLiteralContext(_localctx);
				EnterOuterAlt(_localctx, 9);
				{
				State = 1806;
				Match(NULL);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASE() { return GetToken(CypherParser.CASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode END() { return GetToken(CypherParser.END, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CaseAlternativeContext[] caseAlternative() {
			return GetRuleContexts<CaseAlternativeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public CaseAlternativeContext caseAlternative(int i) {
			return GetRuleContext<CaseAlternativeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(CypherParser.ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public CaseExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCaseExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CaseExpressionContext caseExpression() {
		CaseExpressionContext _localctx = new CaseExpressionContext(Context, State);
		EnterRule(_localctx, 226, RULE_caseExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1809;
			Match(CASE);
			State = 1811;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 1810;
				caseAlternative();
				}
				}
				State = 1813;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			State = 1817;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 1815;
				Match(ELSE);
				State = 1816;
				expression();
				}
			}

			State = 1819;
			Match(END);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CaseAlternativeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(CypherParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(CypherParser.THEN, 0); }
		public CaseAlternativeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_caseAlternative; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCaseAlternative(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CaseAlternativeContext caseAlternative() {
		CaseAlternativeContext _localctx = new CaseAlternativeContext(Context, State);
		EnterRule(_localctx, 228, RULE_caseAlternative);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1821;
			Match(WHEN);
			State = 1822;
			expression();
			State = 1823;
			Match(THEN);
			State = 1824;
			expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExtendedCaseExpressionContext : ParserRuleContext {
		public ExpressionContext elseExp;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASE() { return GetToken(CypherParser.CASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode END() { return GetToken(CypherParser.END, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExtendedCaseAlternativeContext[] extendedCaseAlternative() {
			return GetRuleContexts<ExtendedCaseAlternativeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExtendedCaseAlternativeContext extendedCaseAlternative(int i) {
			return GetRuleContext<ExtendedCaseAlternativeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(CypherParser.ELSE, 0); }
		public ExtendedCaseExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_extendedCaseExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExtendedCaseExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExtendedCaseExpressionContext extendedCaseExpression() {
		ExtendedCaseExpressionContext _localctx = new ExtendedCaseExpressionContext(Context, State);
		EnterRule(_localctx, 230, RULE_extendedCaseExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1826;
			Match(CASE);
			State = 1827;
			expression();
			State = 1829;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 1828;
				extendedCaseAlternative();
				}
				}
				State = 1831;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==WHEN );
			State = 1835;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ELSE) {
				{
				State = 1833;
				Match(ELSE);
				State = 1834;
				_localctx.elseExp = expression();
				}
			}

			State = 1837;
			Match(END);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExtendedCaseAlternativeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(CypherParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExtendedWhenContext[] extendedWhen() {
			return GetRuleContexts<ExtendedWhenContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExtendedWhenContext extendedWhen(int i) {
			return GetRuleContext<ExtendedWhenContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(CypherParser.THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public ExtendedCaseAlternativeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_extendedCaseAlternative; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExtendedCaseAlternative(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExtendedCaseAlternativeContext extendedCaseAlternative() {
		ExtendedCaseAlternativeContext _localctx = new ExtendedCaseAlternativeContext(Context, State);
		EnterRule(_localctx, 232, RULE_extendedCaseAlternative);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1839;
			Match(WHEN);
			State = 1840;
			extendedWhen();
			State = 1845;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 1841;
				Match(COMMA);
				State = 1842;
				extendedWhen();
				}
				}
				State = 1847;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1848;
			Match(THEN);
			State = 1849;
			expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExtendedWhenContext : ParserRuleContext {
		public ExtendedWhenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_extendedWhen; } }
	 
		public ExtendedWhenContext() { }
		public virtual void CopyFrom(ExtendedWhenContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class WhenSimpleComparisonContext : ExtendedWhenContext {
		[System.Diagnostics.DebuggerNonUserCode] public Expression7Context expression7() {
			return GetRuleContext<Expression7Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQ() { return GetToken(CypherParser.EQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INVALID_NEQ() { return GetToken(CypherParser.INVALID_NEQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEQ() { return GetToken(CypherParser.NEQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LE() { return GetToken(CypherParser.LE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GE() { return GetToken(CypherParser.GE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LT() { return GetToken(CypherParser.LT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GT() { return GetToken(CypherParser.GT, 0); }
		public WhenSimpleComparisonContext(ExtendedWhenContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhenSimpleComparison(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class WhenEqualsContext : ExtendedWhenContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public WhenEqualsContext(ExtendedWhenContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhenEquals(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class WhenAdvancedComparisonContext : ExtendedWhenContext {
		[System.Diagnostics.DebuggerNonUserCode] public ComparisonExpression6Context comparisonExpression6() {
			return GetRuleContext<ComparisonExpression6Context>(0);
		}
		public WhenAdvancedComparisonContext(ExtendedWhenContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWhenAdvancedComparison(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExtendedWhenContext extendedWhen() {
		ExtendedWhenContext _localctx = new ExtendedWhenContext(Context, State);
		EnterRule(_localctx, 234, RULE_extendedWhen);
		int _la;
		try {
			State = 1855;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,169,Context) ) {
			case 1:
				_localctx = new WhenSimpleComparisonContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 1851;
				_la = TokenStream.LA(1);
				if ( !(((((_la - 104)) & ~0x3f) == 0 && ((1L << (_la - 104)) & ((1L << (EQ - 104)) | (1L << (GE - 104)) | (1L << (GT - 104)) | (1L << (LE - 104)))) != 0) || ((((_la - 175)) & ~0x3f) == 0 && ((1L << (_la - 175)) & ((1L << (LT - 175)) | (1L << (INVALID_NEQ - 175)) | (1L << (NEQ - 175)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1852;
				expression7();
				}
				break;
			case 2:
				_localctx = new WhenAdvancedComparisonContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 1853;
				comparisonExpression6();
				}
				break;
			case 3:
				_localctx = new WhenEqualsContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 1854;
				expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ListComprehensionContext : ParserRuleContext {
		public ExpressionContext whereExp;
		public ExpressionContext barExp;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CypherParser.LBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(CypherParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CypherParser.RBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BAR() { return GetToken(CypherParser.BAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHERE() { return GetToken(CypherParser.WHERE, 0); }
		public ListComprehensionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_listComprehension; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitListComprehension(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ListComprehensionContext listComprehension() {
		ListComprehensionContext _localctx = new ListComprehensionContext(Context, State);
		EnterRule(_localctx, 236, RULE_listComprehension);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1857;
			Match(LBRACKET);
			State = 1858;
			variable();
			State = 1859;
			Match(IN);
			State = 1860;
			expression();
			State = 1871;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,172,Context) ) {
			case 1:
				{
				State = 1863;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHERE) {
					{
					State = 1861;
					Match(WHERE);
					State = 1862;
					_localctx.whereExp = expression();
					}
				}

				State = 1865;
				Match(BAR);
				State = 1866;
				_localctx.barExp = expression();
				}
				break;
			case 2:
				{
				State = 1869;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHERE) {
					{
					State = 1867;
					Match(WHERE);
					State = 1868;
					_localctx.whereExp = expression();
					}
				}

				}
				break;
			}
			State = 1873;
			Match(RBRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PatternComprehensionContext : ParserRuleContext {
		public ExpressionContext whereExp;
		public ExpressionContext barExp;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CypherParser.LBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PathPatternNonEmptyContext pathPatternNonEmpty() {
			return GetRuleContext<PathPatternNonEmptyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BAR() { return GetToken(CypherParser.BAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CypherParser.RBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQ() { return GetToken(CypherParser.EQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHERE() { return GetToken(CypherParser.WHERE, 0); }
		public PatternComprehensionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_patternComprehension; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPatternComprehension(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PatternComprehensionContext patternComprehension() {
		PatternComprehensionContext _localctx = new PatternComprehensionContext(Context, State);
		EnterRule(_localctx, 238, RULE_patternComprehension);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1875;
			Match(LBRACKET);
			State = 1879;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ESCAPED_SYMBOLIC_NAME) | (1L << ACCESS) | (1L << ACTIVE) | (1L << ADD) | (1L << ADMIN) | (1L << ADMINISTRATOR) | (1L << ALIAS) | (1L << ALIASES) | (1L << ALL_SHORTEST_PATHS) | (1L << ALL) | (1L << ALLREDUCE) | (1L << ALTER) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASCENDING) | (1L << ASSIGN) | (1L << AT) | (1L << AUTH) | (1L << BINDINGS) | (1L << BOOL) | (1L << BOOLEAN) | (1L << BOOSTED) | (1L << BOTH) | (1L << BREAK) | (1L << BUILT) | (1L << BY) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CHANGE) | (1L << CIDR) | (1L << COLLECT) | (1L << COMMAND) | (1L << COMMANDS) | (1L << COMPOSITE) | (1L << CONCURRENT) | (1L << CONSTRAINT) | (1L << CONSTRAINTS) | (1L << CONTAINS) | (1L << COPY) | (1L << CONTINUE) | (1L << COSINE) | (1L << COUNT) | (1L << CREATE) | (1L << CREDENTIAL) | (1L << CSV) | (1L << CURRENT))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CYPHER - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATABASES - 64)) | (1L << (DATE - 64)) | (1L << (DATETIME - 64)) | (1L << (DBMS - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFINED - 64)) | (1L << (DELETE - 64)) | (1L << (DENY - 64)) | (1L << (DESC - 64)) | (1L << (DESCENDING - 64)) | (1L << (DESTROY - 64)) | (1L << (DETACH - 64)) | (1L << (DIFFERENT - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOT_METRIC - 64)) | (1L << (DRIVER - 64)) | (1L << (DROP - 64)) | (1L << (DRYRUN - 64)) | (1L << (DUMP - 64)) | (1L << (DURATION - 64)) | (1L << (EACH - 64)) | (1L << (EDGE - 64)) | (1L << (ENABLE - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELEMENTS - 64)) | (1L << (ELSE - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (EUCLIDEAN - 64)) | (1L << (EUCLIDEAN_SQUARED - 64)) | (1L << (END - 64)) | (1L << (ENDS - 64)) | (1L << (EXECUTABLE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXIST - 64)) | (1L << (EXISTENCE - 64)) | (1L << (EXISTS - 64)) | (1L << (ERROR - 64)) | (1L << (FAIL - 64)) | (1L << (FALSE - 64)) | (1L << (FIELDTERMINATOR - 64)) | (1L << (FILTER - 64)) | (1L << (FINISH - 64)) | (1L << (FLOAT - 64)) | (1L << (FLOAT64 - 64)) | (1L << (FLOAT32 - 64)) | (1L << (FOR - 64)) | (1L << (FOREACH - 64)) | (1L << (FORWARDING - 64)) | (1L << (FROM - 64)) | (1L << (FULLTEXT - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GRANT - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (GRAPH - 128)) | (1L << (GRAPHS - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPS - 128)) | (1L << (HAMMING - 128)) | (1L << (HEADERS - 128)) | (1L << (HOME - 128)) | (1L << (ID - 128)) | (1L << (IF - 128)) | (1L << (IMPERSONATE - 128)) | (1L << (IMMUTABLE - 128)) | (1L << (IN - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXES - 128)) | (1L << (INF - 128)) | (1L << (INFINITY - 128)) | (1L << (INSERT - 128)) | (1L << (INT - 128)) | (1L << (INT64 - 128)) | (1L << (INT32 - 128)) | (1L << (INT16 - 128)) | (1L << (INT8 - 128)) | (1L << (INTEGER - 128)) | (1L << (INTEGER64 - 128)) | (1L << (INTEGER32 - 128)) | (1L << (INTEGER16 - 128)) | (1L << (INTEGER8 - 128)) | (1L << (IS - 128)) | (1L << (JOIN - 128)) | (1L << (KEY - 128)) | (1L << (LABEL - 128)) | (1L << (LABELS - 128)) | (1L << (LANGUAGE - 128)) | (1L << (LEADING - 128)) | (1L << (LET - 128)) | (1L << (LIMITROWS - 128)) | (1L << (LIST - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOOKUP - 128)) | (1L << (MANAGEMENT - 128)) | (1L << (MANHATTAN - 128)) | (1L << (MAP - 128)) | (1L << (MATCH - 128)) | (1L << (MERGE - 128)) | (1L << (IMPLIES - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NAN - 128)) | (1L << (NFC - 128)) | (1L << (NFD - 128)) | (1L << (NFKC - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (NFKD - 192)) | (1L << (NEW - 192)) | (1L << (NEXT - 192)) | (1L << (NODE - 192)) | (1L << (NODETACH - 192)) | (1L << (NODES - 192)) | (1L << (NONE - 192)) | (1L << (NORMALIZE - 192)) | (1L << (NORMALIZED - 192)) | (1L << (NOT - 192)) | (1L << (NOTHING - 192)) | (1L << (NOWAIT - 192)) | (1L << (NULL - 192)) | (1L << (OF - 192)) | (1L << (OFFSET - 192)) | (1L << (OIDC - 192)) | (1L << (ON - 192)) | (1L << (ONLY - 192)) | (1L << (OPTIONAL - 192)) | (1L << (OPTIONS - 192)) | (1L << (OPTION - 192)) | (1L << (OR - 192)) | (1L << (ORDER - 192)) | (1L << (PASSWORD - 192)) | (1L << (PASSWORDS - 192)) | (1L << (PATH - 192)) | (1L << (PATHS - 192)) | (1L << (PLAINTEXT - 192)) | (1L << (POINT - 192)) | (1L << (POPULATED - 192)) | (1L << (PRIMARY - 192)) | (1L << (PRIMARIES - 192)) | (1L << (PRIVILEGE - 192)) | (1L << (PRIVILEGES - 192)) | (1L << (PROCEDURE - 192)) | (1L << (PROCEDURES - 192)) | (1L << (PROPERTIES - 192)) | (1L << (PROPERTY - 192)) | (1L << (PROVIDER - 192)) | (1L << (PROVIDERS - 192)) | (1L << (RANGE - 192)) | (1L << (READ - 192)) | (1L << (REALLOCATE - 192)) | (1L << (REDUCE - 192)) | (1L << (RENAME - 192)) | (1L << (REL - 192)) | (1L << (RELATIONSHIP - 192)) | (1L << (RELATIONSHIPS - 192)) | (1L << (REMOVE - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (REPLICAS - 192)) | (1L << (REPORT - 192)) | (1L << (REQUIRE - 192)) | (1L << (REQUIRED - 192)) | (1L << (RESTRICT - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (RETRY - 256)) | (1L << (RETURN - 256)) | (1L << (REVOKE - 256)) | (1L << (ROLE - 256)) | (1L << (ROLES - 256)) | (1L << (ROW - 256)) | (1L << (ROWS - 256)) | (1L << (SCAN - 256)) | (1L << (SEC - 256)) | (1L << (SECOND - 256)) | (1L << (SECONDARY - 256)) | (1L << (SECONDARIES - 256)) | (1L << (SECONDS - 256)) | (1L << (SEEK - 256)) | (1L << (SERVER - 256)) | (1L << (SERVERS - 256)) | (1L << (SET - 256)) | (1L << (SETTING - 256)) | (1L << (SETTINGS - 256)) | (1L << (SHARD - 256)) | (1L << (SHARDS - 256)) | (1L << (SHORTEST_PATH - 256)) | (1L << (SHORTEST - 256)) | (1L << (SHOW - 256)) | (1L << (SIGNED - 256)) | (1L << (SINGLE - 256)) | (1L << (SKIPROWS - 256)) | (1L << (START - 256)) | (1L << (STARTS - 256)) | (1L << (STATUS - 256)) | (1L << (STOP - 256)) | (1L << (STRING - 256)) | (1L << (SUPPORTED - 256)) | (1L << (SUSPENDED - 256)) | (1L << (TARGET - 256)) | (1L << (TERMINATE - 256)) | (1L << (TEXT - 256)) | (1L << (THEN - 256)) | (1L << (TIME - 256)) | (1L << (TIMESTAMP - 256)) | (1L << (TIMEZONE - 256)) | (1L << (TO - 256)) | (1L << (TOPOLOGY - 256)) | (1L << (TRAILING - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSACTIONS - 256)) | (1L << (TRAVERSE - 256)) | (1L << (TRIM - 256)) | (1L << (TRUE - 256)) | (1L << (TYPE - 256)) | (1L << (TYPED - 256)) | (1L << (TYPES - 256)) | (1L << (UNION - 256)) | (1L << (UNIQUE - 256)) | (1L << (UNIQUENESS - 256)) | (1L << (UNWIND - 256)) | (1L << (URL - 256)) | (1L << (USE - 256)) | (1L << (USER - 256)) | (1L << (USERS - 256)) | (1L << (USING - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (VALUE - 320)) | (1L << (VARCHAR - 320)) | (1L << (VECTOR - 320)) | (1L << (VECTOR_DISTANCE - 320)) | (1L << (VECTOR_NORM - 320)) | (1L << (VERTEX - 320)) | (1L << (WAIT - 320)) | (1L << (WHEN - 320)) | (1L << (WHERE - 320)) | (1L << (WITH - 320)) | (1L << (WITHOUT - 320)) | (1L << (WRITE - 320)) | (1L << (XOR - 320)) | (1L << (YIELD - 320)) | (1L << (ZONE - 320)) | (1L << (ZONED - 320)) | (1L << (IDENTIFIER - 320)))) != 0)) {
				{
				State = 1876;
				variable();
				State = 1877;
				Match(EQ);
				}
			}

			State = 1881;
			pathPatternNonEmpty();
			State = 1884;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 1882;
				Match(WHERE);
				State = 1883;
				_localctx.whereExp = expression();
				}
			}

			State = 1886;
			Match(BAR);
			State = 1887;
			_localctx.barExp = expression();
			State = 1888;
			Match(RBRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReduceExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REDUCE() { return GetToken(CypherParser.REDUCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext[] variable() {
			return GetRuleContexts<VariableContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable(int i) {
			return GetRuleContext<VariableContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQ() { return GetToken(CypherParser.EQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(CypherParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(CypherParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BAR() { return GetToken(CypherParser.BAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		public ReduceExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reduceExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReduceExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReduceExpressionContext reduceExpression() {
		ReduceExpressionContext _localctx = new ReduceExpressionContext(Context, State);
		EnterRule(_localctx, 240, RULE_reduceExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1890;
			Match(REDUCE);
			State = 1891;
			Match(LPAREN);
			State = 1892;
			variable();
			State = 1893;
			Match(EQ);
			State = 1894;
			expression();
			State = 1895;
			Match(COMMA);
			State = 1896;
			variable();
			State = 1897;
			Match(IN);
			State = 1898;
			expression();
			State = 1899;
			Match(BAR);
			State = 1900;
			expression();
			State = 1901;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AllReduceExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AllReduceExpressionValidArgumentsContext allReduceExpressionValidArguments() {
			return GetRuleContext<AllReduceExpressionValidArgumentsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AllReduceExpressionInvalidArgumentsContext allReduceExpressionInvalidArguments() {
			return GetRuleContext<AllReduceExpressionInvalidArgumentsContext>(0);
		}
		public AllReduceExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_allReduceExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAllReduceExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AllReduceExpressionContext allReduceExpression() {
		AllReduceExpressionContext _localctx = new AllReduceExpressionContext(Context, State);
		EnterRule(_localctx, 242, RULE_allReduceExpression);
		try {
			State = 1905;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,175,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 1903;
				allReduceExpressionValidArguments();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 1904;
				allReduceExpressionInvalidArguments();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AllReduceExpressionValidArgumentsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALLREDUCE() { return GetToken(CypherParser.ALLREDUCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext[] variable() {
			return GetRuleContexts<VariableContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable(int i) {
			return GetRuleContext<VariableContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQ() { return GetToken(CypherParser.EQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(CypherParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BAR() { return GetToken(CypherParser.BAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		public AllReduceExpressionValidArgumentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_allReduceExpressionValidArguments; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAllReduceExpressionValidArguments(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AllReduceExpressionValidArgumentsContext allReduceExpressionValidArguments() {
		AllReduceExpressionValidArgumentsContext _localctx = new AllReduceExpressionValidArgumentsContext(Context, State);
		EnterRule(_localctx, 244, RULE_allReduceExpressionValidArguments);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1907;
			Match(ALLREDUCE);
			State = 1908;
			Match(LPAREN);
			State = 1909;
			variable();
			State = 1910;
			Match(EQ);
			State = 1911;
			expression();
			State = 1912;
			Match(COMMA);
			State = 1913;
			variable();
			State = 1914;
			Match(IN);
			State = 1915;
			expression();
			State = 1916;
			Match(BAR);
			State = 1917;
			expression();
			State = 1918;
			Match(COMMA);
			State = 1919;
			expression();
			State = 1920;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AllReduceExpressionInvalidArgumentsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALLREDUCE() { return GetToken(CypherParser.ALLREDUCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] BAR() { return GetTokens(CypherParser.BAR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BAR(int i) {
			return GetToken(CypherParser.BAR, i);
		}
		public AllReduceExpressionInvalidArgumentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_allReduceExpressionInvalidArguments; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAllReduceExpressionInvalidArguments(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AllReduceExpressionInvalidArgumentsContext allReduceExpressionInvalidArguments() {
		AllReduceExpressionInvalidArgumentsContext _localctx = new AllReduceExpressionInvalidArgumentsContext(Context, State);
		EnterRule(_localctx, 246, RULE_allReduceExpressionInvalidArguments);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1922;
			Match(ALLREDUCE);
			State = 1923;
			Match(LPAREN);
			State = 1924;
			expression();
			State = 1929;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==BAR || _la==COMMA) {
				{
				{
				State = 1925;
				_la = TokenStream.LA(1);
				if ( !(_la==BAR || _la==COMMA) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 1926;
				expression();
				}
				}
				State = 1931;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 1932;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ListItemsPredicateContext : ParserRuleContext {
		public ExpressionContext inExp;
		public ExpressionContext whereExp;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(CypherParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(CypherParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANY() { return GetToken(CypherParser.ANY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONE() { return GetToken(CypherParser.NONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SINGLE() { return GetToken(CypherParser.SINGLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHERE() { return GetToken(CypherParser.WHERE, 0); }
		public ListItemsPredicateContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_listItemsPredicate; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitListItemsPredicate(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ListItemsPredicateContext listItemsPredicate() {
		ListItemsPredicateContext _localctx = new ListItemsPredicateContext(Context, State);
		EnterRule(_localctx, 248, RULE_listItemsPredicate);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1934;
			_la = TokenStream.LA(1);
			if ( !(_la==ALL || _la==ANY || _la==NONE || _la==SINGLE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 1935;
			Match(LPAREN);
			State = 1936;
			variable();
			State = 1937;
			Match(IN);
			State = 1938;
			_localctx.inExp = expression();
			State = 1941;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 1939;
				Match(WHERE);
				State = 1940;
				_localctx.whereExp = expression();
				}
			}

			State = 1943;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NormalizeFunctionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NORMALIZE() { return GetToken(CypherParser.NORMALIZE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(CypherParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NormalFormContext normalForm() {
			return GetRuleContext<NormalFormContext>(0);
		}
		public NormalizeFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_normalizeFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNormalizeFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NormalizeFunctionContext normalizeFunction() {
		NormalizeFunctionContext _localctx = new NormalizeFunctionContext(Context, State);
		EnterRule(_localctx, 250, RULE_normalizeFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1945;
			Match(NORMALIZE);
			State = 1946;
			Match(LPAREN);
			State = 1947;
			expression();
			State = 1950;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMMA) {
				{
				State = 1948;
				Match(COMMA);
				State = 1949;
				normalForm();
				}
			}

			State = 1952;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VectorFunctionContext : ParserRuleContext {
		public ExpressionContext vectorValue;
		public ExpressionContext dimension;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VECTOR() { return GetToken(CypherParser.VECTOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VectorCoordinateTypeContext vectorCoordinateType() {
			return GetRuleContext<VectorCoordinateTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public VectorFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_vectorFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVectorFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VectorFunctionContext vectorFunction() {
		VectorFunctionContext _localctx = new VectorFunctionContext(Context, State);
		EnterRule(_localctx, 252, RULE_vectorFunction);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1954;
			Match(VECTOR);
			State = 1955;
			Match(LPAREN);
			State = 1956;
			_localctx.vectorValue = expression();
			State = 1957;
			Match(COMMA);
			State = 1958;
			_localctx.dimension = expression();
			State = 1959;
			Match(COMMA);
			State = 1960;
			vectorCoordinateType();
			State = 1961;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VectorDistanceFunctionContext : ParserRuleContext {
		public ExpressionContext vector1;
		public ExpressionContext vector2;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VECTOR_DISTANCE() { return GetToken(CypherParser.VECTOR_DISTANCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VectorDistanceMetricContext vectorDistanceMetric() {
			return GetRuleContext<VectorDistanceMetricContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		public VectorDistanceFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_vectorDistanceFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVectorDistanceFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VectorDistanceFunctionContext vectorDistanceFunction() {
		VectorDistanceFunctionContext _localctx = new VectorDistanceFunctionContext(Context, State);
		EnterRule(_localctx, 254, RULE_vectorDistanceFunction);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1963;
			Match(VECTOR_DISTANCE);
			State = 1964;
			Match(LPAREN);
			State = 1965;
			_localctx.vector1 = expression();
			State = 1966;
			Match(COMMA);
			State = 1967;
			_localctx.vector2 = expression();
			State = 1968;
			Match(COMMA);
			State = 1969;
			vectorDistanceMetric();
			State = 1970;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VectorNormFunctionContext : ParserRuleContext {
		public ExpressionContext vectorValue;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VECTOR_NORM() { return GetToken(CypherParser.VECTOR_NORM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(CypherParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VectorNormDistanceMetricContext vectorNormDistanceMetric() {
			return GetRuleContext<VectorNormDistanceMetricContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public VectorNormFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_vectorNormFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVectorNormFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VectorNormFunctionContext vectorNormFunction() {
		VectorNormFunctionContext _localctx = new VectorNormFunctionContext(Context, State);
		EnterRule(_localctx, 256, RULE_vectorNormFunction);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1972;
			Match(VECTOR_NORM);
			State = 1973;
			Match(LPAREN);
			State = 1974;
			_localctx.vectorValue = expression();
			State = 1975;
			Match(COMMA);
			State = 1976;
			vectorNormDistanceMetric();
			State = 1977;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VectorDistanceMetricContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EUCLIDEAN() { return GetToken(CypherParser.EUCLIDEAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EUCLIDEAN_SQUARED() { return GetToken(CypherParser.EUCLIDEAN_SQUARED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MANHATTAN() { return GetToken(CypherParser.MANHATTAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COSINE() { return GetToken(CypherParser.COSINE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT_METRIC() { return GetToken(CypherParser.DOT_METRIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HAMMING() { return GetToken(CypherParser.HAMMING, 0); }
		public VectorDistanceMetricContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_vectorDistanceMetric; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVectorDistanceMetric(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VectorDistanceMetricContext vectorDistanceMetric() {
		VectorDistanceMetricContext _localctx = new VectorDistanceMetricContext(Context, State);
		EnterRule(_localctx, 258, RULE_vectorDistanceMetric);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1979;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 58)) & ~0x3f) == 0 && ((1L << (_la - 58)) & ((1L << (COSINE - 58)) | (1L << (DOT_METRIC - 58)) | (1L << (EUCLIDEAN - 58)) | (1L << (EUCLIDEAN_SQUARED - 58)))) != 0) || _la==HAMMING || _la==MANHATTAN) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VectorNormDistanceMetricContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EUCLIDEAN() { return GetToken(CypherParser.EUCLIDEAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MANHATTAN() { return GetToken(CypherParser.MANHATTAN, 0); }
		public VectorNormDistanceMetricContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_vectorNormDistanceMetric; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVectorNormDistanceMetric(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VectorNormDistanceMetricContext vectorNormDistanceMetric() {
		VectorNormDistanceMetricContext _localctx = new VectorNormDistanceMetricContext(Context, State);
		EnterRule(_localctx, 260, RULE_vectorNormDistanceMetric);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1981;
			_la = TokenStream.LA(1);
			if ( !(_la==EUCLIDEAN || _la==MANHATTAN) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TrimFunctionContext : ParserRuleContext {
		public ExpressionContext trimCharacterString;
		public ExpressionContext trimSource;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRIM() { return GetToken(CypherParser.TRIM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FROM() { return GetToken(CypherParser.FROM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BOTH() { return GetToken(CypherParser.BOTH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEADING() { return GetToken(CypherParser.LEADING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRAILING() { return GetToken(CypherParser.TRAILING, 0); }
		public TrimFunctionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_trimFunction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTrimFunction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TrimFunctionContext trimFunction() {
		TrimFunctionContext _localctx = new TrimFunctionContext(Context, State);
		EnterRule(_localctx, 262, RULE_trimFunction);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1983;
			Match(TRIM);
			State = 1984;
			Match(LPAREN);
			State = 1992;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,181,Context) ) {
			case 1:
				{
				State = 1986;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,179,Context) ) {
				case 1:
					{
					State = 1985;
					_la = TokenStream.LA(1);
					if ( !(_la==BOTH || _la==LEADING || _la==TRAILING) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				}
				State = 1989;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,180,Context) ) {
				case 1:
					{
					State = 1988;
					_localctx.trimCharacterString = expression();
					}
					break;
				}
				State = 1991;
				Match(FROM);
				}
				break;
			}
			State = 1994;
			_localctx.trimSource = expression();
			State = 1995;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PatternExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PathPatternNonEmptyContext pathPatternNonEmpty() {
			return GetRuleContext<PathPatternNonEmptyContext>(0);
		}
		public PatternExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_patternExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPatternExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PatternExpressionContext patternExpression() {
		PatternExpressionContext _localctx = new PatternExpressionContext(Context, State);
		EnterRule(_localctx, 264, RULE_patternExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1997;
			pathPatternNonEmpty();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShortestPathExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ShortestPathPatternContext shortestPathPattern() {
			return GetRuleContext<ShortestPathPatternContext>(0);
		}
		public ShortestPathExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shortestPathExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShortestPathExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShortestPathExpressionContext shortestPathExpression() {
		ShortestPathExpressionContext _localctx = new ShortestPathExpressionContext(Context, State);
		EnterRule(_localctx, 266, RULE_shortestPathExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 1999;
			shortestPathPattern();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParenthesizedExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		public ParenthesizedExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_parenthesizedExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParenthesizedExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParenthesizedExpressionContext parenthesizedExpression() {
		ParenthesizedExpressionContext _localctx = new ParenthesizedExpressionContext(Context, State);
		EnterRule(_localctx, 268, RULE_parenthesizedExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2001;
			Match(LPAREN);
			State = 2002;
			expression();
			State = 2003;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MapProjectionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CypherParser.LCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CypherParser.RCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public MapProjectionElementContext[] mapProjectionElement() {
			return GetRuleContexts<MapProjectionElementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MapProjectionElementContext mapProjectionElement(int i) {
			return GetRuleContext<MapProjectionElementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public MapProjectionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mapProjection; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMapProjection(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MapProjectionContext mapProjection() {
		MapProjectionContext _localctx = new MapProjectionContext(Context, State);
		EnterRule(_localctx, 270, RULE_mapProjection);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2005;
			variable();
			State = 2006;
			Match(LCURLY);
			State = 2015;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ESCAPED_SYMBOLIC_NAME) | (1L << ACCESS) | (1L << ACTIVE) | (1L << ADD) | (1L << ADMIN) | (1L << ADMINISTRATOR) | (1L << ALIAS) | (1L << ALIASES) | (1L << ALL_SHORTEST_PATHS) | (1L << ALL) | (1L << ALLREDUCE) | (1L << ALTER) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASCENDING) | (1L << ASSIGN) | (1L << AT) | (1L << AUTH) | (1L << BINDINGS) | (1L << BOOL) | (1L << BOOLEAN) | (1L << BOOSTED) | (1L << BOTH) | (1L << BREAK) | (1L << BUILT) | (1L << BY) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CHANGE) | (1L << CIDR) | (1L << COLLECT) | (1L << COMMAND) | (1L << COMMANDS) | (1L << COMPOSITE) | (1L << CONCURRENT) | (1L << CONSTRAINT) | (1L << CONSTRAINTS) | (1L << CONTAINS) | (1L << COPY) | (1L << CONTINUE) | (1L << COSINE) | (1L << COUNT) | (1L << CREATE) | (1L << CREDENTIAL) | (1L << CSV) | (1L << CURRENT))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CYPHER - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATABASES - 64)) | (1L << (DATE - 64)) | (1L << (DATETIME - 64)) | (1L << (DBMS - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFINED - 64)) | (1L << (DELETE - 64)) | (1L << (DENY - 64)) | (1L << (DESC - 64)) | (1L << (DESCENDING - 64)) | (1L << (DESTROY - 64)) | (1L << (DETACH - 64)) | (1L << (DIFFERENT - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOT - 64)) | (1L << (DOT_METRIC - 64)) | (1L << (DRIVER - 64)) | (1L << (DROP - 64)) | (1L << (DRYRUN - 64)) | (1L << (DUMP - 64)) | (1L << (DURATION - 64)) | (1L << (EACH - 64)) | (1L << (EDGE - 64)) | (1L << (ENABLE - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELEMENTS - 64)) | (1L << (ELSE - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (EUCLIDEAN - 64)) | (1L << (EUCLIDEAN_SQUARED - 64)) | (1L << (END - 64)) | (1L << (ENDS - 64)) | (1L << (EXECUTABLE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXIST - 64)) | (1L << (EXISTENCE - 64)) | (1L << (EXISTS - 64)) | (1L << (ERROR - 64)) | (1L << (FAIL - 64)) | (1L << (FALSE - 64)) | (1L << (FIELDTERMINATOR - 64)) | (1L << (FILTER - 64)) | (1L << (FINISH - 64)) | (1L << (FLOAT - 64)) | (1L << (FLOAT64 - 64)) | (1L << (FLOAT32 - 64)) | (1L << (FOR - 64)) | (1L << (FOREACH - 64)) | (1L << (FORWARDING - 64)) | (1L << (FROM - 64)) | (1L << (FULLTEXT - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GRANT - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (GRAPH - 128)) | (1L << (GRAPHS - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPS - 128)) | (1L << (HAMMING - 128)) | (1L << (HEADERS - 128)) | (1L << (HOME - 128)) | (1L << (ID - 128)) | (1L << (IF - 128)) | (1L << (IMPERSONATE - 128)) | (1L << (IMMUTABLE - 128)) | (1L << (IN - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXES - 128)) | (1L << (INF - 128)) | (1L << (INFINITY - 128)) | (1L << (INSERT - 128)) | (1L << (INT - 128)) | (1L << (INT64 - 128)) | (1L << (INT32 - 128)) | (1L << (INT16 - 128)) | (1L << (INT8 - 128)) | (1L << (INTEGER - 128)) | (1L << (INTEGER64 - 128)) | (1L << (INTEGER32 - 128)) | (1L << (INTEGER16 - 128)) | (1L << (INTEGER8 - 128)) | (1L << (IS - 128)) | (1L << (JOIN - 128)) | (1L << (KEY - 128)) | (1L << (LABEL - 128)) | (1L << (LABELS - 128)) | (1L << (LANGUAGE - 128)) | (1L << (LEADING - 128)) | (1L << (LET - 128)) | (1L << (LIMITROWS - 128)) | (1L << (LIST - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOOKUP - 128)) | (1L << (MANAGEMENT - 128)) | (1L << (MANHATTAN - 128)) | (1L << (MAP - 128)) | (1L << (MATCH - 128)) | (1L << (MERGE - 128)) | (1L << (IMPLIES - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NAN - 128)) | (1L << (NFC - 128)) | (1L << (NFD - 128)) | (1L << (NFKC - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (NFKD - 192)) | (1L << (NEW - 192)) | (1L << (NEXT - 192)) | (1L << (NODE - 192)) | (1L << (NODETACH - 192)) | (1L << (NODES - 192)) | (1L << (NONE - 192)) | (1L << (NORMALIZE - 192)) | (1L << (NORMALIZED - 192)) | (1L << (NOT - 192)) | (1L << (NOTHING - 192)) | (1L << (NOWAIT - 192)) | (1L << (NULL - 192)) | (1L << (OF - 192)) | (1L << (OFFSET - 192)) | (1L << (OIDC - 192)) | (1L << (ON - 192)) | (1L << (ONLY - 192)) | (1L << (OPTIONAL - 192)) | (1L << (OPTIONS - 192)) | (1L << (OPTION - 192)) | (1L << (OR - 192)) | (1L << (ORDER - 192)) | (1L << (PASSWORD - 192)) | (1L << (PASSWORDS - 192)) | (1L << (PATH - 192)) | (1L << (PATHS - 192)) | (1L << (PLAINTEXT - 192)) | (1L << (POINT - 192)) | (1L << (POPULATED - 192)) | (1L << (PRIMARY - 192)) | (1L << (PRIMARIES - 192)) | (1L << (PRIVILEGE - 192)) | (1L << (PRIVILEGES - 192)) | (1L << (PROCEDURE - 192)) | (1L << (PROCEDURES - 192)) | (1L << (PROPERTIES - 192)) | (1L << (PROPERTY - 192)) | (1L << (PROVIDER - 192)) | (1L << (PROVIDERS - 192)) | (1L << (RANGE - 192)) | (1L << (READ - 192)) | (1L << (REALLOCATE - 192)) | (1L << (REDUCE - 192)) | (1L << (RENAME - 192)) | (1L << (REL - 192)) | (1L << (RELATIONSHIP - 192)) | (1L << (RELATIONSHIPS - 192)) | (1L << (REMOVE - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (REPLICAS - 192)) | (1L << (REPORT - 192)) | (1L << (REQUIRE - 192)) | (1L << (REQUIRED - 192)) | (1L << (RESTRICT - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (RETRY - 256)) | (1L << (RETURN - 256)) | (1L << (REVOKE - 256)) | (1L << (ROLE - 256)) | (1L << (ROLES - 256)) | (1L << (ROW - 256)) | (1L << (ROWS - 256)) | (1L << (SCAN - 256)) | (1L << (SEC - 256)) | (1L << (SECOND - 256)) | (1L << (SECONDARY - 256)) | (1L << (SECONDARIES - 256)) | (1L << (SECONDS - 256)) | (1L << (SEEK - 256)) | (1L << (SERVER - 256)) | (1L << (SERVERS - 256)) | (1L << (SET - 256)) | (1L << (SETTING - 256)) | (1L << (SETTINGS - 256)) | (1L << (SHARD - 256)) | (1L << (SHARDS - 256)) | (1L << (SHORTEST_PATH - 256)) | (1L << (SHORTEST - 256)) | (1L << (SHOW - 256)) | (1L << (SIGNED - 256)) | (1L << (SINGLE - 256)) | (1L << (SKIPROWS - 256)) | (1L << (START - 256)) | (1L << (STARTS - 256)) | (1L << (STATUS - 256)) | (1L << (STOP - 256)) | (1L << (STRING - 256)) | (1L << (SUPPORTED - 256)) | (1L << (SUSPENDED - 256)) | (1L << (TARGET - 256)) | (1L << (TERMINATE - 256)) | (1L << (TEXT - 256)) | (1L << (THEN - 256)) | (1L << (TIME - 256)) | (1L << (TIMESTAMP - 256)) | (1L << (TIMEZONE - 256)) | (1L << (TO - 256)) | (1L << (TOPOLOGY - 256)) | (1L << (TRAILING - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSACTIONS - 256)) | (1L << (TRAVERSE - 256)) | (1L << (TRIM - 256)) | (1L << (TRUE - 256)) | (1L << (TYPE - 256)) | (1L << (TYPED - 256)) | (1L << (TYPES - 256)) | (1L << (UNION - 256)) | (1L << (UNIQUE - 256)) | (1L << (UNIQUENESS - 256)) | (1L << (UNWIND - 256)) | (1L << (URL - 256)) | (1L << (USE - 256)) | (1L << (USER - 256)) | (1L << (USERS - 256)) | (1L << (USING - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (VALUE - 320)) | (1L << (VARCHAR - 320)) | (1L << (VECTOR - 320)) | (1L << (VECTOR_DISTANCE - 320)) | (1L << (VECTOR_NORM - 320)) | (1L << (VERTEX - 320)) | (1L << (WAIT - 320)) | (1L << (WHEN - 320)) | (1L << (WHERE - 320)) | (1L << (WITH - 320)) | (1L << (WITHOUT - 320)) | (1L << (WRITE - 320)) | (1L << (XOR - 320)) | (1L << (YIELD - 320)) | (1L << (ZONE - 320)) | (1L << (ZONED - 320)) | (1L << (IDENTIFIER - 320)))) != 0)) {
				{
				State = 2007;
				mapProjectionElement();
				State = 2012;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2008;
					Match(COMMA);
					State = 2009;
					mapProjectionElement();
					}
					}
					State = 2014;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 2017;
			Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MapProjectionElementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PropertyKeyNameContext propertyKeyName() {
			return GetRuleContext<PropertyKeyNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(CypherParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropertyContext property() {
			return GetRuleContext<PropertyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(CypherParser.DOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMES() { return GetToken(CypherParser.TIMES, 0); }
		public MapProjectionElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mapProjectionElement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMapProjectionElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MapProjectionElementContext mapProjectionElement() {
		MapProjectionElementContext _localctx = new MapProjectionElementContext(Context, State);
		EnterRule(_localctx, 272, RULE_mapProjectionElement);
		try {
			State = 2027;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,184,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2019;
				propertyKeyName();
				State = 2020;
				Match(COLON);
				State = 2021;
				expression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2023;
				property();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2024;
				variable();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2025;
				Match(DOT);
				State = 2026;
				Match(TIMES);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CountStarContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COUNT() { return GetToken(CypherParser.COUNT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMES() { return GetToken(CypherParser.TIMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		public CountStarContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_countStar; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCountStar(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CountStarContext countStar() {
		CountStarContext _localctx = new CountStarContext(Context, State);
		EnterRule(_localctx, 274, RULE_countStar);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2029;
			Match(COUNT);
			State = 2030;
			Match(LPAREN);
			State = 2031;
			Match(TIMES);
			State = 2032;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExistsExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CypherParser.LCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CypherParser.RCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NextStatementContext nextStatement() {
			return GetRuleContext<NextStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PatternListContext patternList() {
			return GetRuleContext<PatternListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MatchModeContext matchMode() {
			return GetRuleContext<MatchModeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public ExistsExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_existsExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExistsExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExistsExpressionContext existsExpression() {
		ExistsExpressionContext _localctx = new ExistsExpressionContext(Context, State);
		EnterRule(_localctx, 276, RULE_existsExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2034;
			Match(EXISTS);
			State = 2035;
			Match(LCURLY);
			State = 2044;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,187,Context) ) {
			case 1:
				{
				State = 2036;
				nextStatement();
				}
				break;
			case 2:
				{
				State = 2038;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,185,Context) ) {
				case 1:
					{
					State = 2037;
					matchMode();
					}
					break;
				}
				State = 2040;
				patternList();
				State = 2042;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHERE) {
					{
					State = 2041;
					whereClause();
					}
				}

				}
				break;
			}
			State = 2046;
			Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CountExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COUNT() { return GetToken(CypherParser.COUNT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CypherParser.LCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CypherParser.RCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NextStatementContext nextStatement() {
			return GetRuleContext<NextStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PatternListContext patternList() {
			return GetRuleContext<PatternListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MatchModeContext matchMode() {
			return GetRuleContext<MatchModeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public CountExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_countExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCountExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CountExpressionContext countExpression() {
		CountExpressionContext _localctx = new CountExpressionContext(Context, State);
		EnterRule(_localctx, 278, RULE_countExpression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2048;
			Match(COUNT);
			State = 2049;
			Match(LCURLY);
			State = 2058;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,190,Context) ) {
			case 1:
				{
				State = 2050;
				nextStatement();
				}
				break;
			case 2:
				{
				State = 2052;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,188,Context) ) {
				case 1:
					{
					State = 2051;
					matchMode();
					}
					break;
				}
				State = 2054;
				patternList();
				State = 2056;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHERE) {
					{
					State = 2055;
					whereClause();
					}
				}

				}
				break;
			}
			State = 2060;
			Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CollectExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLLECT() { return GetToken(CypherParser.COLLECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CypherParser.LCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NextStatementContext nextStatement() {
			return GetRuleContext<NextStatementContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CypherParser.RCURLY, 0); }
		public CollectExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_collectExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCollectExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CollectExpressionContext collectExpression() {
		CollectExpressionContext _localctx = new CollectExpressionContext(Context, State);
		EnterRule(_localctx, 280, RULE_collectExpression);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2062;
			Match(COLLECT);
			State = 2063;
			Match(LCURLY);
			State = 2064;
			nextStatement();
			State = 2065;
			Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NumberLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DECIMAL_DOUBLE() { return GetToken(CypherParser.DECIMAL_DOUBLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNSIGNED_DECIMAL_INTEGER() { return GetToken(CypherParser.UNSIGNED_DECIMAL_INTEGER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNSIGNED_HEX_INTEGER() { return GetToken(CypherParser.UNSIGNED_HEX_INTEGER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNSIGNED_OCTAL_INTEGER() { return GetToken(CypherParser.UNSIGNED_OCTAL_INTEGER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(CypherParser.MINUS, 0); }
		public NumberLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_numberLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNumberLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NumberLiteralContext numberLiteral() {
		NumberLiteralContext _localctx = new NumberLiteralContext(Context, State);
		EnterRule(_localctx, 282, RULE_numberLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2068;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MINUS) {
				{
				State = 2067;
				Match(MINUS);
				}
			}

			State = 2070;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << DECIMAL_DOUBLE) | (1L << UNSIGNED_DECIMAL_INTEGER) | (1L << UNSIGNED_HEX_INTEGER) | (1L << UNSIGNED_OCTAL_INTEGER))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SignedIntegerLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNSIGNED_DECIMAL_INTEGER() { return GetToken(CypherParser.UNSIGNED_DECIMAL_INTEGER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MINUS() { return GetToken(CypherParser.MINUS, 0); }
		public SignedIntegerLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_signedIntegerLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSignedIntegerLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SignedIntegerLiteralContext signedIntegerLiteral() {
		SignedIntegerLiteralContext _localctx = new SignedIntegerLiteralContext(Context, State);
		EnterRule(_localctx, 284, RULE_signedIntegerLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2073;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==MINUS) {
				{
				State = 2072;
				Match(MINUS);
				}
			}

			State = 2075;
			Match(UNSIGNED_DECIMAL_INTEGER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ListLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CypherParser.LBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CypherParser.RBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public ListLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_listLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitListLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ListLiteralContext listLiteral() {
		ListLiteralContext _localctx = new ListLiteralContext(Context, State);
		EnterRule(_localctx, 286, RULE_listLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2077;
			Match(LBRACKET);
			State = 2086;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << DECIMAL_DOUBLE) | (1L << UNSIGNED_DECIMAL_INTEGER) | (1L << UNSIGNED_HEX_INTEGER) | (1L << UNSIGNED_OCTAL_INTEGER) | (1L << STRING_LITERAL1) | (1L << STRING_LITERAL2) | (1L << ESCAPED_SYMBOLIC_NAME) | (1L << ACCESS) | (1L << ACTIVE) | (1L << ADD) | (1L << ADMIN) | (1L << ADMINISTRATOR) | (1L << ALIAS) | (1L << ALIASES) | (1L << ALL_SHORTEST_PATHS) | (1L << ALL) | (1L << ALLREDUCE) | (1L << ALTER) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASCENDING) | (1L << ASSIGN) | (1L << AT) | (1L << AUTH) | (1L << BINDINGS) | (1L << BOOL) | (1L << BOOLEAN) | (1L << BOOSTED) | (1L << BOTH) | (1L << BREAK) | (1L << BUILT) | (1L << BY) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CHANGE) | (1L << CIDR) | (1L << COLLECT) | (1L << COMMAND) | (1L << COMMANDS) | (1L << COMPOSITE) | (1L << CONCURRENT) | (1L << CONSTRAINT) | (1L << CONSTRAINTS) | (1L << CONTAINS) | (1L << COPY) | (1L << CONTINUE) | (1L << COSINE) | (1L << COUNT) | (1L << CREATE) | (1L << CREDENTIAL) | (1L << CSV) | (1L << CURRENT))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CYPHER - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATABASES - 64)) | (1L << (DATE - 64)) | (1L << (DATETIME - 64)) | (1L << (DBMS - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFINED - 64)) | (1L << (DELETE - 64)) | (1L << (DENY - 64)) | (1L << (DESC - 64)) | (1L << (DESCENDING - 64)) | (1L << (DESTROY - 64)) | (1L << (DETACH - 64)) | (1L << (DIFFERENT - 64)) | (1L << (DOLLAR - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOT_METRIC - 64)) | (1L << (DRIVER - 64)) | (1L << (DROP - 64)) | (1L << (DRYRUN - 64)) | (1L << (DUMP - 64)) | (1L << (DURATION - 64)) | (1L << (EACH - 64)) | (1L << (EDGE - 64)) | (1L << (ENABLE - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELEMENTS - 64)) | (1L << (ELSE - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (EUCLIDEAN - 64)) | (1L << (EUCLIDEAN_SQUARED - 64)) | (1L << (END - 64)) | (1L << (ENDS - 64)) | (1L << (EXECUTABLE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXIST - 64)) | (1L << (EXISTENCE - 64)) | (1L << (EXISTS - 64)) | (1L << (ERROR - 64)) | (1L << (FAIL - 64)) | (1L << (FALSE - 64)) | (1L << (FIELDTERMINATOR - 64)) | (1L << (FILTER - 64)) | (1L << (FINISH - 64)) | (1L << (FLOAT - 64)) | (1L << (FLOAT64 - 64)) | (1L << (FLOAT32 - 64)) | (1L << (FOR - 64)) | (1L << (FOREACH - 64)) | (1L << (FORWARDING - 64)) | (1L << (FROM - 64)) | (1L << (FULLTEXT - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GRANT - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (GRAPH - 128)) | (1L << (GRAPHS - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPS - 128)) | (1L << (HAMMING - 128)) | (1L << (HEADERS - 128)) | (1L << (HOME - 128)) | (1L << (ID - 128)) | (1L << (IF - 128)) | (1L << (IMPERSONATE - 128)) | (1L << (IMMUTABLE - 128)) | (1L << (IN - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXES - 128)) | (1L << (INF - 128)) | (1L << (INFINITY - 128)) | (1L << (INSERT - 128)) | (1L << (INT - 128)) | (1L << (INT64 - 128)) | (1L << (INT32 - 128)) | (1L << (INT16 - 128)) | (1L << (INT8 - 128)) | (1L << (INTEGER - 128)) | (1L << (INTEGER64 - 128)) | (1L << (INTEGER32 - 128)) | (1L << (INTEGER16 - 128)) | (1L << (INTEGER8 - 128)) | (1L << (IS - 128)) | (1L << (JOIN - 128)) | (1L << (KEY - 128)) | (1L << (LABEL - 128)) | (1L << (LABELS - 128)) | (1L << (LANGUAGE - 128)) | (1L << (LBRACKET - 128)) | (1L << (LCURLY - 128)) | (1L << (LEADING - 128)) | (1L << (LET - 128)) | (1L << (LIMITROWS - 128)) | (1L << (LIST - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOOKUP - 128)) | (1L << (LPAREN - 128)) | (1L << (MANAGEMENT - 128)) | (1L << (MANHATTAN - 128)) | (1L << (MAP - 128)) | (1L << (MATCH - 128)) | (1L << (MERGE - 128)) | (1L << (MINUS - 128)) | (1L << (IMPLIES - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NAN - 128)) | (1L << (NFC - 128)) | (1L << (NFD - 128)) | (1L << (NFKC - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (NFKD - 192)) | (1L << (NEW - 192)) | (1L << (NEXT - 192)) | (1L << (NODE - 192)) | (1L << (NODETACH - 192)) | (1L << (NODES - 192)) | (1L << (NONE - 192)) | (1L << (NORMALIZE - 192)) | (1L << (NORMALIZED - 192)) | (1L << (NOT - 192)) | (1L << (NOTHING - 192)) | (1L << (NOWAIT - 192)) | (1L << (NULL - 192)) | (1L << (OF - 192)) | (1L << (OFFSET - 192)) | (1L << (OIDC - 192)) | (1L << (ON - 192)) | (1L << (ONLY - 192)) | (1L << (OPTIONAL - 192)) | (1L << (OPTIONS - 192)) | (1L << (OPTION - 192)) | (1L << (OR - 192)) | (1L << (ORDER - 192)) | (1L << (PASSWORD - 192)) | (1L << (PASSWORDS - 192)) | (1L << (PATH - 192)) | (1L << (PATHS - 192)) | (1L << (PLAINTEXT - 192)) | (1L << (PLUS - 192)) | (1L << (POINT - 192)) | (1L << (POPULATED - 192)) | (1L << (PRIMARY - 192)) | (1L << (PRIMARIES - 192)) | (1L << (PRIVILEGE - 192)) | (1L << (PRIVILEGES - 192)) | (1L << (PROCEDURE - 192)) | (1L << (PROCEDURES - 192)) | (1L << (PROPERTIES - 192)) | (1L << (PROPERTY - 192)) | (1L << (PROVIDER - 192)) | (1L << (PROVIDERS - 192)) | (1L << (RANGE - 192)) | (1L << (READ - 192)) | (1L << (REALLOCATE - 192)) | (1L << (REDUCE - 192)) | (1L << (RENAME - 192)) | (1L << (REL - 192)) | (1L << (RELATIONSHIP - 192)) | (1L << (RELATIONSHIPS - 192)) | (1L << (REMOVE - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (REPLICAS - 192)) | (1L << (REPORT - 192)) | (1L << (REQUIRE - 192)) | (1L << (REQUIRED - 192)) | (1L << (RESTRICT - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (RETRY - 256)) | (1L << (RETURN - 256)) | (1L << (REVOKE - 256)) | (1L << (ROLE - 256)) | (1L << (ROLES - 256)) | (1L << (ROW - 256)) | (1L << (ROWS - 256)) | (1L << (SCAN - 256)) | (1L << (SEC - 256)) | (1L << (SECOND - 256)) | (1L << (SECONDARY - 256)) | (1L << (SECONDARIES - 256)) | (1L << (SECONDS - 256)) | (1L << (SEEK - 256)) | (1L << (SERVER - 256)) | (1L << (SERVERS - 256)) | (1L << (SET - 256)) | (1L << (SETTING - 256)) | (1L << (SETTINGS - 256)) | (1L << (SHARD - 256)) | (1L << (SHARDS - 256)) | (1L << (SHORTEST_PATH - 256)) | (1L << (SHORTEST - 256)) | (1L << (SHOW - 256)) | (1L << (SIGNED - 256)) | (1L << (SINGLE - 256)) | (1L << (SKIPROWS - 256)) | (1L << (START - 256)) | (1L << (STARTS - 256)) | (1L << (STATUS - 256)) | (1L << (STOP - 256)) | (1L << (STRING - 256)) | (1L << (SUPPORTED - 256)) | (1L << (SUSPENDED - 256)) | (1L << (TARGET - 256)) | (1L << (TERMINATE - 256)) | (1L << (TEXT - 256)) | (1L << (THEN - 256)) | (1L << (TIME - 256)) | (1L << (TIMESTAMP - 256)) | (1L << (TIMEZONE - 256)) | (1L << (TO - 256)) | (1L << (TOPOLOGY - 256)) | (1L << (TRAILING - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSACTIONS - 256)) | (1L << (TRAVERSE - 256)) | (1L << (TRIM - 256)) | (1L << (TRUE - 256)) | (1L << (TYPE - 256)) | (1L << (TYPED - 256)) | (1L << (TYPES - 256)) | (1L << (UNION - 256)) | (1L << (UNIQUE - 256)) | (1L << (UNIQUENESS - 256)) | (1L << (UNWIND - 256)) | (1L << (URL - 256)) | (1L << (USE - 256)) | (1L << (USER - 256)) | (1L << (USERS - 256)) | (1L << (USING - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (VALUE - 320)) | (1L << (VARCHAR - 320)) | (1L << (VECTOR - 320)) | (1L << (VECTOR_DISTANCE - 320)) | (1L << (VECTOR_NORM - 320)) | (1L << (VERTEX - 320)) | (1L << (WAIT - 320)) | (1L << (WHEN - 320)) | (1L << (WHERE - 320)) | (1L << (WITH - 320)) | (1L << (WITHOUT - 320)) | (1L << (WRITE - 320)) | (1L << (XOR - 320)) | (1L << (YIELD - 320)) | (1L << (ZONE - 320)) | (1L << (ZONED - 320)) | (1L << (IDENTIFIER - 320)))) != 0)) {
				{
				State = 2078;
				expression();
				State = 2083;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2079;
					Match(COMMA);
					State = 2080;
					expression();
					}
					}
					State = 2085;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 2088;
			Match(RBRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertyKeyNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString() {
			return GetRuleContext<SymbolicNameStringContext>(0);
		}
		public PropertyKeyNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertyKeyName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertyKeyName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertyKeyNameContext propertyKeyName() {
		PropertyKeyNameContext _localctx = new PropertyKeyNameContext(Context, State);
		EnterRule(_localctx, 288, RULE_propertyKeyName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2090;
			symbolicNameString();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterContext : ParserRuleContext {
		public String paramType;
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOLLAR() { return GetToken(CypherParser.DOLLAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParameterNameContext parameterName() {
			return GetRuleContext<ParameterNameContext>(0);
		}
		public ParameterContext(ParserRuleContext parent, int invokingState) : base(parent, invokingState) { }
		public ParameterContext(ParserRuleContext parent, int invokingState, String paramType)
			: base(parent, invokingState)
		{
			this.paramType = paramType;
		}
		public override int RuleIndex { get { return RULE_parameter; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterContext parameter(String paramType) {
		ParameterContext _localctx = new ParameterContext(Context, State, paramType);
		EnterRule(_localctx, 290, RULE_parameter);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2092;
			Match(DOLLAR);
			State = 2093;
			parameterName(paramType);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ParameterNameContext : ParserRuleContext {
		public String paramType;
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString() {
			return GetRuleContext<SymbolicNameStringContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNSIGNED_DECIMAL_INTEGER() { return GetToken(CypherParser.UNSIGNED_DECIMAL_INTEGER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNSIGNED_OCTAL_INTEGER() { return GetToken(CypherParser.UNSIGNED_OCTAL_INTEGER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXTENDED_IDENTIFIER() { return GetToken(CypherParser.EXTENDED_IDENTIFIER, 0); }
		public ParameterNameContext(ParserRuleContext parent, int invokingState) : base(parent, invokingState) { }
		public ParameterNameContext(ParserRuleContext parent, int invokingState, String paramType)
			: base(parent, invokingState)
		{
			this.paramType = paramType;
		}
		public override int RuleIndex { get { return RULE_parameterName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitParameterName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ParameterNameContext parameterName(String paramType) {
		ParameterNameContext _localctx = new ParameterNameContext(Context, State, paramType);
		EnterRule(_localctx, 292, RULE_parameterName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2099;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ESCAPED_SYMBOLIC_NAME:
			case ACCESS:
			case ACTIVE:
			case ADD:
			case ADMIN:
			case ADMINISTRATOR:
			case ALIAS:
			case ALIASES:
			case ALL_SHORTEST_PATHS:
			case ALL:
			case ALLREDUCE:
			case ALTER:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASCENDING:
			case ASSIGN:
			case AT:
			case AUTH:
			case BINDINGS:
			case BOOL:
			case BOOLEAN:
			case BOOSTED:
			case BOTH:
			case BREAK:
			case BUILT:
			case BY:
			case CALL:
			case CASCADE:
			case CASE:
			case CHANGE:
			case CIDR:
			case COLLECT:
			case COMMAND:
			case COMMANDS:
			case COMPOSITE:
			case CONCURRENT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONTAINS:
			case COPY:
			case CONTINUE:
			case COSINE:
			case COUNT:
			case CREATE:
			case CREDENTIAL:
			case CSV:
			case CURRENT:
			case CYPHER:
			case DATA:
			case DATABASE:
			case DATABASES:
			case DATE:
			case DATETIME:
			case DBMS:
			case DEALLOCATE:
			case DEFAULT:
			case DEFINED:
			case DELETE:
			case DENY:
			case DESC:
			case DESCENDING:
			case DESTROY:
			case DETACH:
			case DIFFERENT:
			case DISTINCT:
			case DOT_METRIC:
			case DRIVER:
			case DROP:
			case DRYRUN:
			case DUMP:
			case DURATION:
			case EACH:
			case EDGE:
			case ENABLE:
			case ELEMENT:
			case ELEMENTS:
			case ELSE:
			case ENCRYPTED:
			case EUCLIDEAN:
			case EUCLIDEAN_SQUARED:
			case END:
			case ENDS:
			case EXECUTABLE:
			case EXECUTE:
			case EXIST:
			case EXISTENCE:
			case EXISTS:
			case ERROR:
			case FAIL:
			case FALSE:
			case FIELDTERMINATOR:
			case FILTER:
			case FINISH:
			case FLOAT:
			case FLOAT64:
			case FLOAT32:
			case FOR:
			case FOREACH:
			case FORWARDING:
			case FROM:
			case FULLTEXT:
			case FUNCTION:
			case FUNCTIONS:
			case GRANT:
			case GRAPH:
			case GRAPHS:
			case GROUP:
			case GROUPS:
			case HAMMING:
			case HEADERS:
			case HOME:
			case ID:
			case IF:
			case IMPERSONATE:
			case IMMUTABLE:
			case IN:
			case INDEX:
			case INDEXES:
			case INF:
			case INFINITY:
			case INSERT:
			case INT:
			case INT64:
			case INT32:
			case INT16:
			case INT8:
			case INTEGER:
			case INTEGER64:
			case INTEGER32:
			case INTEGER16:
			case INTEGER8:
			case IS:
			case JOIN:
			case KEY:
			case LABEL:
			case LABELS:
			case LANGUAGE:
			case LEADING:
			case LET:
			case LIMITROWS:
			case LIST:
			case LOAD:
			case LOCAL:
			case LOOKUP:
			case MANAGEMENT:
			case MANHATTAN:
			case MAP:
			case MATCH:
			case MERGE:
			case IMPLIES:
			case NAME:
			case NAMES:
			case NAN:
			case NFC:
			case NFD:
			case NFKC:
			case NFKD:
			case NEW:
			case NEXT:
			case NODE:
			case NODETACH:
			case NODES:
			case NONE:
			case NORMALIZE:
			case NORMALIZED:
			case NOT:
			case NOTHING:
			case NOWAIT:
			case NULL:
			case OF:
			case OFFSET:
			case OIDC:
			case ON:
			case ONLY:
			case OPTIONAL:
			case OPTIONS:
			case OPTION:
			case OR:
			case ORDER:
			case PASSWORD:
			case PASSWORDS:
			case PATH:
			case PATHS:
			case PLAINTEXT:
			case POINT:
			case POPULATED:
			case PRIMARY:
			case PRIMARIES:
			case PRIVILEGE:
			case PRIVILEGES:
			case PROCEDURE:
			case PROCEDURES:
			case PROPERTIES:
			case PROPERTY:
			case PROVIDER:
			case PROVIDERS:
			case RANGE:
			case READ:
			case REALLOCATE:
			case REDUCE:
			case RENAME:
			case REL:
			case RELATIONSHIP:
			case RELATIONSHIPS:
			case REMOVE:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case REPLICAS:
			case REPORT:
			case REQUIRE:
			case REQUIRED:
			case RESTRICT:
			case RETRY:
			case RETURN:
			case REVOKE:
			case ROLE:
			case ROLES:
			case ROW:
			case ROWS:
			case SCAN:
			case SEC:
			case SECOND:
			case SECONDARY:
			case SECONDARIES:
			case SECONDS:
			case SEEK:
			case SERVER:
			case SERVERS:
			case SET:
			case SETTING:
			case SETTINGS:
			case SHARD:
			case SHARDS:
			case SHORTEST_PATH:
			case SHORTEST:
			case SHOW:
			case SIGNED:
			case SINGLE:
			case SKIPROWS:
			case START:
			case STARTS:
			case STATUS:
			case STOP:
			case STRING:
			case SUPPORTED:
			case SUSPENDED:
			case TARGET:
			case TERMINATE:
			case TEXT:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE:
			case TO:
			case TOPOLOGY:
			case TRAILING:
			case TRANSACTION:
			case TRANSACTIONS:
			case TRAVERSE:
			case TRIM:
			case TRUE:
			case TYPE:
			case TYPED:
			case TYPES:
			case UNION:
			case UNIQUE:
			case UNIQUENESS:
			case UNWIND:
			case URL:
			case USE:
			case USER:
			case USERS:
			case USING:
			case VALUE:
			case VARCHAR:
			case VECTOR:
			case VECTOR_DISTANCE:
			case VECTOR_NORM:
			case VERTEX:
			case WAIT:
			case WHEN:
			case WHERE:
			case WITH:
			case WITHOUT:
			case WRITE:
			case XOR:
			case YIELD:
			case ZONE:
			case ZONED:
			case IDENTIFIER:
				{
				State = 2095;
				symbolicNameString();
				}
				break;
			case UNSIGNED_DECIMAL_INTEGER:
				{
				State = 2096;
				Match(UNSIGNED_DECIMAL_INTEGER);
				}
				break;
			case UNSIGNED_OCTAL_INTEGER:
				{
				State = 2097;
				Match(UNSIGNED_OCTAL_INTEGER);
				}
				break;
			case EXTENDED_IDENTIFIER:
				{
				State = 2098;
				Match(EXTENDED_IDENTIFIER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionInvocationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionNameContext functionName() {
			return GetRuleContext<FunctionNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionArgumentContext[] functionArgument() {
			return GetRuleContexts<FunctionArgumentContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionArgumentContext functionArgument(int i) {
			return GetRuleContext<FunctionArgumentContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISTINCT() { return GetToken(CypherParser.DISTINCT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(CypherParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public FunctionInvocationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionInvocation; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionInvocation(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionInvocationContext functionInvocation() {
		FunctionInvocationContext _localctx = new FunctionInvocationContext(Context, State);
		EnterRule(_localctx, 294, RULE_functionInvocation);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2101;
			functionName();
			State = 2102;
			Match(LPAREN);
			State = 2104;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,196,Context) ) {
			case 1:
				{
				State = 2103;
				_la = TokenStream.LA(1);
				if ( !(_la==ALL || _la==DISTINCT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			}
			State = 2114;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << DECIMAL_DOUBLE) | (1L << UNSIGNED_DECIMAL_INTEGER) | (1L << UNSIGNED_HEX_INTEGER) | (1L << UNSIGNED_OCTAL_INTEGER) | (1L << STRING_LITERAL1) | (1L << STRING_LITERAL2) | (1L << ESCAPED_SYMBOLIC_NAME) | (1L << ACCESS) | (1L << ACTIVE) | (1L << ADD) | (1L << ADMIN) | (1L << ADMINISTRATOR) | (1L << ALIAS) | (1L << ALIASES) | (1L << ALL_SHORTEST_PATHS) | (1L << ALL) | (1L << ALLREDUCE) | (1L << ALTER) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASCENDING) | (1L << ASSIGN) | (1L << AT) | (1L << AUTH) | (1L << BINDINGS) | (1L << BOOL) | (1L << BOOLEAN) | (1L << BOOSTED) | (1L << BOTH) | (1L << BREAK) | (1L << BUILT) | (1L << BY) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CHANGE) | (1L << CIDR) | (1L << COLLECT) | (1L << COMMAND) | (1L << COMMANDS) | (1L << COMPOSITE) | (1L << CONCURRENT) | (1L << CONSTRAINT) | (1L << CONSTRAINTS) | (1L << CONTAINS) | (1L << COPY) | (1L << CONTINUE) | (1L << COSINE) | (1L << COUNT) | (1L << CREATE) | (1L << CREDENTIAL) | (1L << CSV) | (1L << CURRENT))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CYPHER - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATABASES - 64)) | (1L << (DATE - 64)) | (1L << (DATETIME - 64)) | (1L << (DBMS - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFINED - 64)) | (1L << (DELETE - 64)) | (1L << (DENY - 64)) | (1L << (DESC - 64)) | (1L << (DESCENDING - 64)) | (1L << (DESTROY - 64)) | (1L << (DETACH - 64)) | (1L << (DIFFERENT - 64)) | (1L << (DOLLAR - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOT_METRIC - 64)) | (1L << (DRIVER - 64)) | (1L << (DROP - 64)) | (1L << (DRYRUN - 64)) | (1L << (DUMP - 64)) | (1L << (DURATION - 64)) | (1L << (EACH - 64)) | (1L << (EDGE - 64)) | (1L << (ENABLE - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELEMENTS - 64)) | (1L << (ELSE - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (EUCLIDEAN - 64)) | (1L << (EUCLIDEAN_SQUARED - 64)) | (1L << (END - 64)) | (1L << (ENDS - 64)) | (1L << (EXECUTABLE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXIST - 64)) | (1L << (EXISTENCE - 64)) | (1L << (EXISTS - 64)) | (1L << (ERROR - 64)) | (1L << (FAIL - 64)) | (1L << (FALSE - 64)) | (1L << (FIELDTERMINATOR - 64)) | (1L << (FILTER - 64)) | (1L << (FINISH - 64)) | (1L << (FLOAT - 64)) | (1L << (FLOAT64 - 64)) | (1L << (FLOAT32 - 64)) | (1L << (FOR - 64)) | (1L << (FOREACH - 64)) | (1L << (FORWARDING - 64)) | (1L << (FROM - 64)) | (1L << (FULLTEXT - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GRANT - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (GRAPH - 128)) | (1L << (GRAPHS - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPS - 128)) | (1L << (HAMMING - 128)) | (1L << (HEADERS - 128)) | (1L << (HOME - 128)) | (1L << (ID - 128)) | (1L << (IF - 128)) | (1L << (IMPERSONATE - 128)) | (1L << (IMMUTABLE - 128)) | (1L << (IN - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXES - 128)) | (1L << (INF - 128)) | (1L << (INFINITY - 128)) | (1L << (INSERT - 128)) | (1L << (INT - 128)) | (1L << (INT64 - 128)) | (1L << (INT32 - 128)) | (1L << (INT16 - 128)) | (1L << (INT8 - 128)) | (1L << (INTEGER - 128)) | (1L << (INTEGER64 - 128)) | (1L << (INTEGER32 - 128)) | (1L << (INTEGER16 - 128)) | (1L << (INTEGER8 - 128)) | (1L << (IS - 128)) | (1L << (JOIN - 128)) | (1L << (KEY - 128)) | (1L << (LABEL - 128)) | (1L << (LABELS - 128)) | (1L << (LANGUAGE - 128)) | (1L << (LBRACKET - 128)) | (1L << (LCURLY - 128)) | (1L << (LEADING - 128)) | (1L << (LET - 128)) | (1L << (LIMITROWS - 128)) | (1L << (LIST - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOOKUP - 128)) | (1L << (LPAREN - 128)) | (1L << (MANAGEMENT - 128)) | (1L << (MANHATTAN - 128)) | (1L << (MAP - 128)) | (1L << (MATCH - 128)) | (1L << (MERGE - 128)) | (1L << (MINUS - 128)) | (1L << (IMPLIES - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NAN - 128)) | (1L << (NFC - 128)) | (1L << (NFD - 128)) | (1L << (NFKC - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (NFKD - 192)) | (1L << (NEW - 192)) | (1L << (NEXT - 192)) | (1L << (NODE - 192)) | (1L << (NODETACH - 192)) | (1L << (NODES - 192)) | (1L << (NONE - 192)) | (1L << (NORMALIZE - 192)) | (1L << (NORMALIZED - 192)) | (1L << (NOT - 192)) | (1L << (NOTHING - 192)) | (1L << (NOWAIT - 192)) | (1L << (NULL - 192)) | (1L << (OF - 192)) | (1L << (OFFSET - 192)) | (1L << (OIDC - 192)) | (1L << (ON - 192)) | (1L << (ONLY - 192)) | (1L << (OPTIONAL - 192)) | (1L << (OPTIONS - 192)) | (1L << (OPTION - 192)) | (1L << (OR - 192)) | (1L << (ORDER - 192)) | (1L << (PASSWORD - 192)) | (1L << (PASSWORDS - 192)) | (1L << (PATH - 192)) | (1L << (PATHS - 192)) | (1L << (PLAINTEXT - 192)) | (1L << (PLUS - 192)) | (1L << (POINT - 192)) | (1L << (POPULATED - 192)) | (1L << (PRIMARY - 192)) | (1L << (PRIMARIES - 192)) | (1L << (PRIVILEGE - 192)) | (1L << (PRIVILEGES - 192)) | (1L << (PROCEDURE - 192)) | (1L << (PROCEDURES - 192)) | (1L << (PROPERTIES - 192)) | (1L << (PROPERTY - 192)) | (1L << (PROVIDER - 192)) | (1L << (PROVIDERS - 192)) | (1L << (RANGE - 192)) | (1L << (READ - 192)) | (1L << (REALLOCATE - 192)) | (1L << (REDUCE - 192)) | (1L << (RENAME - 192)) | (1L << (REL - 192)) | (1L << (RELATIONSHIP - 192)) | (1L << (RELATIONSHIPS - 192)) | (1L << (REMOVE - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (REPLICAS - 192)) | (1L << (REPORT - 192)) | (1L << (REQUIRE - 192)) | (1L << (REQUIRED - 192)) | (1L << (RESTRICT - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (RETRY - 256)) | (1L << (RETURN - 256)) | (1L << (REVOKE - 256)) | (1L << (ROLE - 256)) | (1L << (ROLES - 256)) | (1L << (ROW - 256)) | (1L << (ROWS - 256)) | (1L << (SCAN - 256)) | (1L << (SEC - 256)) | (1L << (SECOND - 256)) | (1L << (SECONDARY - 256)) | (1L << (SECONDARIES - 256)) | (1L << (SECONDS - 256)) | (1L << (SEEK - 256)) | (1L << (SERVER - 256)) | (1L << (SERVERS - 256)) | (1L << (SET - 256)) | (1L << (SETTING - 256)) | (1L << (SETTINGS - 256)) | (1L << (SHARD - 256)) | (1L << (SHARDS - 256)) | (1L << (SHORTEST_PATH - 256)) | (1L << (SHORTEST - 256)) | (1L << (SHOW - 256)) | (1L << (SIGNED - 256)) | (1L << (SINGLE - 256)) | (1L << (SKIPROWS - 256)) | (1L << (START - 256)) | (1L << (STARTS - 256)) | (1L << (STATUS - 256)) | (1L << (STOP - 256)) | (1L << (STRING - 256)) | (1L << (SUPPORTED - 256)) | (1L << (SUSPENDED - 256)) | (1L << (TARGET - 256)) | (1L << (TERMINATE - 256)) | (1L << (TEXT - 256)) | (1L << (THEN - 256)) | (1L << (TIME - 256)) | (1L << (TIMESTAMP - 256)) | (1L << (TIMEZONE - 256)) | (1L << (TO - 256)) | (1L << (TOPOLOGY - 256)) | (1L << (TRAILING - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSACTIONS - 256)) | (1L << (TRAVERSE - 256)) | (1L << (TRIM - 256)) | (1L << (TRUE - 256)) | (1L << (TYPE - 256)) | (1L << (TYPED - 256)) | (1L << (TYPES - 256)) | (1L << (UNION - 256)) | (1L << (UNIQUE - 256)) | (1L << (UNIQUENESS - 256)) | (1L << (UNWIND - 256)) | (1L << (URL - 256)) | (1L << (USE - 256)) | (1L << (USER - 256)) | (1L << (USERS - 256)) | (1L << (USING - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (VALUE - 320)) | (1L << (VARCHAR - 320)) | (1L << (VECTOR - 320)) | (1L << (VECTOR_DISTANCE - 320)) | (1L << (VECTOR_NORM - 320)) | (1L << (VERTEX - 320)) | (1L << (WAIT - 320)) | (1L << (WHEN - 320)) | (1L << (WHERE - 320)) | (1L << (WITH - 320)) | (1L << (WITHOUT - 320)) | (1L << (WRITE - 320)) | (1L << (XOR - 320)) | (1L << (YIELD - 320)) | (1L << (ZONE - 320)) | (1L << (ZONED - 320)) | (1L << (IDENTIFIER - 320)))) != 0)) {
				{
				State = 2106;
				functionArgument();
				State = 2111;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2107;
					Match(COMMA);
					State = 2108;
					functionArgument();
					}
					}
					State = 2113;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 2116;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionArgumentContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public FunctionArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionArgument; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionArgumentContext functionArgument() {
		FunctionArgumentContext _localctx = new FunctionArgumentContext(Context, State);
		EnterRule(_localctx, 296, RULE_functionArgument);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2118;
			expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NamespaceContext @namespace() {
			return GetRuleContext<NamespaceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString() {
			return GetRuleContext<SymbolicNameStringContext>(0);
		}
		public FunctionNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionNameContext functionName() {
		FunctionNameContext _localctx = new FunctionNameContext(Context, State);
		EnterRule(_localctx, 298, RULE_functionName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2120;
			@namespace();
			State = 2121;
			symbolicNameString();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamespaceContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext[] symbolicNameString() {
			return GetRuleContexts<SymbolicNameStringContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString(int i) {
			return GetRuleContext<SymbolicNameStringContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] DOT() { return GetTokens(CypherParser.DOT); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT(int i) {
			return GetToken(CypherParser.DOT, i);
		}
		public NamespaceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namespace; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamespace(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NamespaceContext @namespace() {
		NamespaceContext _localctx = new NamespaceContext(Context, State);
		EnterRule(_localctx, 300, RULE_namespace);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2128;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,199,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2123;
					symbolicNameString();
					State = 2124;
					Match(DOT);
					}
					} 
				}
				State = 2130;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,199,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VariableContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicVariableNameStringContext symbolicVariableNameString() {
			return GetRuleContext<SymbolicVariableNameStringContext>(0);
		}
		public VariableContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_variable; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVariable(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VariableContext variable() {
		VariableContext _localctx = new VariableContext(Context, State);
		EnterRule(_localctx, 302, RULE_variable);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2131;
			symbolicVariableNameString();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NonEmptyNameListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext[] symbolicNameString() {
			return GetRuleContexts<SymbolicNameStringContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString(int i) {
			return GetRuleContext<SymbolicNameStringContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public NonEmptyNameListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nonEmptyNameList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNonEmptyNameList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NonEmptyNameListContext nonEmptyNameList() {
		NonEmptyNameListContext _localctx = new NonEmptyNameListContext(Context, State);
		EnterRule(_localctx, 304, RULE_nonEmptyNameList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2133;
			symbolicNameString();
			State = 2138;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2134;
				Match(COMMA);
				State = 2135;
				symbolicNameString();
				}
				}
				State = 2140;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypePartContext[] typePart() {
			return GetRuleContexts<TypePartContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypePartContext typePart(int i) {
			return GetRuleContext<TypePartContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] BAR() { return GetTokens(CypherParser.BAR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BAR(int i) {
			return GetToken(CypherParser.BAR, i);
		}
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(Context, State);
		EnterRule(_localctx, 306, RULE_type);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 2141;
			typePart();
			State = 2146;
			ErrorHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(TokenStream,201,Context);
			while ( _alt!=2 && _alt!=global::Antlr4.Runtime.Atn.ATN.INVALID_ALT_NUMBER ) {
				if ( _alt==1 ) {
					{
					{
					State = 2142;
					Match(BAR);
					State = 2143;
					typePart();
					}
					} 
				}
				State = 2148;
				ErrorHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(TokenStream,201,Context);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypePartContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeNameContext typeName() {
			return GetRuleContext<TypeNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeNullabilityContext typeNullability() {
			return GetRuleContext<TypeNullabilityContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeListSuffixContext[] typeListSuffix() {
			return GetRuleContexts<TypeListSuffixContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeListSuffixContext typeListSuffix(int i) {
			return GetRuleContext<TypeListSuffixContext>(i);
		}
		public TypePartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typePart; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypePart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypePartContext typePart() {
		TypePartContext _localctx = new TypePartContext(Context, State);
		EnterRule(_localctx, 308, RULE_typePart);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2149;
			typeName();
			State = 2151;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXCLAMATION_MARK || _la==NOT) {
				{
				State = 2150;
				typeNullability();
				}
			}

			State = 2156;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==ARRAY || _la==LIST) {
				{
				{
				State = 2153;
				typeListSuffix();
				}
				}
				State = 2158;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOTHING() { return GetToken(CypherParser.NOTHING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(CypherParser.NULL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BOOL() { return GetToken(CypherParser.BOOL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BOOLEAN() { return GetToken(CypherParser.BOOLEAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARCHAR() { return GetToken(CypherParser.VARCHAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STRING() { return GetToken(CypherParser.STRING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT() { return GetToken(CypherParser.INT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER() { return GetToken(CypherParser.INTEGER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SIGNED() { return GetToken(CypherParser.SIGNED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER64() { return GetToken(CypherParser.INTEGER64, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT64() { return GetToken(CypherParser.INT64, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FLOAT() { return GetToken(CypherParser.FLOAT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FLOAT64() { return GetToken(CypherParser.FLOAT64, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATE() { return GetToken(CypherParser.DATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCAL() { return GetToken(CypherParser.LOCAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] TIME() { return GetTokens(CypherParser.TIME); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIME(int i) {
			return GetToken(CypherParser.TIME, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATETIME() { return GetToken(CypherParser.DATETIME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ZONED() { return GetToken(CypherParser.ZONED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITHOUT() { return GetToken(CypherParser.WITHOUT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(CypherParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMEZONE() { return GetToken(CypherParser.TIMEZONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ZONE() { return GetToken(CypherParser.ZONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMESTAMP() { return GetToken(CypherParser.TIMESTAMP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DURATION() { return GetToken(CypherParser.DURATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode POINT() { return GetToken(CypherParser.POINT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NODE() { return GetToken(CypherParser.NODE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VECTOR() { return GetToken(CypherParser.VECTOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SignedIntegerLiteralContext signedIntegerLiteral() {
			return GetRuleContext<SignedIntegerLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA() { return GetToken(CypherParser.COMMA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VectorCoordinateTypeContext vectorCoordinateType() {
			return GetRuleContext<VectorCoordinateTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LT() { return GetToken(CypherParser.LT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GT() { return GetToken(CypherParser.GT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VERTEX() { return GetToken(CypherParser.VERTEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELATIONSHIP() { return GetToken(CypherParser.RELATIONSHIP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDGE() { return GetToken(CypherParser.EDGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAP() { return GetToken(CypherParser.MAP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIST() { return GetToken(CypherParser.LIST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ARRAY() { return GetToken(CypherParser.ARRAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PATH() { return GetToken(CypherParser.PATH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PATHS() { return GetToken(CypherParser.PATHS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROPERTY() { return GetToken(CypherParser.PROPERTY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUE() { return GetToken(CypherParser.VALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANY() { return GetToken(CypherParser.ANY, 0); }
		public TypeNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeNameContext typeName() {
		TypeNameContext _localctx = new TypeNameContext(Context, State);
		EnterRule(_localctx, 310, RULE_typeName);
		int _la;
		try {
			State = 2247;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,211,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2159;
				Match(NOTHING);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2160;
				Match(NULL);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2161;
				Match(BOOL);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2162;
				Match(BOOLEAN);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2163;
				Match(VARCHAR);
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2164;
				Match(STRING);
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2165;
				Match(INT);
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 2167;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SIGNED) {
					{
					State = 2166;
					Match(SIGNED);
					}
				}

				State = 2169;
				Match(INTEGER);
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 2170;
				Match(INTEGER64);
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 2171;
				Match(INT64);
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 2172;
				Match(FLOAT);
				}
				break;
			case 12:
				EnterOuterAlt(_localctx, 12);
				{
				State = 2173;
				Match(FLOAT64);
				}
				break;
			case 13:
				EnterOuterAlt(_localctx, 13);
				{
				State = 2174;
				Match(DATE);
				}
				break;
			case 14:
				EnterOuterAlt(_localctx, 14);
				{
				State = 2175;
				Match(LOCAL);
				State = 2176;
				_la = TokenStream.LA(1);
				if ( !(_la==DATETIME || _la==TIME) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 15:
				EnterOuterAlt(_localctx, 15);
				{
				State = 2177;
				Match(ZONED);
				State = 2178;
				_la = TokenStream.LA(1);
				if ( !(_la==DATETIME || _la==TIME) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case 16:
				EnterOuterAlt(_localctx, 16);
				{
				State = 2179;
				Match(TIME);
				State = 2180;
				_la = TokenStream.LA(1);
				if ( !(_la==WITH || _la==WITHOUT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2184;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case TIMEZONE:
					{
					State = 2181;
					Match(TIMEZONE);
					}
					break;
				case TIME:
					{
					State = 2182;
					Match(TIME);
					State = 2183;
					Match(ZONE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 17:
				EnterOuterAlt(_localctx, 17);
				{
				State = 2186;
				Match(TIMESTAMP);
				State = 2187;
				_la = TokenStream.LA(1);
				if ( !(_la==WITH || _la==WITHOUT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2191;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case TIMEZONE:
					{
					State = 2188;
					Match(TIMEZONE);
					}
					break;
				case TIME:
					{
					State = 2189;
					Match(TIME);
					State = 2190;
					Match(ZONE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case 18:
				EnterOuterAlt(_localctx, 18);
				{
				State = 2193;
				Match(DURATION);
				}
				break;
			case 19:
				EnterOuterAlt(_localctx, 19);
				{
				State = 2194;
				Match(POINT);
				}
				break;
			case 20:
				EnterOuterAlt(_localctx, 20);
				{
				State = 2195;
				Match(NODE);
				}
				break;
			case 21:
				EnterOuterAlt(_localctx, 21);
				{
				State = 2196;
				Match(VECTOR);
				State = 2197;
				Match(LPAREN);
				State = 2198;
				signedIntegerLiteral();
				State = 2199;
				Match(COMMA);
				State = 2200;
				vectorCoordinateType();
				State = 2201;
				Match(RPAREN);
				}
				break;
			case 22:
				EnterOuterAlt(_localctx, 22);
				{
				State = 2203;
				Match(VECTOR);
				State = 2208;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,207,Context) ) {
				case 1:
					{
					State = 2204;
					Match(LT);
					State = 2205;
					vectorCoordinateType();
					State = 2206;
					Match(GT);
					}
					break;
				}
				State = 2214;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LPAREN) {
					{
					State = 2210;
					Match(LPAREN);
					State = 2211;
					signedIntegerLiteral();
					State = 2212;
					Match(RPAREN);
					}
				}

				}
				break;
			case 23:
				EnterOuterAlt(_localctx, 23);
				{
				State = 2216;
				Match(VERTEX);
				}
				break;
			case 24:
				EnterOuterAlt(_localctx, 24);
				{
				State = 2217;
				Match(RELATIONSHIP);
				}
				break;
			case 25:
				EnterOuterAlt(_localctx, 25);
				{
				State = 2218;
				Match(EDGE);
				}
				break;
			case 26:
				EnterOuterAlt(_localctx, 26);
				{
				State = 2219;
				Match(MAP);
				}
				break;
			case 27:
				EnterOuterAlt(_localctx, 27);
				{
				State = 2220;
				_la = TokenStream.LA(1);
				if ( !(_la==ARRAY || _la==LIST) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2221;
				Match(LT);
				State = 2222;
				type();
				State = 2223;
				Match(GT);
				}
				break;
			case 28:
				EnterOuterAlt(_localctx, 28);
				{
				State = 2225;
				Match(PATH);
				}
				break;
			case 29:
				EnterOuterAlt(_localctx, 29);
				{
				State = 2226;
				Match(PATHS);
				}
				break;
			case 30:
				EnterOuterAlt(_localctx, 30);
				{
				State = 2227;
				Match(PROPERTY);
				State = 2228;
				Match(VALUE);
				}
				break;
			case 31:
				EnterOuterAlt(_localctx, 31);
				{
				State = 2229;
				Match(ANY);
				State = 2245;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,210,Context) ) {
				case 1:
					{
					State = 2230;
					Match(NODE);
					}
					break;
				case 2:
					{
					State = 2231;
					Match(VERTEX);
					}
					break;
				case 3:
					{
					State = 2232;
					Match(RELATIONSHIP);
					}
					break;
				case 4:
					{
					State = 2233;
					Match(EDGE);
					}
					break;
				case 5:
					{
					State = 2234;
					Match(MAP);
					}
					break;
				case 6:
					{
					State = 2235;
					Match(PROPERTY);
					State = 2236;
					Match(VALUE);
					}
					break;
				case 7:
					{
					State = 2238;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==VALUE) {
						{
						State = 2237;
						Match(VALUE);
						}
					}

					State = 2240;
					Match(LT);
					State = 2241;
					type();
					State = 2242;
					Match(GT);
					}
					break;
				case 8:
					{
					State = 2244;
					Match(VALUE);
					}
					break;
				}
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeNullabilityContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(CypherParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(CypherParser.NULL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXCLAMATION_MARK() { return GetToken(CypherParser.EXCLAMATION_MARK, 0); }
		public TypeNullabilityContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeNullability; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeNullability(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeNullabilityContext typeNullability() {
		TypeNullabilityContext _localctx = new TypeNullabilityContext(Context, State);
		EnterRule(_localctx, 312, RULE_typeNullability);
		try {
			State = 2252;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NOT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2249;
				Match(NOT);
				State = 2250;
				Match(NULL);
				}
				break;
			case EXCLAMATION_MARK:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2251;
				Match(EXCLAMATION_MARK);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeListSuffixContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIST() { return GetToken(CypherParser.LIST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ARRAY() { return GetToken(CypherParser.ARRAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeNullabilityContext typeNullability() {
			return GetRuleContext<TypeNullabilityContext>(0);
		}
		public TypeListSuffixContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typeListSuffix; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTypeListSuffix(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeListSuffixContext typeListSuffix() {
		TypeListSuffixContext _localctx = new TypeListSuffixContext(Context, State);
		EnterRule(_localctx, 314, RULE_typeListSuffix);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2254;
			_la = TokenStream.LA(1);
			if ( !(_la==ARRAY || _la==LIST) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2256;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXCLAMATION_MARK || _la==NOT) {
				{
				State = 2255;
				typeNullability();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class VectorCoordinateTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT() { return GetToken(CypherParser.INT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER() { return GetToken(CypherParser.INTEGER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER64() { return GetToken(CypherParser.INTEGER64, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER32() { return GetToken(CypherParser.INTEGER32, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER16() { return GetToken(CypherParser.INTEGER16, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER8() { return GetToken(CypherParser.INTEGER8, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT64() { return GetToken(CypherParser.INT64, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT32() { return GetToken(CypherParser.INT32, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT16() { return GetToken(CypherParser.INT16, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT8() { return GetToken(CypherParser.INT8, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FLOAT() { return GetToken(CypherParser.FLOAT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FLOAT64() { return GetToken(CypherParser.FLOAT64, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FLOAT32() { return GetToken(CypherParser.FLOAT32, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TypeNullabilityContext typeNullability() {
			return GetRuleContext<TypeNullabilityContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SIGNED() { return GetToken(CypherParser.SIGNED, 0); }
		public VectorCoordinateTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_vectorCoordinateType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitVectorCoordinateType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public VectorCoordinateTypeContext vectorCoordinateType() {
		VectorCoordinateTypeContext _localctx = new VectorCoordinateTypeContext(Context, State);
		EnterRule(_localctx, 316, RULE_vectorCoordinateType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2274;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case INT:
				{
				State = 2258;
				Match(INT);
				}
				break;
			case INTEGER:
			case SIGNED:
				{
				State = 2260;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SIGNED) {
					{
					State = 2259;
					Match(SIGNED);
					}
				}

				State = 2262;
				Match(INTEGER);
				}
				break;
			case INTEGER64:
				{
				State = 2263;
				Match(INTEGER64);
				}
				break;
			case INTEGER32:
				{
				State = 2264;
				Match(INTEGER32);
				}
				break;
			case INTEGER16:
				{
				State = 2265;
				Match(INTEGER16);
				}
				break;
			case INTEGER8:
				{
				State = 2266;
				Match(INTEGER8);
				}
				break;
			case INT64:
				{
				State = 2267;
				Match(INT64);
				}
				break;
			case INT32:
				{
				State = 2268;
				Match(INT32);
				}
				break;
			case INT16:
				{
				State = 2269;
				Match(INT16);
				}
				break;
			case INT8:
				{
				State = 2270;
				Match(INT8);
				}
				break;
			case FLOAT:
				{
				State = 2271;
				Match(FLOAT);
				}
				break;
			case FLOAT64:
				{
				State = 2272;
				Match(FLOAT64);
				}
				break;
			case FLOAT32:
				{
				State = 2273;
				Match(FLOAT32);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2277;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXCLAMATION_MARK || _la==NOT) {
				{
				State = 2276;
				typeNullability();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommandContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public CreateCommandContext createCommand() {
			return GetRuleContext<CreateCommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DropCommandContext dropCommand() {
			return GetRuleContext<DropCommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterCommandContext alterCommand() {
			return GetRuleContext<AlterCommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RenameCommandContext renameCommand() {
			return GetRuleContext<RenameCommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DenyCommandContext denyCommand() {
			return GetRuleContext<DenyCommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RevokeCommandContext revokeCommand() {
			return GetRuleContext<RevokeCommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GrantCommandContext grantCommand() {
			return GetRuleContext<GrantCommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StartDatabaseContext startDatabase() {
			return GetRuleContext<StartDatabaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StopDatabaseContext stopDatabase() {
			return GetRuleContext<StopDatabaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EnableServerCommandContext enableServerCommand() {
			return GetRuleContext<EnableServerCommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AllocationCommandContext allocationCommand() {
			return GetRuleContext<AllocationCommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowCommandContext showCommand() {
			return GetRuleContext<ShowCommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TerminateCommandContext terminateCommand() {
			return GetRuleContext<TerminateCommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UseClauseContext useClause() {
			return GetRuleContext<UseClauseContext>(0);
		}
		public CommandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_command; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCommand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CommandContext command() {
		CommandContext _localctx = new CommandContext(Context, State);
		EnterRule(_localctx, 318, RULE_command);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2280;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==USE) {
				{
				State = 2279;
				useClause();
				}
			}

			State = 2295;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CREATE:
				{
				State = 2282;
				createCommand();
				}
				break;
			case DROP:
				{
				State = 2283;
				dropCommand();
				}
				break;
			case ALTER:
				{
				State = 2284;
				alterCommand();
				}
				break;
			case RENAME:
				{
				State = 2285;
				renameCommand();
				}
				break;
			case DENY:
				{
				State = 2286;
				denyCommand();
				}
				break;
			case REVOKE:
				{
				State = 2287;
				revokeCommand();
				}
				break;
			case GRANT:
				{
				State = 2288;
				grantCommand();
				}
				break;
			case START:
				{
				State = 2289;
				startDatabase();
				}
				break;
			case STOP:
				{
				State = 2290;
				stopDatabase();
				}
				break;
			case ENABLE:
				{
				State = 2291;
				enableServerCommand();
				}
				break;
			case DEALLOCATE:
			case DRYRUN:
			case REALLOCATE:
				{
				State = 2292;
				allocationCommand();
				}
				break;
			case SHOW:
				{
				State = 2293;
				showCommand();
				}
				break;
			case TERMINATE:
				{
				State = 2294;
				terminateCommand();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateCommandContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CREATE() { return GetToken(CypherParser.CREATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CreateAliasContext createAlias() {
			return GetRuleContext<CreateAliasContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateCompositeDatabaseContext createCompositeDatabase() {
			return GetRuleContext<CreateCompositeDatabaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateConstraintContext createConstraint() {
			return GetRuleContext<CreateConstraintContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateDatabaseContext createDatabase() {
			return GetRuleContext<CreateDatabaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateIndexContext createIndex() {
			return GetRuleContext<CreateIndexContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateRoleContext createRole() {
			return GetRuleContext<CreateRoleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateUserContext createUser() {
			return GetRuleContext<CreateUserContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR() { return GetToken(CypherParser.OR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REPLACE() { return GetToken(CypherParser.REPLACE, 0); }
		public CreateCommandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createCommand; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateCommand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateCommandContext createCommand() {
		CreateCommandContext _localctx = new CreateCommandContext(Context, State);
		EnterRule(_localctx, 320, RULE_createCommand);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2297;
			Match(CREATE);
			State = 2300;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OR) {
				{
				State = 2298;
				Match(OR);
				State = 2299;
				Match(REPLACE);
				}
			}

			State = 2309;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALIAS:
				{
				State = 2302;
				createAlias();
				}
				break;
			case COMPOSITE:
				{
				State = 2303;
				createCompositeDatabase();
				}
				break;
			case CONSTRAINT:
				{
				State = 2304;
				createConstraint();
				}
				break;
			case DATABASE:
				{
				State = 2305;
				createDatabase();
				}
				break;
			case FULLTEXT:
			case INDEX:
			case LOOKUP:
			case POINT:
			case RANGE:
			case TEXT:
			case VECTOR:
				{
				State = 2306;
				createIndex();
				}
				break;
			case IMMUTABLE:
			case ROLE:
				{
				State = 2307;
				createRole();
				}
				break;
			case USER:
				{
				State = 2308;
				createUser();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterCommandContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALTER() { return GetToken(CypherParser.ALTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AlterAliasContext alterAlias() {
			return GetRuleContext<AlterAliasContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterCurrentUserContext alterCurrentUser() {
			return GetRuleContext<AlterCurrentUserContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterCurrentGraphTypeContext alterCurrentGraphType() {
			return GetRuleContext<AlterCurrentGraphTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterDatabaseContext alterDatabase() {
			return GetRuleContext<AlterDatabaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterUserContext alterUser() {
			return GetRuleContext<AlterUserContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterServerContext alterServer() {
			return GetRuleContext<AlterServerContext>(0);
		}
		public AlterCommandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterCommand; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterCommand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterCommandContext alterCommand() {
		AlterCommandContext _localctx = new AlterCommandContext(Context, State);
		EnterRule(_localctx, 322, RULE_alterCommand);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2311;
			Match(ALTER);
			State = 2318;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,221,Context) ) {
			case 1:
				{
				State = 2312;
				alterAlias();
				}
				break;
			case 2:
				{
				State = 2313;
				alterCurrentUser();
				}
				break;
			case 3:
				{
				State = 2314;
				alterCurrentGraphType();
				}
				break;
			case 4:
				{
				State = 2315;
				alterDatabase();
				}
				break;
			case 5:
				{
				State = 2316;
				alterUser();
				}
				break;
			case 6:
				{
				State = 2317;
				alterServer();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropCommandContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DROP() { return GetToken(CypherParser.DROP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DropAliasContext dropAlias() {
			return GetRuleContext<DropAliasContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DropConstraintContext dropConstraint() {
			return GetRuleContext<DropConstraintContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DropDatabaseContext dropDatabase() {
			return GetRuleContext<DropDatabaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DropIndexContext dropIndex() {
			return GetRuleContext<DropIndexContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DropRoleContext dropRole() {
			return GetRuleContext<DropRoleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DropServerContext dropServer() {
			return GetRuleContext<DropServerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DropUserContext dropUser() {
			return GetRuleContext<DropUserContext>(0);
		}
		public DropCommandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropCommand; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDropCommand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DropCommandContext dropCommand() {
		DropCommandContext _localctx = new DropCommandContext(Context, State);
		EnterRule(_localctx, 324, RULE_dropCommand);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2320;
			Match(DROP);
			State = 2328;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALIAS:
				{
				State = 2321;
				dropAlias();
				}
				break;
			case CONSTRAINT:
				{
				State = 2322;
				dropConstraint();
				}
				break;
			case COMPOSITE:
			case DATABASE:
				{
				State = 2323;
				dropDatabase();
				}
				break;
			case INDEX:
				{
				State = 2324;
				dropIndex();
				}
				break;
			case ROLE:
				{
				State = 2325;
				dropRole();
				}
				break;
			case SERVER:
				{
				State = 2326;
				dropServer();
				}
				break;
			case USER:
				{
				State = 2327;
				dropUser();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowCommandContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHOW() { return GetToken(CypherParser.SHOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ShowAliasesContext showAliases() {
			return GetRuleContext<ShowAliasesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowConstraintCommandContext showConstraintCommand() {
			return GetRuleContext<ShowConstraintCommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowCurrentGraphTypeCommandContext showCurrentGraphTypeCommand() {
			return GetRuleContext<ShowCurrentGraphTypeCommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowCurrentUserContext showCurrentUser() {
			return GetRuleContext<ShowCurrentUserContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowDatabaseContext showDatabase() {
			return GetRuleContext<ShowDatabaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowFunctionsContext showFunctions() {
			return GetRuleContext<ShowFunctionsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowIndexCommandContext showIndexCommand() {
			return GetRuleContext<ShowIndexCommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowPrivilegesContext showPrivileges() {
			return GetRuleContext<ShowPrivilegesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowProceduresContext showProcedures() {
			return GetRuleContext<ShowProceduresContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowRolePrivilegesContext showRolePrivileges() {
			return GetRuleContext<ShowRolePrivilegesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowRolesContext showRoles() {
			return GetRuleContext<ShowRolesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowServersContext showServers() {
			return GetRuleContext<ShowServersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowSettingsContext showSettings() {
			return GetRuleContext<ShowSettingsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowSupportedPrivilegesContext showSupportedPrivileges() {
			return GetRuleContext<ShowSupportedPrivilegesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowTransactionsContext showTransactions() {
			return GetRuleContext<ShowTransactionsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowUserPrivilegesContext showUserPrivileges() {
			return GetRuleContext<ShowUserPrivilegesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowUsersContext showUsers() {
			return GetRuleContext<ShowUsersContext>(0);
		}
		public ShowCommandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showCommand; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowCommand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowCommandContext showCommand() {
		ShowCommandContext _localctx = new ShowCommandContext(Context, State);
		EnterRule(_localctx, 326, RULE_showCommand);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2330;
			Match(SHOW);
			State = 2348;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,223,Context) ) {
			case 1:
				{
				State = 2331;
				showAliases();
				}
				break;
			case 2:
				{
				State = 2332;
				showConstraintCommand();
				}
				break;
			case 3:
				{
				State = 2333;
				showCurrentGraphTypeCommand();
				}
				break;
			case 4:
				{
				State = 2334;
				showCurrentUser();
				}
				break;
			case 5:
				{
				State = 2335;
				showDatabase();
				}
				break;
			case 6:
				{
				State = 2336;
				showFunctions();
				}
				break;
			case 7:
				{
				State = 2337;
				showIndexCommand();
				}
				break;
			case 8:
				{
				State = 2338;
				showPrivileges();
				}
				break;
			case 9:
				{
				State = 2339;
				showProcedures();
				}
				break;
			case 10:
				{
				State = 2340;
				showRolePrivileges();
				}
				break;
			case 11:
				{
				State = 2341;
				showRoles();
				}
				break;
			case 12:
				{
				State = 2342;
				showServers();
				}
				break;
			case 13:
				{
				State = 2343;
				showSettings();
				}
				break;
			case 14:
				{
				State = 2344;
				showSupportedPrivileges();
				}
				break;
			case 15:
				{
				State = 2345;
				showTransactions();
				}
				break;
			case 16:
				{
				State = 2346;
				showUserPrivileges();
				}
				break;
			case 17:
				{
				State = 2347;
				showUsers();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowCommandYieldContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public YieldClauseContext yieldClause() {
			return GetRuleContext<YieldClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReturnClauseContext returnClause() {
			return GetRuleContext<ReturnClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		public ShowCommandYieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showCommandYield; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowCommandYield(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowCommandYieldContext showCommandYield() {
		ShowCommandYieldContext _localctx = new ShowCommandYieldContext(Context, State);
		EnterRule(_localctx, 328, RULE_showCommandYield);
		int _la;
		try {
			State = 2355;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case YIELD:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2350;
				yieldClause();
				State = 2352;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==RETURN) {
					{
					State = 2351;
					returnClause();
					}
				}

				}
				break;
			case WHERE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2354;
				whereClause();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class YieldItemContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext[] variable() {
			return GetRuleContexts<VariableContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable(int i) {
			return GetRuleContext<VariableContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(CypherParser.AS, 0); }
		public YieldItemContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_yieldItem; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitYieldItem(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public YieldItemContext yieldItem() {
		YieldItemContext _localctx = new YieldItemContext(Context, State);
		EnterRule(_localctx, 330, RULE_yieldItem);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2357;
			variable();
			State = 2360;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 2358;
				Match(AS);
				State = 2359;
				variable();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class YieldSkipContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SignedIntegerLiteralContext signedIntegerLiteral() {
			return GetRuleContext<SignedIntegerLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OFFSET() { return GetToken(CypherParser.OFFSET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SKIPROWS() { return GetToken(CypherParser.SKIPROWS, 0); }
		public YieldSkipContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_yieldSkip; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitYieldSkip(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public YieldSkipContext yieldSkip() {
		YieldSkipContext _localctx = new YieldSkipContext(Context, State);
		EnterRule(_localctx, 332, RULE_yieldSkip);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2362;
			_la = TokenStream.LA(1);
			if ( !(_la==OFFSET || _la==SKIPROWS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2363;
			signedIntegerLiteral();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class YieldLimitContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIMITROWS() { return GetToken(CypherParser.LIMITROWS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SignedIntegerLiteralContext signedIntegerLiteral() {
			return GetRuleContext<SignedIntegerLiteralContext>(0);
		}
		public YieldLimitContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_yieldLimit; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitYieldLimit(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public YieldLimitContext yieldLimit() {
		YieldLimitContext _localctx = new YieldLimitContext(Context, State);
		EnterRule(_localctx, 334, RULE_yieldLimit);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2365;
			Match(LIMITROWS);
			State = 2366;
			signedIntegerLiteral();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class YieldClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode YIELD() { return GetToken(CypherParser.YIELD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMES() { return GetToken(CypherParser.TIMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public YieldItemContext[] yieldItem() {
			return GetRuleContexts<YieldItemContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public YieldItemContext yieldItem(int i) {
			return GetRuleContext<YieldItemContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public OrderByContext orderBy() {
			return GetRuleContext<OrderByContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public YieldSkipContext yieldSkip() {
			return GetRuleContext<YieldSkipContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public YieldLimitContext yieldLimit() {
			return GetRuleContext<YieldLimitContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WhereClauseContext whereClause() {
			return GetRuleContext<WhereClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public YieldClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_yieldClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitYieldClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public YieldClauseContext yieldClause() {
		YieldClauseContext _localctx = new YieldClauseContext(Context, State);
		EnterRule(_localctx, 336, RULE_yieldClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2368;
			Match(YIELD);
			State = 2378;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TIMES:
				{
				State = 2369;
				Match(TIMES);
				}
				break;
			case ESCAPED_SYMBOLIC_NAME:
			case ACCESS:
			case ACTIVE:
			case ADD:
			case ADMIN:
			case ADMINISTRATOR:
			case ALIAS:
			case ALIASES:
			case ALL_SHORTEST_PATHS:
			case ALL:
			case ALLREDUCE:
			case ALTER:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASCENDING:
			case ASSIGN:
			case AT:
			case AUTH:
			case BINDINGS:
			case BOOL:
			case BOOLEAN:
			case BOOSTED:
			case BOTH:
			case BREAK:
			case BUILT:
			case BY:
			case CALL:
			case CASCADE:
			case CASE:
			case CHANGE:
			case CIDR:
			case COLLECT:
			case COMMAND:
			case COMMANDS:
			case COMPOSITE:
			case CONCURRENT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONTAINS:
			case COPY:
			case CONTINUE:
			case COSINE:
			case COUNT:
			case CREATE:
			case CREDENTIAL:
			case CSV:
			case CURRENT:
			case CYPHER:
			case DATA:
			case DATABASE:
			case DATABASES:
			case DATE:
			case DATETIME:
			case DBMS:
			case DEALLOCATE:
			case DEFAULT:
			case DEFINED:
			case DELETE:
			case DENY:
			case DESC:
			case DESCENDING:
			case DESTROY:
			case DETACH:
			case DIFFERENT:
			case DISTINCT:
			case DOT_METRIC:
			case DRIVER:
			case DROP:
			case DRYRUN:
			case DUMP:
			case DURATION:
			case EACH:
			case EDGE:
			case ENABLE:
			case ELEMENT:
			case ELEMENTS:
			case ELSE:
			case ENCRYPTED:
			case EUCLIDEAN:
			case EUCLIDEAN_SQUARED:
			case END:
			case ENDS:
			case EXECUTABLE:
			case EXECUTE:
			case EXIST:
			case EXISTENCE:
			case EXISTS:
			case ERROR:
			case FAIL:
			case FALSE:
			case FIELDTERMINATOR:
			case FILTER:
			case FINISH:
			case FLOAT:
			case FLOAT64:
			case FLOAT32:
			case FOR:
			case FOREACH:
			case FORWARDING:
			case FROM:
			case FULLTEXT:
			case FUNCTION:
			case FUNCTIONS:
			case GRANT:
			case GRAPH:
			case GRAPHS:
			case GROUP:
			case GROUPS:
			case HAMMING:
			case HEADERS:
			case HOME:
			case ID:
			case IF:
			case IMPERSONATE:
			case IMMUTABLE:
			case IN:
			case INDEX:
			case INDEXES:
			case INF:
			case INFINITY:
			case INSERT:
			case INT:
			case INT64:
			case INT32:
			case INT16:
			case INT8:
			case INTEGER:
			case INTEGER64:
			case INTEGER32:
			case INTEGER16:
			case INTEGER8:
			case IS:
			case JOIN:
			case KEY:
			case LABEL:
			case LABELS:
			case LANGUAGE:
			case LEADING:
			case LET:
			case LIMITROWS:
			case LIST:
			case LOAD:
			case LOCAL:
			case LOOKUP:
			case MANAGEMENT:
			case MANHATTAN:
			case MAP:
			case MATCH:
			case MERGE:
			case IMPLIES:
			case NAME:
			case NAMES:
			case NAN:
			case NFC:
			case NFD:
			case NFKC:
			case NFKD:
			case NEW:
			case NEXT:
			case NODE:
			case NODETACH:
			case NODES:
			case NONE:
			case NORMALIZE:
			case NORMALIZED:
			case NOT:
			case NOTHING:
			case NOWAIT:
			case NULL:
			case OF:
			case OFFSET:
			case OIDC:
			case ON:
			case ONLY:
			case OPTIONAL:
			case OPTIONS:
			case OPTION:
			case OR:
			case ORDER:
			case PASSWORD:
			case PASSWORDS:
			case PATH:
			case PATHS:
			case PLAINTEXT:
			case POINT:
			case POPULATED:
			case PRIMARY:
			case PRIMARIES:
			case PRIVILEGE:
			case PRIVILEGES:
			case PROCEDURE:
			case PROCEDURES:
			case PROPERTIES:
			case PROPERTY:
			case PROVIDER:
			case PROVIDERS:
			case RANGE:
			case READ:
			case REALLOCATE:
			case REDUCE:
			case RENAME:
			case REL:
			case RELATIONSHIP:
			case RELATIONSHIPS:
			case REMOVE:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case REPLICAS:
			case REPORT:
			case REQUIRE:
			case REQUIRED:
			case RESTRICT:
			case RETRY:
			case RETURN:
			case REVOKE:
			case ROLE:
			case ROLES:
			case ROW:
			case ROWS:
			case SCAN:
			case SEC:
			case SECOND:
			case SECONDARY:
			case SECONDARIES:
			case SECONDS:
			case SEEK:
			case SERVER:
			case SERVERS:
			case SET:
			case SETTING:
			case SETTINGS:
			case SHARD:
			case SHARDS:
			case SHORTEST_PATH:
			case SHORTEST:
			case SHOW:
			case SIGNED:
			case SINGLE:
			case SKIPROWS:
			case START:
			case STARTS:
			case STATUS:
			case STOP:
			case STRING:
			case SUPPORTED:
			case SUSPENDED:
			case TARGET:
			case TERMINATE:
			case TEXT:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE:
			case TO:
			case TOPOLOGY:
			case TRAILING:
			case TRANSACTION:
			case TRANSACTIONS:
			case TRAVERSE:
			case TRIM:
			case TRUE:
			case TYPE:
			case TYPED:
			case TYPES:
			case UNION:
			case UNIQUE:
			case UNIQUENESS:
			case UNWIND:
			case URL:
			case USE:
			case USER:
			case USERS:
			case USING:
			case VALUE:
			case VARCHAR:
			case VECTOR:
			case VECTOR_DISTANCE:
			case VECTOR_NORM:
			case VERTEX:
			case WAIT:
			case WHEN:
			case WHERE:
			case WITH:
			case WITHOUT:
			case WRITE:
			case XOR:
			case YIELD:
			case ZONE:
			case ZONED:
			case IDENTIFIER:
				{
				State = 2370;
				yieldItem();
				State = 2375;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2371;
					Match(COMMA);
					State = 2372;
					yieldItem();
					}
					}
					State = 2377;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 2381;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ORDER) {
				{
				State = 2380;
				orderBy();
				}
			}

			State = 2384;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OFFSET || _la==SKIPROWS) {
				{
				State = 2383;
				yieldSkip();
				}
			}

			State = 2387;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LIMITROWS) {
				{
				State = 2386;
				yieldLimit();
				}
			}

			State = 2390;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE) {
				{
				State = 2389;
				whereClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommandOptionsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPTIONS() { return GetToken(CypherParser.OPTIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public MapOrParameterContext mapOrParameter() {
			return GetRuleContext<MapOrParameterContext>(0);
		}
		public CommandOptionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commandOptions; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCommandOptions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CommandOptionsContext commandOptions() {
		CommandOptionsContext _localctx = new CommandOptionsContext(Context, State);
		EnterRule(_localctx, 338, RULE_commandOptions);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2392;
			Match(OPTIONS);
			State = 2393;
			mapOrParameter();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TerminateCommandContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TERMINATE() { return GetToken(CypherParser.TERMINATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TerminateTransactionsContext terminateTransactions() {
			return GetRuleContext<TerminateTransactionsContext>(0);
		}
		public TerminateCommandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_terminateCommand; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTerminateCommand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TerminateCommandContext terminateCommand() {
		TerminateCommandContext _localctx = new TerminateCommandContext(Context, State);
		EnterRule(_localctx, 340, RULE_terminateCommand);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2395;
			Match(TERMINATE);
			State = 2396;
			terminateTransactions();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComposableCommandClausesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TerminateCommandContext terminateCommand() {
			return GetRuleContext<TerminateCommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComposableShowCommandClausesContext composableShowCommandClauses() {
			return GetRuleContext<ComposableShowCommandClausesContext>(0);
		}
		public ComposableCommandClausesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_composableCommandClauses; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComposableCommandClauses(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ComposableCommandClausesContext composableCommandClauses() {
		ComposableCommandClausesContext _localctx = new ComposableCommandClausesContext(Context, State);
		EnterRule(_localctx, 342, RULE_composableCommandClauses);
		try {
			State = 2400;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TERMINATE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2398;
				terminateCommand();
				}
				break;
			case SHOW:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2399;
				composableShowCommandClauses();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ComposableShowCommandClausesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHOW() { return GetToken(CypherParser.SHOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ShowIndexCommandContext showIndexCommand() {
			return GetRuleContext<ShowIndexCommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowConstraintCommandContext showConstraintCommand() {
			return GetRuleContext<ShowConstraintCommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowCurrentGraphTypeCommandContext showCurrentGraphTypeCommand() {
			return GetRuleContext<ShowCurrentGraphTypeCommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowFunctionsContext showFunctions() {
			return GetRuleContext<ShowFunctionsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowProceduresContext showProcedures() {
			return GetRuleContext<ShowProceduresContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowSettingsContext showSettings() {
			return GetRuleContext<ShowSettingsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowTransactionsContext showTransactions() {
			return GetRuleContext<ShowTransactionsContext>(0);
		}
		public ComposableShowCommandClausesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_composableShowCommandClauses; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitComposableShowCommandClauses(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ComposableShowCommandClausesContext composableShowCommandClauses() {
		ComposableShowCommandClausesContext _localctx = new ComposableShowCommandClausesContext(Context, State);
		EnterRule(_localctx, 344, RULE_composableShowCommandClauses);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2402;
			Match(SHOW);
			State = 2410;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,234,Context) ) {
			case 1:
				{
				State = 2403;
				showIndexCommand();
				}
				break;
			case 2:
				{
				State = 2404;
				showConstraintCommand();
				}
				break;
			case 3:
				{
				State = 2405;
				showCurrentGraphTypeCommand();
				}
				break;
			case 4:
				{
				State = 2406;
				showFunctions();
				}
				break;
			case 5:
				{
				State = 2407;
				showProcedures();
				}
				break;
			case 6:
				{
				State = 2408;
				showSettings();
				}
				break;
			case 7:
				{
				State = 2409;
				showTransactions();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowIndexCommandContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ShowIndexesEndContext showIndexesEnd() {
			return GetRuleContext<ShowIndexesEndContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowIndexTypeContext showIndexType() {
			return GetRuleContext<ShowIndexTypeContext>(0);
		}
		public ShowIndexCommandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showIndexCommand; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowIndexCommand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowIndexCommandContext showIndexCommand() {
		ShowIndexCommandContext _localctx = new ShowIndexCommandContext(Context, State);
		EnterRule(_localctx, 346, RULE_showIndexCommand);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2413;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL || _la==FULLTEXT || _la==LOOKUP || _la==POINT || _la==RANGE || _la==TEXT || _la==VECTOR) {
				{
				State = 2412;
				showIndexType();
				}
			}

			State = 2415;
			showIndexesEnd();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowIndexTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(CypherParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FULLTEXT() { return GetToken(CypherParser.FULLTEXT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOOKUP() { return GetToken(CypherParser.LOOKUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode POINT() { return GetToken(CypherParser.POINT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RANGE() { return GetToken(CypherParser.RANGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TEXT() { return GetToken(CypherParser.TEXT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VECTOR() { return GetToken(CypherParser.VECTOR, 0); }
		public ShowIndexTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showIndexType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowIndexType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowIndexTypeContext showIndexType() {
		ShowIndexTypeContext _localctx = new ShowIndexTypeContext(Context, State);
		EnterRule(_localctx, 348, RULE_showIndexType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2417;
			_la = TokenStream.LA(1);
			if ( !(_la==ALL || _la==FULLTEXT || _la==LOOKUP || _la==POINT || _la==RANGE || _la==TEXT || _la==VECTOR) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowIndexesEndContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IndexTokenContext indexToken() {
			return GetRuleContext<IndexTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowCommandYieldContext showCommandYield() {
			return GetRuleContext<ShowCommandYieldContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComposableCommandClausesContext composableCommandClauses() {
			return GetRuleContext<ComposableCommandClausesContext>(0);
		}
		public ShowIndexesEndContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showIndexesEnd; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowIndexesEnd(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowIndexesEndContext showIndexesEnd() {
		ShowIndexesEndContext _localctx = new ShowIndexesEndContext(Context, State);
		EnterRule(_localctx, 350, RULE_showIndexesEnd);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2419;
			indexToken();
			State = 2421;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE || _la==YIELD) {
				{
				State = 2420;
				showCommandYield();
				}
			}

			State = 2424;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SHOW || _la==TERMINATE) {
				{
				State = 2423;
				composableCommandClauses();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowConstraintCommandContext : ParserRuleContext {
		public ShowConstraintCommandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showConstraintCommand; } }
	 
		public ShowConstraintCommandContext() { }
		public virtual void CopyFrom(ShowConstraintCommandContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ShowConstraintUniqueContext : ShowConstraintCommandContext {
		[System.Diagnostics.DebuggerNonUserCode] public ShowConstraintsEndContext showConstraintsEnd() {
			return GetRuleContext<ShowConstraintsEndContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIQUE() { return GetToken(CypherParser.UNIQUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIQUENESS() { return GetToken(CypherParser.UNIQUENESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ShowConstraintEntityContext showConstraintEntity() {
			return GetRuleContext<ShowConstraintEntityContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROPERTY() { return GetToken(CypherParser.PROPERTY, 0); }
		public ShowConstraintUniqueContext(ShowConstraintCommandContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowConstraintUnique(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShowConstraintExistContext : ShowConstraintCommandContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintExistTypeContext constraintExistType() {
			return GetRuleContext<ConstraintExistTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowConstraintsEndContext showConstraintsEnd() {
			return GetRuleContext<ShowConstraintsEndContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowConstraintEntityContext showConstraintEntity() {
			return GetRuleContext<ShowConstraintEntityContext>(0);
		}
		public ShowConstraintExistContext(ShowConstraintCommandContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowConstraintExist(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShowConstraintAllContext : ShowConstraintCommandContext {
		[System.Diagnostics.DebuggerNonUserCode] public ShowConstraintsEndContext showConstraintsEnd() {
			return GetRuleContext<ShowConstraintsEndContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(CypherParser.ALL, 0); }
		public ShowConstraintAllContext(ShowConstraintCommandContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowConstraintAll(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShowConstraintKeyContext : ShowConstraintCommandContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEY() { return GetToken(CypherParser.KEY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ShowConstraintsEndContext showConstraintsEnd() {
			return GetRuleContext<ShowConstraintsEndContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowConstraintEntityContext showConstraintEntity() {
			return GetRuleContext<ShowConstraintEntityContext>(0);
		}
		public ShowConstraintKeyContext(ShowConstraintCommandContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowConstraintKey(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ShowConstraintPropTypeContext : ShowConstraintCommandContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROPERTY() { return GetToken(CypherParser.PROPERTY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(CypherParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ShowConstraintsEndContext showConstraintsEnd() {
			return GetRuleContext<ShowConstraintsEndContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowConstraintEntityContext showConstraintEntity() {
			return GetRuleContext<ShowConstraintEntityContext>(0);
		}
		public ShowConstraintPropTypeContext(ShowConstraintCommandContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowConstraintPropType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowConstraintCommandContext showConstraintCommand() {
		ShowConstraintCommandContext _localctx = new ShowConstraintCommandContext(Context, State);
		EnterRule(_localctx, 352, RULE_showConstraintCommand);
		int _la;
		try {
			State = 2455;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,244,Context) ) {
			case 1:
				_localctx = new ShowConstraintAllContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 2427;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ALL) {
					{
					State = 2426;
					Match(ALL);
					}
				}

				State = 2429;
				showConstraintsEnd();
				}
				break;
			case 2:
				_localctx = new ShowConstraintExistContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 2431;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (NODE - 195)) | (1L << (REL - 195)) | (1L << (RELATIONSHIP - 195)))) != 0)) {
					{
					State = 2430;
					showConstraintEntity();
					}
				}

				State = 2433;
				constraintExistType();
				State = 2434;
				showConstraintsEnd();
				}
				break;
			case 3:
				_localctx = new ShowConstraintKeyContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 2437;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (NODE - 195)) | (1L << (REL - 195)) | (1L << (RELATIONSHIP - 195)))) != 0)) {
					{
					State = 2436;
					showConstraintEntity();
					}
				}

				State = 2439;
				Match(KEY);
				State = 2440;
				showConstraintsEnd();
				}
				break;
			case 4:
				_localctx = new ShowConstraintPropTypeContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 2442;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (NODE - 195)) | (1L << (REL - 195)) | (1L << (RELATIONSHIP - 195)))) != 0)) {
					{
					State = 2441;
					showConstraintEntity();
					}
				}

				State = 2444;
				Match(PROPERTY);
				State = 2445;
				Match(TYPE);
				State = 2446;
				showConstraintsEnd();
				}
				break;
			case 5:
				_localctx = new ShowConstraintUniqueContext(_localctx);
				EnterOuterAlt(_localctx, 5);
				{
				State = 2448;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (NODE - 195)) | (1L << (REL - 195)) | (1L << (RELATIONSHIP - 195)))) != 0)) {
					{
					State = 2447;
					showConstraintEntity();
					}
				}

				State = 2451;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==PROPERTY) {
					{
					State = 2450;
					Match(PROPERTY);
					}
				}

				State = 2453;
				_la = TokenStream.LA(1);
				if ( !(_la==UNIQUE || _la==UNIQUENESS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2454;
				showConstraintsEnd();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowConstraintEntityContext : ParserRuleContext {
		public ShowConstraintEntityContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showConstraintEntity; } }
	 
		public ShowConstraintEntityContext() { }
		public virtual void CopyFrom(ShowConstraintEntityContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class NodeEntityContext : ShowConstraintEntityContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NODE() { return GetToken(CypherParser.NODE, 0); }
		public NodeEntityContext(ShowConstraintEntityContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNodeEntity(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class RelEntityContext : ShowConstraintEntityContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELATIONSHIP() { return GetToken(CypherParser.RELATIONSHIP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REL() { return GetToken(CypherParser.REL, 0); }
		public RelEntityContext(ShowConstraintEntityContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelEntity(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowConstraintEntityContext showConstraintEntity() {
		ShowConstraintEntityContext _localctx = new ShowConstraintEntityContext(Context, State);
		EnterRule(_localctx, 354, RULE_showConstraintEntity);
		int _la;
		try {
			State = 2459;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case NODE:
				_localctx = new NodeEntityContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 2457;
				Match(NODE);
				}
				break;
			case REL:
			case RELATIONSHIP:
				_localctx = new RelEntityContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 2458;
				_la = TokenStream.LA(1);
				if ( !(_la==REL || _la==RELATIONSHIP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstraintExistTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTENCE() { return GetToken(CypherParser.EXISTENCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXIST() { return GetToken(CypherParser.EXIST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROPERTY() { return GetToken(CypherParser.PROPERTY, 0); }
		public ConstraintExistTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraintExistType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstraintExistType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstraintExistTypeContext constraintExistType() {
		ConstraintExistTypeContext _localctx = new ConstraintExistTypeContext(Context, State);
		EnterRule(_localctx, 356, RULE_constraintExistType);
		try {
			State = 2467;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,246,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2461;
				Match(EXISTENCE);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2462;
				Match(EXIST);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2463;
				Match(PROPERTY);
				State = 2464;
				Match(EXISTENCE);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2465;
				Match(PROPERTY);
				State = 2466;
				Match(EXIST);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowConstraintsEndContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintTokenContext constraintToken() {
			return GetRuleContext<ConstraintTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowCommandYieldContext showCommandYield() {
			return GetRuleContext<ShowCommandYieldContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComposableCommandClausesContext composableCommandClauses() {
			return GetRuleContext<ComposableCommandClausesContext>(0);
		}
		public ShowConstraintsEndContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showConstraintsEnd; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowConstraintsEnd(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowConstraintsEndContext showConstraintsEnd() {
		ShowConstraintsEndContext _localctx = new ShowConstraintsEndContext(Context, State);
		EnterRule(_localctx, 358, RULE_showConstraintsEnd);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2469;
			constraintToken();
			State = 2471;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE || _la==YIELD) {
				{
				State = 2470;
				showCommandYield();
				}
			}

			State = 2474;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SHOW || _la==TERMINATE) {
				{
				State = 2473;
				composableCommandClauses();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowCurrentGraphTypeCommandContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT() { return GetToken(CypherParser.CURRENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GRAPH() { return GetToken(CypherParser.GRAPH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(CypherParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ShowCommandYieldContext showCommandYield() {
			return GetRuleContext<ShowCommandYieldContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComposableCommandClausesContext composableCommandClauses() {
			return GetRuleContext<ComposableCommandClausesContext>(0);
		}
		public ShowCurrentGraphTypeCommandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showCurrentGraphTypeCommand; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowCurrentGraphTypeCommand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowCurrentGraphTypeCommandContext showCurrentGraphTypeCommand() {
		ShowCurrentGraphTypeCommandContext _localctx = new ShowCurrentGraphTypeCommandContext(Context, State);
		EnterRule(_localctx, 360, RULE_showCurrentGraphTypeCommand);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2476;
			Match(CURRENT);
			State = 2477;
			Match(GRAPH);
			State = 2478;
			Match(TYPE);
			State = 2480;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE || _la==YIELD) {
				{
				State = 2479;
				showCommandYield();
				}
			}

			State = 2483;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SHOW || _la==TERMINATE) {
				{
				State = 2482;
				composableCommandClauses();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowProceduresContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROCEDURE() { return GetToken(CypherParser.PROCEDURE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROCEDURES() { return GetToken(CypherParser.PROCEDURES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExecutableByContext executableBy() {
			return GetRuleContext<ExecutableByContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowCommandYieldContext showCommandYield() {
			return GetRuleContext<ShowCommandYieldContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComposableCommandClausesContext composableCommandClauses() {
			return GetRuleContext<ComposableCommandClausesContext>(0);
		}
		public ShowProceduresContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showProcedures; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowProcedures(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowProceduresContext showProcedures() {
		ShowProceduresContext _localctx = new ShowProceduresContext(Context, State);
		EnterRule(_localctx, 362, RULE_showProcedures);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2485;
			_la = TokenStream.LA(1);
			if ( !(_la==PROCEDURE || _la==PROCEDURES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 2487;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXECUTABLE) {
				{
				State = 2486;
				executableBy();
				}
			}

			State = 2490;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE || _la==YIELD) {
				{
				State = 2489;
				showCommandYield();
				}
			}

			State = 2493;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SHOW || _la==TERMINATE) {
				{
				State = 2492;
				composableCommandClauses();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowFunctionsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public FunctionTokenContext functionToken() {
			return GetRuleContext<FunctionTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowFunctionsTypeContext showFunctionsType() {
			return GetRuleContext<ShowFunctionsTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExecutableByContext executableBy() {
			return GetRuleContext<ExecutableByContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowCommandYieldContext showCommandYield() {
			return GetRuleContext<ShowCommandYieldContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComposableCommandClausesContext composableCommandClauses() {
			return GetRuleContext<ComposableCommandClausesContext>(0);
		}
		public ShowFunctionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showFunctions; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowFunctions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowFunctionsContext showFunctions() {
		ShowFunctionsContext _localctx = new ShowFunctionsContext(Context, State);
		EnterRule(_localctx, 364, RULE_showFunctions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2496;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL || _la==BUILT || _la==USER) {
				{
				State = 2495;
				showFunctionsType();
				}
			}

			State = 2498;
			functionToken();
			State = 2500;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EXECUTABLE) {
				{
				State = 2499;
				executableBy();
				}
			}

			State = 2503;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE || _la==YIELD) {
				{
				State = 2502;
				showCommandYield();
				}
			}

			State = 2506;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SHOW || _la==TERMINATE) {
				{
				State = 2505;
				composableCommandClauses();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUNCTION() { return GetToken(CypherParser.FUNCTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUNCTIONS() { return GetToken(CypherParser.FUNCTIONS, 0); }
		public FunctionTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionTokenContext functionToken() {
		FunctionTokenContext _localctx = new FunctionTokenContext(Context, State);
		EnterRule(_localctx, 366, RULE_functionToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2508;
			_la = TokenStream.LA(1);
			if ( !(_la==FUNCTION || _la==FUNCTIONS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExecutableByContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXECUTABLE() { return GetToken(CypherParser.EXECUTABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(CypherParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT() { return GetToken(CypherParser.CURRENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(CypherParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString() {
			return GetRuleContext<SymbolicNameStringContext>(0);
		}
		public ExecutableByContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_executableBy; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExecutableBy(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExecutableByContext executableBy() {
		ExecutableByContext _localctx = new ExecutableByContext(Context, State);
		EnterRule(_localctx, 368, RULE_executableBy);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2510;
			Match(EXECUTABLE);
			State = 2517;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==BY) {
				{
				State = 2511;
				Match(BY);
				State = 2515;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,258,Context) ) {
				case 1:
					{
					State = 2512;
					Match(CURRENT);
					State = 2513;
					Match(USER);
					}
					break;
				case 2:
					{
					State = 2514;
					symbolicNameString();
					}
					break;
				}
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowFunctionsTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(CypherParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BUILT() { return GetToken(CypherParser.BUILT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(CypherParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(CypherParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFINED() { return GetToken(CypherParser.DEFINED, 0); }
		public ShowFunctionsTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showFunctionsType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowFunctionsType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowFunctionsTypeContext showFunctionsType() {
		ShowFunctionsTypeContext _localctx = new ShowFunctionsTypeContext(Context, State);
		EnterRule(_localctx, 370, RULE_showFunctionsType);
		try {
			State = 2524;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALL:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2519;
				Match(ALL);
				}
				break;
			case BUILT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2520;
				Match(BUILT);
				State = 2521;
				Match(IN);
				}
				break;
			case USER:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2522;
				Match(USER);
				State = 2523;
				Match(DEFINED);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowTransactionsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TransactionTokenContext transactionToken() {
			return GetRuleContext<TransactionTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NamesAndClausesContext namesAndClauses() {
			return GetRuleContext<NamesAndClausesContext>(0);
		}
		public ShowTransactionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showTransactions; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowTransactions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowTransactionsContext showTransactions() {
		ShowTransactionsContext _localctx = new ShowTransactionsContext(Context, State);
		EnterRule(_localctx, 372, RULE_showTransactions);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2526;
			transactionToken();
			State = 2527;
			namesAndClauses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TerminateTransactionsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TransactionTokenContext transactionToken() {
			return GetRuleContext<TransactionTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StringsOrExpressionContext stringsOrExpression() {
			return GetRuleContext<StringsOrExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowCommandYieldContext showCommandYield() {
			return GetRuleContext<ShowCommandYieldContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComposableCommandClausesContext composableCommandClauses() {
			return GetRuleContext<ComposableCommandClausesContext>(0);
		}
		public TerminateTransactionsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_terminateTransactions; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTerminateTransactions(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TerminateTransactionsContext terminateTransactions() {
		TerminateTransactionsContext _localctx = new TerminateTransactionsContext(Context, State);
		EnterRule(_localctx, 374, RULE_terminateTransactions);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2529;
			transactionToken();
			State = 2530;
			stringsOrExpression();
			State = 2532;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE || _la==YIELD) {
				{
				State = 2531;
				showCommandYield();
				}
			}

			State = 2535;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SHOW || _la==TERMINATE) {
				{
				State = 2534;
				composableCommandClauses();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowSettingsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SettingTokenContext settingToken() {
			return GetRuleContext<SettingTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NamesAndClausesContext namesAndClauses() {
			return GetRuleContext<NamesAndClausesContext>(0);
		}
		public ShowSettingsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showSettings; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowSettings(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowSettingsContext showSettings() {
		ShowSettingsContext _localctx = new ShowSettingsContext(Context, State);
		EnterRule(_localctx, 376, RULE_showSettings);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2537;
			settingToken();
			State = 2538;
			namesAndClauses();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SettingTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SETTING() { return GetToken(CypherParser.SETTING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SETTINGS() { return GetToken(CypherParser.SETTINGS, 0); }
		public SettingTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_settingToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSettingToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SettingTokenContext settingToken() {
		SettingTokenContext _localctx = new SettingTokenContext(Context, State);
		EnterRule(_localctx, 378, RULE_settingToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2540;
			_la = TokenStream.LA(1);
			if ( !(_la==SETTING || _la==SETTINGS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NamesAndClausesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StringsOrExpressionContext stringsOrExpression() {
			return GetRuleContext<StringsOrExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ComposableCommandClausesContext composableCommandClauses() {
			return GetRuleContext<ComposableCommandClausesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowCommandYieldContext showCommandYield() {
			return GetRuleContext<ShowCommandYieldContext>(0);
		}
		public NamesAndClausesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_namesAndClauses; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNamesAndClauses(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NamesAndClausesContext namesAndClauses() {
		NamesAndClausesContext _localctx = new NamesAndClausesContext(Context, State);
		EnterRule(_localctx, 380, RULE_namesAndClauses);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2549;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,265,Context) ) {
			case 1:
				{
				State = 2543;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHERE || _la==YIELD) {
					{
					State = 2542;
					showCommandYield();
					}
				}

				}
				break;
			case 2:
				{
				State = 2545;
				stringsOrExpression();
				State = 2547;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHERE || _la==YIELD) {
					{
					State = 2546;
					showCommandYield();
					}
				}

				}
				break;
			}
			State = 2552;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SHOW || _la==TERMINATE) {
				{
				State = 2551;
				composableCommandClauses();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringsOrExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StringListContext stringList() {
			return GetRuleContext<StringListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public StringsOrExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stringsOrExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStringsOrExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StringsOrExpressionContext stringsOrExpression() {
		StringsOrExpressionContext _localctx = new StringsOrExpressionContext(Context, State);
		EnterRule(_localctx, 382, RULE_stringsOrExpression);
		try {
			State = 2556;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,267,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2554;
				stringList();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2555;
				expression();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommandNodePatternContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LabelTypeContext labelType() {
			return GetRuleContext<LabelTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		public CommandNodePatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commandNodePattern; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCommandNodePattern(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CommandNodePatternContext commandNodePattern() {
		CommandNodePatternContext _localctx = new CommandNodePatternContext(Context, State);
		EnterRule(_localctx, 384, RULE_commandNodePattern);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2558;
			Match(LPAREN);
			State = 2559;
			variable();
			State = 2560;
			labelType();
			State = 2561;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommandRelPatternContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LPAREN() { return GetTokens(CypherParser.LPAREN); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN(int i) {
			return GetToken(CypherParser.LPAREN, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] RPAREN() { return GetTokens(CypherParser.RPAREN); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN(int i) {
			return GetToken(CypherParser.RPAREN, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArrowLineContext[] arrowLine() {
			return GetRuleContexts<ArrowLineContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArrowLineContext arrowLine(int i) {
			return GetRuleContext<ArrowLineContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CypherParser.LBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RelTypeContext relType() {
			return GetRuleContext<RelTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CypherParser.RBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LeftArrowContext leftArrow() {
			return GetRuleContext<LeftArrowContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RightArrowContext rightArrow() {
			return GetRuleContext<RightArrowContext>(0);
		}
		public CommandRelPatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commandRelPattern; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCommandRelPattern(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CommandRelPatternContext commandRelPattern() {
		CommandRelPatternContext _localctx = new CommandRelPatternContext(Context, State);
		EnterRule(_localctx, 386, RULE_commandRelPattern);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2563;
			Match(LPAREN);
			State = 2564;
			Match(RPAREN);
			State = 2566;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LT || _la==ARROW_LEFT_HEAD) {
				{
				State = 2565;
				leftArrow();
				}
			}

			State = 2568;
			arrowLine();
			State = 2569;
			Match(LBRACKET);
			State = 2570;
			variable();
			State = 2571;
			relType();
			State = 2572;
			Match(RBRACKET);
			State = 2573;
			arrowLine();
			State = 2575;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==GT || _la==ARROW_RIGHT_HEAD) {
				{
				State = 2574;
				rightArrow();
				}
			}

			State = 2577;
			Match(LPAREN);
			State = 2578;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateConstraintContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTRAINT() { return GetToken(CypherParser.CONSTRAINT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(CypherParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintTypeContext constraintType() {
			return GetRuleContext<ConstraintTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommandNodePatternContext commandNodePattern() {
			return GetRuleContext<CommandNodePatternContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommandRelPatternContext commandRelPattern() {
			return GetRuleContext<CommandRelPatternContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameOrStringParameterContext symbolicNameOrStringParameter() {
			return GetRuleContext<SymbolicNameOrStringParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CypherParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(CypherParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CommandOptionsContext commandOptions() {
			return GetRuleContext<CommandOptionsContext>(0);
		}
		public CreateConstraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createConstraint; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateConstraint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateConstraintContext createConstraint() {
		CreateConstraintContext _localctx = new CreateConstraintContext(Context, State);
		EnterRule(_localctx, 388, RULE_createConstraint);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2580;
			Match(CONSTRAINT);
			State = 2582;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,270,Context) ) {
			case 1:
				{
				State = 2581;
				symbolicNameOrStringParameter();
				}
				break;
			}
			State = 2587;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2584;
				Match(IF);
				State = 2585;
				Match(NOT);
				State = 2586;
				Match(EXISTS);
				}
			}

			State = 2589;
			Match(FOR);
			State = 2592;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,272,Context) ) {
			case 1:
				{
				State = 2590;
				commandNodePattern();
				}
				break;
			case 2:
				{
				State = 2591;
				commandRelPattern();
				}
				break;
			}
			State = 2594;
			constraintType();
			State = 2596;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OPTIONS) {
				{
				State = 2595;
				commandOptions();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstraintTypeContext : ParserRuleContext {
		public ConstraintTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraintType; } }
	 
		public ConstraintTypeContext() { }
		public virtual void CopyFrom(ConstraintTypeContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class ConstraintTypedContext : ConstraintTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REQUIRE() { return GetToken(CypherParser.REQUIRE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropertyListContext propertyList() {
			return GetRuleContext<PropertyListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLONCOLON() { return GetToken(CypherParser.COLONCOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(CypherParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPED() { return GetToken(CypherParser.TYPED, 0); }
		public ConstraintTypedContext(ConstraintTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstraintTyped(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ConstraintKeyContext : ConstraintTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REQUIRE() { return GetToken(CypherParser.REQUIRE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropertyListContext propertyList() {
			return GetRuleContext<PropertyListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(CypherParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEY() { return GetToken(CypherParser.KEY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NODE() { return GetToken(CypherParser.NODE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELATIONSHIP() { return GetToken(CypherParser.RELATIONSHIP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REL() { return GetToken(CypherParser.REL, 0); }
		public ConstraintKeyContext(ConstraintTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstraintKey(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ConstraintIsNotNullContext : ConstraintTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REQUIRE() { return GetToken(CypherParser.REQUIRE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropertyListContext propertyList() {
			return GetRuleContext<PropertyListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(CypherParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(CypherParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(CypherParser.NULL, 0); }
		public ConstraintIsNotNullContext(ConstraintTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstraintIsNotNull(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class ConstraintIsUniqueContext : ConstraintTypeContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REQUIRE() { return GetToken(CypherParser.REQUIRE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropertyListContext propertyList() {
			return GetRuleContext<PropertyListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(CypherParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIQUE() { return GetToken(CypherParser.UNIQUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NODE() { return GetToken(CypherParser.NODE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELATIONSHIP() { return GetToken(CypherParser.RELATIONSHIP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REL() { return GetToken(CypherParser.REL, 0); }
		public ConstraintIsUniqueContext(ConstraintTypeContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstraintIsUnique(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstraintTypeContext constraintType() {
		ConstraintTypeContext _localctx = new ConstraintTypeContext(Context, State);
		EnterRule(_localctx, 390, RULE_constraintType);
		int _la;
		try {
			State = 2629;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,277,Context) ) {
			case 1:
				_localctx = new ConstraintTypedContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 2598;
				Match(REQUIRE);
				State = 2599;
				propertyList();
				State = 2603;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case COLONCOLON:
					{
					State = 2600;
					Match(COLONCOLON);
					}
					break;
				case IS:
					{
					State = 2601;
					Match(IS);
					State = 2602;
					_la = TokenStream.LA(1);
					if ( !(_la==COLONCOLON || _la==TYPED) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 2605;
				type();
				}
				break;
			case 2:
				_localctx = new ConstraintIsUniqueContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 2607;
				Match(REQUIRE);
				State = 2608;
				propertyList();
				State = 2609;
				Match(IS);
				State = 2611;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (NODE - 195)) | (1L << (REL - 195)) | (1L << (RELATIONSHIP - 195)))) != 0)) {
					{
					State = 2610;
					_la = TokenStream.LA(1);
					if ( !(((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (NODE - 195)) | (1L << (REL - 195)) | (1L << (RELATIONSHIP - 195)))) != 0)) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 2613;
				Match(UNIQUE);
				}
				break;
			case 3:
				_localctx = new ConstraintKeyContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 2615;
				Match(REQUIRE);
				State = 2616;
				propertyList();
				State = 2617;
				Match(IS);
				State = 2619;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (NODE - 195)) | (1L << (REL - 195)) | (1L << (RELATIONSHIP - 195)))) != 0)) {
					{
					State = 2618;
					_la = TokenStream.LA(1);
					if ( !(((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (NODE - 195)) | (1L << (REL - 195)) | (1L << (RELATIONSHIP - 195)))) != 0)) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 2621;
				Match(KEY);
				}
				break;
			case 4:
				_localctx = new ConstraintIsNotNullContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 2623;
				Match(REQUIRE);
				State = 2624;
				propertyList();
				State = 2625;
				Match(IS);
				State = 2626;
				Match(NOT);
				State = 2627;
				Match(NULL);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropConstraintContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTRAINT() { return GetToken(CypherParser.CONSTRAINT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameOrStringParameterContext symbolicNameOrStringParameter() {
			return GetRuleContext<SymbolicNameOrStringParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CypherParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		public DropConstraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropConstraint; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDropConstraint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DropConstraintContext dropConstraint() {
		DropConstraintContext _localctx = new DropConstraintContext(Context, State);
		EnterRule(_localctx, 392, RULE_dropConstraint);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2631;
			Match(CONSTRAINT);
			State = 2632;
			symbolicNameOrStringParameter();
			State = 2635;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2633;
				Match(IF);
				State = 2634;
				Match(EXISTS);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateIndexContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RANGE() { return GetToken(CypherParser.RANGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(CypherParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CreateIndex_Context createIndex_() {
			return GetRuleContext<CreateIndex_Context>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TEXT() { return GetToken(CypherParser.TEXT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode POINT() { return GetToken(CypherParser.POINT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VECTOR() { return GetToken(CypherParser.VECTOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOOKUP() { return GetToken(CypherParser.LOOKUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CreateLookupIndexContext createLookupIndex() {
			return GetRuleContext<CreateLookupIndexContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FULLTEXT() { return GetToken(CypherParser.FULLTEXT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CreateFulltextIndexContext createFulltextIndex() {
			return GetRuleContext<CreateFulltextIndexContext>(0);
		}
		public CreateIndexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createIndex; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateIndex(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateIndexContext createIndex() {
		CreateIndexContext _localctx = new CreateIndexContext(Context, State);
		EnterRule(_localctx, 394, RULE_createIndex);
		try {
			State = 2657;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case RANGE:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2637;
				Match(RANGE);
				State = 2638;
				Match(INDEX);
				State = 2639;
				createIndex_();
				}
				break;
			case TEXT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2640;
				Match(TEXT);
				State = 2641;
				Match(INDEX);
				State = 2642;
				createIndex_();
				}
				break;
			case POINT:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2643;
				Match(POINT);
				State = 2644;
				Match(INDEX);
				State = 2645;
				createIndex_();
				}
				break;
			case VECTOR:
				EnterOuterAlt(_localctx, 4);
				{
				State = 2646;
				Match(VECTOR);
				State = 2647;
				Match(INDEX);
				State = 2648;
				createIndex_();
				}
				break;
			case LOOKUP:
				EnterOuterAlt(_localctx, 5);
				{
				State = 2649;
				Match(LOOKUP);
				State = 2650;
				Match(INDEX);
				State = 2651;
				createLookupIndex();
				}
				break;
			case FULLTEXT:
				EnterOuterAlt(_localctx, 6);
				{
				State = 2652;
				Match(FULLTEXT);
				State = 2653;
				Match(INDEX);
				State = 2654;
				createFulltextIndex();
				}
				break;
			case INDEX:
				EnterOuterAlt(_localctx, 7);
				{
				State = 2655;
				Match(INDEX);
				State = 2656;
				createIndex_();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateIndex_Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(CypherParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(CypherParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropertyListContext propertyList() {
			return GetRuleContext<PropertyListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommandNodePatternContext commandNodePattern() {
			return GetRuleContext<CommandNodePatternContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommandRelPatternContext commandRelPattern() {
			return GetRuleContext<CommandRelPatternContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameOrStringParameterContext symbolicNameOrStringParameter() {
			return GetRuleContext<SymbolicNameOrStringParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CypherParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(CypherParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CommandOptionsContext commandOptions() {
			return GetRuleContext<CommandOptionsContext>(0);
		}
		public CreateIndex_Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createIndex_; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateIndex_(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateIndex_Context createIndex_() {
		CreateIndex_Context _localctx = new CreateIndex_Context(Context, State);
		EnterRule(_localctx, 396, RULE_createIndex_);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2660;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,280,Context) ) {
			case 1:
				{
				State = 2659;
				symbolicNameOrStringParameter();
				}
				break;
			}
			State = 2665;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2662;
				Match(IF);
				State = 2663;
				Match(NOT);
				State = 2664;
				Match(EXISTS);
				}
			}

			State = 2667;
			Match(FOR);
			State = 2670;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,282,Context) ) {
			case 1:
				{
				State = 2668;
				commandNodePattern();
				}
				break;
			case 2:
				{
				State = 2669;
				commandRelPattern();
				}
				break;
			}
			State = 2672;
			Match(ON);
			State = 2673;
			propertyList();
			State = 2675;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OPTIONS) {
				{
				State = 2674;
				commandOptions();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateFulltextIndexContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(CypherParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(CypherParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EACH() { return GetToken(CypherParser.EACH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CypherParser.LBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EnclosedPropertyListContext enclosedPropertyList() {
			return GetRuleContext<EnclosedPropertyListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CypherParser.RBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FulltextNodePatternContext fulltextNodePattern() {
			return GetRuleContext<FulltextNodePatternContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FulltextRelPatternContext fulltextRelPattern() {
			return GetRuleContext<FulltextRelPatternContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameOrStringParameterContext symbolicNameOrStringParameter() {
			return GetRuleContext<SymbolicNameOrStringParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CypherParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(CypherParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CommandOptionsContext commandOptions() {
			return GetRuleContext<CommandOptionsContext>(0);
		}
		public CreateFulltextIndexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createFulltextIndex; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateFulltextIndex(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateFulltextIndexContext createFulltextIndex() {
		CreateFulltextIndexContext _localctx = new CreateFulltextIndexContext(Context, State);
		EnterRule(_localctx, 398, RULE_createFulltextIndex);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2678;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,284,Context) ) {
			case 1:
				{
				State = 2677;
				symbolicNameOrStringParameter();
				}
				break;
			}
			State = 2683;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2680;
				Match(IF);
				State = 2681;
				Match(NOT);
				State = 2682;
				Match(EXISTS);
				}
			}

			State = 2685;
			Match(FOR);
			State = 2688;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,286,Context) ) {
			case 1:
				{
				State = 2686;
				fulltextNodePattern();
				}
				break;
			case 2:
				{
				State = 2687;
				fulltextRelPattern();
				}
				break;
			}
			State = 2690;
			Match(ON);
			State = 2691;
			Match(EACH);
			State = 2692;
			Match(LBRACKET);
			State = 2693;
			enclosedPropertyList();
			State = 2694;
			Match(RBRACKET);
			State = 2696;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OPTIONS) {
				{
				State = 2695;
				commandOptions();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FulltextNodePatternContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(CypherParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext[] symbolicNameString() {
			return GetRuleContexts<SymbolicNameStringContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString(int i) {
			return GetRuleContext<SymbolicNameStringContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] BAR() { return GetTokens(CypherParser.BAR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BAR(int i) {
			return GetToken(CypherParser.BAR, i);
		}
		public FulltextNodePatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fulltextNodePattern; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFulltextNodePattern(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FulltextNodePatternContext fulltextNodePattern() {
		FulltextNodePatternContext _localctx = new FulltextNodePatternContext(Context, State);
		EnterRule(_localctx, 400, RULE_fulltextNodePattern);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2698;
			Match(LPAREN);
			State = 2699;
			variable();
			State = 2700;
			Match(COLON);
			State = 2701;
			symbolicNameString();
			State = 2706;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==BAR) {
				{
				{
				State = 2702;
				Match(BAR);
				State = 2703;
				symbolicNameString();
				}
				}
				State = 2708;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2709;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FulltextRelPatternContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LPAREN() { return GetTokens(CypherParser.LPAREN); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN(int i) {
			return GetToken(CypherParser.LPAREN, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] RPAREN() { return GetTokens(CypherParser.RPAREN); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN(int i) {
			return GetToken(CypherParser.RPAREN, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArrowLineContext[] arrowLine() {
			return GetRuleContexts<ArrowLineContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArrowLineContext arrowLine(int i) {
			return GetRuleContext<ArrowLineContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CypherParser.LBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(CypherParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext[] symbolicNameString() {
			return GetRuleContexts<SymbolicNameStringContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString(int i) {
			return GetRuleContext<SymbolicNameStringContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CypherParser.RBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LeftArrowContext leftArrow() {
			return GetRuleContext<LeftArrowContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] BAR() { return GetTokens(CypherParser.BAR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BAR(int i) {
			return GetToken(CypherParser.BAR, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RightArrowContext rightArrow() {
			return GetRuleContext<RightArrowContext>(0);
		}
		public FulltextRelPatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_fulltextRelPattern; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFulltextRelPattern(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FulltextRelPatternContext fulltextRelPattern() {
		FulltextRelPatternContext _localctx = new FulltextRelPatternContext(Context, State);
		EnterRule(_localctx, 402, RULE_fulltextRelPattern);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2711;
			Match(LPAREN);
			State = 2712;
			Match(RPAREN);
			State = 2714;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LT || _la==ARROW_LEFT_HEAD) {
				{
				State = 2713;
				leftArrow();
				}
			}

			State = 2716;
			arrowLine();
			State = 2717;
			Match(LBRACKET);
			State = 2718;
			variable();
			State = 2719;
			Match(COLON);
			State = 2720;
			symbolicNameString();
			State = 2725;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==BAR) {
				{
				{
				State = 2721;
				Match(BAR);
				State = 2722;
				symbolicNameString();
				}
				}
				State = 2727;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 2728;
			Match(RBRACKET);
			State = 2729;
			arrowLine();
			State = 2731;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==GT || _la==ARROW_RIGHT_HEAD) {
				{
				State = 2730;
				rightArrow();
				}
			}

			State = 2733;
			Match(LPAREN);
			State = 2734;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateLookupIndexContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(CypherParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString() {
			return GetRuleContext<SymbolicNameStringContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LookupIndexNodePatternContext lookupIndexNodePattern() {
			return GetRuleContext<LookupIndexNodePatternContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LookupIndexRelPatternContext lookupIndexRelPattern() {
			return GetRuleContext<LookupIndexRelPatternContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameOrStringParameterContext symbolicNameOrStringParameter() {
			return GetRuleContext<SymbolicNameOrStringParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CypherParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(CypherParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CommandOptionsContext commandOptions() {
			return GetRuleContext<CommandOptionsContext>(0);
		}
		public CreateLookupIndexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createLookupIndex; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateLookupIndex(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateLookupIndexContext createLookupIndex() {
		CreateLookupIndexContext _localctx = new CreateLookupIndexContext(Context, State);
		EnterRule(_localctx, 404, RULE_createLookupIndex);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2737;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,292,Context) ) {
			case 1:
				{
				State = 2736;
				symbolicNameOrStringParameter();
				}
				break;
			}
			State = 2742;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2739;
				Match(IF);
				State = 2740;
				Match(NOT);
				State = 2741;
				Match(EXISTS);
				}
			}

			State = 2744;
			Match(FOR);
			State = 2747;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,294,Context) ) {
			case 1:
				{
				State = 2745;
				lookupIndexNodePattern();
				}
				break;
			case 2:
				{
				State = 2746;
				lookupIndexRelPattern();
				}
				break;
			}
			State = 2749;
			symbolicNameString();
			State = 2750;
			Match(LPAREN);
			State = 2751;
			variable();
			State = 2752;
			Match(RPAREN);
			State = 2754;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OPTIONS) {
				{
				State = 2753;
				commandOptions();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LookupIndexNodePatternContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(CypherParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EACH() { return GetToken(CypherParser.EACH, 0); }
		public LookupIndexNodePatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lookupIndexNodePattern; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLookupIndexNodePattern(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LookupIndexNodePatternContext lookupIndexNodePattern() {
		LookupIndexNodePatternContext _localctx = new LookupIndexNodePatternContext(Context, State);
		EnterRule(_localctx, 406, RULE_lookupIndexNodePattern);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2756;
			Match(LPAREN);
			State = 2757;
			variable();
			State = 2758;
			Match(RPAREN);
			State = 2759;
			Match(ON);
			State = 2760;
			Match(EACH);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LookupIndexRelPatternContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LPAREN() { return GetTokens(CypherParser.LPAREN); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN(int i) {
			return GetToken(CypherParser.LPAREN, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] RPAREN() { return GetTokens(CypherParser.RPAREN); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN(int i) {
			return GetToken(CypherParser.RPAREN, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArrowLineContext[] arrowLine() {
			return GetRuleContexts<ArrowLineContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArrowLineContext arrowLine(int i) {
			return GetRuleContext<ArrowLineContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CypherParser.LBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CypherParser.RBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(CypherParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LeftArrowContext leftArrow() {
			return GetRuleContext<LeftArrowContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RightArrowContext rightArrow() {
			return GetRuleContext<RightArrowContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EACH() { return GetToken(CypherParser.EACH, 0); }
		public LookupIndexRelPatternContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_lookupIndexRelPattern; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLookupIndexRelPattern(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LookupIndexRelPatternContext lookupIndexRelPattern() {
		LookupIndexRelPatternContext _localctx = new LookupIndexRelPatternContext(Context, State);
		EnterRule(_localctx, 408, RULE_lookupIndexRelPattern);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2762;
			Match(LPAREN);
			State = 2763;
			Match(RPAREN);
			State = 2765;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LT || _la==ARROW_LEFT_HEAD) {
				{
				State = 2764;
				leftArrow();
				}
			}

			State = 2767;
			arrowLine();
			State = 2768;
			Match(LBRACKET);
			State = 2769;
			variable();
			State = 2770;
			Match(RBRACKET);
			State = 2771;
			arrowLine();
			State = 2773;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==GT || _la==ARROW_RIGHT_HEAD) {
				{
				State = 2772;
				rightArrow();
				}
			}

			State = 2775;
			Match(LPAREN);
			State = 2776;
			Match(RPAREN);
			State = 2777;
			Match(ON);
			State = 2779;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,298,Context) ) {
			case 1:
				{
				State = 2778;
				Match(EACH);
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropIndexContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(CypherParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameOrStringParameterContext symbolicNameOrStringParameter() {
			return GetRuleContext<SymbolicNameOrStringParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CypherParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		public DropIndexContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropIndex; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDropIndex(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DropIndexContext dropIndex() {
		DropIndexContext _localctx = new DropIndexContext(Context, State);
		EnterRule(_localctx, 410, RULE_dropIndex);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2781;
			Match(INDEX);
			State = 2782;
			symbolicNameOrStringParameter();
			State = 2785;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 2783;
				Match(IF);
				State = 2784;
				Match(EXISTS);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertyListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropertyContext property() {
			return GetRuleContext<PropertyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EnclosedPropertyListContext enclosedPropertyList() {
			return GetRuleContext<EnclosedPropertyListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		public PropertyListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertyList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertyList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertyListContext propertyList() {
		PropertyListContext _localctx = new PropertyListContext(Context, State);
		EnterRule(_localctx, 412, RULE_propertyList);
		try {
			State = 2794;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ESCAPED_SYMBOLIC_NAME:
			case ACCESS:
			case ACTIVE:
			case ADD:
			case ADMIN:
			case ADMINISTRATOR:
			case ALIAS:
			case ALIASES:
			case ALL_SHORTEST_PATHS:
			case ALL:
			case ALLREDUCE:
			case ALTER:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASCENDING:
			case ASSIGN:
			case AT:
			case AUTH:
			case BINDINGS:
			case BOOL:
			case BOOLEAN:
			case BOOSTED:
			case BOTH:
			case BREAK:
			case BUILT:
			case BY:
			case CALL:
			case CASCADE:
			case CASE:
			case CHANGE:
			case CIDR:
			case COLLECT:
			case COMMAND:
			case COMMANDS:
			case COMPOSITE:
			case CONCURRENT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONTAINS:
			case COPY:
			case CONTINUE:
			case COSINE:
			case COUNT:
			case CREATE:
			case CREDENTIAL:
			case CSV:
			case CURRENT:
			case CYPHER:
			case DATA:
			case DATABASE:
			case DATABASES:
			case DATE:
			case DATETIME:
			case DBMS:
			case DEALLOCATE:
			case DEFAULT:
			case DEFINED:
			case DELETE:
			case DENY:
			case DESC:
			case DESCENDING:
			case DESTROY:
			case DETACH:
			case DIFFERENT:
			case DISTINCT:
			case DOT_METRIC:
			case DRIVER:
			case DROP:
			case DRYRUN:
			case DUMP:
			case DURATION:
			case EACH:
			case EDGE:
			case ENABLE:
			case ELEMENT:
			case ELEMENTS:
			case ELSE:
			case ENCRYPTED:
			case EUCLIDEAN:
			case EUCLIDEAN_SQUARED:
			case END:
			case ENDS:
			case EXECUTABLE:
			case EXECUTE:
			case EXIST:
			case EXISTENCE:
			case EXISTS:
			case ERROR:
			case FAIL:
			case FALSE:
			case FIELDTERMINATOR:
			case FILTER:
			case FINISH:
			case FLOAT:
			case FLOAT64:
			case FLOAT32:
			case FOR:
			case FOREACH:
			case FORWARDING:
			case FROM:
			case FULLTEXT:
			case FUNCTION:
			case FUNCTIONS:
			case GRANT:
			case GRAPH:
			case GRAPHS:
			case GROUP:
			case GROUPS:
			case HAMMING:
			case HEADERS:
			case HOME:
			case ID:
			case IF:
			case IMPERSONATE:
			case IMMUTABLE:
			case IN:
			case INDEX:
			case INDEXES:
			case INF:
			case INFINITY:
			case INSERT:
			case INT:
			case INT64:
			case INT32:
			case INT16:
			case INT8:
			case INTEGER:
			case INTEGER64:
			case INTEGER32:
			case INTEGER16:
			case INTEGER8:
			case IS:
			case JOIN:
			case KEY:
			case LABEL:
			case LABELS:
			case LANGUAGE:
			case LEADING:
			case LET:
			case LIMITROWS:
			case LIST:
			case LOAD:
			case LOCAL:
			case LOOKUP:
			case MANAGEMENT:
			case MANHATTAN:
			case MAP:
			case MATCH:
			case MERGE:
			case IMPLIES:
			case NAME:
			case NAMES:
			case NAN:
			case NFC:
			case NFD:
			case NFKC:
			case NFKD:
			case NEW:
			case NEXT:
			case NODE:
			case NODETACH:
			case NODES:
			case NONE:
			case NORMALIZE:
			case NORMALIZED:
			case NOT:
			case NOTHING:
			case NOWAIT:
			case NULL:
			case OF:
			case OFFSET:
			case OIDC:
			case ON:
			case ONLY:
			case OPTIONAL:
			case OPTIONS:
			case OPTION:
			case OR:
			case ORDER:
			case PASSWORD:
			case PASSWORDS:
			case PATH:
			case PATHS:
			case PLAINTEXT:
			case POINT:
			case POPULATED:
			case PRIMARY:
			case PRIMARIES:
			case PRIVILEGE:
			case PRIVILEGES:
			case PROCEDURE:
			case PROCEDURES:
			case PROPERTIES:
			case PROPERTY:
			case PROVIDER:
			case PROVIDERS:
			case RANGE:
			case READ:
			case REALLOCATE:
			case REDUCE:
			case RENAME:
			case REL:
			case RELATIONSHIP:
			case RELATIONSHIPS:
			case REMOVE:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case REPLICAS:
			case REPORT:
			case REQUIRE:
			case REQUIRED:
			case RESTRICT:
			case RETRY:
			case RETURN:
			case REVOKE:
			case ROLE:
			case ROLES:
			case ROW:
			case ROWS:
			case SCAN:
			case SEC:
			case SECOND:
			case SECONDARY:
			case SECONDARIES:
			case SECONDS:
			case SEEK:
			case SERVER:
			case SERVERS:
			case SET:
			case SETTING:
			case SETTINGS:
			case SHARD:
			case SHARDS:
			case SHORTEST_PATH:
			case SHORTEST:
			case SHOW:
			case SIGNED:
			case SINGLE:
			case SKIPROWS:
			case START:
			case STARTS:
			case STATUS:
			case STOP:
			case STRING:
			case SUPPORTED:
			case SUSPENDED:
			case TARGET:
			case TERMINATE:
			case TEXT:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE:
			case TO:
			case TOPOLOGY:
			case TRAILING:
			case TRANSACTION:
			case TRANSACTIONS:
			case TRAVERSE:
			case TRIM:
			case TRUE:
			case TYPE:
			case TYPED:
			case TYPES:
			case UNION:
			case UNIQUE:
			case UNIQUENESS:
			case UNWIND:
			case URL:
			case USE:
			case USER:
			case USERS:
			case USING:
			case VALUE:
			case VARCHAR:
			case VECTOR:
			case VECTOR_DISTANCE:
			case VECTOR_NORM:
			case VERTEX:
			case WAIT:
			case WHEN:
			case WHERE:
			case WITH:
			case WITHOUT:
			case WRITE:
			case XOR:
			case YIELD:
			case ZONE:
			case ZONED:
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2787;
				variable();
				State = 2788;
				property();
				}
				break;
			case LPAREN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2790;
				Match(LPAREN);
				State = 2791;
				enclosedPropertyList();
				State = 2792;
				Match(RPAREN);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnclosedPropertyListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext[] variable() {
			return GetRuleContexts<VariableContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable(int i) {
			return GetRuleContext<VariableContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropertyContext[] property() {
			return GetRuleContexts<PropertyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropertyContext property(int i) {
			return GetRuleContext<PropertyContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public EnclosedPropertyListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enclosedPropertyList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEnclosedPropertyList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EnclosedPropertyListContext enclosedPropertyList() {
		EnclosedPropertyListContext _localctx = new EnclosedPropertyListContext(Context, State);
		EnterRule(_localctx, 414, RULE_enclosedPropertyList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2796;
			variable();
			State = 2797;
			property();
			State = 2804;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2798;
				Match(COMMA);
				State = 2799;
				variable();
				State = 2800;
				property();
				}
				}
				State = 2806;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterCurrentGraphTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT() { return GetToken(CypherParser.CURRENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GRAPH() { return GetToken(CypherParser.GRAPH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(CypherParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GraphTypeSpecificationContext graphTypeSpecification() {
			return GetRuleContext<GraphTypeSpecificationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DROP() { return GetToken(CypherParser.DROP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GraphTypeDropSpecificationContext graphTypeDropSpecification() {
			return GetRuleContext<GraphTypeDropSpecificationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(CypherParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADD() { return GetToken(CypherParser.ADD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALTER() { return GetToken(CypherParser.ALTER, 0); }
		public AlterCurrentGraphTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterCurrentGraphType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterCurrentGraphType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterCurrentGraphTypeContext alterCurrentGraphType() {
		AlterCurrentGraphTypeContext _localctx = new AlterCurrentGraphTypeContext(Context, State);
		EnterRule(_localctx, 416, RULE_alterCurrentGraphType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2807;
			Match(CURRENT);
			State = 2808;
			Match(GRAPH);
			State = 2809;
			Match(TYPE);
			State = 2814;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ADD:
			case ALTER:
			case SET:
				{
				State = 2810;
				_la = TokenStream.LA(1);
				if ( !(_la==ADD || _la==ALTER || _la==SET) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 2811;
				graphTypeSpecification();
				}
				break;
			case DROP:
				{
				State = 2812;
				Match(DROP);
				State = 2813;
				graphTypeDropSpecification();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GraphTypeSpecificationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CypherParser.LCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CypherParser.RCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GraphTypeSpecificationBodyContext graphTypeSpecificationBody() {
			return GetRuleContext<GraphTypeSpecificationBodyContext>(0);
		}
		public GraphTypeSpecificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_graphTypeSpecification; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGraphTypeSpecification(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GraphTypeSpecificationContext graphTypeSpecification() {
		GraphTypeSpecificationContext _localctx = new GraphTypeSpecificationContext(Context, State);
		EnterRule(_localctx, 418, RULE_graphTypeSpecification);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2816;
			Match(LCURLY);
			State = 2818;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONSTRAINT || _la==LPAREN) {
				{
				State = 2817;
				graphTypeSpecificationBody();
				}
			}

			State = 2820;
			Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GraphTypeDropSpecificationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CypherParser.LCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CypherParser.RCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GraphTypeDropSpecificationBodyContext graphTypeDropSpecificationBody() {
			return GetRuleContext<GraphTypeDropSpecificationBodyContext>(0);
		}
		public GraphTypeDropSpecificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_graphTypeDropSpecification; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGraphTypeDropSpecification(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GraphTypeDropSpecificationContext graphTypeDropSpecification() {
		GraphTypeDropSpecificationContext _localctx = new GraphTypeDropSpecificationContext(Context, State);
		EnterRule(_localctx, 420, RULE_graphTypeDropSpecification);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2822;
			Match(LCURLY);
			State = 2824;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CONSTRAINT || _la==LPAREN) {
				{
				State = 2823;
				graphTypeDropSpecificationBody();
				}
			}

			State = 2826;
			Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GraphTypeSpecificationBodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GraphTypeElementContext[] graphTypeElement() {
			return GetRuleContexts<GraphTypeElementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public GraphTypeElementContext graphTypeElement(int i) {
			return GetRuleContext<GraphTypeElementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public GraphTypeSpecificationBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_graphTypeSpecificationBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGraphTypeSpecificationBody(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GraphTypeSpecificationBodyContext graphTypeSpecificationBody() {
		GraphTypeSpecificationBodyContext _localctx = new GraphTypeSpecificationBodyContext(Context, State);
		EnterRule(_localctx, 422, RULE_graphTypeSpecificationBody);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2828;
			graphTypeElement();
			State = 2833;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2829;
				Match(COMMA);
				State = 2830;
				graphTypeElement();
				}
				}
				State = 2835;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GraphTypeDropSpecificationBodyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GraphTypeDropElementContext[] graphTypeDropElement() {
			return GetRuleContexts<GraphTypeDropElementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public GraphTypeDropElementContext graphTypeDropElement(int i) {
			return GetRuleContext<GraphTypeDropElementContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public GraphTypeDropSpecificationBodyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_graphTypeDropSpecificationBody; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGraphTypeDropSpecificationBody(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GraphTypeDropSpecificationBodyContext graphTypeDropSpecificationBody() {
		GraphTypeDropSpecificationBodyContext _localctx = new GraphTypeDropSpecificationBodyContext(Context, State);
		EnterRule(_localctx, 424, RULE_graphTypeDropSpecificationBody);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2836;
			graphTypeDropElement();
			State = 2841;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 2837;
				Match(COMMA);
				State = 2838;
				graphTypeDropElement();
				}
				}
				State = 2843;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GraphTypeElementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public EdgeTypeSpecificationContext edgeTypeSpecification() {
			return GetRuleContext<EdgeTypeSpecificationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NodeTypeSpecificationContext nodeTypeSpecification() {
			return GetRuleContext<NodeTypeSpecificationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintSpecificationContext constraintSpecification() {
			return GetRuleContext<ConstraintSpecificationContext>(0);
		}
		public GraphTypeElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_graphTypeElement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGraphTypeElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GraphTypeElementContext graphTypeElement() {
		GraphTypeElementContext _localctx = new GraphTypeElementContext(Context, State);
		EnterRule(_localctx, 426, RULE_graphTypeElement);
		try {
			State = 2847;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,307,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2844;
				edgeTypeSpecification();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2845;
				nodeTypeSpecification();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2846;
				constraintSpecification();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GraphTypeDropElementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public EdgeTypeSpecificationContext edgeTypeSpecification() {
			return GetRuleContext<EdgeTypeSpecificationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NodeTypeSpecificationContext nodeTypeSpecification() {
			return GetRuleContext<NodeTypeSpecificationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTRAINT() { return GetToken(CypherParser.CONSTRAINT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString() {
			return GetRuleContext<SymbolicNameStringContext>(0);
		}
		public GraphTypeDropElementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_graphTypeDropElement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGraphTypeDropElement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GraphTypeDropElementContext graphTypeDropElement() {
		GraphTypeDropElementContext _localctx = new GraphTypeDropElementContext(Context, State);
		EnterRule(_localctx, 428, RULE_graphTypeDropElement);
		try {
			State = 2853;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,308,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2849;
				edgeTypeSpecification();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2850;
				nodeTypeSpecification();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 2851;
				Match(CONSTRAINT);
				State = 2852;
				symbolicNameString();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NodeTypeInlineConstraintListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintTypeContext[] constraintType() {
			return GetRuleContexts<ConstraintTypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintTypeContext constraintType(int i) {
			return GetRuleContext<ConstraintTypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommandOptionsContext[] commandOptions() {
			return GetRuleContexts<CommandOptionsContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommandOptionsContext commandOptions(int i) {
			return GetRuleContext<CommandOptionsContext>(i);
		}
		public NodeTypeInlineConstraintListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nodeTypeInlineConstraintList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNodeTypeInlineConstraintList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NodeTypeInlineConstraintListContext nodeTypeInlineConstraintList() {
		NodeTypeInlineConstraintListContext _localctx = new NodeTypeInlineConstraintListContext(Context, State);
		EnterRule(_localctx, 430, RULE_nodeTypeInlineConstraintList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2859;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 2855;
				constraintType();
				State = 2857;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==OPTIONS) {
					{
					State = 2856;
					commandOptions();
					}
				}

				}
				}
				State = 2861;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==REQUIRE );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EdgeTypeInlineConstraintListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintTypeContext[] constraintType() {
			return GetRuleContexts<ConstraintTypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintTypeContext constraintType(int i) {
			return GetRuleContext<ConstraintTypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommandOptionsContext[] commandOptions() {
			return GetRuleContexts<CommandOptionsContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommandOptionsContext commandOptions(int i) {
			return GetRuleContext<CommandOptionsContext>(i);
		}
		public EdgeTypeInlineConstraintListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_edgeTypeInlineConstraintList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEdgeTypeInlineConstraintList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EdgeTypeInlineConstraintListContext edgeTypeInlineConstraintList() {
		EdgeTypeInlineConstraintListContext _localctx = new EdgeTypeInlineConstraintListContext(Context, State);
		EnterRule(_localctx, 432, RULE_edgeTypeInlineConstraintList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2867;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 2863;
				constraintType();
				State = 2865;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==OPTIONS) {
					{
					State = 2864;
					commandOptions();
					}
				}

				}
				}
				State = 2869;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==REQUIRE );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ImpliesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EQ() { return GetToken(CypherParser.EQ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RightArrowContext rightArrow() {
			return GetRuleContext<RightArrowContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMPLIES() { return GetToken(CypherParser.IMPLIES, 0); }
		public ImpliesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_implies; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitImplies(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ImpliesContext implies() {
		ImpliesContext _localctx = new ImpliesContext(Context, State);
		EnterRule(_localctx, 434, RULE_implies);
		try {
			State = 2874;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case EQ:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2871;
				Match(EQ);
				State = 2872;
				rightArrow();
				}
				break;
			case IMPLIES:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2873;
				Match(IMPLIES);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NodeTypeSpecificationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifyingLabelContext identifyingLabel() {
			return GetRuleContext<IdentifyingLabelContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ImpliedLabelSetContext impliedLabelSet() {
			return GetRuleContext<ImpliedLabelSetContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropertyTypeListContext propertyTypeList() {
			return GetRuleContext<PropertyTypeListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NodeTypeInlineConstraintListContext nodeTypeInlineConstraintList() {
			return GetRuleContext<NodeTypeInlineConstraintListContext>(0);
		}
		public NodeTypeSpecificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nodeTypeSpecification; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNodeTypeSpecification(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NodeTypeSpecificationContext nodeTypeSpecification() {
		NodeTypeSpecificationContext _localctx = new NodeTypeSpecificationContext(Context, State);
		EnterRule(_localctx, 436, RULE_nodeTypeSpecification);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2876;
			Match(LPAREN);
			State = 2878;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ESCAPED_SYMBOLIC_NAME) | (1L << ACCESS) | (1L << ACTIVE) | (1L << ADD) | (1L << ADMIN) | (1L << ADMINISTRATOR) | (1L << ALIAS) | (1L << ALIASES) | (1L << ALL_SHORTEST_PATHS) | (1L << ALL) | (1L << ALLREDUCE) | (1L << ALTER) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASCENDING) | (1L << ASSIGN) | (1L << AT) | (1L << AUTH) | (1L << BINDINGS) | (1L << BOOL) | (1L << BOOLEAN) | (1L << BOOSTED) | (1L << BOTH) | (1L << BREAK) | (1L << BUILT) | (1L << BY) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CHANGE) | (1L << CIDR) | (1L << COLLECT) | (1L << COMMAND) | (1L << COMMANDS) | (1L << COMPOSITE) | (1L << CONCURRENT) | (1L << CONSTRAINT) | (1L << CONSTRAINTS) | (1L << CONTAINS) | (1L << COPY) | (1L << CONTINUE) | (1L << COSINE) | (1L << COUNT) | (1L << CREATE) | (1L << CREDENTIAL) | (1L << CSV) | (1L << CURRENT))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CYPHER - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATABASES - 64)) | (1L << (DATE - 64)) | (1L << (DATETIME - 64)) | (1L << (DBMS - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFINED - 64)) | (1L << (DELETE - 64)) | (1L << (DENY - 64)) | (1L << (DESC - 64)) | (1L << (DESCENDING - 64)) | (1L << (DESTROY - 64)) | (1L << (DETACH - 64)) | (1L << (DIFFERENT - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOT_METRIC - 64)) | (1L << (DRIVER - 64)) | (1L << (DROP - 64)) | (1L << (DRYRUN - 64)) | (1L << (DUMP - 64)) | (1L << (DURATION - 64)) | (1L << (EACH - 64)) | (1L << (EDGE - 64)) | (1L << (ENABLE - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELEMENTS - 64)) | (1L << (ELSE - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (EUCLIDEAN - 64)) | (1L << (EUCLIDEAN_SQUARED - 64)) | (1L << (END - 64)) | (1L << (ENDS - 64)) | (1L << (EXECUTABLE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXIST - 64)) | (1L << (EXISTENCE - 64)) | (1L << (EXISTS - 64)) | (1L << (ERROR - 64)) | (1L << (FAIL - 64)) | (1L << (FALSE - 64)) | (1L << (FIELDTERMINATOR - 64)) | (1L << (FILTER - 64)) | (1L << (FINISH - 64)) | (1L << (FLOAT - 64)) | (1L << (FLOAT64 - 64)) | (1L << (FLOAT32 - 64)) | (1L << (FOR - 64)) | (1L << (FOREACH - 64)) | (1L << (FORWARDING - 64)) | (1L << (FROM - 64)) | (1L << (FULLTEXT - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GRANT - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (GRAPH - 128)) | (1L << (GRAPHS - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPS - 128)) | (1L << (HAMMING - 128)) | (1L << (HEADERS - 128)) | (1L << (HOME - 128)) | (1L << (ID - 128)) | (1L << (IF - 128)) | (1L << (IMPERSONATE - 128)) | (1L << (IMMUTABLE - 128)) | (1L << (IN - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXES - 128)) | (1L << (INF - 128)) | (1L << (INFINITY - 128)) | (1L << (INSERT - 128)) | (1L << (INT - 128)) | (1L << (INT64 - 128)) | (1L << (INT32 - 128)) | (1L << (INT16 - 128)) | (1L << (INT8 - 128)) | (1L << (INTEGER - 128)) | (1L << (INTEGER64 - 128)) | (1L << (INTEGER32 - 128)) | (1L << (INTEGER16 - 128)) | (1L << (INTEGER8 - 128)) | (1L << (IS - 128)) | (1L << (JOIN - 128)) | (1L << (KEY - 128)) | (1L << (LABEL - 128)) | (1L << (LABELS - 128)) | (1L << (LANGUAGE - 128)) | (1L << (LEADING - 128)) | (1L << (LET - 128)) | (1L << (LIMITROWS - 128)) | (1L << (LIST - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOOKUP - 128)) | (1L << (MANAGEMENT - 128)) | (1L << (MANHATTAN - 128)) | (1L << (MAP - 128)) | (1L << (MATCH - 128)) | (1L << (MERGE - 128)) | (1L << (IMPLIES - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NAN - 128)) | (1L << (NFC - 128)) | (1L << (NFD - 128)) | (1L << (NFKC - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (NFKD - 192)) | (1L << (NEW - 192)) | (1L << (NEXT - 192)) | (1L << (NODE - 192)) | (1L << (NODETACH - 192)) | (1L << (NODES - 192)) | (1L << (NONE - 192)) | (1L << (NORMALIZE - 192)) | (1L << (NORMALIZED - 192)) | (1L << (NOT - 192)) | (1L << (NOTHING - 192)) | (1L << (NOWAIT - 192)) | (1L << (NULL - 192)) | (1L << (OF - 192)) | (1L << (OFFSET - 192)) | (1L << (OIDC - 192)) | (1L << (ON - 192)) | (1L << (ONLY - 192)) | (1L << (OPTIONAL - 192)) | (1L << (OPTIONS - 192)) | (1L << (OPTION - 192)) | (1L << (OR - 192)) | (1L << (ORDER - 192)) | (1L << (PASSWORD - 192)) | (1L << (PASSWORDS - 192)) | (1L << (PATH - 192)) | (1L << (PATHS - 192)) | (1L << (PLAINTEXT - 192)) | (1L << (POINT - 192)) | (1L << (POPULATED - 192)) | (1L << (PRIMARY - 192)) | (1L << (PRIMARIES - 192)) | (1L << (PRIVILEGE - 192)) | (1L << (PRIVILEGES - 192)) | (1L << (PROCEDURE - 192)) | (1L << (PROCEDURES - 192)) | (1L << (PROPERTIES - 192)) | (1L << (PROPERTY - 192)) | (1L << (PROVIDER - 192)) | (1L << (PROVIDERS - 192)) | (1L << (RANGE - 192)) | (1L << (READ - 192)) | (1L << (REALLOCATE - 192)) | (1L << (REDUCE - 192)) | (1L << (RENAME - 192)) | (1L << (REL - 192)) | (1L << (RELATIONSHIP - 192)) | (1L << (RELATIONSHIPS - 192)) | (1L << (REMOVE - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (REPLICAS - 192)) | (1L << (REPORT - 192)) | (1L << (REQUIRE - 192)) | (1L << (REQUIRED - 192)) | (1L << (RESTRICT - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (RETRY - 256)) | (1L << (RETURN - 256)) | (1L << (REVOKE - 256)) | (1L << (ROLE - 256)) | (1L << (ROLES - 256)) | (1L << (ROW - 256)) | (1L << (ROWS - 256)) | (1L << (SCAN - 256)) | (1L << (SEC - 256)) | (1L << (SECOND - 256)) | (1L << (SECONDARY - 256)) | (1L << (SECONDARIES - 256)) | (1L << (SECONDS - 256)) | (1L << (SEEK - 256)) | (1L << (SERVER - 256)) | (1L << (SERVERS - 256)) | (1L << (SET - 256)) | (1L << (SETTING - 256)) | (1L << (SETTINGS - 256)) | (1L << (SHARD - 256)) | (1L << (SHARDS - 256)) | (1L << (SHORTEST_PATH - 256)) | (1L << (SHORTEST - 256)) | (1L << (SHOW - 256)) | (1L << (SIGNED - 256)) | (1L << (SINGLE - 256)) | (1L << (SKIPROWS - 256)) | (1L << (START - 256)) | (1L << (STARTS - 256)) | (1L << (STATUS - 256)) | (1L << (STOP - 256)) | (1L << (STRING - 256)) | (1L << (SUPPORTED - 256)) | (1L << (SUSPENDED - 256)) | (1L << (TARGET - 256)) | (1L << (TERMINATE - 256)) | (1L << (TEXT - 256)) | (1L << (THEN - 256)) | (1L << (TIME - 256)) | (1L << (TIMESTAMP - 256)) | (1L << (TIMEZONE - 256)) | (1L << (TO - 256)) | (1L << (TOPOLOGY - 256)) | (1L << (TRAILING - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSACTIONS - 256)) | (1L << (TRAVERSE - 256)) | (1L << (TRIM - 256)) | (1L << (TRUE - 256)) | (1L << (TYPE - 256)) | (1L << (TYPED - 256)) | (1L << (TYPES - 256)) | (1L << (UNION - 256)) | (1L << (UNIQUE - 256)) | (1L << (UNIQUENESS - 256)) | (1L << (UNWIND - 256)) | (1L << (URL - 256)) | (1L << (USE - 256)) | (1L << (USER - 256)) | (1L << (USERS - 256)) | (1L << (USING - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (VALUE - 320)) | (1L << (VARCHAR - 320)) | (1L << (VECTOR - 320)) | (1L << (VECTOR_DISTANCE - 320)) | (1L << (VECTOR_NORM - 320)) | (1L << (VERTEX - 320)) | (1L << (WAIT - 320)) | (1L << (WHEN - 320)) | (1L << (WHERE - 320)) | (1L << (WITH - 320)) | (1L << (WITHOUT - 320)) | (1L << (WRITE - 320)) | (1L << (XOR - 320)) | (1L << (YIELD - 320)) | (1L << (ZONE - 320)) | (1L << (ZONED - 320)) | (1L << (IDENTIFIER - 320)))) != 0)) {
				{
				State = 2877;
				variable();
				}
			}

			State = 2880;
			identifyingLabel();
			State = 2882;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLON) {
				{
				State = 2881;
				impliedLabelSet();
				}
			}

			State = 2885;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LCURLY) {
				{
				State = 2884;
				propertyTypeList();
				}
			}

			State = 2887;
			Match(RPAREN);
			State = 2889;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==REQUIRE) {
				{
				State = 2888;
				nodeTypeInlineConstraintList();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ImpliedLabelSetContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LabelTypeContext labelType() {
			return GetRuleContext<LabelTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] AMPERSAND() { return GetTokens(CypherParser.AMPERSAND); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AMPERSAND(int i) {
			return GetToken(CypherParser.AMPERSAND, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext[] symbolicNameString() {
			return GetRuleContexts<SymbolicNameStringContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString(int i) {
			return GetRuleContext<SymbolicNameStringContext>(i);
		}
		public ImpliedLabelSetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_impliedLabelSet; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitImpliedLabelSet(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ImpliedLabelSetContext impliedLabelSet() {
		ImpliedLabelSetContext _localctx = new ImpliedLabelSetContext(Context, State);
		EnterRule(_localctx, 438, RULE_impliedLabelSet);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2891;
			labelType();
			State = 2896;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==AMPERSAND) {
				{
				{
				State = 2892;
				Match(AMPERSAND);
				State = 2893;
				symbolicNameString();
				}
				}
				State = 2898;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifyingLabelContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public LabelTypeContext labelType() {
			return GetRuleContext<LabelTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ImpliesContext implies() {
			return GetRuleContext<ImpliesContext>(0);
		}
		public IdentifyingLabelContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifyingLabel; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifyingLabel(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifyingLabelContext identifyingLabel() {
		IdentifyingLabelContext _localctx = new IdentifyingLabelContext(Context, State);
		EnterRule(_localctx, 440, RULE_identifyingLabel);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2899;
			labelType();
			State = 2900;
			implies();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NodeTypeReferenceContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NodeTypeAliasReferenceContext nodeTypeAliasReference() {
			return GetRuleContext<NodeTypeAliasReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NodeTypeInSituReferenceContext nodeTypeInSituReference() {
			return GetRuleContext<NodeTypeInSituReferenceContext>(0);
		}
		public NodeTypeReferenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nodeTypeReference; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNodeTypeReference(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NodeTypeReferenceContext nodeTypeReference() {
		NodeTypeReferenceContext _localctx = new NodeTypeReferenceContext(Context, State);
		EnterRule(_localctx, 442, RULE_nodeTypeReference);
		try {
			State = 2904;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,319,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2902;
				nodeTypeAliasReference();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2903;
				nodeTypeInSituReference();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NodeTypeAliasReferenceContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		public NodeTypeAliasReferenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nodeTypeAliasReference; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNodeTypeAliasReference(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NodeTypeAliasReferenceContext nodeTypeAliasReference() {
		NodeTypeAliasReferenceContext _localctx = new NodeTypeAliasReferenceContext(Context, State);
		EnterRule(_localctx, 444, RULE_nodeTypeAliasReference);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2906;
			Match(LPAREN);
			State = 2907;
			variable();
			State = 2908;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NodeTypeInSituReferenceContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LabelTypeContext labelType() {
			return GetRuleContext<LabelTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ImpliesContext implies() {
			return GetRuleContext<ImpliesContext>(0);
		}
		public NodeTypeInSituReferenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nodeTypeInSituReference; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNodeTypeInSituReference(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NodeTypeInSituReferenceContext nodeTypeInSituReference() {
		NodeTypeInSituReferenceContext _localctx = new NodeTypeInSituReferenceContext(Context, State);
		EnterRule(_localctx, 446, RULE_nodeTypeInSituReference);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2910;
			Match(LPAREN);
			State = 2918;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ESCAPED_SYMBOLIC_NAME) | (1L << ACCESS) | (1L << ACTIVE) | (1L << ADD) | (1L << ADMIN) | (1L << ADMINISTRATOR) | (1L << ALIAS) | (1L << ALIASES) | (1L << ALL_SHORTEST_PATHS) | (1L << ALL) | (1L << ALLREDUCE) | (1L << ALTER) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASCENDING) | (1L << ASSIGN) | (1L << AT) | (1L << AUTH) | (1L << BINDINGS) | (1L << BOOL) | (1L << BOOLEAN) | (1L << BOOSTED) | (1L << BOTH) | (1L << BREAK) | (1L << BUILT) | (1L << BY) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CHANGE) | (1L << CIDR) | (1L << COLLECT) | (1L << COLON) | (1L << COMMAND) | (1L << COMMANDS) | (1L << COMPOSITE) | (1L << CONCURRENT) | (1L << CONSTRAINT) | (1L << CONSTRAINTS) | (1L << CONTAINS) | (1L << COPY) | (1L << CONTINUE) | (1L << COSINE) | (1L << COUNT) | (1L << CREATE) | (1L << CREDENTIAL) | (1L << CSV) | (1L << CURRENT))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CYPHER - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATABASES - 64)) | (1L << (DATE - 64)) | (1L << (DATETIME - 64)) | (1L << (DBMS - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFINED - 64)) | (1L << (DELETE - 64)) | (1L << (DENY - 64)) | (1L << (DESC - 64)) | (1L << (DESCENDING - 64)) | (1L << (DESTROY - 64)) | (1L << (DETACH - 64)) | (1L << (DIFFERENT - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOT_METRIC - 64)) | (1L << (DRIVER - 64)) | (1L << (DROP - 64)) | (1L << (DRYRUN - 64)) | (1L << (DUMP - 64)) | (1L << (DURATION - 64)) | (1L << (EACH - 64)) | (1L << (EDGE - 64)) | (1L << (ENABLE - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELEMENTS - 64)) | (1L << (ELSE - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (EUCLIDEAN - 64)) | (1L << (EUCLIDEAN_SQUARED - 64)) | (1L << (END - 64)) | (1L << (ENDS - 64)) | (1L << (EXECUTABLE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXIST - 64)) | (1L << (EXISTENCE - 64)) | (1L << (EXISTS - 64)) | (1L << (ERROR - 64)) | (1L << (FAIL - 64)) | (1L << (FALSE - 64)) | (1L << (FIELDTERMINATOR - 64)) | (1L << (FILTER - 64)) | (1L << (FINISH - 64)) | (1L << (FLOAT - 64)) | (1L << (FLOAT64 - 64)) | (1L << (FLOAT32 - 64)) | (1L << (FOR - 64)) | (1L << (FOREACH - 64)) | (1L << (FORWARDING - 64)) | (1L << (FROM - 64)) | (1L << (FULLTEXT - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GRANT - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (GRAPH - 128)) | (1L << (GRAPHS - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPS - 128)) | (1L << (HAMMING - 128)) | (1L << (HEADERS - 128)) | (1L << (HOME - 128)) | (1L << (ID - 128)) | (1L << (IF - 128)) | (1L << (IMPERSONATE - 128)) | (1L << (IMMUTABLE - 128)) | (1L << (IN - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXES - 128)) | (1L << (INF - 128)) | (1L << (INFINITY - 128)) | (1L << (INSERT - 128)) | (1L << (INT - 128)) | (1L << (INT64 - 128)) | (1L << (INT32 - 128)) | (1L << (INT16 - 128)) | (1L << (INT8 - 128)) | (1L << (INTEGER - 128)) | (1L << (INTEGER64 - 128)) | (1L << (INTEGER32 - 128)) | (1L << (INTEGER16 - 128)) | (1L << (INTEGER8 - 128)) | (1L << (IS - 128)) | (1L << (JOIN - 128)) | (1L << (KEY - 128)) | (1L << (LABEL - 128)) | (1L << (LABELS - 128)) | (1L << (LANGUAGE - 128)) | (1L << (LEADING - 128)) | (1L << (LET - 128)) | (1L << (LIMITROWS - 128)) | (1L << (LIST - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOOKUP - 128)) | (1L << (MANAGEMENT - 128)) | (1L << (MANHATTAN - 128)) | (1L << (MAP - 128)) | (1L << (MATCH - 128)) | (1L << (MERGE - 128)) | (1L << (IMPLIES - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NAN - 128)) | (1L << (NFC - 128)) | (1L << (NFD - 128)) | (1L << (NFKC - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (NFKD - 192)) | (1L << (NEW - 192)) | (1L << (NEXT - 192)) | (1L << (NODE - 192)) | (1L << (NODETACH - 192)) | (1L << (NODES - 192)) | (1L << (NONE - 192)) | (1L << (NORMALIZE - 192)) | (1L << (NORMALIZED - 192)) | (1L << (NOT - 192)) | (1L << (NOTHING - 192)) | (1L << (NOWAIT - 192)) | (1L << (NULL - 192)) | (1L << (OF - 192)) | (1L << (OFFSET - 192)) | (1L << (OIDC - 192)) | (1L << (ON - 192)) | (1L << (ONLY - 192)) | (1L << (OPTIONAL - 192)) | (1L << (OPTIONS - 192)) | (1L << (OPTION - 192)) | (1L << (OR - 192)) | (1L << (ORDER - 192)) | (1L << (PASSWORD - 192)) | (1L << (PASSWORDS - 192)) | (1L << (PATH - 192)) | (1L << (PATHS - 192)) | (1L << (PLAINTEXT - 192)) | (1L << (POINT - 192)) | (1L << (POPULATED - 192)) | (1L << (PRIMARY - 192)) | (1L << (PRIMARIES - 192)) | (1L << (PRIVILEGE - 192)) | (1L << (PRIVILEGES - 192)) | (1L << (PROCEDURE - 192)) | (1L << (PROCEDURES - 192)) | (1L << (PROPERTIES - 192)) | (1L << (PROPERTY - 192)) | (1L << (PROVIDER - 192)) | (1L << (PROVIDERS - 192)) | (1L << (RANGE - 192)) | (1L << (READ - 192)) | (1L << (REALLOCATE - 192)) | (1L << (REDUCE - 192)) | (1L << (RENAME - 192)) | (1L << (REL - 192)) | (1L << (RELATIONSHIP - 192)) | (1L << (RELATIONSHIPS - 192)) | (1L << (REMOVE - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (REPLICAS - 192)) | (1L << (REPORT - 192)) | (1L << (REQUIRE - 192)) | (1L << (REQUIRED - 192)) | (1L << (RESTRICT - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (RETRY - 256)) | (1L << (RETURN - 256)) | (1L << (REVOKE - 256)) | (1L << (ROLE - 256)) | (1L << (ROLES - 256)) | (1L << (ROW - 256)) | (1L << (ROWS - 256)) | (1L << (SCAN - 256)) | (1L << (SEC - 256)) | (1L << (SECOND - 256)) | (1L << (SECONDARY - 256)) | (1L << (SECONDARIES - 256)) | (1L << (SECONDS - 256)) | (1L << (SEEK - 256)) | (1L << (SERVER - 256)) | (1L << (SERVERS - 256)) | (1L << (SET - 256)) | (1L << (SETTING - 256)) | (1L << (SETTINGS - 256)) | (1L << (SHARD - 256)) | (1L << (SHARDS - 256)) | (1L << (SHORTEST_PATH - 256)) | (1L << (SHORTEST - 256)) | (1L << (SHOW - 256)) | (1L << (SIGNED - 256)) | (1L << (SINGLE - 256)) | (1L << (SKIPROWS - 256)) | (1L << (START - 256)) | (1L << (STARTS - 256)) | (1L << (STATUS - 256)) | (1L << (STOP - 256)) | (1L << (STRING - 256)) | (1L << (SUPPORTED - 256)) | (1L << (SUSPENDED - 256)) | (1L << (TARGET - 256)) | (1L << (TERMINATE - 256)) | (1L << (TEXT - 256)) | (1L << (THEN - 256)) | (1L << (TIME - 256)) | (1L << (TIMESTAMP - 256)) | (1L << (TIMEZONE - 256)) | (1L << (TO - 256)) | (1L << (TOPOLOGY - 256)) | (1L << (TRAILING - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSACTIONS - 256)) | (1L << (TRAVERSE - 256)) | (1L << (TRIM - 256)) | (1L << (TRUE - 256)) | (1L << (TYPE - 256)) | (1L << (TYPED - 256)) | (1L << (TYPES - 256)) | (1L << (UNION - 256)) | (1L << (UNIQUE - 256)) | (1L << (UNIQUENESS - 256)) | (1L << (UNWIND - 256)) | (1L << (URL - 256)) | (1L << (USE - 256)) | (1L << (USER - 256)) | (1L << (USERS - 256)) | (1L << (USING - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (VALUE - 320)) | (1L << (VARCHAR - 320)) | (1L << (VECTOR - 320)) | (1L << (VECTOR_DISTANCE - 320)) | (1L << (VECTOR_NORM - 320)) | (1L << (VERTEX - 320)) | (1L << (WAIT - 320)) | (1L << (WHEN - 320)) | (1L << (WHERE - 320)) | (1L << (WITH - 320)) | (1L << (WITHOUT - 320)) | (1L << (WRITE - 320)) | (1L << (XOR - 320)) | (1L << (YIELD - 320)) | (1L << (ZONE - 320)) | (1L << (ZONED - 320)) | (1L << (IDENTIFIER - 320)))) != 0)) {
				{
				State = 2912;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ESCAPED_SYMBOLIC_NAME) | (1L << ACCESS) | (1L << ACTIVE) | (1L << ADD) | (1L << ADMIN) | (1L << ADMINISTRATOR) | (1L << ALIAS) | (1L << ALIASES) | (1L << ALL_SHORTEST_PATHS) | (1L << ALL) | (1L << ALLREDUCE) | (1L << ALTER) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASCENDING) | (1L << ASSIGN) | (1L << AT) | (1L << AUTH) | (1L << BINDINGS) | (1L << BOOL) | (1L << BOOLEAN) | (1L << BOOSTED) | (1L << BOTH) | (1L << BREAK) | (1L << BUILT) | (1L << BY) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CHANGE) | (1L << CIDR) | (1L << COLLECT) | (1L << COMMAND) | (1L << COMMANDS) | (1L << COMPOSITE) | (1L << CONCURRENT) | (1L << CONSTRAINT) | (1L << CONSTRAINTS) | (1L << CONTAINS) | (1L << COPY) | (1L << CONTINUE) | (1L << COSINE) | (1L << COUNT) | (1L << CREATE) | (1L << CREDENTIAL) | (1L << CSV) | (1L << CURRENT))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CYPHER - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATABASES - 64)) | (1L << (DATE - 64)) | (1L << (DATETIME - 64)) | (1L << (DBMS - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFINED - 64)) | (1L << (DELETE - 64)) | (1L << (DENY - 64)) | (1L << (DESC - 64)) | (1L << (DESCENDING - 64)) | (1L << (DESTROY - 64)) | (1L << (DETACH - 64)) | (1L << (DIFFERENT - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOT_METRIC - 64)) | (1L << (DRIVER - 64)) | (1L << (DROP - 64)) | (1L << (DRYRUN - 64)) | (1L << (DUMP - 64)) | (1L << (DURATION - 64)) | (1L << (EACH - 64)) | (1L << (EDGE - 64)) | (1L << (ENABLE - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELEMENTS - 64)) | (1L << (ELSE - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (EUCLIDEAN - 64)) | (1L << (EUCLIDEAN_SQUARED - 64)) | (1L << (END - 64)) | (1L << (ENDS - 64)) | (1L << (EXECUTABLE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXIST - 64)) | (1L << (EXISTENCE - 64)) | (1L << (EXISTS - 64)) | (1L << (ERROR - 64)) | (1L << (FAIL - 64)) | (1L << (FALSE - 64)) | (1L << (FIELDTERMINATOR - 64)) | (1L << (FILTER - 64)) | (1L << (FINISH - 64)) | (1L << (FLOAT - 64)) | (1L << (FLOAT64 - 64)) | (1L << (FLOAT32 - 64)) | (1L << (FOR - 64)) | (1L << (FOREACH - 64)) | (1L << (FORWARDING - 64)) | (1L << (FROM - 64)) | (1L << (FULLTEXT - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GRANT - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (GRAPH - 128)) | (1L << (GRAPHS - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPS - 128)) | (1L << (HAMMING - 128)) | (1L << (HEADERS - 128)) | (1L << (HOME - 128)) | (1L << (ID - 128)) | (1L << (IF - 128)) | (1L << (IMPERSONATE - 128)) | (1L << (IMMUTABLE - 128)) | (1L << (IN - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXES - 128)) | (1L << (INF - 128)) | (1L << (INFINITY - 128)) | (1L << (INSERT - 128)) | (1L << (INT - 128)) | (1L << (INT64 - 128)) | (1L << (INT32 - 128)) | (1L << (INT16 - 128)) | (1L << (INT8 - 128)) | (1L << (INTEGER - 128)) | (1L << (INTEGER64 - 128)) | (1L << (INTEGER32 - 128)) | (1L << (INTEGER16 - 128)) | (1L << (INTEGER8 - 128)) | (1L << (IS - 128)) | (1L << (JOIN - 128)) | (1L << (KEY - 128)) | (1L << (LABEL - 128)) | (1L << (LABELS - 128)) | (1L << (LANGUAGE - 128)) | (1L << (LEADING - 128)) | (1L << (LET - 128)) | (1L << (LIMITROWS - 128)) | (1L << (LIST - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOOKUP - 128)) | (1L << (MANAGEMENT - 128)) | (1L << (MANHATTAN - 128)) | (1L << (MAP - 128)) | (1L << (MATCH - 128)) | (1L << (MERGE - 128)) | (1L << (IMPLIES - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NAN - 128)) | (1L << (NFC - 128)) | (1L << (NFD - 128)) | (1L << (NFKC - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (NFKD - 192)) | (1L << (NEW - 192)) | (1L << (NEXT - 192)) | (1L << (NODE - 192)) | (1L << (NODETACH - 192)) | (1L << (NODES - 192)) | (1L << (NONE - 192)) | (1L << (NORMALIZE - 192)) | (1L << (NORMALIZED - 192)) | (1L << (NOT - 192)) | (1L << (NOTHING - 192)) | (1L << (NOWAIT - 192)) | (1L << (NULL - 192)) | (1L << (OF - 192)) | (1L << (OFFSET - 192)) | (1L << (OIDC - 192)) | (1L << (ON - 192)) | (1L << (ONLY - 192)) | (1L << (OPTIONAL - 192)) | (1L << (OPTIONS - 192)) | (1L << (OPTION - 192)) | (1L << (OR - 192)) | (1L << (ORDER - 192)) | (1L << (PASSWORD - 192)) | (1L << (PASSWORDS - 192)) | (1L << (PATH - 192)) | (1L << (PATHS - 192)) | (1L << (PLAINTEXT - 192)) | (1L << (POINT - 192)) | (1L << (POPULATED - 192)) | (1L << (PRIMARY - 192)) | (1L << (PRIMARIES - 192)) | (1L << (PRIVILEGE - 192)) | (1L << (PRIVILEGES - 192)) | (1L << (PROCEDURE - 192)) | (1L << (PROCEDURES - 192)) | (1L << (PROPERTIES - 192)) | (1L << (PROPERTY - 192)) | (1L << (PROVIDER - 192)) | (1L << (PROVIDERS - 192)) | (1L << (RANGE - 192)) | (1L << (READ - 192)) | (1L << (REALLOCATE - 192)) | (1L << (REDUCE - 192)) | (1L << (RENAME - 192)) | (1L << (REL - 192)) | (1L << (RELATIONSHIP - 192)) | (1L << (RELATIONSHIPS - 192)) | (1L << (REMOVE - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (REPLICAS - 192)) | (1L << (REPORT - 192)) | (1L << (REQUIRE - 192)) | (1L << (REQUIRED - 192)) | (1L << (RESTRICT - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (RETRY - 256)) | (1L << (RETURN - 256)) | (1L << (REVOKE - 256)) | (1L << (ROLE - 256)) | (1L << (ROLES - 256)) | (1L << (ROW - 256)) | (1L << (ROWS - 256)) | (1L << (SCAN - 256)) | (1L << (SEC - 256)) | (1L << (SECOND - 256)) | (1L << (SECONDARY - 256)) | (1L << (SECONDARIES - 256)) | (1L << (SECONDS - 256)) | (1L << (SEEK - 256)) | (1L << (SERVER - 256)) | (1L << (SERVERS - 256)) | (1L << (SET - 256)) | (1L << (SETTING - 256)) | (1L << (SETTINGS - 256)) | (1L << (SHARD - 256)) | (1L << (SHARDS - 256)) | (1L << (SHORTEST_PATH - 256)) | (1L << (SHORTEST - 256)) | (1L << (SHOW - 256)) | (1L << (SIGNED - 256)) | (1L << (SINGLE - 256)) | (1L << (SKIPROWS - 256)) | (1L << (START - 256)) | (1L << (STARTS - 256)) | (1L << (STATUS - 256)) | (1L << (STOP - 256)) | (1L << (STRING - 256)) | (1L << (SUPPORTED - 256)) | (1L << (SUSPENDED - 256)) | (1L << (TARGET - 256)) | (1L << (TERMINATE - 256)) | (1L << (TEXT - 256)) | (1L << (THEN - 256)) | (1L << (TIME - 256)) | (1L << (TIMESTAMP - 256)) | (1L << (TIMEZONE - 256)) | (1L << (TO - 256)) | (1L << (TOPOLOGY - 256)) | (1L << (TRAILING - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSACTIONS - 256)) | (1L << (TRAVERSE - 256)) | (1L << (TRIM - 256)) | (1L << (TRUE - 256)) | (1L << (TYPE - 256)) | (1L << (TYPED - 256)) | (1L << (TYPES - 256)) | (1L << (UNION - 256)) | (1L << (UNIQUE - 256)) | (1L << (UNIQUENESS - 256)) | (1L << (UNWIND - 256)) | (1L << (URL - 256)) | (1L << (USE - 256)) | (1L << (USER - 256)) | (1L << (USERS - 256)) | (1L << (USING - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (VALUE - 320)) | (1L << (VARCHAR - 320)) | (1L << (VECTOR - 320)) | (1L << (VECTOR_DISTANCE - 320)) | (1L << (VECTOR_NORM - 320)) | (1L << (VERTEX - 320)) | (1L << (WAIT - 320)) | (1L << (WHEN - 320)) | (1L << (WHERE - 320)) | (1L << (WITH - 320)) | (1L << (WITHOUT - 320)) | (1L << (WRITE - 320)) | (1L << (XOR - 320)) | (1L << (YIELD - 320)) | (1L << (ZONE - 320)) | (1L << (ZONED - 320)) | (1L << (IDENTIFIER - 320)))) != 0)) {
					{
					State = 2911;
					variable();
					}
				}

				State = 2914;
				labelType();
				State = 2916;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==EQ || _la==IMPLIES) {
					{
					State = 2915;
					implies();
					}
				}

				}
			}

			State = 2920;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EdgeTypeSpecificationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public NodeTypeReferenceContext[] nodeTypeReference() {
			return GetRuleContexts<NodeTypeReferenceContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public NodeTypeReferenceContext nodeTypeReference(int i) {
			return GetRuleContext<NodeTypeReferenceContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArcTypePointingRightContext arcTypePointingRight() {
			return GetRuleContext<ArcTypePointingRightContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EdgeTypeInlineConstraintListContext edgeTypeInlineConstraintList() {
			return GetRuleContext<EdgeTypeInlineConstraintListContext>(0);
		}
		public EdgeTypeSpecificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_edgeTypeSpecification; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEdgeTypeSpecification(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EdgeTypeSpecificationContext edgeTypeSpecification() {
		EdgeTypeSpecificationContext _localctx = new EdgeTypeSpecificationContext(Context, State);
		EnterRule(_localctx, 448, RULE_edgeTypeSpecification);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2922;
			nodeTypeReference();
			State = 2923;
			arcTypePointingRight();
			State = 2924;
			nodeTypeReference();
			State = 2926;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==REQUIRE) {
				{
				State = 2925;
				edgeTypeInlineConstraintList();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArcTypePointingRightContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ArrowLineContext[] arrowLine() {
			return GetRuleContexts<ArrowLineContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArrowLineContext arrowLine(int i) {
			return GetRuleContext<ArrowLineContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CypherParser.LBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IdentifyingRelationshipContext identifyingRelationship() {
			return GetRuleContext<IdentifyingRelationshipContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CypherParser.RBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RightArrowContext rightArrow() {
			return GetRuleContext<RightArrowContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropertyTypeListContext propertyTypeList() {
			return GetRuleContext<PropertyTypeListContext>(0);
		}
		public ArcTypePointingRightContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arcTypePointingRight; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArcTypePointingRight(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArcTypePointingRightContext arcTypePointingRight() {
		ArcTypePointingRightContext _localctx = new ArcTypePointingRightContext(Context, State);
		EnterRule(_localctx, 450, RULE_arcTypePointingRight);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2928;
			arrowLine();
			State = 2929;
			Match(LBRACKET);
			State = 2931;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ESCAPED_SYMBOLIC_NAME) | (1L << ACCESS) | (1L << ACTIVE) | (1L << ADD) | (1L << ADMIN) | (1L << ADMINISTRATOR) | (1L << ALIAS) | (1L << ALIASES) | (1L << ALL_SHORTEST_PATHS) | (1L << ALL) | (1L << ALLREDUCE) | (1L << ALTER) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASCENDING) | (1L << ASSIGN) | (1L << AT) | (1L << AUTH) | (1L << BINDINGS) | (1L << BOOL) | (1L << BOOLEAN) | (1L << BOOSTED) | (1L << BOTH) | (1L << BREAK) | (1L << BUILT) | (1L << BY) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CHANGE) | (1L << CIDR) | (1L << COLLECT) | (1L << COMMAND) | (1L << COMMANDS) | (1L << COMPOSITE) | (1L << CONCURRENT) | (1L << CONSTRAINT) | (1L << CONSTRAINTS) | (1L << CONTAINS) | (1L << COPY) | (1L << CONTINUE) | (1L << COSINE) | (1L << COUNT) | (1L << CREATE) | (1L << CREDENTIAL) | (1L << CSV) | (1L << CURRENT))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CYPHER - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATABASES - 64)) | (1L << (DATE - 64)) | (1L << (DATETIME - 64)) | (1L << (DBMS - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFINED - 64)) | (1L << (DELETE - 64)) | (1L << (DENY - 64)) | (1L << (DESC - 64)) | (1L << (DESCENDING - 64)) | (1L << (DESTROY - 64)) | (1L << (DETACH - 64)) | (1L << (DIFFERENT - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOT_METRIC - 64)) | (1L << (DRIVER - 64)) | (1L << (DROP - 64)) | (1L << (DRYRUN - 64)) | (1L << (DUMP - 64)) | (1L << (DURATION - 64)) | (1L << (EACH - 64)) | (1L << (EDGE - 64)) | (1L << (ENABLE - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELEMENTS - 64)) | (1L << (ELSE - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (EUCLIDEAN - 64)) | (1L << (EUCLIDEAN_SQUARED - 64)) | (1L << (END - 64)) | (1L << (ENDS - 64)) | (1L << (EXECUTABLE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXIST - 64)) | (1L << (EXISTENCE - 64)) | (1L << (EXISTS - 64)) | (1L << (ERROR - 64)) | (1L << (FAIL - 64)) | (1L << (FALSE - 64)) | (1L << (FIELDTERMINATOR - 64)) | (1L << (FILTER - 64)) | (1L << (FINISH - 64)) | (1L << (FLOAT - 64)) | (1L << (FLOAT64 - 64)) | (1L << (FLOAT32 - 64)) | (1L << (FOR - 64)) | (1L << (FOREACH - 64)) | (1L << (FORWARDING - 64)) | (1L << (FROM - 64)) | (1L << (FULLTEXT - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GRANT - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (GRAPH - 128)) | (1L << (GRAPHS - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPS - 128)) | (1L << (HAMMING - 128)) | (1L << (HEADERS - 128)) | (1L << (HOME - 128)) | (1L << (ID - 128)) | (1L << (IF - 128)) | (1L << (IMPERSONATE - 128)) | (1L << (IMMUTABLE - 128)) | (1L << (IN - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXES - 128)) | (1L << (INF - 128)) | (1L << (INFINITY - 128)) | (1L << (INSERT - 128)) | (1L << (INT - 128)) | (1L << (INT64 - 128)) | (1L << (INT32 - 128)) | (1L << (INT16 - 128)) | (1L << (INT8 - 128)) | (1L << (INTEGER - 128)) | (1L << (INTEGER64 - 128)) | (1L << (INTEGER32 - 128)) | (1L << (INTEGER16 - 128)) | (1L << (INTEGER8 - 128)) | (1L << (IS - 128)) | (1L << (JOIN - 128)) | (1L << (KEY - 128)) | (1L << (LABEL - 128)) | (1L << (LABELS - 128)) | (1L << (LANGUAGE - 128)) | (1L << (LEADING - 128)) | (1L << (LET - 128)) | (1L << (LIMITROWS - 128)) | (1L << (LIST - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOOKUP - 128)) | (1L << (MANAGEMENT - 128)) | (1L << (MANHATTAN - 128)) | (1L << (MAP - 128)) | (1L << (MATCH - 128)) | (1L << (MERGE - 128)) | (1L << (IMPLIES - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NAN - 128)) | (1L << (NFC - 128)) | (1L << (NFD - 128)) | (1L << (NFKC - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (NFKD - 192)) | (1L << (NEW - 192)) | (1L << (NEXT - 192)) | (1L << (NODE - 192)) | (1L << (NODETACH - 192)) | (1L << (NODES - 192)) | (1L << (NONE - 192)) | (1L << (NORMALIZE - 192)) | (1L << (NORMALIZED - 192)) | (1L << (NOT - 192)) | (1L << (NOTHING - 192)) | (1L << (NOWAIT - 192)) | (1L << (NULL - 192)) | (1L << (OF - 192)) | (1L << (OFFSET - 192)) | (1L << (OIDC - 192)) | (1L << (ON - 192)) | (1L << (ONLY - 192)) | (1L << (OPTIONAL - 192)) | (1L << (OPTIONS - 192)) | (1L << (OPTION - 192)) | (1L << (OR - 192)) | (1L << (ORDER - 192)) | (1L << (PASSWORD - 192)) | (1L << (PASSWORDS - 192)) | (1L << (PATH - 192)) | (1L << (PATHS - 192)) | (1L << (PLAINTEXT - 192)) | (1L << (POINT - 192)) | (1L << (POPULATED - 192)) | (1L << (PRIMARY - 192)) | (1L << (PRIMARIES - 192)) | (1L << (PRIVILEGE - 192)) | (1L << (PRIVILEGES - 192)) | (1L << (PROCEDURE - 192)) | (1L << (PROCEDURES - 192)) | (1L << (PROPERTIES - 192)) | (1L << (PROPERTY - 192)) | (1L << (PROVIDER - 192)) | (1L << (PROVIDERS - 192)) | (1L << (RANGE - 192)) | (1L << (READ - 192)) | (1L << (REALLOCATE - 192)) | (1L << (REDUCE - 192)) | (1L << (RENAME - 192)) | (1L << (REL - 192)) | (1L << (RELATIONSHIP - 192)) | (1L << (RELATIONSHIPS - 192)) | (1L << (REMOVE - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (REPLICAS - 192)) | (1L << (REPORT - 192)) | (1L << (REQUIRE - 192)) | (1L << (REQUIRED - 192)) | (1L << (RESTRICT - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (RETRY - 256)) | (1L << (RETURN - 256)) | (1L << (REVOKE - 256)) | (1L << (ROLE - 256)) | (1L << (ROLES - 256)) | (1L << (ROW - 256)) | (1L << (ROWS - 256)) | (1L << (SCAN - 256)) | (1L << (SEC - 256)) | (1L << (SECOND - 256)) | (1L << (SECONDARY - 256)) | (1L << (SECONDARIES - 256)) | (1L << (SECONDS - 256)) | (1L << (SEEK - 256)) | (1L << (SERVER - 256)) | (1L << (SERVERS - 256)) | (1L << (SET - 256)) | (1L << (SETTING - 256)) | (1L << (SETTINGS - 256)) | (1L << (SHARD - 256)) | (1L << (SHARDS - 256)) | (1L << (SHORTEST_PATH - 256)) | (1L << (SHORTEST - 256)) | (1L << (SHOW - 256)) | (1L << (SIGNED - 256)) | (1L << (SINGLE - 256)) | (1L << (SKIPROWS - 256)) | (1L << (START - 256)) | (1L << (STARTS - 256)) | (1L << (STATUS - 256)) | (1L << (STOP - 256)) | (1L << (STRING - 256)) | (1L << (SUPPORTED - 256)) | (1L << (SUSPENDED - 256)) | (1L << (TARGET - 256)) | (1L << (TERMINATE - 256)) | (1L << (TEXT - 256)) | (1L << (THEN - 256)) | (1L << (TIME - 256)) | (1L << (TIMESTAMP - 256)) | (1L << (TIMEZONE - 256)) | (1L << (TO - 256)) | (1L << (TOPOLOGY - 256)) | (1L << (TRAILING - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSACTIONS - 256)) | (1L << (TRAVERSE - 256)) | (1L << (TRIM - 256)) | (1L << (TRUE - 256)) | (1L << (TYPE - 256)) | (1L << (TYPED - 256)) | (1L << (TYPES - 256)) | (1L << (UNION - 256)) | (1L << (UNIQUE - 256)) | (1L << (UNIQUENESS - 256)) | (1L << (UNWIND - 256)) | (1L << (URL - 256)) | (1L << (USE - 256)) | (1L << (USER - 256)) | (1L << (USERS - 256)) | (1L << (USING - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (VALUE - 320)) | (1L << (VARCHAR - 320)) | (1L << (VECTOR - 320)) | (1L << (VECTOR_DISTANCE - 320)) | (1L << (VECTOR_NORM - 320)) | (1L << (VERTEX - 320)) | (1L << (WAIT - 320)) | (1L << (WHEN - 320)) | (1L << (WHERE - 320)) | (1L << (WITH - 320)) | (1L << (WITHOUT - 320)) | (1L << (WRITE - 320)) | (1L << (XOR - 320)) | (1L << (YIELD - 320)) | (1L << (ZONE - 320)) | (1L << (ZONED - 320)) | (1L << (IDENTIFIER - 320)))) != 0)) {
				{
				State = 2930;
				variable();
				}
			}

			State = 2933;
			identifyingRelationship();
			State = 2935;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==LCURLY) {
				{
				State = 2934;
				propertyTypeList();
				}
			}

			State = 2937;
			Match(RBRACKET);
			State = 2938;
			arrowLine();
			State = 2939;
			rightArrow();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IdentifyingRelationshipContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RelTypeContext relType() {
			return GetRuleContext<RelTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ImpliesContext implies() {
			return GetRuleContext<ImpliesContext>(0);
		}
		public IdentifyingRelationshipContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_identifyingRelationship; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIdentifyingRelationship(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IdentifyingRelationshipContext identifyingRelationship() {
		IdentifyingRelationshipContext _localctx = new IdentifyingRelationshipContext(Context, State);
		EnterRule(_localctx, 452, RULE_identifyingRelationship);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2941;
			relType();
			State = 2942;
			implies();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EdgeTypeReferenceContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public EdgeTypeAliasReferenceContext edgeTypeAliasReference() {
			return GetRuleContext<EdgeTypeAliasReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EdgeTypeInSituReferenceContext edgeTypeInSituReference() {
			return GetRuleContext<EdgeTypeInSituReferenceContext>(0);
		}
		public EdgeTypeReferenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_edgeTypeReference; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEdgeTypeReference(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EdgeTypeReferenceContext edgeTypeReference() {
		EdgeTypeReferenceContext _localctx = new EdgeTypeReferenceContext(Context, State);
		EnterRule(_localctx, 454, RULE_edgeTypeReference);
		try {
			State = 2946;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,326,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 2944;
				edgeTypeAliasReference();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 2945;
				edgeTypeInSituReference();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EdgeTypeAliasReferenceContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LPAREN() { return GetTokens(CypherParser.LPAREN); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN(int i) {
			return GetToken(CypherParser.LPAREN, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] RPAREN() { return GetTokens(CypherParser.RPAREN); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN(int i) {
			return GetToken(CypherParser.RPAREN, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArrowLineContext[] arrowLine() {
			return GetRuleContexts<ArrowLineContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArrowLineContext arrowLine(int i) {
			return GetRuleContext<ArrowLineContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CypherParser.LBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CypherParser.RBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RightArrowContext rightArrow() {
			return GetRuleContext<RightArrowContext>(0);
		}
		public EdgeTypeAliasReferenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_edgeTypeAliasReference; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEdgeTypeAliasReference(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EdgeTypeAliasReferenceContext edgeTypeAliasReference() {
		EdgeTypeAliasReferenceContext _localctx = new EdgeTypeAliasReferenceContext(Context, State);
		EnterRule(_localctx, 456, RULE_edgeTypeAliasReference);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2948;
			Match(LPAREN);
			State = 2949;
			Match(RPAREN);
			State = 2950;
			arrowLine();
			State = 2951;
			Match(LBRACKET);
			State = 2952;
			variable();
			State = 2953;
			Match(RBRACKET);
			State = 2954;
			arrowLine();
			State = 2955;
			rightArrow();
			State = 2956;
			Match(LPAREN);
			State = 2957;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EdgeTypeInSituReferenceContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LPAREN() { return GetTokens(CypherParser.LPAREN); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN(int i) {
			return GetToken(CypherParser.LPAREN, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] RPAREN() { return GetTokens(CypherParser.RPAREN); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN(int i) {
			return GetToken(CypherParser.RPAREN, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArrowLineContext[] arrowLine() {
			return GetRuleContexts<ArrowLineContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArrowLineContext arrowLine(int i) {
			return GetRuleContext<ArrowLineContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CypherParser.LBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RelTypeContext relType() {
			return GetRuleContext<RelTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CypherParser.RBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RightArrowContext rightArrow() {
			return GetRuleContext<RightArrowContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ImpliesContext implies() {
			return GetRuleContext<ImpliesContext>(0);
		}
		public EdgeTypeInSituReferenceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_edgeTypeInSituReference; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEdgeTypeInSituReference(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EdgeTypeInSituReferenceContext edgeTypeInSituReference() {
		EdgeTypeInSituReferenceContext _localctx = new EdgeTypeInSituReferenceContext(Context, State);
		EnterRule(_localctx, 458, RULE_edgeTypeInSituReference);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2959;
			Match(LPAREN);
			State = 2960;
			Match(RPAREN);
			State = 2961;
			arrowLine();
			State = 2962;
			Match(LBRACKET);
			State = 2964;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ESCAPED_SYMBOLIC_NAME) | (1L << ACCESS) | (1L << ACTIVE) | (1L << ADD) | (1L << ADMIN) | (1L << ADMINISTRATOR) | (1L << ALIAS) | (1L << ALIASES) | (1L << ALL_SHORTEST_PATHS) | (1L << ALL) | (1L << ALLREDUCE) | (1L << ALTER) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASCENDING) | (1L << ASSIGN) | (1L << AT) | (1L << AUTH) | (1L << BINDINGS) | (1L << BOOL) | (1L << BOOLEAN) | (1L << BOOSTED) | (1L << BOTH) | (1L << BREAK) | (1L << BUILT) | (1L << BY) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CHANGE) | (1L << CIDR) | (1L << COLLECT) | (1L << COMMAND) | (1L << COMMANDS) | (1L << COMPOSITE) | (1L << CONCURRENT) | (1L << CONSTRAINT) | (1L << CONSTRAINTS) | (1L << CONTAINS) | (1L << COPY) | (1L << CONTINUE) | (1L << COSINE) | (1L << COUNT) | (1L << CREATE) | (1L << CREDENTIAL) | (1L << CSV) | (1L << CURRENT))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CYPHER - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATABASES - 64)) | (1L << (DATE - 64)) | (1L << (DATETIME - 64)) | (1L << (DBMS - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFINED - 64)) | (1L << (DELETE - 64)) | (1L << (DENY - 64)) | (1L << (DESC - 64)) | (1L << (DESCENDING - 64)) | (1L << (DESTROY - 64)) | (1L << (DETACH - 64)) | (1L << (DIFFERENT - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOT_METRIC - 64)) | (1L << (DRIVER - 64)) | (1L << (DROP - 64)) | (1L << (DRYRUN - 64)) | (1L << (DUMP - 64)) | (1L << (DURATION - 64)) | (1L << (EACH - 64)) | (1L << (EDGE - 64)) | (1L << (ENABLE - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELEMENTS - 64)) | (1L << (ELSE - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (EUCLIDEAN - 64)) | (1L << (EUCLIDEAN_SQUARED - 64)) | (1L << (END - 64)) | (1L << (ENDS - 64)) | (1L << (EXECUTABLE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXIST - 64)) | (1L << (EXISTENCE - 64)) | (1L << (EXISTS - 64)) | (1L << (ERROR - 64)) | (1L << (FAIL - 64)) | (1L << (FALSE - 64)) | (1L << (FIELDTERMINATOR - 64)) | (1L << (FILTER - 64)) | (1L << (FINISH - 64)) | (1L << (FLOAT - 64)) | (1L << (FLOAT64 - 64)) | (1L << (FLOAT32 - 64)) | (1L << (FOR - 64)) | (1L << (FOREACH - 64)) | (1L << (FORWARDING - 64)) | (1L << (FROM - 64)) | (1L << (FULLTEXT - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GRANT - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (GRAPH - 128)) | (1L << (GRAPHS - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPS - 128)) | (1L << (HAMMING - 128)) | (1L << (HEADERS - 128)) | (1L << (HOME - 128)) | (1L << (ID - 128)) | (1L << (IF - 128)) | (1L << (IMPERSONATE - 128)) | (1L << (IMMUTABLE - 128)) | (1L << (IN - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXES - 128)) | (1L << (INF - 128)) | (1L << (INFINITY - 128)) | (1L << (INSERT - 128)) | (1L << (INT - 128)) | (1L << (INT64 - 128)) | (1L << (INT32 - 128)) | (1L << (INT16 - 128)) | (1L << (INT8 - 128)) | (1L << (INTEGER - 128)) | (1L << (INTEGER64 - 128)) | (1L << (INTEGER32 - 128)) | (1L << (INTEGER16 - 128)) | (1L << (INTEGER8 - 128)) | (1L << (IS - 128)) | (1L << (JOIN - 128)) | (1L << (KEY - 128)) | (1L << (LABEL - 128)) | (1L << (LABELS - 128)) | (1L << (LANGUAGE - 128)) | (1L << (LEADING - 128)) | (1L << (LET - 128)) | (1L << (LIMITROWS - 128)) | (1L << (LIST - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOOKUP - 128)) | (1L << (MANAGEMENT - 128)) | (1L << (MANHATTAN - 128)) | (1L << (MAP - 128)) | (1L << (MATCH - 128)) | (1L << (MERGE - 128)) | (1L << (IMPLIES - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NAN - 128)) | (1L << (NFC - 128)) | (1L << (NFD - 128)) | (1L << (NFKC - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (NFKD - 192)) | (1L << (NEW - 192)) | (1L << (NEXT - 192)) | (1L << (NODE - 192)) | (1L << (NODETACH - 192)) | (1L << (NODES - 192)) | (1L << (NONE - 192)) | (1L << (NORMALIZE - 192)) | (1L << (NORMALIZED - 192)) | (1L << (NOT - 192)) | (1L << (NOTHING - 192)) | (1L << (NOWAIT - 192)) | (1L << (NULL - 192)) | (1L << (OF - 192)) | (1L << (OFFSET - 192)) | (1L << (OIDC - 192)) | (1L << (ON - 192)) | (1L << (ONLY - 192)) | (1L << (OPTIONAL - 192)) | (1L << (OPTIONS - 192)) | (1L << (OPTION - 192)) | (1L << (OR - 192)) | (1L << (ORDER - 192)) | (1L << (PASSWORD - 192)) | (1L << (PASSWORDS - 192)) | (1L << (PATH - 192)) | (1L << (PATHS - 192)) | (1L << (PLAINTEXT - 192)) | (1L << (POINT - 192)) | (1L << (POPULATED - 192)) | (1L << (PRIMARY - 192)) | (1L << (PRIMARIES - 192)) | (1L << (PRIVILEGE - 192)) | (1L << (PRIVILEGES - 192)) | (1L << (PROCEDURE - 192)) | (1L << (PROCEDURES - 192)) | (1L << (PROPERTIES - 192)) | (1L << (PROPERTY - 192)) | (1L << (PROVIDER - 192)) | (1L << (PROVIDERS - 192)) | (1L << (RANGE - 192)) | (1L << (READ - 192)) | (1L << (REALLOCATE - 192)) | (1L << (REDUCE - 192)) | (1L << (RENAME - 192)) | (1L << (REL - 192)) | (1L << (RELATIONSHIP - 192)) | (1L << (RELATIONSHIPS - 192)) | (1L << (REMOVE - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (REPLICAS - 192)) | (1L << (REPORT - 192)) | (1L << (REQUIRE - 192)) | (1L << (REQUIRED - 192)) | (1L << (RESTRICT - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (RETRY - 256)) | (1L << (RETURN - 256)) | (1L << (REVOKE - 256)) | (1L << (ROLE - 256)) | (1L << (ROLES - 256)) | (1L << (ROW - 256)) | (1L << (ROWS - 256)) | (1L << (SCAN - 256)) | (1L << (SEC - 256)) | (1L << (SECOND - 256)) | (1L << (SECONDARY - 256)) | (1L << (SECONDARIES - 256)) | (1L << (SECONDS - 256)) | (1L << (SEEK - 256)) | (1L << (SERVER - 256)) | (1L << (SERVERS - 256)) | (1L << (SET - 256)) | (1L << (SETTING - 256)) | (1L << (SETTINGS - 256)) | (1L << (SHARD - 256)) | (1L << (SHARDS - 256)) | (1L << (SHORTEST_PATH - 256)) | (1L << (SHORTEST - 256)) | (1L << (SHOW - 256)) | (1L << (SIGNED - 256)) | (1L << (SINGLE - 256)) | (1L << (SKIPROWS - 256)) | (1L << (START - 256)) | (1L << (STARTS - 256)) | (1L << (STATUS - 256)) | (1L << (STOP - 256)) | (1L << (STRING - 256)) | (1L << (SUPPORTED - 256)) | (1L << (SUSPENDED - 256)) | (1L << (TARGET - 256)) | (1L << (TERMINATE - 256)) | (1L << (TEXT - 256)) | (1L << (THEN - 256)) | (1L << (TIME - 256)) | (1L << (TIMESTAMP - 256)) | (1L << (TIMEZONE - 256)) | (1L << (TO - 256)) | (1L << (TOPOLOGY - 256)) | (1L << (TRAILING - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSACTIONS - 256)) | (1L << (TRAVERSE - 256)) | (1L << (TRIM - 256)) | (1L << (TRUE - 256)) | (1L << (TYPE - 256)) | (1L << (TYPED - 256)) | (1L << (TYPES - 256)) | (1L << (UNION - 256)) | (1L << (UNIQUE - 256)) | (1L << (UNIQUENESS - 256)) | (1L << (UNWIND - 256)) | (1L << (URL - 256)) | (1L << (USE - 256)) | (1L << (USER - 256)) | (1L << (USERS - 256)) | (1L << (USING - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (VALUE - 320)) | (1L << (VARCHAR - 320)) | (1L << (VECTOR - 320)) | (1L << (VECTOR_DISTANCE - 320)) | (1L << (VECTOR_NORM - 320)) | (1L << (VERTEX - 320)) | (1L << (WAIT - 320)) | (1L << (WHEN - 320)) | (1L << (WHERE - 320)) | (1L << (WITH - 320)) | (1L << (WITHOUT - 320)) | (1L << (WRITE - 320)) | (1L << (XOR - 320)) | (1L << (YIELD - 320)) | (1L << (ZONE - 320)) | (1L << (ZONED - 320)) | (1L << (IDENTIFIER - 320)))) != 0)) {
				{
				State = 2963;
				variable();
				}
			}

			State = 2966;
			relType();
			State = 2968;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==EQ || _la==IMPLIES) {
				{
				State = 2967;
				implies();
				}
			}

			State = 2970;
			Match(RBRACKET);
			State = 2971;
			arrowLine();
			State = 2972;
			rightArrow();
			State = 2973;
			Match(LPAREN);
			State = 2974;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertyTypeListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CypherParser.LCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CypherParser.RCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropertyTypeContext[] propertyType() {
			return GetRuleContexts<PropertyTypeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropertyTypeContext propertyType(int i) {
			return GetRuleContext<PropertyTypeContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public PropertyTypeListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertyTypeList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertyTypeList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertyTypeListContext propertyTypeList() {
		PropertyTypeListContext _localctx = new PropertyTypeListContext(Context, State);
		EnterRule(_localctx, 460, RULE_propertyTypeList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2976;
			Match(LCURLY);
			State = 2985;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ESCAPED_SYMBOLIC_NAME) | (1L << ACCESS) | (1L << ACTIVE) | (1L << ADD) | (1L << ADMIN) | (1L << ADMINISTRATOR) | (1L << ALIAS) | (1L << ALIASES) | (1L << ALL_SHORTEST_PATHS) | (1L << ALL) | (1L << ALLREDUCE) | (1L << ALTER) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASCENDING) | (1L << ASSIGN) | (1L << AT) | (1L << AUTH) | (1L << BINDINGS) | (1L << BOOL) | (1L << BOOLEAN) | (1L << BOOSTED) | (1L << BOTH) | (1L << BREAK) | (1L << BUILT) | (1L << BY) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CHANGE) | (1L << CIDR) | (1L << COLLECT) | (1L << COMMAND) | (1L << COMMANDS) | (1L << COMPOSITE) | (1L << CONCURRENT) | (1L << CONSTRAINT) | (1L << CONSTRAINTS) | (1L << CONTAINS) | (1L << COPY) | (1L << CONTINUE) | (1L << COSINE) | (1L << COUNT) | (1L << CREATE) | (1L << CREDENTIAL) | (1L << CSV) | (1L << CURRENT))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CYPHER - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATABASES - 64)) | (1L << (DATE - 64)) | (1L << (DATETIME - 64)) | (1L << (DBMS - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFINED - 64)) | (1L << (DELETE - 64)) | (1L << (DENY - 64)) | (1L << (DESC - 64)) | (1L << (DESCENDING - 64)) | (1L << (DESTROY - 64)) | (1L << (DETACH - 64)) | (1L << (DIFFERENT - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOT_METRIC - 64)) | (1L << (DRIVER - 64)) | (1L << (DROP - 64)) | (1L << (DRYRUN - 64)) | (1L << (DUMP - 64)) | (1L << (DURATION - 64)) | (1L << (EACH - 64)) | (1L << (EDGE - 64)) | (1L << (ENABLE - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELEMENTS - 64)) | (1L << (ELSE - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (EUCLIDEAN - 64)) | (1L << (EUCLIDEAN_SQUARED - 64)) | (1L << (END - 64)) | (1L << (ENDS - 64)) | (1L << (EXECUTABLE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXIST - 64)) | (1L << (EXISTENCE - 64)) | (1L << (EXISTS - 64)) | (1L << (ERROR - 64)) | (1L << (FAIL - 64)) | (1L << (FALSE - 64)) | (1L << (FIELDTERMINATOR - 64)) | (1L << (FILTER - 64)) | (1L << (FINISH - 64)) | (1L << (FLOAT - 64)) | (1L << (FLOAT64 - 64)) | (1L << (FLOAT32 - 64)) | (1L << (FOR - 64)) | (1L << (FOREACH - 64)) | (1L << (FORWARDING - 64)) | (1L << (FROM - 64)) | (1L << (FULLTEXT - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GRANT - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (GRAPH - 128)) | (1L << (GRAPHS - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPS - 128)) | (1L << (HAMMING - 128)) | (1L << (HEADERS - 128)) | (1L << (HOME - 128)) | (1L << (ID - 128)) | (1L << (IF - 128)) | (1L << (IMPERSONATE - 128)) | (1L << (IMMUTABLE - 128)) | (1L << (IN - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXES - 128)) | (1L << (INF - 128)) | (1L << (INFINITY - 128)) | (1L << (INSERT - 128)) | (1L << (INT - 128)) | (1L << (INT64 - 128)) | (1L << (INT32 - 128)) | (1L << (INT16 - 128)) | (1L << (INT8 - 128)) | (1L << (INTEGER - 128)) | (1L << (INTEGER64 - 128)) | (1L << (INTEGER32 - 128)) | (1L << (INTEGER16 - 128)) | (1L << (INTEGER8 - 128)) | (1L << (IS - 128)) | (1L << (JOIN - 128)) | (1L << (KEY - 128)) | (1L << (LABEL - 128)) | (1L << (LABELS - 128)) | (1L << (LANGUAGE - 128)) | (1L << (LEADING - 128)) | (1L << (LET - 128)) | (1L << (LIMITROWS - 128)) | (1L << (LIST - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOOKUP - 128)) | (1L << (MANAGEMENT - 128)) | (1L << (MANHATTAN - 128)) | (1L << (MAP - 128)) | (1L << (MATCH - 128)) | (1L << (MERGE - 128)) | (1L << (IMPLIES - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NAN - 128)) | (1L << (NFC - 128)) | (1L << (NFD - 128)) | (1L << (NFKC - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (NFKD - 192)) | (1L << (NEW - 192)) | (1L << (NEXT - 192)) | (1L << (NODE - 192)) | (1L << (NODETACH - 192)) | (1L << (NODES - 192)) | (1L << (NONE - 192)) | (1L << (NORMALIZE - 192)) | (1L << (NORMALIZED - 192)) | (1L << (NOT - 192)) | (1L << (NOTHING - 192)) | (1L << (NOWAIT - 192)) | (1L << (NULL - 192)) | (1L << (OF - 192)) | (1L << (OFFSET - 192)) | (1L << (OIDC - 192)) | (1L << (ON - 192)) | (1L << (ONLY - 192)) | (1L << (OPTIONAL - 192)) | (1L << (OPTIONS - 192)) | (1L << (OPTION - 192)) | (1L << (OR - 192)) | (1L << (ORDER - 192)) | (1L << (PASSWORD - 192)) | (1L << (PASSWORDS - 192)) | (1L << (PATH - 192)) | (1L << (PATHS - 192)) | (1L << (PLAINTEXT - 192)) | (1L << (POINT - 192)) | (1L << (POPULATED - 192)) | (1L << (PRIMARY - 192)) | (1L << (PRIMARIES - 192)) | (1L << (PRIVILEGE - 192)) | (1L << (PRIVILEGES - 192)) | (1L << (PROCEDURE - 192)) | (1L << (PROCEDURES - 192)) | (1L << (PROPERTIES - 192)) | (1L << (PROPERTY - 192)) | (1L << (PROVIDER - 192)) | (1L << (PROVIDERS - 192)) | (1L << (RANGE - 192)) | (1L << (READ - 192)) | (1L << (REALLOCATE - 192)) | (1L << (REDUCE - 192)) | (1L << (RENAME - 192)) | (1L << (REL - 192)) | (1L << (RELATIONSHIP - 192)) | (1L << (RELATIONSHIPS - 192)) | (1L << (REMOVE - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (REPLICAS - 192)) | (1L << (REPORT - 192)) | (1L << (REQUIRE - 192)) | (1L << (REQUIRED - 192)) | (1L << (RESTRICT - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (RETRY - 256)) | (1L << (RETURN - 256)) | (1L << (REVOKE - 256)) | (1L << (ROLE - 256)) | (1L << (ROLES - 256)) | (1L << (ROW - 256)) | (1L << (ROWS - 256)) | (1L << (SCAN - 256)) | (1L << (SEC - 256)) | (1L << (SECOND - 256)) | (1L << (SECONDARY - 256)) | (1L << (SECONDARIES - 256)) | (1L << (SECONDS - 256)) | (1L << (SEEK - 256)) | (1L << (SERVER - 256)) | (1L << (SERVERS - 256)) | (1L << (SET - 256)) | (1L << (SETTING - 256)) | (1L << (SETTINGS - 256)) | (1L << (SHARD - 256)) | (1L << (SHARDS - 256)) | (1L << (SHORTEST_PATH - 256)) | (1L << (SHORTEST - 256)) | (1L << (SHOW - 256)) | (1L << (SIGNED - 256)) | (1L << (SINGLE - 256)) | (1L << (SKIPROWS - 256)) | (1L << (START - 256)) | (1L << (STARTS - 256)) | (1L << (STATUS - 256)) | (1L << (STOP - 256)) | (1L << (STRING - 256)) | (1L << (SUPPORTED - 256)) | (1L << (SUSPENDED - 256)) | (1L << (TARGET - 256)) | (1L << (TERMINATE - 256)) | (1L << (TEXT - 256)) | (1L << (THEN - 256)) | (1L << (TIME - 256)) | (1L << (TIMESTAMP - 256)) | (1L << (TIMEZONE - 256)) | (1L << (TO - 256)) | (1L << (TOPOLOGY - 256)) | (1L << (TRAILING - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSACTIONS - 256)) | (1L << (TRAVERSE - 256)) | (1L << (TRIM - 256)) | (1L << (TRUE - 256)) | (1L << (TYPE - 256)) | (1L << (TYPED - 256)) | (1L << (TYPES - 256)) | (1L << (UNION - 256)) | (1L << (UNIQUE - 256)) | (1L << (UNIQUENESS - 256)) | (1L << (UNWIND - 256)) | (1L << (URL - 256)) | (1L << (USE - 256)) | (1L << (USER - 256)) | (1L << (USERS - 256)) | (1L << (USING - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (VALUE - 320)) | (1L << (VARCHAR - 320)) | (1L << (VECTOR - 320)) | (1L << (VECTOR_DISTANCE - 320)) | (1L << (VECTOR_NORM - 320)) | (1L << (VERTEX - 320)) | (1L << (WAIT - 320)) | (1L << (WHEN - 320)) | (1L << (WHERE - 320)) | (1L << (WITH - 320)) | (1L << (WITHOUT - 320)) | (1L << (WRITE - 320)) | (1L << (XOR - 320)) | (1L << (YIELD - 320)) | (1L << (ZONE - 320)) | (1L << (ZONED - 320)) | (1L << (IDENTIFIER - 320)))) != 0)) {
				{
				State = 2977;
				propertyType();
				State = 2982;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 2978;
					Match(COMMA);
					State = 2979;
					propertyType();
					}
					}
					State = 2984;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 2987;
			Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertyTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PropertyKeyNameContext propertyKeyName() {
			return GetRuleContext<PropertyKeyNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TypedContext typed() {
			return GetRuleContext<TypedContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropertyTypeInlineConstraintContext propertyTypeInlineConstraint() {
			return GetRuleContext<PropertyTypeInlineConstraintContext>(0);
		}
		public PropertyTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertyType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertyType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertyTypeContext propertyType() {
		PropertyTypeContext _localctx = new PropertyTypeContext(Context, State);
		EnterRule(_localctx, 462, RULE_propertyType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2989;
			propertyKeyName();
			State = 2991;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COLONCOLON || _la==TYPED) {
				{
				State = 2990;
				typed();
				}
			}

			State = 2993;
			type();
			State = 2995;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IS) {
				{
				State = 2994;
				propertyTypeInlineConstraint();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertyTypeInlineConstraintContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(CypherParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEY() { return GetToken(CypherParser.KEY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIQUE() { return GetToken(CypherParser.UNIQUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NODE() { return GetToken(CypherParser.NODE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELATIONSHIP() { return GetToken(CypherParser.RELATIONSHIP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REL() { return GetToken(CypherParser.REL, 0); }
		public PropertyTypeInlineConstraintContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertyTypeInlineConstraint; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertyTypeInlineConstraint(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertyTypeInlineConstraintContext propertyTypeInlineConstraint() {
		PropertyTypeInlineConstraintContext _localctx = new PropertyTypeInlineConstraintContext(Context, State);
		EnterRule(_localctx, 464, RULE_propertyTypeInlineConstraint);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 2997;
			Match(IS);
			State = 2999;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (NODE - 195)) | (1L << (REL - 195)) | (1L << (RELATIONSHIP - 195)))) != 0)) {
				{
				State = 2998;
				_la = TokenStream.LA(1);
				if ( !(((((_la - 195)) & ~0x3f) == 0 && ((1L << (_la - 195)) & ((1L << (NODE - 195)) | (1L << (REL - 195)) | (1L << (RELATIONSHIP - 195)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3001;
			_la = TokenStream.LA(1);
			if ( !(_la==KEY || _la==UNIQUE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypedContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLONCOLON() { return GetToken(CypherParser.COLONCOLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPED() { return GetToken(CypherParser.TYPED, 0); }
		public TypedContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_typed; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTyped(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypedContext typed() {
		TypedContext _localctx = new TypedContext(Context, State);
		EnterRule(_localctx, 466, RULE_typed);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3003;
			_la = TokenStream.LA(1);
			if ( !(_la==COLONCOLON || _la==TYPED) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstraintSpecificationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTRAINT() { return GetToken(CypherParser.CONSTRAINT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(CypherParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintTypeContext constraintType() {
			return GetRuleContext<ConstraintTypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NodeTypeReferenceContext nodeTypeReference() {
			return GetRuleContext<NodeTypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public EdgeTypeReferenceContext edgeTypeReference() {
			return GetRuleContext<EdgeTypeReferenceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString() {
			return GetRuleContext<SymbolicNameStringContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommandOptionsContext commandOptions() {
			return GetRuleContext<CommandOptionsContext>(0);
		}
		public ConstraintSpecificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraintSpecification; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstraintSpecification(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstraintSpecificationContext constraintSpecification() {
		ConstraintSpecificationContext _localctx = new ConstraintSpecificationContext(Context, State);
		EnterRule(_localctx, 468, RULE_constraintSpecification);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3005;
			Match(CONSTRAINT);
			State = 3007;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,334,Context) ) {
			case 1:
				{
				State = 3006;
				symbolicNameString();
				}
				break;
			}
			State = 3009;
			Match(FOR);
			State = 3012;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,335,Context) ) {
			case 1:
				{
				State = 3010;
				nodeTypeReference();
				}
				break;
			case 2:
				{
				State = 3011;
				edgeTypeReference();
				}
				break;
			}
			State = 3014;
			constraintType();
			State = 3016;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OPTIONS) {
				{
				State = 3015;
				commandOptions();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RenameCommandContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RENAME() { return GetToken(CypherParser.RENAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RenameRoleContext renameRole() {
			return GetRuleContext<RenameRoleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RenameServerContext renameServer() {
			return GetRuleContext<RenameServerContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RenameUserContext renameUser() {
			return GetRuleContext<RenameUserContext>(0);
		}
		public RenameCommandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_renameCommand; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRenameCommand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RenameCommandContext renameCommand() {
		RenameCommandContext _localctx = new RenameCommandContext(Context, State);
		EnterRule(_localctx, 470, RULE_renameCommand);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3018;
			Match(RENAME);
			State = 3022;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ROLE:
				{
				State = 3019;
				renameRole();
				}
				break;
			case SERVER:
				{
				State = 3020;
				renameServer();
				}
				break;
			case USER:
				{
				State = 3021;
				renameUser();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GrantCommandContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GRANT() { return GetToken(CypherParser.GRANT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PrivilegeContext privilege() {
			return GetRuleContext<PrivilegeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(CypherParser.TO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RoleNamesContext roleNames() {
			return GetRuleContext<RoleNamesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RoleTokenContext roleToken() {
			return GetRuleContext<RoleTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GrantRoleContext grantRole() {
			return GetRuleContext<GrantRoleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMMUTABLE() { return GetToken(CypherParser.IMMUTABLE, 0); }
		public GrantCommandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grantCommand; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGrantCommand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GrantCommandContext grantCommand() {
		GrantCommandContext _localctx = new GrantCommandContext(Context, State);
		EnterRule(_localctx, 472, RULE_grantCommand);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3024;
			Match(GRANT);
			State = 3035;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,339,Context) ) {
			case 1:
				{
				State = 3026;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IMMUTABLE) {
					{
					State = 3025;
					Match(IMMUTABLE);
					}
				}

				State = 3028;
				privilege();
				State = 3029;
				Match(TO);
				State = 3030;
				roleNames();
				}
				break;
			case 2:
				{
				State = 3032;
				roleToken();
				State = 3033;
				grantRole();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DenyCommandContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DENY() { return GetToken(CypherParser.DENY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PrivilegeContext privilege() {
			return GetRuleContext<PrivilegeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(CypherParser.TO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RoleNamesContext roleNames() {
			return GetRuleContext<RoleNamesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMMUTABLE() { return GetToken(CypherParser.IMMUTABLE, 0); }
		public DenyCommandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_denyCommand; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDenyCommand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DenyCommandContext denyCommand() {
		DenyCommandContext _localctx = new DenyCommandContext(Context, State);
		EnterRule(_localctx, 474, RULE_denyCommand);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3037;
			Match(DENY);
			State = 3039;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IMMUTABLE) {
				{
				State = 3038;
				Match(IMMUTABLE);
				}
			}

			State = 3041;
			privilege();
			State = 3042;
			Match(TO);
			State = 3043;
			roleNames();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RevokeCommandContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REVOKE() { return GetToken(CypherParser.REVOKE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PrivilegeContext privilege() {
			return GetRuleContext<PrivilegeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FROM() { return GetToken(CypherParser.FROM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public RoleNamesContext roleNames() {
			return GetRuleContext<RoleNamesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RoleTokenContext roleToken() {
			return GetRuleContext<RoleTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RevokeRoleContext revokeRole() {
			return GetRuleContext<RevokeRoleContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMMUTABLE() { return GetToken(CypherParser.IMMUTABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DENY() { return GetToken(CypherParser.DENY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GRANT() { return GetToken(CypherParser.GRANT, 0); }
		public RevokeCommandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_revokeCommand; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRevokeCommand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RevokeCommandContext revokeCommand() {
		RevokeCommandContext _localctx = new RevokeCommandContext(Context, State);
		EnterRule(_localctx, 476, RULE_revokeCommand);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3045;
			Match(REVOKE);
			State = 3059;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,343,Context) ) {
			case 1:
				{
				State = 3047;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DENY || _la==GRANT) {
					{
					State = 3046;
					_la = TokenStream.LA(1);
					if ( !(_la==DENY || _la==GRANT) ) {
					ErrorHandler.RecoverInline(this);
					}
					else {
						ErrorHandler.ReportMatch(this);
					    Consume();
					}
					}
				}

				State = 3050;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==IMMUTABLE) {
					{
					State = 3049;
					Match(IMMUTABLE);
					}
				}

				State = 3052;
				privilege();
				State = 3053;
				Match(FROM);
				State = 3054;
				roleNames();
				}
				break;
			case 2:
				{
				State = 3056;
				roleToken();
				State = 3057;
				revokeRole();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UserNamesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameOrStringParameterListContext symbolicNameOrStringParameterList() {
			return GetRuleContext<SymbolicNameOrStringParameterListContext>(0);
		}
		public UserNamesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_userNames; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUserNames(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UserNamesContext userNames() {
		UserNamesContext _localctx = new UserNamesContext(Context, State);
		EnterRule(_localctx, 478, RULE_userNames);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3061;
			symbolicNameOrStringParameterList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RoleNamesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameOrStringParameterListContext symbolicNameOrStringParameterList() {
			return GetRuleContext<SymbolicNameOrStringParameterListContext>(0);
		}
		public RoleNamesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_roleNames; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRoleNames(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RoleNamesContext roleNames() {
		RoleNamesContext _localctx = new RoleNamesContext(Context, State);
		EnterRule(_localctx, 480, RULE_roleNames);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3063;
			symbolicNameOrStringParameterList();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RoleTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLES() { return GetToken(CypherParser.ROLES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLE() { return GetToken(CypherParser.ROLE, 0); }
		public RoleTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_roleToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRoleToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RoleTokenContext roleToken() {
		RoleTokenContext _localctx = new RoleTokenContext(Context, State);
		EnterRule(_localctx, 482, RULE_roleToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3065;
			_la = TokenStream.LA(1);
			if ( !(_la==ROLE || _la==ROLES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EnableServerCommandContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENABLE() { return GetToken(CypherParser.ENABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERVER() { return GetToken(CypherParser.SERVER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StringOrParameterContext stringOrParameter() {
			return GetRuleContext<StringOrParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommandOptionsContext commandOptions() {
			return GetRuleContext<CommandOptionsContext>(0);
		}
		public EnableServerCommandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_enableServerCommand; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEnableServerCommand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EnableServerCommandContext enableServerCommand() {
		EnableServerCommandContext _localctx = new EnableServerCommandContext(Context, State);
		EnterRule(_localctx, 484, RULE_enableServerCommand);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3067;
			Match(ENABLE);
			State = 3068;
			Match(SERVER);
			State = 3069;
			stringOrParameter();
			State = 3071;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OPTIONS) {
				{
				State = 3070;
				commandOptions();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterServerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERVER() { return GetToken(CypherParser.SERVER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StringOrParameterContext stringOrParameter() {
			return GetRuleContext<StringOrParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(CypherParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CommandOptionsContext commandOptions() {
			return GetRuleContext<CommandOptionsContext>(0);
		}
		public AlterServerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterServer; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterServer(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterServerContext alterServer() {
		AlterServerContext _localctx = new AlterServerContext(Context, State);
		EnterRule(_localctx, 486, RULE_alterServer);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3073;
			Match(SERVER);
			State = 3074;
			stringOrParameter();
			State = 3075;
			Match(SET);
			State = 3076;
			commandOptions();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RenameServerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERVER() { return GetToken(CypherParser.SERVER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StringOrParameterContext[] stringOrParameter() {
			return GetRuleContexts<StringOrParameterContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StringOrParameterContext stringOrParameter(int i) {
			return GetRuleContext<StringOrParameterContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(CypherParser.TO, 0); }
		public RenameServerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_renameServer; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRenameServer(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RenameServerContext renameServer() {
		RenameServerContext _localctx = new RenameServerContext(Context, State);
		EnterRule(_localctx, 488, RULE_renameServer);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3078;
			Match(SERVER);
			State = 3079;
			stringOrParameter();
			State = 3080;
			Match(TO);
			State = 3081;
			stringOrParameter();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropServerContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERVER() { return GetToken(CypherParser.SERVER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StringOrParameterContext stringOrParameter() {
			return GetRuleContext<StringOrParameterContext>(0);
		}
		public DropServerContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropServer; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDropServer(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DropServerContext dropServer() {
		DropServerContext _localctx = new DropServerContext(Context, State);
		EnterRule(_localctx, 490, RULE_dropServer);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3083;
			Match(SERVER);
			State = 3084;
			stringOrParameter();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowServersContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERVER() { return GetToken(CypherParser.SERVER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERVERS() { return GetToken(CypherParser.SERVERS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ShowCommandYieldContext showCommandYield() {
			return GetRuleContext<ShowCommandYieldContext>(0);
		}
		public ShowServersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showServers; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowServers(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowServersContext showServers() {
		ShowServersContext _localctx = new ShowServersContext(Context, State);
		EnterRule(_localctx, 492, RULE_showServers);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3086;
			_la = TokenStream.LA(1);
			if ( !(_la==SERVER || _la==SERVERS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3088;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE || _la==YIELD) {
				{
				State = 3087;
				showCommandYield();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AllocationCommandContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeallocateDatabaseFromServersContext deallocateDatabaseFromServers() {
			return GetRuleContext<DeallocateDatabaseFromServersContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReallocateDatabasesContext reallocateDatabases() {
			return GetRuleContext<ReallocateDatabasesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DRYRUN() { return GetToken(CypherParser.DRYRUN, 0); }
		public AllocationCommandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_allocationCommand; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAllocationCommand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AllocationCommandContext allocationCommand() {
		AllocationCommandContext _localctx = new AllocationCommandContext(Context, State);
		EnterRule(_localctx, 494, RULE_allocationCommand);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3091;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DRYRUN) {
				{
				State = 3090;
				Match(DRYRUN);
				}
			}

			State = 3095;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DEALLOCATE:
				{
				State = 3093;
				deallocateDatabaseFromServers();
				}
				break;
			case REALLOCATE:
				{
				State = 3094;
				reallocateDatabases();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeallocateDatabaseFromServersContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEALLOCATE() { return GetToken(CypherParser.DEALLOCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FROM() { return GetToken(CypherParser.FROM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StringOrParameterContext[] stringOrParameter() {
			return GetRuleContexts<StringOrParameterContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StringOrParameterContext stringOrParameter(int i) {
			return GetRuleContext<StringOrParameterContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASES() { return GetToken(CypherParser.DATABASES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERVER() { return GetToken(CypherParser.SERVER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERVERS() { return GetToken(CypherParser.SERVERS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public DeallocateDatabaseFromServersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_deallocateDatabaseFromServers; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeallocateDatabaseFromServers(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeallocateDatabaseFromServersContext deallocateDatabaseFromServers() {
		DeallocateDatabaseFromServersContext _localctx = new DeallocateDatabaseFromServersContext(Context, State);
		EnterRule(_localctx, 496, RULE_deallocateDatabaseFromServers);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3097;
			Match(DEALLOCATE);
			State = 3098;
			_la = TokenStream.LA(1);
			if ( !(_la==DATABASE || _la==DATABASES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3099;
			Match(FROM);
			State = 3100;
			_la = TokenStream.LA(1);
			if ( !(_la==SERVER || _la==SERVERS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3101;
			stringOrParameter();
			State = 3106;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3102;
				Match(COMMA);
				State = 3103;
				stringOrParameter();
				}
				}
				State = 3108;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReallocateDatabasesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REALLOCATE() { return GetToken(CypherParser.REALLOCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASES() { return GetToken(CypherParser.DATABASES, 0); }
		public ReallocateDatabasesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_reallocateDatabases; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReallocateDatabases(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReallocateDatabasesContext reallocateDatabases() {
		ReallocateDatabasesContext _localctx = new ReallocateDatabasesContext(Context, State);
		EnterRule(_localctx, 498, RULE_reallocateDatabases);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3109;
			Match(REALLOCATE);
			State = 3110;
			_la = TokenStream.LA(1);
			if ( !(_la==DATABASE || _la==DATABASES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateRoleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLE() { return GetToken(CypherParser.ROLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CommandNameExpressionContext[] commandNameExpression() {
			return GetRuleContexts<CommandNameExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommandNameExpressionContext commandNameExpression(int i) {
			return GetRuleContext<CommandNameExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMMUTABLE() { return GetToken(CypherParser.IMMUTABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CypherParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(CypherParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(CypherParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COPY() { return GetToken(CypherParser.COPY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(CypherParser.OF, 0); }
		public CreateRoleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createRole; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateRole(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateRoleContext createRole() {
		CreateRoleContext _localctx = new CreateRoleContext(Context, State);
		EnterRule(_localctx, 500, RULE_createRole);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3113;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IMMUTABLE) {
				{
				State = 3112;
				Match(IMMUTABLE);
				}
			}

			State = 3115;
			Match(ROLE);
			State = 3116;
			commandNameExpression();
			State = 3120;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 3117;
				Match(IF);
				State = 3118;
				Match(NOT);
				State = 3119;
				Match(EXISTS);
				}
			}

			State = 3126;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 3122;
				Match(AS);
				State = 3123;
				Match(COPY);
				State = 3124;
				Match(OF);
				State = 3125;
				commandNameExpression();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropRoleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLE() { return GetToken(CypherParser.ROLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CommandNameExpressionContext commandNameExpression() {
			return GetRuleContext<CommandNameExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CypherParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		public DropRoleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropRole; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDropRole(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DropRoleContext dropRole() {
		DropRoleContext _localctx = new DropRoleContext(Context, State);
		EnterRule(_localctx, 502, RULE_dropRole);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3128;
			Match(ROLE);
			State = 3129;
			commandNameExpression();
			State = 3132;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 3130;
				Match(IF);
				State = 3131;
				Match(EXISTS);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RenameRoleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLE() { return GetToken(CypherParser.ROLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CommandNameExpressionContext[] commandNameExpression() {
			return GetRuleContexts<CommandNameExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommandNameExpressionContext commandNameExpression(int i) {
			return GetRuleContext<CommandNameExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(CypherParser.TO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CypherParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		public RenameRoleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_renameRole; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRenameRole(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RenameRoleContext renameRole() {
		RenameRoleContext _localctx = new RenameRoleContext(Context, State);
		EnterRule(_localctx, 504, RULE_renameRole);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3134;
			Match(ROLE);
			State = 3135;
			commandNameExpression();
			State = 3138;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 3136;
				Match(IF);
				State = 3137;
				Match(EXISTS);
				}
			}

			State = 3140;
			Match(TO);
			State = 3141;
			commandNameExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowRolesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RoleTokenContext roleToken() {
			return GetRuleContext<RoleTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(CypherParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ShowCommandYieldContext showCommandYield() {
			return GetRuleContext<ShowCommandYieldContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(CypherParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode POPULATED() { return GetToken(CypherParser.POPULATED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(CypherParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USERS() { return GetToken(CypherParser.USERS, 0); }
		public ShowRolesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showRoles; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowRoles(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowRolesContext showRoles() {
		ShowRolesContext _localctx = new ShowRolesContext(Context, State);
		EnterRule(_localctx, 506, RULE_showRoles);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3144;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL || _la==POPULATED) {
				{
				State = 3143;
				_la = TokenStream.LA(1);
				if ( !(_la==ALL || _la==POPULATED) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3146;
			roleToken();
			State = 3149;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 3147;
				Match(WITH);
				State = 3148;
				_la = TokenStream.LA(1);
				if ( !(_la==USER || _la==USERS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3152;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE || _la==YIELD) {
				{
				State = 3151;
				showCommandYield();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GrantRoleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RoleNamesContext roleNames() {
			return GetRuleContext<RoleNamesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(CypherParser.TO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UserNamesContext userNames() {
			return GetRuleContext<UserNamesContext>(0);
		}
		public GrantRoleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_grantRole; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGrantRole(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GrantRoleContext grantRole() {
		GrantRoleContext _localctx = new GrantRoleContext(Context, State);
		EnterRule(_localctx, 508, RULE_grantRole);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3154;
			roleNames();
			State = 3155;
			Match(TO);
			State = 3156;
			userNames();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RevokeRoleContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RoleNamesContext roleNames() {
			return GetRuleContext<RoleNamesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FROM() { return GetToken(CypherParser.FROM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UserNamesContext userNames() {
			return GetRuleContext<UserNamesContext>(0);
		}
		public RevokeRoleContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_revokeRole; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRevokeRole(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RevokeRoleContext revokeRole() {
		RevokeRoleContext _localctx = new RevokeRoleContext(Context, State);
		EnterRule(_localctx, 510, RULE_revokeRole);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3158;
			roleNames();
			State = 3159;
			Match(FROM);
			State = 3160;
			userNames();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateUserContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(CypherParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CommandNameExpressionContext commandNameExpression() {
			return GetRuleContext<CommandNameExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CypherParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(CypherParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] SET() { return GetTokens(CypherParser.SET); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET(int i) {
			return GetToken(CypherParser.SET, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PasswordContext[] password() {
			return GetRuleContexts<PasswordContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PasswordContext password(int i) {
			return GetRuleContext<PasswordContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] PASSWORD() { return GetTokens(CypherParser.PASSWORD); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSWORD(int i) {
			return GetToken(CypherParser.PASSWORD, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PasswordChangeRequiredContext[] passwordChangeRequired() {
			return GetRuleContexts<PasswordChangeRequiredContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PasswordChangeRequiredContext passwordChangeRequired(int i) {
			return GetRuleContext<PasswordChangeRequiredContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UserStatusContext[] userStatus() {
			return GetRuleContexts<UserStatusContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public UserStatusContext userStatus(int i) {
			return GetRuleContext<UserStatusContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public HomeDatabaseContext[] homeDatabase() {
			return GetRuleContexts<HomeDatabaseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public HomeDatabaseContext homeDatabase(int i) {
			return GetRuleContext<HomeDatabaseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SetAuthClauseContext[] setAuthClause() {
			return GetRuleContexts<SetAuthClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SetAuthClauseContext setAuthClause(int i) {
			return GetRuleContext<SetAuthClauseContext>(i);
		}
		public CreateUserContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createUser; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateUser(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateUserContext createUser() {
		CreateUserContext _localctx = new CreateUserContext(Context, State);
		EnterRule(_localctx, 512, RULE_createUser);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3162;
			Match(USER);
			State = 3163;
			commandNameExpression();
			State = 3167;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 3164;
				Match(IF);
				State = 3165;
				Match(NOT);
				State = 3166;
				Match(EXISTS);
				}
			}

			State = 3178;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 3169;
				Match(SET);
				State = 3176;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,358,Context) ) {
				case 1:
					{
					State = 3170;
					password();
					}
					break;
				case 2:
					{
					State = 3171;
					Match(PASSWORD);
					State = 3172;
					passwordChangeRequired();
					}
					break;
				case 3:
					{
					State = 3173;
					userStatus();
					}
					break;
				case 4:
					{
					State = 3174;
					homeDatabase();
					}
					break;
				case 5:
					{
					State = 3175;
					setAuthClause();
					}
					break;
				}
				}
				}
				State = 3180;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==SET );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropUserContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(CypherParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CommandNameExpressionContext commandNameExpression() {
			return GetRuleContext<CommandNameExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CypherParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		public DropUserContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropUser; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDropUser(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DropUserContext dropUser() {
		DropUserContext _localctx = new DropUserContext(Context, State);
		EnterRule(_localctx, 514, RULE_dropUser);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3182;
			Match(USER);
			State = 3183;
			commandNameExpression();
			State = 3186;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 3184;
				Match(IF);
				State = 3185;
				Match(EXISTS);
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RenameUserContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(CypherParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CommandNameExpressionContext[] commandNameExpression() {
			return GetRuleContexts<CommandNameExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommandNameExpressionContext commandNameExpression(int i) {
			return GetRuleContext<CommandNameExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(CypherParser.TO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CypherParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		public RenameUserContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_renameUser; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRenameUser(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RenameUserContext renameUser() {
		RenameUserContext _localctx = new RenameUserContext(Context, State);
		EnterRule(_localctx, 516, RULE_renameUser);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3188;
			Match(USER);
			State = 3189;
			commandNameExpression();
			State = 3192;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 3190;
				Match(IF);
				State = 3191;
				Match(EXISTS);
				}
			}

			State = 3194;
			Match(TO);
			State = 3195;
			commandNameExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterCurrentUserContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT() { return GetToken(CypherParser.CURRENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(CypherParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(CypherParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSWORD() { return GetToken(CypherParser.PASSWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FROM() { return GetToken(CypherParser.FROM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PasswordExpressionContext[] passwordExpression() {
			return GetRuleContexts<PasswordExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PasswordExpressionContext passwordExpression(int i) {
			return GetRuleContext<PasswordExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(CypherParser.TO, 0); }
		public AlterCurrentUserContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterCurrentUser; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterCurrentUser(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterCurrentUserContext alterCurrentUser() {
		AlterCurrentUserContext _localctx = new AlterCurrentUserContext(Context, State);
		EnterRule(_localctx, 518, RULE_alterCurrentUser);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3197;
			Match(CURRENT);
			State = 3198;
			Match(USER);
			State = 3199;
			Match(SET);
			State = 3200;
			Match(PASSWORD);
			State = 3201;
			Match(FROM);
			State = 3202;
			passwordExpression();
			State = 3203;
			Match(TO);
			State = 3204;
			passwordExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterUserContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(CypherParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CommandNameExpressionContext commandNameExpression() {
			return GetRuleContext<CommandNameExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CypherParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] REMOVE() { return GetTokens(CypherParser.REMOVE); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REMOVE(int i) {
			return GetToken(CypherParser.REMOVE, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] SET() { return GetTokens(CypherParser.SET); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET(int i) {
			return GetToken(CypherParser.SET, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] HOME() { return GetTokens(CypherParser.HOME); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HOME(int i) {
			return GetToken(CypherParser.HOME, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] DATABASE() { return GetTokens(CypherParser.DATABASE); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE(int i) {
			return GetToken(CypherParser.DATABASE, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] ALL() { return GetTokens(CypherParser.ALL); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL(int i) {
			return GetToken(CypherParser.ALL, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] AUTH() { return GetTokens(CypherParser.AUTH); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTH(int i) {
			return GetToken(CypherParser.AUTH, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RemoveNamedProviderContext[] removeNamedProvider() {
			return GetRuleContexts<RemoveNamedProviderContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public RemoveNamedProviderContext removeNamedProvider(int i) {
			return GetRuleContext<RemoveNamedProviderContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PasswordContext[] password() {
			return GetRuleContexts<PasswordContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PasswordContext password(int i) {
			return GetRuleContext<PasswordContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] PASSWORD() { return GetTokens(CypherParser.PASSWORD); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSWORD(int i) {
			return GetToken(CypherParser.PASSWORD, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PasswordChangeRequiredContext[] passwordChangeRequired() {
			return GetRuleContexts<PasswordChangeRequiredContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PasswordChangeRequiredContext passwordChangeRequired(int i) {
			return GetRuleContext<PasswordChangeRequiredContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UserStatusContext[] userStatus() {
			return GetRuleContexts<UserStatusContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public UserStatusContext userStatus(int i) {
			return GetRuleContext<UserStatusContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public HomeDatabaseContext[] homeDatabase() {
			return GetRuleContexts<HomeDatabaseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public HomeDatabaseContext homeDatabase(int i) {
			return GetRuleContext<HomeDatabaseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SetAuthClauseContext[] setAuthClause() {
			return GetRuleContexts<SetAuthClauseContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SetAuthClauseContext setAuthClause(int i) {
			return GetRuleContext<SetAuthClauseContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] PROVIDER() { return GetTokens(CypherParser.PROVIDER); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROVIDER(int i) {
			return GetToken(CypherParser.PROVIDER, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] PROVIDERS() { return GetTokens(CypherParser.PROVIDERS); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROVIDERS(int i) {
			return GetToken(CypherParser.PROVIDERS, i);
		}
		public AlterUserContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterUser; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterUser(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterUserContext alterUser() {
		AlterUserContext _localctx = new AlterUserContext(Context, State);
		EnterRule(_localctx, 520, RULE_alterUser);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3206;
			Match(USER);
			State = 3207;
			commandNameExpression();
			State = 3210;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 3208;
				Match(IF);
				State = 3209;
				Match(EXISTS);
				}
			}

			State = 3225;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==REMOVE) {
				{
				{
				State = 3212;
				Match(REMOVE);
				State = 3221;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case HOME:
					{
					State = 3213;
					Match(HOME);
					State = 3214;
					Match(DATABASE);
					}
					break;
				case ALL:
					{
					State = 3215;
					Match(ALL);
					State = 3216;
					Match(AUTH);
					State = 3218;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==PROVIDER || _la==PROVIDERS) {
						{
						State = 3217;
						_la = TokenStream.LA(1);
						if ( !(_la==PROVIDER || _la==PROVIDERS) ) {
						ErrorHandler.RecoverInline(this);
						}
						else {
							ErrorHandler.ReportMatch(this);
						    Consume();
						}
						}
					}

					}
					break;
				case AUTH:
					{
					State = 3220;
					removeNamedProvider();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				}
				State = 3227;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 3239;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==SET) {
				{
				{
				State = 3228;
				Match(SET);
				State = 3235;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,366,Context) ) {
				case 1:
					{
					State = 3229;
					password();
					}
					break;
				case 2:
					{
					State = 3230;
					Match(PASSWORD);
					State = 3231;
					passwordChangeRequired();
					}
					break;
				case 3:
					{
					State = 3232;
					userStatus();
					}
					break;
				case 4:
					{
					State = 3233;
					homeDatabase();
					}
					break;
				case 5:
					{
					State = 3234;
					setAuthClause();
					}
					break;
				}
				}
				}
				State = 3241;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RemoveNamedProviderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTH() { return GetToken(CypherParser.AUTH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StringLiteralContext stringLiteral() {
			return GetRuleContext<StringLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public StringListLiteralContext stringListLiteral() {
			return GetRuleContext<StringListLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParameterContext parameter() {
			return GetRuleContext<ParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROVIDER() { return GetToken(CypherParser.PROVIDER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROVIDERS() { return GetToken(CypherParser.PROVIDERS, 0); }
		public RemoveNamedProviderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_removeNamedProvider; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRemoveNamedProvider(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RemoveNamedProviderContext removeNamedProvider() {
		RemoveNamedProviderContext _localctx = new RemoveNamedProviderContext(Context, State);
		EnterRule(_localctx, 522, RULE_removeNamedProvider);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3242;
			Match(AUTH);
			State = 3244;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PROVIDER || _la==PROVIDERS) {
				{
				State = 3243;
				_la = TokenStream.LA(1);
				if ( !(_la==PROVIDER || _la==PROVIDERS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3249;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STRING_LITERAL1:
			case STRING_LITERAL2:
				{
				State = 3246;
				stringLiteral();
				}
				break;
			case LBRACKET:
				{
				State = 3247;
				stringListLiteral();
				}
				break;
			case DOLLAR:
				{
				State = 3248;
				parameter("ANY");
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PasswordContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSWORD() { return GetToken(CypherParser.PASSWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PasswordExpressionContext passwordExpression() {
			return GetRuleContext<PasswordExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PasswordChangeRequiredContext passwordChangeRequired() {
			return GetRuleContext<PasswordChangeRequiredContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLAINTEXT() { return GetToken(CypherParser.PLAINTEXT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENCRYPTED() { return GetToken(CypherParser.ENCRYPTED, 0); }
		public PasswordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_password; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPassword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PasswordContext password() {
		PasswordContext _localctx = new PasswordContext(Context, State);
		EnterRule(_localctx, 524, RULE_password);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3252;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ENCRYPTED || _la==PLAINTEXT) {
				{
				State = 3251;
				_la = TokenStream.LA(1);
				if ( !(_la==ENCRYPTED || _la==PLAINTEXT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3254;
			Match(PASSWORD);
			State = 3255;
			passwordExpression();
			State = 3257;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CHANGE) {
				{
				State = 3256;
				passwordChangeRequired();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PasswordOnlyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSWORD() { return GetToken(CypherParser.PASSWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PasswordExpressionContext passwordExpression() {
			return GetRuleContext<PasswordExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLAINTEXT() { return GetToken(CypherParser.PLAINTEXT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENCRYPTED() { return GetToken(CypherParser.ENCRYPTED, 0); }
		public PasswordOnlyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_passwordOnly; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPasswordOnly(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PasswordOnlyContext passwordOnly() {
		PasswordOnlyContext _localctx = new PasswordOnlyContext(Context, State);
		EnterRule(_localctx, 526, RULE_passwordOnly);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3260;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ENCRYPTED || _la==PLAINTEXT) {
				{
				State = 3259;
				_la = TokenStream.LA(1);
				if ( !(_la==ENCRYPTED || _la==PLAINTEXT) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3262;
			Match(PASSWORD);
			State = 3263;
			passwordExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PasswordExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StringLiteralContext stringLiteral() {
			return GetRuleContext<StringLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParameterContext parameter() {
			return GetRuleContext<ParameterContext>(0);
		}
		public PasswordExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_passwordExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPasswordExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PasswordExpressionContext passwordExpression() {
		PasswordExpressionContext _localctx = new PasswordExpressionContext(Context, State);
		EnterRule(_localctx, 528, RULE_passwordExpression);
		try {
			State = 3267;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STRING_LITERAL1:
			case STRING_LITERAL2:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3265;
				stringLiteral();
				}
				break;
			case DOLLAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3266;
				parameter("STRING");
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PasswordChangeRequiredContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHANGE() { return GetToken(CypherParser.CHANGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REQUIRED() { return GetToken(CypherParser.REQUIRED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(CypherParser.NOT, 0); }
		public PasswordChangeRequiredContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_passwordChangeRequired; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPasswordChangeRequired(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PasswordChangeRequiredContext passwordChangeRequired() {
		PasswordChangeRequiredContext _localctx = new PasswordChangeRequiredContext(Context, State);
		EnterRule(_localctx, 530, RULE_passwordChangeRequired);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3269;
			Match(CHANGE);
			State = 3271;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOT) {
				{
				State = 3270;
				Match(NOT);
				}
			}

			State = 3273;
			Match(REQUIRED);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UserStatusContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATUS() { return GetToken(CypherParser.STATUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUSPENDED() { return GetToken(CypherParser.SUSPENDED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ACTIVE() { return GetToken(CypherParser.ACTIVE, 0); }
		public UserStatusContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_userStatus; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUserStatus(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UserStatusContext userStatus() {
		UserStatusContext _localctx = new UserStatusContext(Context, State);
		EnterRule(_localctx, 532, RULE_userStatus);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3275;
			Match(STATUS);
			State = 3276;
			_la = TokenStream.LA(1);
			if ( !(_la==ACTIVE || _la==SUSPENDED) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class HomeDatabaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HOME() { return GetToken(CypherParser.HOME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicAliasNameOrParameterContext symbolicAliasNameOrParameter() {
			return GetRuleContext<SymbolicAliasNameOrParameterContext>(0);
		}
		public HomeDatabaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_homeDatabase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitHomeDatabase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public HomeDatabaseContext homeDatabase() {
		HomeDatabaseContext _localctx = new HomeDatabaseContext(Context, State);
		EnterRule(_localctx, 534, RULE_homeDatabase);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3278;
			Match(HOME);
			State = 3279;
			Match(DATABASE);
			State = 3280;
			symbolicAliasNameOrParameter();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetAuthClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTH() { return GetToken(CypherParser.AUTH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StringLiteralContext stringLiteral() {
			return GetRuleContext<StringLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CypherParser.LCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CypherParser.RCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROVIDER() { return GetToken(CypherParser.PROVIDER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] SET() { return GetTokens(CypherParser.SET); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET(int i) {
			return GetToken(CypherParser.SET, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UserAuthAttributeContext[] userAuthAttribute() {
			return GetRuleContexts<UserAuthAttributeContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public UserAuthAttributeContext userAuthAttribute(int i) {
			return GetRuleContext<UserAuthAttributeContext>(i);
		}
		public SetAuthClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setAuthClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetAuthClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SetAuthClauseContext setAuthClause() {
		SetAuthClauseContext _localctx = new SetAuthClauseContext(Context, State);
		EnterRule(_localctx, 536, RULE_setAuthClause);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3282;
			Match(AUTH);
			State = 3284;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PROVIDER) {
				{
				State = 3283;
				Match(PROVIDER);
				}
			}

			State = 3286;
			stringLiteral();
			State = 3287;
			Match(LCURLY);
			State = 3290;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 3288;
				Match(SET);
				{
				State = 3289;
				userAuthAttribute();
				}
				}
				}
				State = 3292;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==SET );
			State = 3294;
			Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UserAuthAttributeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(CypherParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StringOrParameterExpressionContext stringOrParameterExpression() {
			return GetRuleContext<StringOrParameterExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PasswordOnlyContext passwordOnly() {
			return GetRuleContext<PasswordOnlyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSWORD() { return GetToken(CypherParser.PASSWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PasswordChangeRequiredContext passwordChangeRequired() {
			return GetRuleContext<PasswordChangeRequiredContext>(0);
		}
		public UserAuthAttributeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_userAuthAttribute; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUserAuthAttribute(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UserAuthAttributeContext userAuthAttribute() {
		UserAuthAttributeContext _localctx = new UserAuthAttributeContext(Context, State);
		EnterRule(_localctx, 538, RULE_userAuthAttribute);
		try {
			State = 3301;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,377,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3296;
				Match(ID);
				State = 3297;
				stringOrParameterExpression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3298;
				passwordOnly();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3299;
				Match(PASSWORD);
				State = 3300;
				passwordChangeRequired();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowUsersContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(CypherParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USERS() { return GetToken(CypherParser.USERS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(CypherParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTH() { return GetToken(CypherParser.AUTH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ShowCommandYieldContext showCommandYield() {
			return GetRuleContext<ShowCommandYieldContext>(0);
		}
		public ShowUsersContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showUsers; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowUsers(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowUsersContext showUsers() {
		ShowUsersContext _localctx = new ShowUsersContext(Context, State);
		EnterRule(_localctx, 540, RULE_showUsers);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3303;
			_la = TokenStream.LA(1);
			if ( !(_la==USER || _la==USERS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3306;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WITH) {
				{
				State = 3304;
				Match(WITH);
				State = 3305;
				Match(AUTH);
				}
			}

			State = 3309;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE || _la==YIELD) {
				{
				State = 3308;
				showCommandYield();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowCurrentUserContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT() { return GetToken(CypherParser.CURRENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(CypherParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ShowCommandYieldContext showCommandYield() {
			return GetRuleContext<ShowCommandYieldContext>(0);
		}
		public ShowCurrentUserContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showCurrentUser; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowCurrentUser(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowCurrentUserContext showCurrentUser() {
		ShowCurrentUserContext _localctx = new ShowCurrentUserContext(Context, State);
		EnterRule(_localctx, 542, RULE_showCurrentUser);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3311;
			Match(CURRENT);
			State = 3312;
			Match(USER);
			State = 3314;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE || _la==YIELD) {
				{
				State = 3313;
				showCommandYield();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowSupportedPrivilegesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUPPORTED() { return GetToken(CypherParser.SUPPORTED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PrivilegeTokenContext privilegeToken() {
			return GetRuleContext<PrivilegeTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowCommandYieldContext showCommandYield() {
			return GetRuleContext<ShowCommandYieldContext>(0);
		}
		public ShowSupportedPrivilegesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showSupportedPrivileges; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowSupportedPrivileges(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowSupportedPrivilegesContext showSupportedPrivileges() {
		ShowSupportedPrivilegesContext _localctx = new ShowSupportedPrivilegesContext(Context, State);
		EnterRule(_localctx, 544, RULE_showSupportedPrivileges);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3316;
			Match(SUPPORTED);
			State = 3317;
			privilegeToken();
			State = 3319;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE || _la==YIELD) {
				{
				State = 3318;
				showCommandYield();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowPrivilegesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PrivilegeTokenContext privilegeToken() {
			return GetRuleContext<PrivilegeTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(CypherParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PrivilegeAsCommandContext privilegeAsCommand() {
			return GetRuleContext<PrivilegeAsCommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowCommandYieldContext showCommandYield() {
			return GetRuleContext<ShowCommandYieldContext>(0);
		}
		public ShowPrivilegesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showPrivileges; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowPrivileges(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowPrivilegesContext showPrivileges() {
		ShowPrivilegesContext _localctx = new ShowPrivilegesContext(Context, State);
		EnterRule(_localctx, 546, RULE_showPrivileges);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3322;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==ALL) {
				{
				State = 3321;
				Match(ALL);
				}
			}

			State = 3324;
			privilegeToken();
			State = 3326;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 3325;
				privilegeAsCommand();
				}
			}

			State = 3329;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE || _la==YIELD) {
				{
				State = 3328;
				showCommandYield();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowRolePrivilegesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RoleNamesContext roleNames() {
			return GetRuleContext<RoleNamesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PrivilegeTokenContext privilegeToken() {
			return GetRuleContext<PrivilegeTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLE() { return GetToken(CypherParser.ROLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLES() { return GetToken(CypherParser.ROLES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PrivilegeAsCommandContext privilegeAsCommand() {
			return GetRuleContext<PrivilegeAsCommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowCommandYieldContext showCommandYield() {
			return GetRuleContext<ShowCommandYieldContext>(0);
		}
		public ShowRolePrivilegesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showRolePrivileges; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowRolePrivileges(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowRolePrivilegesContext showRolePrivileges() {
		ShowRolePrivilegesContext _localctx = new ShowRolePrivilegesContext(Context, State);
		EnterRule(_localctx, 548, RULE_showRolePrivileges);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3331;
			_la = TokenStream.LA(1);
			if ( !(_la==ROLE || _la==ROLES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3332;
			roleNames();
			State = 3333;
			privilegeToken();
			State = 3335;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 3334;
				privilegeAsCommand();
				}
			}

			State = 3338;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE || _la==YIELD) {
				{
				State = 3337;
				showCommandYield();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowUserPrivilegesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PrivilegeTokenContext privilegeToken() {
			return GetRuleContext<PrivilegeTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(CypherParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USERS() { return GetToken(CypherParser.USERS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UserNamesContext userNames() {
			return GetRuleContext<UserNamesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PrivilegeAsCommandContext privilegeAsCommand() {
			return GetRuleContext<PrivilegeAsCommandContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowCommandYieldContext showCommandYield() {
			return GetRuleContext<ShowCommandYieldContext>(0);
		}
		public ShowUserPrivilegesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showUserPrivileges; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowUserPrivileges(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowUserPrivilegesContext showUserPrivileges() {
		ShowUserPrivilegesContext _localctx = new ShowUserPrivilegesContext(Context, State);
		EnterRule(_localctx, 550, RULE_showUserPrivileges);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3340;
			_la = TokenStream.LA(1);
			if ( !(_la==USER || _la==USERS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3342;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,387,Context) ) {
			case 1:
				{
				State = 3341;
				userNames();
				}
				break;
			}
			State = 3344;
			privilegeToken();
			State = 3346;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AS) {
				{
				State = 3345;
				privilegeAsCommand();
				}
			}

			State = 3349;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE || _la==YIELD) {
				{
				State = 3348;
				showCommandYield();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrivilegeAsCommandContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(CypherParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMAND() { return GetToken(CypherParser.COMMAND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMANDS() { return GetToken(CypherParser.COMMANDS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REVOKE() { return GetToken(CypherParser.REVOKE, 0); }
		public PrivilegeAsCommandContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_privilegeAsCommand; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrivilegeAsCommand(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrivilegeAsCommandContext privilegeAsCommand() {
		PrivilegeAsCommandContext _localctx = new PrivilegeAsCommandContext(Context, State);
		EnterRule(_localctx, 552, RULE_privilegeAsCommand);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3351;
			Match(AS);
			State = 3353;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==REVOKE) {
				{
				State = 3352;
				Match(REVOKE);
				}
			}

			State = 3355;
			_la = TokenStream.LA(1);
			if ( !(_la==COMMAND || _la==COMMANDS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrivilegeTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIVILEGE() { return GetToken(CypherParser.PRIVILEGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIVILEGES() { return GetToken(CypherParser.PRIVILEGES, 0); }
		public PrivilegeTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_privilegeToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrivilegeToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrivilegeTokenContext privilegeToken() {
		PrivilegeTokenContext _localctx = new PrivilegeTokenContext(Context, State);
		EnterRule(_localctx, 554, RULE_privilegeToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3357;
			_la = TokenStream.LA(1);
			if ( !(_la==PRIVILEGE || _la==PRIVILEGES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrivilegeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public AllPrivilegeContext allPrivilege() {
			return GetRuleContext<AllPrivilegeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreatePrivilegeContext createPrivilege() {
			return GetRuleContext<CreatePrivilegeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DatabasePrivilegeContext databasePrivilege() {
			return GetRuleContext<DatabasePrivilegeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DbmsPrivilegeContext dbmsPrivilege() {
			return GetRuleContext<DbmsPrivilegeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DropPrivilegeContext dropPrivilege() {
			return GetRuleContext<DropPrivilegeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LoadPrivilegeContext loadPrivilege() {
			return GetRuleContext<LoadPrivilegeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public QualifiedGraphPrivilegesContext qualifiedGraphPrivileges() {
			return GetRuleContext<QualifiedGraphPrivilegesContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RemovePrivilegeContext removePrivilege() {
			return GetRuleContext<RemovePrivilegeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SetPrivilegeContext setPrivilege() {
			return GetRuleContext<SetPrivilegeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowPrivilegeContext showPrivilege() {
			return GetRuleContext<ShowPrivilegeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WritePrivilegeContext writePrivilege() {
			return GetRuleContext<WritePrivilegeContext>(0);
		}
		public PrivilegeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_privilege; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrivilege(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrivilegeContext privilege() {
		PrivilegeContext _localctx = new PrivilegeContext(Context, State);
		EnterRule(_localctx, 556, RULE_privilege);
		try {
			State = 3370;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,391,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3359;
				allPrivilege();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3360;
				createPrivilege();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3361;
				databasePrivilege();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3362;
				dbmsPrivilege();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3363;
				dropPrivilege();
				}
				break;
			case 6:
				EnterOuterAlt(_localctx, 6);
				{
				State = 3364;
				loadPrivilege();
				}
				break;
			case 7:
				EnterOuterAlt(_localctx, 7);
				{
				State = 3365;
				qualifiedGraphPrivileges();
				}
				break;
			case 8:
				EnterOuterAlt(_localctx, 8);
				{
				State = 3366;
				removePrivilege();
				}
				break;
			case 9:
				EnterOuterAlt(_localctx, 9);
				{
				State = 3367;
				setPrivilege();
				}
				break;
			case 10:
				EnterOuterAlt(_localctx, 10);
				{
				State = 3368;
				showPrivilege();
				}
				break;
			case 11:
				EnterOuterAlt(_localctx, 11);
				{
				State = 3369;
				writePrivilege();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AllPrivilegeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(CypherParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(CypherParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AllPrivilegeTargetContext allPrivilegeTarget() {
			return GetRuleContext<AllPrivilegeTargetContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AllPrivilegeTypeContext allPrivilegeType() {
			return GetRuleContext<AllPrivilegeTypeContext>(0);
		}
		public AllPrivilegeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_allPrivilege; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAllPrivilege(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AllPrivilegeContext allPrivilege() {
		AllPrivilegeContext _localctx = new AllPrivilegeContext(Context, State);
		EnterRule(_localctx, 558, RULE_allPrivilege);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3372;
			Match(ALL);
			State = 3374;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (DATABASE - 66)) | (1L << (DBMS - 66)) | (1L << (GRAPH - 66)))) != 0) || _la==PRIVILEGES) {
				{
				State = 3373;
				allPrivilegeType();
				}
			}

			State = 3376;
			Match(ON);
			State = 3377;
			allPrivilegeTarget();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AllPrivilegeTypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIVILEGES() { return GetToken(CypherParser.PRIVILEGES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GRAPH() { return GetToken(CypherParser.GRAPH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DBMS() { return GetToken(CypherParser.DBMS, 0); }
		public AllPrivilegeTypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_allPrivilegeType; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAllPrivilegeType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AllPrivilegeTypeContext allPrivilegeType() {
		AllPrivilegeTypeContext _localctx = new AllPrivilegeTypeContext(Context, State);
		EnterRule(_localctx, 560, RULE_allPrivilegeType);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3380;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (DATABASE - 66)) | (1L << (DBMS - 66)) | (1L << (GRAPH - 66)))) != 0)) {
				{
				State = 3379;
				_la = TokenStream.LA(1);
				if ( !(((((_la - 66)) & ~0x3f) == 0 && ((1L << (_la - 66)) & ((1L << (DATABASE - 66)) | (1L << (DBMS - 66)) | (1L << (GRAPH - 66)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3382;
			Match(PRIVILEGES);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AllPrivilegeTargetContext : ParserRuleContext {
		public AllPrivilegeTargetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_allPrivilegeTarget; } }
	 
		public AllPrivilegeTargetContext() { }
		public virtual void CopyFrom(AllPrivilegeTargetContext context) {
			base.CopyFrom(context);
		}
	}
	public partial class DefaultTargetContext : AllPrivilegeTargetContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HOME() { return GetToken(CypherParser.HOME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GRAPH() { return GetToken(CypherParser.GRAPH, 0); }
		public DefaultTargetContext(AllPrivilegeTargetContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefaultTarget(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DatabaseVariableTargetContext : AllPrivilegeTargetContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASES() { return GetToken(CypherParser.DATABASES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMES() { return GetToken(CypherParser.TIMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicAliasNameListContext symbolicAliasNameList() {
			return GetRuleContext<SymbolicAliasNameListContext>(0);
		}
		public DatabaseVariableTargetContext(AllPrivilegeTargetContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDatabaseVariableTarget(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class GraphVariableTargetContext : AllPrivilegeTargetContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GRAPH() { return GetToken(CypherParser.GRAPH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GRAPHS() { return GetToken(CypherParser.GRAPHS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMES() { return GetToken(CypherParser.TIMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicAliasNameListContext symbolicAliasNameList() {
			return GetRuleContext<SymbolicAliasNameListContext>(0);
		}
		public GraphVariableTargetContext(AllPrivilegeTargetContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGraphVariableTarget(this);
			else return visitor.VisitChildren(this);
		}
	}
	public partial class DBMSTargetContext : AllPrivilegeTargetContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DBMS() { return GetToken(CypherParser.DBMS, 0); }
		public DBMSTargetContext(AllPrivilegeTargetContext context) { CopyFrom(context); }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDBMSTarget(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AllPrivilegeTargetContext allPrivilegeTarget() {
		AllPrivilegeTargetContext _localctx = new AllPrivilegeTargetContext(Context, State);
		EnterRule(_localctx, 562, RULE_allPrivilegeTarget);
		int _la;
		try {
			State = 3397;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case HOME:
				_localctx = new DefaultTargetContext(_localctx);
				EnterOuterAlt(_localctx, 1);
				{
				State = 3384;
				Match(HOME);
				State = 3385;
				_la = TokenStream.LA(1);
				if ( !(_la==DATABASE || _la==GRAPH) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case DATABASE:
			case DATABASES:
				_localctx = new DatabaseVariableTargetContext(_localctx);
				EnterOuterAlt(_localctx, 2);
				{
				State = 3386;
				_la = TokenStream.LA(1);
				if ( !(_la==DATABASE || _la==DATABASES) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3389;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case TIMES:
					{
					State = 3387;
					Match(TIMES);
					}
					break;
				case ESCAPED_SYMBOLIC_NAME:
				case ACCESS:
				case ACTIVE:
				case ADD:
				case ADMIN:
				case ADMINISTRATOR:
				case ALIAS:
				case ALIASES:
				case ALL_SHORTEST_PATHS:
				case ALL:
				case ALLREDUCE:
				case ALTER:
				case AND:
				case ANY:
				case ARRAY:
				case AS:
				case ASC:
				case ASCENDING:
				case ASSIGN:
				case AT:
				case AUTH:
				case BINDINGS:
				case BOOL:
				case BOOLEAN:
				case BOOSTED:
				case BOTH:
				case BREAK:
				case BUILT:
				case BY:
				case CALL:
				case CASCADE:
				case CASE:
				case CHANGE:
				case CIDR:
				case COLLECT:
				case COMMAND:
				case COMMANDS:
				case COMPOSITE:
				case CONCURRENT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONTAINS:
				case COPY:
				case CONTINUE:
				case COSINE:
				case COUNT:
				case CREATE:
				case CREDENTIAL:
				case CSV:
				case CURRENT:
				case CYPHER:
				case DATA:
				case DATABASE:
				case DATABASES:
				case DATE:
				case DATETIME:
				case DBMS:
				case DEALLOCATE:
				case DEFAULT:
				case DEFINED:
				case DELETE:
				case DENY:
				case DESC:
				case DESCENDING:
				case DESTROY:
				case DETACH:
				case DIFFERENT:
				case DOLLAR:
				case DISTINCT:
				case DOT_METRIC:
				case DRIVER:
				case DROP:
				case DRYRUN:
				case DUMP:
				case DURATION:
				case EACH:
				case EDGE:
				case ENABLE:
				case ELEMENT:
				case ELEMENTS:
				case ELSE:
				case ENCRYPTED:
				case EUCLIDEAN:
				case EUCLIDEAN_SQUARED:
				case END:
				case ENDS:
				case EXECUTABLE:
				case EXECUTE:
				case EXIST:
				case EXISTENCE:
				case EXISTS:
				case ERROR:
				case FAIL:
				case FALSE:
				case FIELDTERMINATOR:
				case FILTER:
				case FINISH:
				case FLOAT:
				case FLOAT64:
				case FLOAT32:
				case FOR:
				case FOREACH:
				case FORWARDING:
				case FROM:
				case FULLTEXT:
				case FUNCTION:
				case FUNCTIONS:
				case GRANT:
				case GRAPH:
				case GRAPHS:
				case GROUP:
				case GROUPS:
				case HAMMING:
				case HEADERS:
				case HOME:
				case ID:
				case IF:
				case IMPERSONATE:
				case IMMUTABLE:
				case IN:
				case INDEX:
				case INDEXES:
				case INF:
				case INFINITY:
				case INSERT:
				case INT:
				case INT64:
				case INT32:
				case INT16:
				case INT8:
				case INTEGER:
				case INTEGER64:
				case INTEGER32:
				case INTEGER16:
				case INTEGER8:
				case IS:
				case JOIN:
				case KEY:
				case LABEL:
				case LABELS:
				case LANGUAGE:
				case LEADING:
				case LET:
				case LIMITROWS:
				case LIST:
				case LOAD:
				case LOCAL:
				case LOOKUP:
				case MANAGEMENT:
				case MANHATTAN:
				case MAP:
				case MATCH:
				case MERGE:
				case IMPLIES:
				case NAME:
				case NAMES:
				case NAN:
				case NFC:
				case NFD:
				case NFKC:
				case NFKD:
				case NEW:
				case NEXT:
				case NODE:
				case NODETACH:
				case NODES:
				case NONE:
				case NORMALIZE:
				case NORMALIZED:
				case NOT:
				case NOTHING:
				case NOWAIT:
				case NULL:
				case OF:
				case OFFSET:
				case OIDC:
				case ON:
				case ONLY:
				case OPTIONAL:
				case OPTIONS:
				case OPTION:
				case OR:
				case ORDER:
				case PASSWORD:
				case PASSWORDS:
				case PATH:
				case PATHS:
				case PLAINTEXT:
				case POINT:
				case POPULATED:
				case PRIMARY:
				case PRIMARIES:
				case PRIVILEGE:
				case PRIVILEGES:
				case PROCEDURE:
				case PROCEDURES:
				case PROPERTIES:
				case PROPERTY:
				case PROVIDER:
				case PROVIDERS:
				case RANGE:
				case READ:
				case REALLOCATE:
				case REDUCE:
				case RENAME:
				case REL:
				case RELATIONSHIP:
				case RELATIONSHIPS:
				case REMOVE:
				case REPEATABLE:
				case REPLACE:
				case REPLICA:
				case REPLICAS:
				case REPORT:
				case REQUIRE:
				case REQUIRED:
				case RESTRICT:
				case RETRY:
				case RETURN:
				case REVOKE:
				case ROLE:
				case ROLES:
				case ROW:
				case ROWS:
				case SCAN:
				case SEC:
				case SECOND:
				case SECONDARY:
				case SECONDARIES:
				case SECONDS:
				case SEEK:
				case SERVER:
				case SERVERS:
				case SET:
				case SETTING:
				case SETTINGS:
				case SHARD:
				case SHARDS:
				case SHORTEST_PATH:
				case SHORTEST:
				case SHOW:
				case SIGNED:
				case SINGLE:
				case SKIPROWS:
				case START:
				case STARTS:
				case STATUS:
				case STOP:
				case STRING:
				case SUPPORTED:
				case SUSPENDED:
				case TARGET:
				case TERMINATE:
				case TEXT:
				case THEN:
				case TIME:
				case TIMESTAMP:
				case TIMEZONE:
				case TO:
				case TOPOLOGY:
				case TRAILING:
				case TRANSACTION:
				case TRANSACTIONS:
				case TRAVERSE:
				case TRIM:
				case TRUE:
				case TYPE:
				case TYPED:
				case TYPES:
				case UNION:
				case UNIQUE:
				case UNIQUENESS:
				case UNWIND:
				case URL:
				case USE:
				case USER:
				case USERS:
				case USING:
				case VALUE:
				case VARCHAR:
				case VECTOR:
				case VECTOR_DISTANCE:
				case VECTOR_NORM:
				case VERTEX:
				case WAIT:
				case WHEN:
				case WHERE:
				case WITH:
				case WITHOUT:
				case WRITE:
				case XOR:
				case YIELD:
				case ZONE:
				case ZONED:
				case IDENTIFIER:
					{
					State = 3388;
					symbolicAliasNameList();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case GRAPH:
			case GRAPHS:
				_localctx = new GraphVariableTargetContext(_localctx);
				EnterOuterAlt(_localctx, 3);
				{
				State = 3391;
				_la = TokenStream.LA(1);
				if ( !(_la==GRAPH || _la==GRAPHS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3394;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case TIMES:
					{
					State = 3392;
					Match(TIMES);
					}
					break;
				case ESCAPED_SYMBOLIC_NAME:
				case ACCESS:
				case ACTIVE:
				case ADD:
				case ADMIN:
				case ADMINISTRATOR:
				case ALIAS:
				case ALIASES:
				case ALL_SHORTEST_PATHS:
				case ALL:
				case ALLREDUCE:
				case ALTER:
				case AND:
				case ANY:
				case ARRAY:
				case AS:
				case ASC:
				case ASCENDING:
				case ASSIGN:
				case AT:
				case AUTH:
				case BINDINGS:
				case BOOL:
				case BOOLEAN:
				case BOOSTED:
				case BOTH:
				case BREAK:
				case BUILT:
				case BY:
				case CALL:
				case CASCADE:
				case CASE:
				case CHANGE:
				case CIDR:
				case COLLECT:
				case COMMAND:
				case COMMANDS:
				case COMPOSITE:
				case CONCURRENT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONTAINS:
				case COPY:
				case CONTINUE:
				case COSINE:
				case COUNT:
				case CREATE:
				case CREDENTIAL:
				case CSV:
				case CURRENT:
				case CYPHER:
				case DATA:
				case DATABASE:
				case DATABASES:
				case DATE:
				case DATETIME:
				case DBMS:
				case DEALLOCATE:
				case DEFAULT:
				case DEFINED:
				case DELETE:
				case DENY:
				case DESC:
				case DESCENDING:
				case DESTROY:
				case DETACH:
				case DIFFERENT:
				case DOLLAR:
				case DISTINCT:
				case DOT_METRIC:
				case DRIVER:
				case DROP:
				case DRYRUN:
				case DUMP:
				case DURATION:
				case EACH:
				case EDGE:
				case ENABLE:
				case ELEMENT:
				case ELEMENTS:
				case ELSE:
				case ENCRYPTED:
				case EUCLIDEAN:
				case EUCLIDEAN_SQUARED:
				case END:
				case ENDS:
				case EXECUTABLE:
				case EXECUTE:
				case EXIST:
				case EXISTENCE:
				case EXISTS:
				case ERROR:
				case FAIL:
				case FALSE:
				case FIELDTERMINATOR:
				case FILTER:
				case FINISH:
				case FLOAT:
				case FLOAT64:
				case FLOAT32:
				case FOR:
				case FOREACH:
				case FORWARDING:
				case FROM:
				case FULLTEXT:
				case FUNCTION:
				case FUNCTIONS:
				case GRANT:
				case GRAPH:
				case GRAPHS:
				case GROUP:
				case GROUPS:
				case HAMMING:
				case HEADERS:
				case HOME:
				case ID:
				case IF:
				case IMPERSONATE:
				case IMMUTABLE:
				case IN:
				case INDEX:
				case INDEXES:
				case INF:
				case INFINITY:
				case INSERT:
				case INT:
				case INT64:
				case INT32:
				case INT16:
				case INT8:
				case INTEGER:
				case INTEGER64:
				case INTEGER32:
				case INTEGER16:
				case INTEGER8:
				case IS:
				case JOIN:
				case KEY:
				case LABEL:
				case LABELS:
				case LANGUAGE:
				case LEADING:
				case LET:
				case LIMITROWS:
				case LIST:
				case LOAD:
				case LOCAL:
				case LOOKUP:
				case MANAGEMENT:
				case MANHATTAN:
				case MAP:
				case MATCH:
				case MERGE:
				case IMPLIES:
				case NAME:
				case NAMES:
				case NAN:
				case NFC:
				case NFD:
				case NFKC:
				case NFKD:
				case NEW:
				case NEXT:
				case NODE:
				case NODETACH:
				case NODES:
				case NONE:
				case NORMALIZE:
				case NORMALIZED:
				case NOT:
				case NOTHING:
				case NOWAIT:
				case NULL:
				case OF:
				case OFFSET:
				case OIDC:
				case ON:
				case ONLY:
				case OPTIONAL:
				case OPTIONS:
				case OPTION:
				case OR:
				case ORDER:
				case PASSWORD:
				case PASSWORDS:
				case PATH:
				case PATHS:
				case PLAINTEXT:
				case POINT:
				case POPULATED:
				case PRIMARY:
				case PRIMARIES:
				case PRIVILEGE:
				case PRIVILEGES:
				case PROCEDURE:
				case PROCEDURES:
				case PROPERTIES:
				case PROPERTY:
				case PROVIDER:
				case PROVIDERS:
				case RANGE:
				case READ:
				case REALLOCATE:
				case REDUCE:
				case RENAME:
				case REL:
				case RELATIONSHIP:
				case RELATIONSHIPS:
				case REMOVE:
				case REPEATABLE:
				case REPLACE:
				case REPLICA:
				case REPLICAS:
				case REPORT:
				case REQUIRE:
				case REQUIRED:
				case RESTRICT:
				case RETRY:
				case RETURN:
				case REVOKE:
				case ROLE:
				case ROLES:
				case ROW:
				case ROWS:
				case SCAN:
				case SEC:
				case SECOND:
				case SECONDARY:
				case SECONDARIES:
				case SECONDS:
				case SEEK:
				case SERVER:
				case SERVERS:
				case SET:
				case SETTING:
				case SETTINGS:
				case SHARD:
				case SHARDS:
				case SHORTEST_PATH:
				case SHORTEST:
				case SHOW:
				case SIGNED:
				case SINGLE:
				case SKIPROWS:
				case START:
				case STARTS:
				case STATUS:
				case STOP:
				case STRING:
				case SUPPORTED:
				case SUSPENDED:
				case TARGET:
				case TERMINATE:
				case TEXT:
				case THEN:
				case TIME:
				case TIMESTAMP:
				case TIMEZONE:
				case TO:
				case TOPOLOGY:
				case TRAILING:
				case TRANSACTION:
				case TRANSACTIONS:
				case TRAVERSE:
				case TRIM:
				case TRUE:
				case TYPE:
				case TYPED:
				case TYPES:
				case UNION:
				case UNIQUE:
				case UNIQUENESS:
				case UNWIND:
				case URL:
				case USE:
				case USER:
				case USERS:
				case USING:
				case VALUE:
				case VARCHAR:
				case VECTOR:
				case VECTOR_DISTANCE:
				case VECTOR_NORM:
				case VERTEX:
				case WAIT:
				case WHEN:
				case WHERE:
				case WITH:
				case WITHOUT:
				case WRITE:
				case XOR:
				case YIELD:
				case ZONE:
				case ZONED:
				case IDENTIFIER:
					{
					State = 3393;
					symbolicAliasNameList();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case DBMS:
				_localctx = new DBMSTargetContext(_localctx);
				EnterOuterAlt(_localctx, 4);
				{
				State = 3396;
				Match(DBMS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreatePrivilegeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CREATE() { return GetToken(CypherParser.CREATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CreatePrivilegeForDatabaseContext createPrivilegeForDatabase() {
			return GetRuleContext<CreatePrivilegeForDatabaseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(CypherParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DatabaseScopeContext databaseScope() {
			return GetRuleContext<DatabaseScopeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ActionForDBMSContext actionForDBMS() {
			return GetRuleContext<ActionForDBMSContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DBMS() { return GetToken(CypherParser.DBMS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GraphScopeContext graphScope() {
			return GetRuleContext<GraphScopeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GraphQualifierContext graphQualifier() {
			return GetRuleContext<GraphQualifierContext>(0);
		}
		public CreatePrivilegeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createPrivilege; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreatePrivilege(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreatePrivilegeContext createPrivilege() {
		CreatePrivilegeContext _localctx = new CreatePrivilegeContext(Context, State);
		EnterRule(_localctx, 564, RULE_createPrivilege);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3399;
			Match(CREATE);
			State = 3412;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CONSTRAINT:
			case CONSTRAINTS:
			case INDEX:
			case INDEXES:
			case NEW:
				{
				State = 3400;
				createPrivilegeForDatabase();
				State = 3401;
				Match(ON);
				State = 3402;
				databaseScope();
				}
				break;
			case ALIAS:
			case COMPOSITE:
			case DATABASE:
			case ROLE:
			case USER:
				{
				State = 3404;
				actionForDBMS();
				State = 3405;
				Match(ON);
				State = 3406;
				Match(DBMS);
				}
				break;
			case ON:
				{
				State = 3408;
				Match(ON);
				State = 3409;
				graphScope();
				State = 3410;
				graphQualifier();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreatePrivilegeForDatabaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public IndexTokenContext indexToken() {
			return GetRuleContext<IndexTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintTokenContext constraintToken() {
			return GetRuleContext<ConstraintTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateNodePrivilegeTokenContext createNodePrivilegeToken() {
			return GetRuleContext<CreateNodePrivilegeTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreateRelPrivilegeTokenContext createRelPrivilegeToken() {
			return GetRuleContext<CreateRelPrivilegeTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CreatePropertyPrivilegeTokenContext createPropertyPrivilegeToken() {
			return GetRuleContext<CreatePropertyPrivilegeTokenContext>(0);
		}
		public CreatePrivilegeForDatabaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createPrivilegeForDatabase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreatePrivilegeForDatabase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreatePrivilegeForDatabaseContext createPrivilegeForDatabase() {
		CreatePrivilegeForDatabaseContext _localctx = new CreatePrivilegeForDatabaseContext(Context, State);
		EnterRule(_localctx, 566, RULE_createPrivilegeForDatabase);
		try {
			State = 3419;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,398,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3414;
				indexToken();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3415;
				constraintToken();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3416;
				createNodePrivilegeToken();
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3417;
				createRelPrivilegeToken();
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 3418;
				createPropertyPrivilegeToken();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateNodePrivilegeTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEW() { return GetToken(CypherParser.NEW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LABEL() { return GetToken(CypherParser.LABEL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LABELS() { return GetToken(CypherParser.LABELS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NODE() { return GetToken(CypherParser.NODE, 0); }
		public CreateNodePrivilegeTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createNodePrivilegeToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateNodePrivilegeToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateNodePrivilegeTokenContext createNodePrivilegeToken() {
		CreateNodePrivilegeTokenContext _localctx = new CreateNodePrivilegeTokenContext(Context, State);
		EnterRule(_localctx, 568, RULE_createNodePrivilegeToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3421;
			Match(NEW);
			State = 3423;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NODE) {
				{
				State = 3422;
				Match(NODE);
				}
			}

			State = 3425;
			_la = TokenStream.LA(1);
			if ( !(_la==LABEL || _la==LABELS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateRelPrivilegeTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEW() { return GetToken(CypherParser.NEW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(CypherParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPES() { return GetToken(CypherParser.TYPES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELATIONSHIP() { return GetToken(CypherParser.RELATIONSHIP, 0); }
		public CreateRelPrivilegeTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createRelPrivilegeToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateRelPrivilegeToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateRelPrivilegeTokenContext createRelPrivilegeToken() {
		CreateRelPrivilegeTokenContext _localctx = new CreateRelPrivilegeTokenContext(Context, State);
		EnterRule(_localctx, 570, RULE_createRelPrivilegeToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3427;
			Match(NEW);
			State = 3429;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==RELATIONSHIP) {
				{
				State = 3428;
				Match(RELATIONSHIP);
				}
			}

			State = 3431;
			_la = TokenStream.LA(1);
			if ( !(_la==TYPE || _la==TYPES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreatePropertyPrivilegeTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEW() { return GetToken(CypherParser.NEW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NAME() { return GetToken(CypherParser.NAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NAMES() { return GetToken(CypherParser.NAMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROPERTY() { return GetToken(CypherParser.PROPERTY, 0); }
		public CreatePropertyPrivilegeTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createPropertyPrivilegeToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreatePropertyPrivilegeToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreatePropertyPrivilegeTokenContext createPropertyPrivilegeToken() {
		CreatePropertyPrivilegeTokenContext _localctx = new CreatePropertyPrivilegeTokenContext(Context, State);
		EnterRule(_localctx, 572, RULE_createPropertyPrivilegeToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3433;
			Match(NEW);
			State = 3435;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PROPERTY) {
				{
				State = 3434;
				Match(PROPERTY);
				}
			}

			State = 3437;
			_la = TokenStream.LA(1);
			if ( !(_la==NAME || _la==NAMES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ActionForDBMSContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALIAS() { return GetToken(CypherParser.ALIAS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPOSITE() { return GetToken(CypherParser.COMPOSITE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLE() { return GetToken(CypherParser.ROLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(CypherParser.USER, 0); }
		public ActionForDBMSContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_actionForDBMS; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitActionForDBMS(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ActionForDBMSContext actionForDBMS() {
		ActionForDBMSContext _localctx = new ActionForDBMSContext(Context, State);
		EnterRule(_localctx, 574, RULE_actionForDBMS);
		int _la;
		try {
			State = 3446;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALIAS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3439;
				Match(ALIAS);
				}
				break;
			case COMPOSITE:
			case DATABASE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3441;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMPOSITE) {
					{
					State = 3440;
					Match(COMPOSITE);
					}
				}

				State = 3443;
				Match(DATABASE);
				}
				break;
			case ROLE:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3444;
				Match(ROLE);
				}
				break;
			case USER:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3445;
				Match(USER);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropPrivilegeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DROP() { return GetToken(CypherParser.DROP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(CypherParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DatabaseScopeContext databaseScope() {
			return GetRuleContext<DatabaseScopeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ActionForDBMSContext actionForDBMS() {
			return GetRuleContext<ActionForDBMSContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DBMS() { return GetToken(CypherParser.DBMS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IndexTokenContext indexToken() {
			return GetRuleContext<IndexTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintTokenContext constraintToken() {
			return GetRuleContext<ConstraintTokenContext>(0);
		}
		public DropPrivilegeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropPrivilege; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDropPrivilege(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DropPrivilegeContext dropPrivilege() {
		DropPrivilegeContext _localctx = new DropPrivilegeContext(Context, State);
		EnterRule(_localctx, 576, RULE_dropPrivilege);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3448;
			Match(DROP);
			State = 3460;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CONSTRAINT:
			case CONSTRAINTS:
			case INDEX:
			case INDEXES:
				{
				State = 3451;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case INDEX:
				case INDEXES:
					{
					State = 3449;
					indexToken();
					}
					break;
				case CONSTRAINT:
				case CONSTRAINTS:
					{
					State = 3450;
					constraintToken();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 3453;
				Match(ON);
				State = 3454;
				databaseScope();
				}
				break;
			case ALIAS:
			case COMPOSITE:
			case DATABASE:
			case ROLE:
			case USER:
				{
				State = 3456;
				actionForDBMS();
				State = 3457;
				Match(ON);
				State = 3458;
				Match(DBMS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LoadPrivilegeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOAD() { return GetToken(CypherParser.LOAD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(CypherParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StringOrParameterContext stringOrParameter() {
			return GetRuleContext<StringOrParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(CypherParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATA() { return GetToken(CypherParser.DATA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode URL() { return GetToken(CypherParser.URL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CIDR() { return GetToken(CypherParser.CIDR, 0); }
		public LoadPrivilegeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_loadPrivilege; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLoadPrivilege(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LoadPrivilegeContext loadPrivilege() {
		LoadPrivilegeContext _localctx = new LoadPrivilegeContext(Context, State);
		EnterRule(_localctx, 578, RULE_loadPrivilege);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3462;
			Match(LOAD);
			State = 3463;
			Match(ON);
			State = 3468;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CIDR:
			case URL:
				{
				State = 3464;
				_la = TokenStream.LA(1);
				if ( !(_la==CIDR || _la==URL) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3465;
				stringOrParameter();
				}
				break;
			case ALL:
				{
				State = 3466;
				Match(ALL);
				State = 3467;
				Match(DATA);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowPrivilegeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHOW() { return GetToken(CypherParser.SHOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(CypherParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DatabaseScopeContext databaseScope() {
			return GetRuleContext<DatabaseScopeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DBMS() { return GetToken(CypherParser.DBMS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IndexTokenContext indexToken() {
			return GetRuleContext<IndexTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintTokenContext constraintToken() {
			return GetRuleContext<ConstraintTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TransactionTokenContext transactionToken() {
			return GetRuleContext<TransactionTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALIAS() { return GetToken(CypherParser.ALIAS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIVILEGE() { return GetToken(CypherParser.PRIVILEGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLE() { return GetToken(CypherParser.ROLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERVER() { return GetToken(CypherParser.SERVER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERVERS() { return GetToken(CypherParser.SERVERS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SettingTokenContext settingToken() {
			return GetRuleContext<SettingTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SettingQualifierContext settingQualifier() {
			return GetRuleContext<SettingQualifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(CypherParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UserQualifierContext userQualifier() {
			return GetRuleContext<UserQualifierContext>(0);
		}
		public ShowPrivilegeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showPrivilege; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowPrivilege(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowPrivilegeContext showPrivilege() {
		ShowPrivilegeContext _localctx = new ShowPrivilegeContext(Context, State);
		EnterRule(_localctx, 580, RULE_showPrivilege);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3470;
			Match(SHOW);
			State = 3495;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case CONSTRAINT:
			case CONSTRAINTS:
			case INDEX:
			case INDEXES:
			case TRANSACTION:
			case TRANSACTIONS:
				{
				State = 3477;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case INDEX:
				case INDEXES:
					{
					State = 3471;
					indexToken();
					}
					break;
				case CONSTRAINT:
				case CONSTRAINTS:
					{
					State = 3472;
					constraintToken();
					}
					break;
				case TRANSACTION:
				case TRANSACTIONS:
					{
					State = 3473;
					transactionToken();
					State = 3475;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==LPAREN) {
						{
						State = 3474;
						userQualifier();
						}
					}

					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 3479;
				Match(ON);
				State = 3480;
				databaseScope();
				}
				break;
			case ALIAS:
			case PRIVILEGE:
			case ROLE:
			case SERVER:
			case SERVERS:
			case SETTING:
			case SETTINGS:
			case USER:
				{
				State = 3491;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ALIAS:
					{
					State = 3482;
					Match(ALIAS);
					}
					break;
				case PRIVILEGE:
					{
					State = 3483;
					Match(PRIVILEGE);
					}
					break;
				case ROLE:
					{
					State = 3484;
					Match(ROLE);
					}
					break;
				case SERVER:
					{
					State = 3485;
					Match(SERVER);
					}
					break;
				case SERVERS:
					{
					State = 3486;
					Match(SERVERS);
					}
					break;
				case SETTING:
				case SETTINGS:
					{
					State = 3487;
					settingToken();
					State = 3488;
					settingQualifier();
					}
					break;
				case USER:
					{
					State = 3490;
					Match(USER);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 3493;
				Match(ON);
				State = 3494;
				Match(DBMS);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SetPrivilegeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(CypherParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(CypherParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DBMS() { return GetToken(CypherParser.DBMS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DatabaseScopeContext databaseScope() {
			return GetRuleContext<DatabaseScopeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LABEL() { return GetToken(CypherParser.LABEL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LabelsResourceContext labelsResource() {
			return GetRuleContext<LabelsResourceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GraphScopeContext graphScope() {
			return GetRuleContext<GraphScopeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROPERTY() { return GetToken(CypherParser.PROPERTY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropertiesResourceContext propertiesResource() {
			return GetRuleContext<PropertiesResourceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GraphQualifierContext graphQualifier() {
			return GetRuleContext<GraphQualifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PasswordTokenContext passwordToken() {
			return GetRuleContext<PasswordTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(CypherParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTH() { return GetToken(CypherParser.AUTH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ACCESS() { return GetToken(CypherParser.ACCESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(CypherParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LANGUAGE() { return GetToken(CypherParser.LANGUAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATUS() { return GetToken(CypherParser.STATUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HOME() { return GetToken(CypherParser.HOME, 0); }
		public SetPrivilegeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_setPrivilege; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSetPrivilege(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SetPrivilegeContext setPrivilege() {
		SetPrivilegeContext _localctx = new SetPrivilegeContext(Context, State);
		EnterRule(_localctx, 582, RULE_setPrivilege);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3497;
			Match(SET);
			State = 3535;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,415,Context) ) {
			case 1:
				{
				State = 3512;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case PASSWORD:
				case PASSWORDS:
					{
					State = 3498;
					passwordToken();
					}
					break;
				case USER:
					{
					State = 3499;
					Match(USER);
					State = 3503;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case STATUS:
						{
						State = 3500;
						Match(STATUS);
						}
						break;
					case HOME:
						{
						State = 3501;
						Match(HOME);
						State = 3502;
						Match(DATABASE);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					break;
				case DATABASE:
					{
					State = 3505;
					Match(DATABASE);
					State = 3509;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case ACCESS:
						{
						State = 3506;
						Match(ACCESS);
						}
						break;
					case DEFAULT:
						{
						State = 3507;
						Match(DEFAULT);
						State = 3508;
						Match(LANGUAGE);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					break;
				case AUTH:
					{
					State = 3511;
					Match(AUTH);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 3514;
				Match(ON);
				State = 3515;
				Match(DBMS);
				}
				break;
			case 2:
				{
				State = 3516;
				Match(DATABASE);
				State = 3520;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ACCESS:
					{
					State = 3517;
					Match(ACCESS);
					}
					break;
				case DEFAULT:
					{
					State = 3518;
					Match(DEFAULT);
					State = 3519;
					Match(LANGUAGE);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 3522;
				Match(ON);
				State = 3523;
				databaseScope();
				}
				break;
			case 3:
				{
				State = 3524;
				Match(LABEL);
				State = 3525;
				labelsResource();
				State = 3526;
				Match(ON);
				State = 3527;
				graphScope();
				}
				break;
			case 4:
				{
				State = 3529;
				Match(PROPERTY);
				State = 3530;
				propertiesResource();
				State = 3531;
				Match(ON);
				State = 3532;
				graphScope();
				State = 3533;
				graphQualifier();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PasswordTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSWORD() { return GetToken(CypherParser.PASSWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSWORDS() { return GetToken(CypherParser.PASSWORDS, 0); }
		public PasswordTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_passwordToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPasswordToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PasswordTokenContext passwordToken() {
		PasswordTokenContext _localctx = new PasswordTokenContext(Context, State);
		EnterRule(_localctx, 584, RULE_passwordToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3537;
			_la = TokenStream.LA(1);
			if ( !(_la==PASSWORD || _la==PASSWORDS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RemovePrivilegeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REMOVE() { return GetToken(CypherParser.REMOVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(CypherParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DBMS() { return GetToken(CypherParser.DBMS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LABEL() { return GetToken(CypherParser.LABEL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public LabelsResourceContext labelsResource() {
			return GetRuleContext<LabelsResourceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GraphScopeContext graphScope() {
			return GetRuleContext<GraphScopeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIVILEGE() { return GetToken(CypherParser.PRIVILEGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLE() { return GetToken(CypherParser.ROLE, 0); }
		public RemovePrivilegeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_removePrivilege; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRemovePrivilege(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RemovePrivilegeContext removePrivilege() {
		RemovePrivilegeContext _localctx = new RemovePrivilegeContext(Context, State);
		EnterRule(_localctx, 586, RULE_removePrivilege);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3539;
			Match(REMOVE);
			State = 3548;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case PRIVILEGE:
			case ROLE:
				{
				State = 3540;
				_la = TokenStream.LA(1);
				if ( !(_la==PRIVILEGE || _la==ROLE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3541;
				Match(ON);
				State = 3542;
				Match(DBMS);
				}
				break;
			case LABEL:
				{
				State = 3543;
				Match(LABEL);
				State = 3544;
				labelsResource();
				State = 3545;
				Match(ON);
				State = 3546;
				graphScope();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WritePrivilegeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WRITE() { return GetToken(CypherParser.WRITE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(CypherParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GraphScopeContext graphScope() {
			return GetRuleContext<GraphScopeContext>(0);
		}
		public WritePrivilegeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_writePrivilege; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWritePrivilege(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WritePrivilegeContext writePrivilege() {
		WritePrivilegeContext _localctx = new WritePrivilegeContext(Context, State);
		EnterRule(_localctx, 588, RULE_writePrivilege);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3550;
			Match(WRITE);
			State = 3551;
			Match(ON);
			State = 3552;
			graphScope();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DatabasePrivilegeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(CypherParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DatabaseScopeContext databaseScope() {
			return GetRuleContext<DatabaseScopeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ACCESS() { return GetToken(CypherParser.ACCESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALTER() { return GetToken(CypherParser.ALTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode START() { return GetToken(CypherParser.START, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STOP() { return GetToken(CypherParser.STOP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public IndexTokenContext indexToken() {
			return GetRuleContext<IndexTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ConstraintTokenContext constraintToken() {
			return GetRuleContext<ConstraintTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NAME() { return GetToken(CypherParser.NAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRANSACTION() { return GetToken(CypherParser.TRANSACTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TERMINATE() { return GetToken(CypherParser.TERMINATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TransactionTokenContext transactionToken() {
			return GetRuleContext<TransactionTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPOSITE() { return GetToken(CypherParser.COMPOSITE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MANAGEMENT() { return GetToken(CypherParser.MANAGEMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UserQualifierContext userQualifier() {
			return GetRuleContext<UserQualifierContext>(0);
		}
		public DatabasePrivilegeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_databasePrivilege; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDatabasePrivilege(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DatabasePrivilegeContext databasePrivilege() {
		DatabasePrivilegeContext _localctx = new DatabasePrivilegeContext(Context, State);
		EnterRule(_localctx, 590, RULE_databasePrivilege);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3581;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ACCESS:
				{
				State = 3554;
				Match(ACCESS);
				}
				break;
			case ALTER:
				{
				State = 3555;
				Match(ALTER);
				State = 3557;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==COMPOSITE) {
					{
					State = 3556;
					Match(COMPOSITE);
					}
				}

				State = 3559;
				Match(DATABASE);
				}
				break;
			case START:
				{
				State = 3560;
				Match(START);
				}
				break;
			case STOP:
				{
				State = 3561;
				Match(STOP);
				}
				break;
			case CONSTRAINT:
			case CONSTRAINTS:
			case INDEX:
			case INDEXES:
			case NAME:
				{
				State = 3565;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case INDEX:
				case INDEXES:
					{
					State = 3562;
					indexToken();
					}
					break;
				case CONSTRAINT:
				case CONSTRAINTS:
					{
					State = 3563;
					constraintToken();
					}
					break;
				case NAME:
					{
					State = 3564;
					Match(NAME);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 3568;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==MANAGEMENT) {
					{
					State = 3567;
					Match(MANAGEMENT);
					}
				}

				}
				break;
			case TERMINATE:
			case TRANSACTION:
				{
				State = 3576;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case TRANSACTION:
					{
					State = 3570;
					Match(TRANSACTION);
					State = 3572;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==MANAGEMENT) {
						{
						State = 3571;
						Match(MANAGEMENT);
						}
					}

					}
					break;
				case TERMINATE:
					{
					State = 3574;
					Match(TERMINATE);
					State = 3575;
					transactionToken();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 3579;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LPAREN) {
					{
					State = 3578;
					userQualifier();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3583;
			Match(ON);
			State = 3584;
			databaseScope();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DbmsPrivilegeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(CypherParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DBMS() { return GetToken(CypherParser.DBMS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALTER() { return GetToken(CypherParser.ALTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(CypherParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MANAGEMENT() { return GetToken(CypherParser.MANAGEMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DbmsPrivilegeExecuteContext dbmsPrivilegeExecute() {
			return GetRuleContext<DbmsPrivilegeExecuteContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RENAME() { return GetToken(CypherParser.RENAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMPERSONATE() { return GetToken(CypherParser.IMPERSONATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIVILEGE() { return GetToken(CypherParser.PRIVILEGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLE() { return GetToken(CypherParser.ROLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(CypherParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALIAS() { return GetToken(CypherParser.ALIAS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERVER() { return GetToken(CypherParser.SERVER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UserQualifierContext userQualifier() {
			return GetRuleContext<UserQualifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPOSITE() { return GetToken(CypherParser.COMPOSITE, 0); }
		public DbmsPrivilegeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dbmsPrivilege; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDbmsPrivilege(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DbmsPrivilegeContext dbmsPrivilege() {
		DbmsPrivilegeContext _localctx = new DbmsPrivilegeContext(Context, State);
		EnterRule(_localctx, 592, RULE_dbmsPrivilege);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3616;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ALTER:
				{
				State = 3586;
				Match(ALTER);
				State = 3593;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ALIAS:
					{
					State = 3587;
					Match(ALIAS);
					}
					break;
				case COMPOSITE:
				case DATABASE:
					{
					State = 3589;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMPOSITE) {
						{
						State = 3588;
						Match(COMPOSITE);
						}
					}

					State = 3591;
					Match(DATABASE);
					}
					break;
				case USER:
					{
					State = 3592;
					Match(USER);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case ASSIGN:
				{
				State = 3595;
				Match(ASSIGN);
				State = 3596;
				_la = TokenStream.LA(1);
				if ( !(_la==PRIVILEGE || _la==ROLE) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case ALIAS:
			case COMPOSITE:
			case DATABASE:
			case PRIVILEGE:
			case ROLE:
			case SERVER:
			case USER:
				{
				State = 3606;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case ALIAS:
					{
					State = 3597;
					Match(ALIAS);
					}
					break;
				case COMPOSITE:
				case DATABASE:
					{
					State = 3599;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COMPOSITE) {
						{
						State = 3598;
						Match(COMPOSITE);
						}
					}

					State = 3601;
					Match(DATABASE);
					}
					break;
				case PRIVILEGE:
					{
					State = 3602;
					Match(PRIVILEGE);
					}
					break;
				case ROLE:
					{
					State = 3603;
					Match(ROLE);
					}
					break;
				case SERVER:
					{
					State = 3604;
					Match(SERVER);
					}
					break;
				case USER:
					{
					State = 3605;
					Match(USER);
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				State = 3608;
				Match(MANAGEMENT);
				}
				break;
			case EXECUTE:
				{
				State = 3609;
				dbmsPrivilegeExecute();
				}
				break;
			case RENAME:
				{
				State = 3610;
				Match(RENAME);
				State = 3611;
				_la = TokenStream.LA(1);
				if ( !(_la==ROLE || _la==USER) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			case IMPERSONATE:
				{
				State = 3612;
				Match(IMPERSONATE);
				State = 3614;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==LPAREN) {
					{
					State = 3613;
					userQualifier();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3618;
			Match(ON);
			State = 3619;
			Match(DBMS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DbmsPrivilegeExecuteContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXECUTE() { return GetToken(CypherParser.EXECUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AdminTokenContext adminToken() {
			return GetRuleContext<AdminTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROCEDURES() { return GetToken(CypherParser.PROCEDURES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ProcedureTokenContext procedureToken() {
			return GetRuleContext<ProcedureTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExecuteProcedureQualifierContext executeProcedureQualifier() {
			return GetRuleContext<ExecuteProcedureQualifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionTokenContext functionToken() {
			return GetRuleContext<FunctionTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExecuteFunctionQualifierContext executeFunctionQualifier() {
			return GetRuleContext<ExecuteFunctionQualifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BOOSTED() { return GetToken(CypherParser.BOOSTED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(CypherParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFINED() { return GetToken(CypherParser.DEFINED, 0); }
		public DbmsPrivilegeExecuteContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dbmsPrivilegeExecute; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDbmsPrivilegeExecute(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DbmsPrivilegeExecuteContext dbmsPrivilegeExecute() {
		DbmsPrivilegeExecuteContext _localctx = new DbmsPrivilegeExecuteContext(Context, State);
		EnterRule(_localctx, 594, RULE_dbmsPrivilegeExecute);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3621;
			Match(EXECUTE);
			State = 3642;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ADMIN:
			case ADMINISTRATOR:
				{
				State = 3622;
				adminToken();
				State = 3623;
				Match(PROCEDURES);
				}
				break;
			case BOOSTED:
			case FUNCTION:
			case FUNCTIONS:
			case PROCEDURE:
			case PROCEDURES:
			case USER:
				{
				State = 3626;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==BOOSTED) {
					{
					State = 3625;
					Match(BOOSTED);
					}
				}

				State = 3640;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case PROCEDURE:
				case PROCEDURES:
					{
					State = 3628;
					procedureToken();
					State = 3629;
					executeProcedureQualifier();
					}
					break;
				case FUNCTION:
				case FUNCTIONS:
				case USER:
					{
					State = 3635;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==USER) {
						{
						State = 3631;
						Match(USER);
						State = 3633;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==DEFINED) {
							{
							State = 3632;
							Match(DEFINED);
							}
						}

						}
					}

					State = 3637;
					functionToken();
					State = 3638;
					executeFunctionQualifier();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AdminTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADMIN() { return GetToken(CypherParser.ADMIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADMINISTRATOR() { return GetToken(CypherParser.ADMINISTRATOR, 0); }
		public AdminTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_adminToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAdminToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AdminTokenContext adminToken() {
		AdminTokenContext _localctx = new AdminTokenContext(Context, State);
		EnterRule(_localctx, 596, RULE_adminToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3644;
			_la = TokenStream.LA(1);
			if ( !(_la==ADMIN || _la==ADMINISTRATOR) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ProcedureTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROCEDURE() { return GetToken(CypherParser.PROCEDURE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROCEDURES() { return GetToken(CypherParser.PROCEDURES, 0); }
		public ProcedureTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_procedureToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProcedureToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProcedureTokenContext procedureToken() {
		ProcedureTokenContext _localctx = new ProcedureTokenContext(Context, State);
		EnterRule(_localctx, 598, RULE_procedureToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3646;
			_la = TokenStream.LA(1);
			if ( !(_la==PROCEDURE || _la==PROCEDURES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class IndexTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(CypherParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEXES() { return GetToken(CypherParser.INDEXES, 0); }
		public IndexTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_indexToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitIndexToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public IndexTokenContext indexToken() {
		IndexTokenContext _localctx = new IndexTokenContext(Context, State);
		EnterRule(_localctx, 600, RULE_indexToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3648;
			_la = TokenStream.LA(1);
			if ( !(_la==INDEX || _la==INDEXES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ConstraintTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTRAINT() { return GetToken(CypherParser.CONSTRAINT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTRAINTS() { return GetToken(CypherParser.CONSTRAINTS, 0); }
		public ConstraintTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_constraintToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitConstraintToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ConstraintTokenContext constraintToken() {
		ConstraintTokenContext _localctx = new ConstraintTokenContext(Context, State);
		EnterRule(_localctx, 602, RULE_constraintToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3650;
			_la = TokenStream.LA(1);
			if ( !(_la==CONSTRAINT || _la==CONSTRAINTS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TransactionTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRANSACTION() { return GetToken(CypherParser.TRANSACTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRANSACTIONS() { return GetToken(CypherParser.TRANSACTIONS, 0); }
		public TransactionTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_transactionToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTransactionToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TransactionTokenContext transactionToken() {
		TransactionTokenContext _localctx = new TransactionTokenContext(Context, State);
		EnterRule(_localctx, 604, RULE_transactionToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3652;
			_la = TokenStream.LA(1);
			if ( !(_la==TRANSACTION || _la==TRANSACTIONS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UserQualifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN() { return GetToken(CypherParser.LPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN() { return GetToken(CypherParser.RPAREN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMES() { return GetToken(CypherParser.TIMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UserNamesContext userNames() {
			return GetRuleContext<UserNamesContext>(0);
		}
		public UserQualifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_userQualifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUserQualifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UserQualifierContext userQualifier() {
		UserQualifierContext _localctx = new UserQualifierContext(Context, State);
		EnterRule(_localctx, 606, RULE_userQualifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3654;
			Match(LPAREN);
			State = 3657;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TIMES:
				{
				State = 3655;
				Match(TIMES);
				}
				break;
			case ESCAPED_SYMBOLIC_NAME:
			case ACCESS:
			case ACTIVE:
			case ADD:
			case ADMIN:
			case ADMINISTRATOR:
			case ALIAS:
			case ALIASES:
			case ALL_SHORTEST_PATHS:
			case ALL:
			case ALLREDUCE:
			case ALTER:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASCENDING:
			case ASSIGN:
			case AT:
			case AUTH:
			case BINDINGS:
			case BOOL:
			case BOOLEAN:
			case BOOSTED:
			case BOTH:
			case BREAK:
			case BUILT:
			case BY:
			case CALL:
			case CASCADE:
			case CASE:
			case CHANGE:
			case CIDR:
			case COLLECT:
			case COMMAND:
			case COMMANDS:
			case COMPOSITE:
			case CONCURRENT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONTAINS:
			case COPY:
			case CONTINUE:
			case COSINE:
			case COUNT:
			case CREATE:
			case CREDENTIAL:
			case CSV:
			case CURRENT:
			case CYPHER:
			case DATA:
			case DATABASE:
			case DATABASES:
			case DATE:
			case DATETIME:
			case DBMS:
			case DEALLOCATE:
			case DEFAULT:
			case DEFINED:
			case DELETE:
			case DENY:
			case DESC:
			case DESCENDING:
			case DESTROY:
			case DETACH:
			case DIFFERENT:
			case DOLLAR:
			case DISTINCT:
			case DOT_METRIC:
			case DRIVER:
			case DROP:
			case DRYRUN:
			case DUMP:
			case DURATION:
			case EACH:
			case EDGE:
			case ENABLE:
			case ELEMENT:
			case ELEMENTS:
			case ELSE:
			case ENCRYPTED:
			case EUCLIDEAN:
			case EUCLIDEAN_SQUARED:
			case END:
			case ENDS:
			case EXECUTABLE:
			case EXECUTE:
			case EXIST:
			case EXISTENCE:
			case EXISTS:
			case ERROR:
			case FAIL:
			case FALSE:
			case FIELDTERMINATOR:
			case FILTER:
			case FINISH:
			case FLOAT:
			case FLOAT64:
			case FLOAT32:
			case FOR:
			case FOREACH:
			case FORWARDING:
			case FROM:
			case FULLTEXT:
			case FUNCTION:
			case FUNCTIONS:
			case GRANT:
			case GRAPH:
			case GRAPHS:
			case GROUP:
			case GROUPS:
			case HAMMING:
			case HEADERS:
			case HOME:
			case ID:
			case IF:
			case IMPERSONATE:
			case IMMUTABLE:
			case IN:
			case INDEX:
			case INDEXES:
			case INF:
			case INFINITY:
			case INSERT:
			case INT:
			case INT64:
			case INT32:
			case INT16:
			case INT8:
			case INTEGER:
			case INTEGER64:
			case INTEGER32:
			case INTEGER16:
			case INTEGER8:
			case IS:
			case JOIN:
			case KEY:
			case LABEL:
			case LABELS:
			case LANGUAGE:
			case LEADING:
			case LET:
			case LIMITROWS:
			case LIST:
			case LOAD:
			case LOCAL:
			case LOOKUP:
			case MANAGEMENT:
			case MANHATTAN:
			case MAP:
			case MATCH:
			case MERGE:
			case IMPLIES:
			case NAME:
			case NAMES:
			case NAN:
			case NFC:
			case NFD:
			case NFKC:
			case NFKD:
			case NEW:
			case NEXT:
			case NODE:
			case NODETACH:
			case NODES:
			case NONE:
			case NORMALIZE:
			case NORMALIZED:
			case NOT:
			case NOTHING:
			case NOWAIT:
			case NULL:
			case OF:
			case OFFSET:
			case OIDC:
			case ON:
			case ONLY:
			case OPTIONAL:
			case OPTIONS:
			case OPTION:
			case OR:
			case ORDER:
			case PASSWORD:
			case PASSWORDS:
			case PATH:
			case PATHS:
			case PLAINTEXT:
			case POINT:
			case POPULATED:
			case PRIMARY:
			case PRIMARIES:
			case PRIVILEGE:
			case PRIVILEGES:
			case PROCEDURE:
			case PROCEDURES:
			case PROPERTIES:
			case PROPERTY:
			case PROVIDER:
			case PROVIDERS:
			case RANGE:
			case READ:
			case REALLOCATE:
			case REDUCE:
			case RENAME:
			case REL:
			case RELATIONSHIP:
			case RELATIONSHIPS:
			case REMOVE:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case REPLICAS:
			case REPORT:
			case REQUIRE:
			case REQUIRED:
			case RESTRICT:
			case RETRY:
			case RETURN:
			case REVOKE:
			case ROLE:
			case ROLES:
			case ROW:
			case ROWS:
			case SCAN:
			case SEC:
			case SECOND:
			case SECONDARY:
			case SECONDARIES:
			case SECONDS:
			case SEEK:
			case SERVER:
			case SERVERS:
			case SET:
			case SETTING:
			case SETTINGS:
			case SHARD:
			case SHARDS:
			case SHORTEST_PATH:
			case SHORTEST:
			case SHOW:
			case SIGNED:
			case SINGLE:
			case SKIPROWS:
			case START:
			case STARTS:
			case STATUS:
			case STOP:
			case STRING:
			case SUPPORTED:
			case SUSPENDED:
			case TARGET:
			case TERMINATE:
			case TEXT:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE:
			case TO:
			case TOPOLOGY:
			case TRAILING:
			case TRANSACTION:
			case TRANSACTIONS:
			case TRAVERSE:
			case TRIM:
			case TRUE:
			case TYPE:
			case TYPED:
			case TYPES:
			case UNION:
			case UNIQUE:
			case UNIQUENESS:
			case UNWIND:
			case URL:
			case USE:
			case USER:
			case USERS:
			case USING:
			case VALUE:
			case VARCHAR:
			case VECTOR:
			case VECTOR_DISTANCE:
			case VECTOR_NORM:
			case VERTEX:
			case WAIT:
			case WHEN:
			case WHERE:
			case WITH:
			case WITHOUT:
			case WRITE:
			case XOR:
			case YIELD:
			case ZONE:
			case ZONED:
			case IDENTIFIER:
				{
				State = 3656;
				userNames();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3659;
			Match(RPAREN);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExecuteFunctionQualifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GlobsContext globs() {
			return GetRuleContext<GlobsContext>(0);
		}
		public ExecuteFunctionQualifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_executeFunctionQualifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExecuteFunctionQualifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExecuteFunctionQualifierContext executeFunctionQualifier() {
		ExecuteFunctionQualifierContext _localctx = new ExecuteFunctionQualifierContext(Context, State);
		EnterRule(_localctx, 608, RULE_executeFunctionQualifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3661;
			globs();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExecuteProcedureQualifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GlobsContext globs() {
			return GetRuleContext<GlobsContext>(0);
		}
		public ExecuteProcedureQualifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_executeProcedureQualifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExecuteProcedureQualifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExecuteProcedureQualifierContext executeProcedureQualifier() {
		ExecuteProcedureQualifierContext _localctx = new ExecuteProcedureQualifierContext(Context, State);
		EnterRule(_localctx, 610, RULE_executeProcedureQualifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3663;
			globs();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SettingQualifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GlobsContext globs() {
			return GetRuleContext<GlobsContext>(0);
		}
		public SettingQualifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_settingQualifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSettingQualifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SettingQualifierContext settingQualifier() {
		SettingQualifierContext _localctx = new SettingQualifierContext(Context, State);
		EnterRule(_localctx, 612, RULE_settingQualifier);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3665;
			globs();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GlobsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GlobContext[] glob() {
			return GetRuleContexts<GlobContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public GlobContext glob(int i) {
			return GetRuleContext<GlobContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public GlobsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_globs; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGlobs(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GlobsContext globs() {
		GlobsContext _localctx = new GlobsContext(Context, State);
		EnterRule(_localctx, 614, RULE_globs);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3667;
			glob();
			State = 3672;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3668;
				Match(COMMA);
				State = 3669;
				glob();
				}
				}
				State = 3674;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GlobContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public EscapedSymbolicNameStringContext escapedSymbolicNameString() {
			return GetRuleContext<EscapedSymbolicNameStringContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GlobRecursiveContext globRecursive() {
			return GetRuleContext<GlobRecursiveContext>(0);
		}
		public GlobContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_glob; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGlob(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GlobContext glob() {
		GlobContext _localctx = new GlobContext(Context, State);
		EnterRule(_localctx, 616, RULE_glob);
		try {
			State = 3680;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ESCAPED_SYMBOLIC_NAME:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3675;
				escapedSymbolicNameString();
				State = 3677;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,437,Context) ) {
				case 1:
					{
					State = 3676;
					globRecursive();
					}
					break;
				}
				}
				break;
			case ACCESS:
			case ACTIVE:
			case ADD:
			case ADMIN:
			case ADMINISTRATOR:
			case ALIAS:
			case ALIASES:
			case ALL_SHORTEST_PATHS:
			case ALL:
			case ALLREDUCE:
			case ALTER:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASCENDING:
			case ASSIGN:
			case AT:
			case AUTH:
			case BINDINGS:
			case BOOL:
			case BOOLEAN:
			case BOOSTED:
			case BOTH:
			case BREAK:
			case BUILT:
			case BY:
			case CALL:
			case CASCADE:
			case CASE:
			case CHANGE:
			case CIDR:
			case COLLECT:
			case COMMAND:
			case COMMANDS:
			case COMPOSITE:
			case CONCURRENT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONTAINS:
			case COPY:
			case CONTINUE:
			case COSINE:
			case COUNT:
			case CREATE:
			case CREDENTIAL:
			case CSV:
			case CURRENT:
			case CYPHER:
			case DATA:
			case DATABASE:
			case DATABASES:
			case DATE:
			case DATETIME:
			case DBMS:
			case DEALLOCATE:
			case DEFAULT:
			case DEFINED:
			case DELETE:
			case DENY:
			case DESC:
			case DESCENDING:
			case DESTROY:
			case DETACH:
			case DIFFERENT:
			case DISTINCT:
			case DOT:
			case DOT_METRIC:
			case DRIVER:
			case DROP:
			case DRYRUN:
			case DUMP:
			case DURATION:
			case EACH:
			case EDGE:
			case ENABLE:
			case ELEMENT:
			case ELEMENTS:
			case ELSE:
			case ENCRYPTED:
			case EUCLIDEAN:
			case EUCLIDEAN_SQUARED:
			case END:
			case ENDS:
			case EXECUTABLE:
			case EXECUTE:
			case EXIST:
			case EXISTENCE:
			case EXISTS:
			case ERROR:
			case FAIL:
			case FALSE:
			case FIELDTERMINATOR:
			case FILTER:
			case FINISH:
			case FLOAT:
			case FLOAT64:
			case FLOAT32:
			case FOR:
			case FOREACH:
			case FORWARDING:
			case FROM:
			case FULLTEXT:
			case FUNCTION:
			case FUNCTIONS:
			case GRANT:
			case GRAPH:
			case GRAPHS:
			case GROUP:
			case GROUPS:
			case HAMMING:
			case HEADERS:
			case HOME:
			case ID:
			case IF:
			case IMPERSONATE:
			case IMMUTABLE:
			case IN:
			case INDEX:
			case INDEXES:
			case INF:
			case INFINITY:
			case INSERT:
			case INT:
			case INT64:
			case INT32:
			case INT16:
			case INT8:
			case INTEGER:
			case INTEGER64:
			case INTEGER32:
			case INTEGER16:
			case INTEGER8:
			case IS:
			case JOIN:
			case KEY:
			case LABEL:
			case LABELS:
			case LANGUAGE:
			case LEADING:
			case LET:
			case LIMITROWS:
			case LIST:
			case LOAD:
			case LOCAL:
			case LOOKUP:
			case MANAGEMENT:
			case MANHATTAN:
			case MAP:
			case MATCH:
			case MERGE:
			case IMPLIES:
			case NAME:
			case NAMES:
			case NAN:
			case NFC:
			case NFD:
			case NFKC:
			case NFKD:
			case NEW:
			case NEXT:
			case NODE:
			case NODETACH:
			case NODES:
			case NONE:
			case NORMALIZE:
			case NORMALIZED:
			case NOT:
			case NOTHING:
			case NOWAIT:
			case NULL:
			case OF:
			case OFFSET:
			case OIDC:
			case ON:
			case ONLY:
			case OPTIONAL:
			case OPTIONS:
			case OPTION:
			case OR:
			case ORDER:
			case PASSWORD:
			case PASSWORDS:
			case PATH:
			case PATHS:
			case PLAINTEXT:
			case POINT:
			case POPULATED:
			case PRIMARY:
			case PRIMARIES:
			case PRIVILEGE:
			case PRIVILEGES:
			case PROCEDURE:
			case PROCEDURES:
			case PROPERTIES:
			case PROPERTY:
			case PROVIDER:
			case PROVIDERS:
			case QUESTION:
			case RANGE:
			case READ:
			case REALLOCATE:
			case REDUCE:
			case RENAME:
			case REL:
			case RELATIONSHIP:
			case RELATIONSHIPS:
			case REMOVE:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case REPLICAS:
			case REPORT:
			case REQUIRE:
			case REQUIRED:
			case RESTRICT:
			case RETRY:
			case RETURN:
			case REVOKE:
			case ROLE:
			case ROLES:
			case ROW:
			case ROWS:
			case SCAN:
			case SEC:
			case SECOND:
			case SECONDARY:
			case SECONDARIES:
			case SECONDS:
			case SEEK:
			case SERVER:
			case SERVERS:
			case SET:
			case SETTING:
			case SETTINGS:
			case SHARD:
			case SHARDS:
			case SHORTEST_PATH:
			case SHORTEST:
			case SHOW:
			case SIGNED:
			case SINGLE:
			case SKIPROWS:
			case START:
			case STARTS:
			case STATUS:
			case STOP:
			case STRING:
			case SUPPORTED:
			case SUSPENDED:
			case TARGET:
			case TERMINATE:
			case TEXT:
			case THEN:
			case TIME:
			case TIMES:
			case TIMESTAMP:
			case TIMEZONE:
			case TO:
			case TOPOLOGY:
			case TRAILING:
			case TRANSACTION:
			case TRANSACTIONS:
			case TRAVERSE:
			case TRIM:
			case TRUE:
			case TYPE:
			case TYPED:
			case TYPES:
			case UNION:
			case UNIQUE:
			case UNIQUENESS:
			case UNWIND:
			case URL:
			case USE:
			case USER:
			case USERS:
			case USING:
			case VALUE:
			case VARCHAR:
			case VECTOR:
			case VECTOR_DISTANCE:
			case VECTOR_NORM:
			case VERTEX:
			case WAIT:
			case WHEN:
			case WHERE:
			case WITH:
			case WITHOUT:
			case WRITE:
			case XOR:
			case YIELD:
			case ZONE:
			case ZONED:
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3679;
				globRecursive();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GlobRecursiveContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GlobPartContext globPart() {
			return GetRuleContext<GlobPartContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GlobRecursiveContext globRecursive() {
			return GetRuleContext<GlobRecursiveContext>(0);
		}
		public GlobRecursiveContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_globRecursive; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGlobRecursive(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GlobRecursiveContext globRecursive() {
		GlobRecursiveContext _localctx = new GlobRecursiveContext(Context, State);
		EnterRule(_localctx, 618, RULE_globRecursive);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3682;
			globPart();
			State = 3684;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,439,Context) ) {
			case 1:
				{
				State = 3683;
				globRecursive();
				}
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GlobPartContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT() { return GetToken(CypherParser.DOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public EscapedSymbolicNameStringContext escapedSymbolicNameString() {
			return GetRuleContext<EscapedSymbolicNameStringContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode QUESTION() { return GetToken(CypherParser.QUESTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMES() { return GetToken(CypherParser.TIMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UnescapedSymbolicNameStringContext unescapedSymbolicNameString() {
			return GetRuleContext<UnescapedSymbolicNameStringContext>(0);
		}
		public GlobPartContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_globPart; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGlobPart(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GlobPartContext globPart() {
		GlobPartContext _localctx = new GlobPartContext(Context, State);
		EnterRule(_localctx, 620, RULE_globPart);
		int _la;
		try {
			State = 3693;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DOT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3686;
				Match(DOT);
				State = 3688;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==ESCAPED_SYMBOLIC_NAME) {
					{
					State = 3687;
					escapedSymbolicNameString();
					}
				}

				}
				break;
			case QUESTION:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3690;
				Match(QUESTION);
				}
				break;
			case TIMES:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3691;
				Match(TIMES);
				}
				break;
			case ACCESS:
			case ACTIVE:
			case ADD:
			case ADMIN:
			case ADMINISTRATOR:
			case ALIAS:
			case ALIASES:
			case ALL_SHORTEST_PATHS:
			case ALL:
			case ALLREDUCE:
			case ALTER:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASCENDING:
			case ASSIGN:
			case AT:
			case AUTH:
			case BINDINGS:
			case BOOL:
			case BOOLEAN:
			case BOOSTED:
			case BOTH:
			case BREAK:
			case BUILT:
			case BY:
			case CALL:
			case CASCADE:
			case CASE:
			case CHANGE:
			case CIDR:
			case COLLECT:
			case COMMAND:
			case COMMANDS:
			case COMPOSITE:
			case CONCURRENT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONTAINS:
			case COPY:
			case CONTINUE:
			case COSINE:
			case COUNT:
			case CREATE:
			case CREDENTIAL:
			case CSV:
			case CURRENT:
			case CYPHER:
			case DATA:
			case DATABASE:
			case DATABASES:
			case DATE:
			case DATETIME:
			case DBMS:
			case DEALLOCATE:
			case DEFAULT:
			case DEFINED:
			case DELETE:
			case DENY:
			case DESC:
			case DESCENDING:
			case DESTROY:
			case DETACH:
			case DIFFERENT:
			case DISTINCT:
			case DOT_METRIC:
			case DRIVER:
			case DROP:
			case DRYRUN:
			case DUMP:
			case DURATION:
			case EACH:
			case EDGE:
			case ENABLE:
			case ELEMENT:
			case ELEMENTS:
			case ELSE:
			case ENCRYPTED:
			case EUCLIDEAN:
			case EUCLIDEAN_SQUARED:
			case END:
			case ENDS:
			case EXECUTABLE:
			case EXECUTE:
			case EXIST:
			case EXISTENCE:
			case EXISTS:
			case ERROR:
			case FAIL:
			case FALSE:
			case FIELDTERMINATOR:
			case FILTER:
			case FINISH:
			case FLOAT:
			case FLOAT64:
			case FLOAT32:
			case FOR:
			case FOREACH:
			case FORWARDING:
			case FROM:
			case FULLTEXT:
			case FUNCTION:
			case FUNCTIONS:
			case GRANT:
			case GRAPH:
			case GRAPHS:
			case GROUP:
			case GROUPS:
			case HAMMING:
			case HEADERS:
			case HOME:
			case ID:
			case IF:
			case IMPERSONATE:
			case IMMUTABLE:
			case IN:
			case INDEX:
			case INDEXES:
			case INF:
			case INFINITY:
			case INSERT:
			case INT:
			case INT64:
			case INT32:
			case INT16:
			case INT8:
			case INTEGER:
			case INTEGER64:
			case INTEGER32:
			case INTEGER16:
			case INTEGER8:
			case IS:
			case JOIN:
			case KEY:
			case LABEL:
			case LABELS:
			case LANGUAGE:
			case LEADING:
			case LET:
			case LIMITROWS:
			case LIST:
			case LOAD:
			case LOCAL:
			case LOOKUP:
			case MANAGEMENT:
			case MANHATTAN:
			case MAP:
			case MATCH:
			case MERGE:
			case IMPLIES:
			case NAME:
			case NAMES:
			case NAN:
			case NFC:
			case NFD:
			case NFKC:
			case NFKD:
			case NEW:
			case NEXT:
			case NODE:
			case NODETACH:
			case NODES:
			case NONE:
			case NORMALIZE:
			case NORMALIZED:
			case NOT:
			case NOTHING:
			case NOWAIT:
			case NULL:
			case OF:
			case OFFSET:
			case OIDC:
			case ON:
			case ONLY:
			case OPTIONAL:
			case OPTIONS:
			case OPTION:
			case OR:
			case ORDER:
			case PASSWORD:
			case PASSWORDS:
			case PATH:
			case PATHS:
			case PLAINTEXT:
			case POINT:
			case POPULATED:
			case PRIMARY:
			case PRIMARIES:
			case PRIVILEGE:
			case PRIVILEGES:
			case PROCEDURE:
			case PROCEDURES:
			case PROPERTIES:
			case PROPERTY:
			case PROVIDER:
			case PROVIDERS:
			case RANGE:
			case READ:
			case REALLOCATE:
			case REDUCE:
			case RENAME:
			case REL:
			case RELATIONSHIP:
			case RELATIONSHIPS:
			case REMOVE:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case REPLICAS:
			case REPORT:
			case REQUIRE:
			case REQUIRED:
			case RESTRICT:
			case RETRY:
			case RETURN:
			case REVOKE:
			case ROLE:
			case ROLES:
			case ROW:
			case ROWS:
			case SCAN:
			case SEC:
			case SECOND:
			case SECONDARY:
			case SECONDARIES:
			case SECONDS:
			case SEEK:
			case SERVER:
			case SERVERS:
			case SET:
			case SETTING:
			case SETTINGS:
			case SHARD:
			case SHARDS:
			case SHORTEST_PATH:
			case SHORTEST:
			case SHOW:
			case SIGNED:
			case SINGLE:
			case SKIPROWS:
			case START:
			case STARTS:
			case STATUS:
			case STOP:
			case STRING:
			case SUPPORTED:
			case SUSPENDED:
			case TARGET:
			case TERMINATE:
			case TEXT:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE:
			case TO:
			case TOPOLOGY:
			case TRAILING:
			case TRANSACTION:
			case TRANSACTIONS:
			case TRAVERSE:
			case TRIM:
			case TRUE:
			case TYPE:
			case TYPED:
			case TYPES:
			case UNION:
			case UNIQUE:
			case UNIQUENESS:
			case UNWIND:
			case URL:
			case USE:
			case USER:
			case USERS:
			case USING:
			case VALUE:
			case VARCHAR:
			case VECTOR:
			case VECTOR_DISTANCE:
			case VECTOR_NORM:
			case VERTEX:
			case WAIT:
			case WHEN:
			case WHERE:
			case WITH:
			case WITHOUT:
			case WRITE:
			case XOR:
			case YIELD:
			case ZONE:
			case ZONED:
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 4);
				{
				State = 3692;
				unescapedSymbolicNameString();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class QualifiedGraphPrivilegesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(CypherParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public GraphScopeContext graphScope() {
			return GetRuleContext<GraphScopeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GraphQualifierContext graphQualifier() {
			return GetRuleContext<GraphQualifierContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRAVERSE() { return GetToken(CypherParser.TRAVERSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DELETE() { return GetToken(CypherParser.DELETE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropertiesResourceContext propertiesResource() {
			return GetRuleContext<PropertiesResourceContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode READ() { return GetToken(CypherParser.READ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MATCH() { return GetToken(CypherParser.MATCH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MERGE() { return GetToken(CypherParser.MERGE, 0); }
		public QualifiedGraphPrivilegesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_qualifiedGraphPrivileges; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitQualifiedGraphPrivileges(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public QualifiedGraphPrivilegesContext qualifiedGraphPrivileges() {
		QualifiedGraphPrivilegesContext _localctx = new QualifiedGraphPrivilegesContext(Context, State);
		EnterRule(_localctx, 622, RULE_qualifiedGraphPrivileges);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3699;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TRAVERSE:
				{
				State = 3695;
				Match(TRAVERSE);
				}
				break;
			case DELETE:
				{
				State = 3696;
				Match(DELETE);
				}
				break;
			case MATCH:
			case MERGE:
			case READ:
				{
				State = 3697;
				_la = TokenStream.LA(1);
				if ( !(((((_la - 179)) & ~0x3f) == 0 && ((1L << (_la - 179)) & ((1L << (MATCH - 179)) | (1L << (MERGE - 179)) | (1L << (READ - 179)))) != 0)) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3698;
				propertiesResource();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3701;
			Match(ON);
			State = 3702;
			graphScope();
			State = 3703;
			graphQualifier();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class LabelsResourceContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMES() { return GetToken(CypherParser.TIMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NonEmptyStringListContext nonEmptyStringList() {
			return GetRuleContext<NonEmptyStringListContext>(0);
		}
		public LabelsResourceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_labelsResource; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitLabelsResource(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public LabelsResourceContext labelsResource() {
		LabelsResourceContext _localctx = new LabelsResourceContext(Context, State);
		EnterRule(_localctx, 624, RULE_labelsResource);
		try {
			State = 3707;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TIMES:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3705;
				Match(TIMES);
				}
				break;
			case ESCAPED_SYMBOLIC_NAME:
			case ACCESS:
			case ACTIVE:
			case ADD:
			case ADMIN:
			case ADMINISTRATOR:
			case ALIAS:
			case ALIASES:
			case ALL_SHORTEST_PATHS:
			case ALL:
			case ALLREDUCE:
			case ALTER:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASCENDING:
			case ASSIGN:
			case AT:
			case AUTH:
			case BINDINGS:
			case BOOL:
			case BOOLEAN:
			case BOOSTED:
			case BOTH:
			case BREAK:
			case BUILT:
			case BY:
			case CALL:
			case CASCADE:
			case CASE:
			case CHANGE:
			case CIDR:
			case COLLECT:
			case COMMAND:
			case COMMANDS:
			case COMPOSITE:
			case CONCURRENT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONTAINS:
			case COPY:
			case CONTINUE:
			case COSINE:
			case COUNT:
			case CREATE:
			case CREDENTIAL:
			case CSV:
			case CURRENT:
			case CYPHER:
			case DATA:
			case DATABASE:
			case DATABASES:
			case DATE:
			case DATETIME:
			case DBMS:
			case DEALLOCATE:
			case DEFAULT:
			case DEFINED:
			case DELETE:
			case DENY:
			case DESC:
			case DESCENDING:
			case DESTROY:
			case DETACH:
			case DIFFERENT:
			case DISTINCT:
			case DOT_METRIC:
			case DRIVER:
			case DROP:
			case DRYRUN:
			case DUMP:
			case DURATION:
			case EACH:
			case EDGE:
			case ENABLE:
			case ELEMENT:
			case ELEMENTS:
			case ELSE:
			case ENCRYPTED:
			case EUCLIDEAN:
			case EUCLIDEAN_SQUARED:
			case END:
			case ENDS:
			case EXECUTABLE:
			case EXECUTE:
			case EXIST:
			case EXISTENCE:
			case EXISTS:
			case ERROR:
			case FAIL:
			case FALSE:
			case FIELDTERMINATOR:
			case FILTER:
			case FINISH:
			case FLOAT:
			case FLOAT64:
			case FLOAT32:
			case FOR:
			case FOREACH:
			case FORWARDING:
			case FROM:
			case FULLTEXT:
			case FUNCTION:
			case FUNCTIONS:
			case GRANT:
			case GRAPH:
			case GRAPHS:
			case GROUP:
			case GROUPS:
			case HAMMING:
			case HEADERS:
			case HOME:
			case ID:
			case IF:
			case IMPERSONATE:
			case IMMUTABLE:
			case IN:
			case INDEX:
			case INDEXES:
			case INF:
			case INFINITY:
			case INSERT:
			case INT:
			case INT64:
			case INT32:
			case INT16:
			case INT8:
			case INTEGER:
			case INTEGER64:
			case INTEGER32:
			case INTEGER16:
			case INTEGER8:
			case IS:
			case JOIN:
			case KEY:
			case LABEL:
			case LABELS:
			case LANGUAGE:
			case LEADING:
			case LET:
			case LIMITROWS:
			case LIST:
			case LOAD:
			case LOCAL:
			case LOOKUP:
			case MANAGEMENT:
			case MANHATTAN:
			case MAP:
			case MATCH:
			case MERGE:
			case IMPLIES:
			case NAME:
			case NAMES:
			case NAN:
			case NFC:
			case NFD:
			case NFKC:
			case NFKD:
			case NEW:
			case NEXT:
			case NODE:
			case NODETACH:
			case NODES:
			case NONE:
			case NORMALIZE:
			case NORMALIZED:
			case NOT:
			case NOTHING:
			case NOWAIT:
			case NULL:
			case OF:
			case OFFSET:
			case OIDC:
			case ON:
			case ONLY:
			case OPTIONAL:
			case OPTIONS:
			case OPTION:
			case OR:
			case ORDER:
			case PASSWORD:
			case PASSWORDS:
			case PATH:
			case PATHS:
			case PLAINTEXT:
			case POINT:
			case POPULATED:
			case PRIMARY:
			case PRIMARIES:
			case PRIVILEGE:
			case PRIVILEGES:
			case PROCEDURE:
			case PROCEDURES:
			case PROPERTIES:
			case PROPERTY:
			case PROVIDER:
			case PROVIDERS:
			case RANGE:
			case READ:
			case REALLOCATE:
			case REDUCE:
			case RENAME:
			case REL:
			case RELATIONSHIP:
			case RELATIONSHIPS:
			case REMOVE:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case REPLICAS:
			case REPORT:
			case REQUIRE:
			case REQUIRED:
			case RESTRICT:
			case RETRY:
			case RETURN:
			case REVOKE:
			case ROLE:
			case ROLES:
			case ROW:
			case ROWS:
			case SCAN:
			case SEC:
			case SECOND:
			case SECONDARY:
			case SECONDARIES:
			case SECONDS:
			case SEEK:
			case SERVER:
			case SERVERS:
			case SET:
			case SETTING:
			case SETTINGS:
			case SHARD:
			case SHARDS:
			case SHORTEST_PATH:
			case SHORTEST:
			case SHOW:
			case SIGNED:
			case SINGLE:
			case SKIPROWS:
			case START:
			case STARTS:
			case STATUS:
			case STOP:
			case STRING:
			case SUPPORTED:
			case SUSPENDED:
			case TARGET:
			case TERMINATE:
			case TEXT:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE:
			case TO:
			case TOPOLOGY:
			case TRAILING:
			case TRANSACTION:
			case TRANSACTIONS:
			case TRAVERSE:
			case TRIM:
			case TRUE:
			case TYPE:
			case TYPED:
			case TYPES:
			case UNION:
			case UNIQUE:
			case UNIQUENESS:
			case UNWIND:
			case URL:
			case USE:
			case USER:
			case USERS:
			case USING:
			case VALUE:
			case VARCHAR:
			case VECTOR:
			case VECTOR_DISTANCE:
			case VECTOR_NORM:
			case VERTEX:
			case WAIT:
			case WHEN:
			case WHERE:
			case WITH:
			case WITHOUT:
			case WRITE:
			case XOR:
			case YIELD:
			case ZONE:
			case ZONED:
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3706;
				nonEmptyStringList();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertiesResourceContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CypherParser.LCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CypherParser.RCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMES() { return GetToken(CypherParser.TIMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NonEmptyStringListContext nonEmptyStringList() {
			return GetRuleContext<NonEmptyStringListContext>(0);
		}
		public PropertiesResourceContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertiesResource; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertiesResource(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertiesResourceContext propertiesResource() {
		PropertiesResourceContext _localctx = new PropertiesResourceContext(Context, State);
		EnterRule(_localctx, 626, RULE_propertiesResource);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3709;
			Match(LCURLY);
			State = 3712;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case TIMES:
				{
				State = 3710;
				Match(TIMES);
				}
				break;
			case ESCAPED_SYMBOLIC_NAME:
			case ACCESS:
			case ACTIVE:
			case ADD:
			case ADMIN:
			case ADMINISTRATOR:
			case ALIAS:
			case ALIASES:
			case ALL_SHORTEST_PATHS:
			case ALL:
			case ALLREDUCE:
			case ALTER:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASCENDING:
			case ASSIGN:
			case AT:
			case AUTH:
			case BINDINGS:
			case BOOL:
			case BOOLEAN:
			case BOOSTED:
			case BOTH:
			case BREAK:
			case BUILT:
			case BY:
			case CALL:
			case CASCADE:
			case CASE:
			case CHANGE:
			case CIDR:
			case COLLECT:
			case COMMAND:
			case COMMANDS:
			case COMPOSITE:
			case CONCURRENT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONTAINS:
			case COPY:
			case CONTINUE:
			case COSINE:
			case COUNT:
			case CREATE:
			case CREDENTIAL:
			case CSV:
			case CURRENT:
			case CYPHER:
			case DATA:
			case DATABASE:
			case DATABASES:
			case DATE:
			case DATETIME:
			case DBMS:
			case DEALLOCATE:
			case DEFAULT:
			case DEFINED:
			case DELETE:
			case DENY:
			case DESC:
			case DESCENDING:
			case DESTROY:
			case DETACH:
			case DIFFERENT:
			case DISTINCT:
			case DOT_METRIC:
			case DRIVER:
			case DROP:
			case DRYRUN:
			case DUMP:
			case DURATION:
			case EACH:
			case EDGE:
			case ENABLE:
			case ELEMENT:
			case ELEMENTS:
			case ELSE:
			case ENCRYPTED:
			case EUCLIDEAN:
			case EUCLIDEAN_SQUARED:
			case END:
			case ENDS:
			case EXECUTABLE:
			case EXECUTE:
			case EXIST:
			case EXISTENCE:
			case EXISTS:
			case ERROR:
			case FAIL:
			case FALSE:
			case FIELDTERMINATOR:
			case FILTER:
			case FINISH:
			case FLOAT:
			case FLOAT64:
			case FLOAT32:
			case FOR:
			case FOREACH:
			case FORWARDING:
			case FROM:
			case FULLTEXT:
			case FUNCTION:
			case FUNCTIONS:
			case GRANT:
			case GRAPH:
			case GRAPHS:
			case GROUP:
			case GROUPS:
			case HAMMING:
			case HEADERS:
			case HOME:
			case ID:
			case IF:
			case IMPERSONATE:
			case IMMUTABLE:
			case IN:
			case INDEX:
			case INDEXES:
			case INF:
			case INFINITY:
			case INSERT:
			case INT:
			case INT64:
			case INT32:
			case INT16:
			case INT8:
			case INTEGER:
			case INTEGER64:
			case INTEGER32:
			case INTEGER16:
			case INTEGER8:
			case IS:
			case JOIN:
			case KEY:
			case LABEL:
			case LABELS:
			case LANGUAGE:
			case LEADING:
			case LET:
			case LIMITROWS:
			case LIST:
			case LOAD:
			case LOCAL:
			case LOOKUP:
			case MANAGEMENT:
			case MANHATTAN:
			case MAP:
			case MATCH:
			case MERGE:
			case IMPLIES:
			case NAME:
			case NAMES:
			case NAN:
			case NFC:
			case NFD:
			case NFKC:
			case NFKD:
			case NEW:
			case NEXT:
			case NODE:
			case NODETACH:
			case NODES:
			case NONE:
			case NORMALIZE:
			case NORMALIZED:
			case NOT:
			case NOTHING:
			case NOWAIT:
			case NULL:
			case OF:
			case OFFSET:
			case OIDC:
			case ON:
			case ONLY:
			case OPTIONAL:
			case OPTIONS:
			case OPTION:
			case OR:
			case ORDER:
			case PASSWORD:
			case PASSWORDS:
			case PATH:
			case PATHS:
			case PLAINTEXT:
			case POINT:
			case POPULATED:
			case PRIMARY:
			case PRIMARIES:
			case PRIVILEGE:
			case PRIVILEGES:
			case PROCEDURE:
			case PROCEDURES:
			case PROPERTIES:
			case PROPERTY:
			case PROVIDER:
			case PROVIDERS:
			case RANGE:
			case READ:
			case REALLOCATE:
			case REDUCE:
			case RENAME:
			case REL:
			case RELATIONSHIP:
			case RELATIONSHIPS:
			case REMOVE:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case REPLICAS:
			case REPORT:
			case REQUIRE:
			case REQUIRED:
			case RESTRICT:
			case RETRY:
			case RETURN:
			case REVOKE:
			case ROLE:
			case ROLES:
			case ROW:
			case ROWS:
			case SCAN:
			case SEC:
			case SECOND:
			case SECONDARY:
			case SECONDARIES:
			case SECONDS:
			case SEEK:
			case SERVER:
			case SERVERS:
			case SET:
			case SETTING:
			case SETTINGS:
			case SHARD:
			case SHARDS:
			case SHORTEST_PATH:
			case SHORTEST:
			case SHOW:
			case SIGNED:
			case SINGLE:
			case SKIPROWS:
			case START:
			case STARTS:
			case STATUS:
			case STOP:
			case STRING:
			case SUPPORTED:
			case SUSPENDED:
			case TARGET:
			case TERMINATE:
			case TEXT:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE:
			case TO:
			case TOPOLOGY:
			case TRAILING:
			case TRANSACTION:
			case TRANSACTIONS:
			case TRAVERSE:
			case TRIM:
			case TRUE:
			case TYPE:
			case TYPED:
			case TYPES:
			case UNION:
			case UNIQUE:
			case UNIQUENESS:
			case UNWIND:
			case URL:
			case USE:
			case USER:
			case USERS:
			case USING:
			case VALUE:
			case VARCHAR:
			case VECTOR:
			case VECTOR_DISTANCE:
			case VECTOR_NORM:
			case VERTEX:
			case WAIT:
			case WHEN:
			case WHERE:
			case WITH:
			case WITHOUT:
			case WRITE:
			case XOR:
			case YIELD:
			case ZONE:
			case ZONED:
			case IDENTIFIER:
				{
				State = 3711;
				nonEmptyStringList();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3714;
			Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NonEmptyStringListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext[] symbolicNameString() {
			return GetRuleContexts<SymbolicNameStringContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString(int i) {
			return GetRuleContext<SymbolicNameStringContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public NonEmptyStringListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nonEmptyStringList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNonEmptyStringList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NonEmptyStringListContext nonEmptyStringList() {
		NonEmptyStringListContext _localctx = new NonEmptyStringListContext(Context, State);
		EnterRule(_localctx, 628, RULE_nonEmptyStringList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3716;
			symbolicNameString();
			State = 3721;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 3717;
				Match(COMMA);
				State = 3718;
				symbolicNameString();
				}
				}
				State = 3723;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GraphQualifierContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public GraphQualifierTokenContext graphQualifierToken() {
			return GetRuleContext<GraphQualifierTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(CypherParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMES() { return GetToken(CypherParser.TIMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public NonEmptyStringListContext nonEmptyStringList() {
			return GetRuleContext<NonEmptyStringListContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] LPAREN() { return GetTokens(CypherParser.LPAREN); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LPAREN(int i) {
			return GetToken(CypherParser.LPAREN, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] RPAREN() { return GetTokens(CypherParser.RPAREN); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RPAREN(int i) {
			return GetToken(CypherParser.RPAREN, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArrowLineContext[] arrowLine() {
			return GetRuleContexts<ArrowLineContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArrowLineContext arrowLine(int i) {
			return GetRuleContext<ArrowLineContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CypherParser.LBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHERE() { return GetToken(CypherParser.WHERE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CypherParser.RBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public VariableContext variable() {
			return GetRuleContext<VariableContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON() { return GetToken(CypherParser.COLON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext[] symbolicNameString() {
			return GetRuleContexts<SymbolicNameStringContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString(int i) {
			return GetRuleContext<SymbolicNameStringContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public LeftArrowContext leftArrow() {
			return GetRuleContext<LeftArrowContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public MapContext map() {
			return GetRuleContext<MapContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RightArrowContext rightArrow() {
			return GetRuleContext<RightArrowContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] BAR() { return GetTokens(CypherParser.BAR); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BAR(int i) {
			return GetToken(CypherParser.BAR, i);
		}
		public GraphQualifierContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_graphQualifier; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGraphQualifier(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GraphQualifierContext graphQualifier() {
		GraphQualifierContext _localctx = new GraphQualifierContext(Context, State);
		EnterRule(_localctx, 630, RULE_graphQualifier);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3805;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ELEMENT:
			case ELEMENTS:
			case NODE:
			case NODES:
			case RELATIONSHIP:
			case RELATIONSHIPS:
				{
				State = 3724;
				graphQualifierToken();
				State = 3727;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case TIMES:
					{
					State = 3725;
					Match(TIMES);
					}
					break;
				case ESCAPED_SYMBOLIC_NAME:
				case ACCESS:
				case ACTIVE:
				case ADD:
				case ADMIN:
				case ADMINISTRATOR:
				case ALIAS:
				case ALIASES:
				case ALL_SHORTEST_PATHS:
				case ALL:
				case ALLREDUCE:
				case ALTER:
				case AND:
				case ANY:
				case ARRAY:
				case AS:
				case ASC:
				case ASCENDING:
				case ASSIGN:
				case AT:
				case AUTH:
				case BINDINGS:
				case BOOL:
				case BOOLEAN:
				case BOOSTED:
				case BOTH:
				case BREAK:
				case BUILT:
				case BY:
				case CALL:
				case CASCADE:
				case CASE:
				case CHANGE:
				case CIDR:
				case COLLECT:
				case COMMAND:
				case COMMANDS:
				case COMPOSITE:
				case CONCURRENT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONTAINS:
				case COPY:
				case CONTINUE:
				case COSINE:
				case COUNT:
				case CREATE:
				case CREDENTIAL:
				case CSV:
				case CURRENT:
				case CYPHER:
				case DATA:
				case DATABASE:
				case DATABASES:
				case DATE:
				case DATETIME:
				case DBMS:
				case DEALLOCATE:
				case DEFAULT:
				case DEFINED:
				case DELETE:
				case DENY:
				case DESC:
				case DESCENDING:
				case DESTROY:
				case DETACH:
				case DIFFERENT:
				case DISTINCT:
				case DOT_METRIC:
				case DRIVER:
				case DROP:
				case DRYRUN:
				case DUMP:
				case DURATION:
				case EACH:
				case EDGE:
				case ENABLE:
				case ELEMENT:
				case ELEMENTS:
				case ELSE:
				case ENCRYPTED:
				case EUCLIDEAN:
				case EUCLIDEAN_SQUARED:
				case END:
				case ENDS:
				case EXECUTABLE:
				case EXECUTE:
				case EXIST:
				case EXISTENCE:
				case EXISTS:
				case ERROR:
				case FAIL:
				case FALSE:
				case FIELDTERMINATOR:
				case FILTER:
				case FINISH:
				case FLOAT:
				case FLOAT64:
				case FLOAT32:
				case FOR:
				case FOREACH:
				case FORWARDING:
				case FROM:
				case FULLTEXT:
				case FUNCTION:
				case FUNCTIONS:
				case GRANT:
				case GRAPH:
				case GRAPHS:
				case GROUP:
				case GROUPS:
				case HAMMING:
				case HEADERS:
				case HOME:
				case ID:
				case IF:
				case IMPERSONATE:
				case IMMUTABLE:
				case IN:
				case INDEX:
				case INDEXES:
				case INF:
				case INFINITY:
				case INSERT:
				case INT:
				case INT64:
				case INT32:
				case INT16:
				case INT8:
				case INTEGER:
				case INTEGER64:
				case INTEGER32:
				case INTEGER16:
				case INTEGER8:
				case IS:
				case JOIN:
				case KEY:
				case LABEL:
				case LABELS:
				case LANGUAGE:
				case LEADING:
				case LET:
				case LIMITROWS:
				case LIST:
				case LOAD:
				case LOCAL:
				case LOOKUP:
				case MANAGEMENT:
				case MANHATTAN:
				case MAP:
				case MATCH:
				case MERGE:
				case IMPLIES:
				case NAME:
				case NAMES:
				case NAN:
				case NFC:
				case NFD:
				case NFKC:
				case NFKD:
				case NEW:
				case NEXT:
				case NODE:
				case NODETACH:
				case NODES:
				case NONE:
				case NORMALIZE:
				case NORMALIZED:
				case NOT:
				case NOTHING:
				case NOWAIT:
				case NULL:
				case OF:
				case OFFSET:
				case OIDC:
				case ON:
				case ONLY:
				case OPTIONAL:
				case OPTIONS:
				case OPTION:
				case OR:
				case ORDER:
				case PASSWORD:
				case PASSWORDS:
				case PATH:
				case PATHS:
				case PLAINTEXT:
				case POINT:
				case POPULATED:
				case PRIMARY:
				case PRIMARIES:
				case PRIVILEGE:
				case PRIVILEGES:
				case PROCEDURE:
				case PROCEDURES:
				case PROPERTIES:
				case PROPERTY:
				case PROVIDER:
				case PROVIDERS:
				case RANGE:
				case READ:
				case REALLOCATE:
				case REDUCE:
				case RENAME:
				case REL:
				case RELATIONSHIP:
				case RELATIONSHIPS:
				case REMOVE:
				case REPEATABLE:
				case REPLACE:
				case REPLICA:
				case REPLICAS:
				case REPORT:
				case REQUIRE:
				case REQUIRED:
				case RESTRICT:
				case RETRY:
				case RETURN:
				case REVOKE:
				case ROLE:
				case ROLES:
				case ROW:
				case ROWS:
				case SCAN:
				case SEC:
				case SECOND:
				case SECONDARY:
				case SECONDARIES:
				case SECONDS:
				case SEEK:
				case SERVER:
				case SERVERS:
				case SET:
				case SETTING:
				case SETTINGS:
				case SHARD:
				case SHARDS:
				case SHORTEST_PATH:
				case SHORTEST:
				case SHOW:
				case SIGNED:
				case SINGLE:
				case SKIPROWS:
				case START:
				case STARTS:
				case STATUS:
				case STOP:
				case STRING:
				case SUPPORTED:
				case SUSPENDED:
				case TARGET:
				case TERMINATE:
				case TEXT:
				case THEN:
				case TIME:
				case TIMESTAMP:
				case TIMEZONE:
				case TO:
				case TOPOLOGY:
				case TRAILING:
				case TRANSACTION:
				case TRANSACTIONS:
				case TRAVERSE:
				case TRIM:
				case TRUE:
				case TYPE:
				case TYPED:
				case TYPES:
				case UNION:
				case UNIQUE:
				case UNIQUENESS:
				case UNWIND:
				case URL:
				case USE:
				case USER:
				case USERS:
				case USING:
				case VALUE:
				case VARCHAR:
				case VECTOR:
				case VECTOR_DISTANCE:
				case VECTOR_NORM:
				case VERTEX:
				case WAIT:
				case WHEN:
				case WHERE:
				case WITH:
				case WITHOUT:
				case WRITE:
				case XOR:
				case YIELD:
				case ZONE:
				case ZONED:
				case IDENTIFIER:
					{
					State = 3726;
					nonEmptyStringList();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			case FOR:
				{
				State = 3729;
				Match(FOR);
				State = 3803;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,460,Context) ) {
				case 1:
					{
					State = 3730;
					Match(LPAREN);
					State = 3732;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,447,Context) ) {
					case 1:
						{
						State = 3731;
						variable();
						}
						break;
					}
					State = 3743;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COLON) {
						{
						State = 3734;
						Match(COLON);
						State = 3735;
						symbolicNameString();
						State = 3740;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						while (_la==BAR) {
							{
							{
							State = 3736;
							Match(BAR);
							State = 3737;
							symbolicNameString();
							}
							}
							State = 3742;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
						}
						}
					}

					State = 3755;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case RPAREN:
						{
						State = 3745;
						Match(RPAREN);
						State = 3746;
						Match(WHERE);
						State = 3747;
						expression();
						}
						break;
					case LCURLY:
					case WHERE:
						{
						State = 3751;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case WHERE:
							{
							State = 3748;
							Match(WHERE);
							State = 3749;
							expression();
							}
							break;
						case LCURLY:
							{
							State = 3750;
							map();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						State = 3753;
						Match(RPAREN);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					break;
				case 2:
					{
					State = 3757;
					Match(LPAREN);
					State = 3758;
					Match(RPAREN);
					State = 3760;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==LT || _la==ARROW_LEFT_HEAD) {
						{
						State = 3759;
						leftArrow();
						}
					}

					State = 3762;
					arrowLine();
					State = 3763;
					Match(LBRACKET);
					State = 3765;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,453,Context) ) {
					case 1:
						{
						State = 3764;
						variable();
						}
						break;
					}
					State = 3776;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (_la==COLON) {
						{
						State = 3767;
						Match(COLON);
						State = 3768;
						symbolicNameString();
						State = 3773;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						while (_la==BAR) {
							{
							{
							State = 3769;
							Match(BAR);
							State = 3770;
							symbolicNameString();
							}
							}
							State = 3775;
							ErrorHandler.Sync(this);
							_la = TokenStream.LA(1);
						}
						}
					}

					State = 3801;
					ErrorHandler.Sync(this);
					switch (TokenStream.LA(1)) {
					case RBRACKET:
						{
						State = 3778;
						Match(RBRACKET);
						State = 3779;
						arrowLine();
						State = 3781;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==GT || _la==ARROW_RIGHT_HEAD) {
							{
							State = 3780;
							rightArrow();
							}
						}

						State = 3783;
						Match(LPAREN);
						State = 3784;
						Match(RPAREN);
						State = 3785;
						Match(WHERE);
						State = 3786;
						expression();
						}
						break;
					case LCURLY:
					case WHERE:
						{
						State = 3791;
						ErrorHandler.Sync(this);
						switch (TokenStream.LA(1)) {
						case WHERE:
							{
							State = 3788;
							Match(WHERE);
							State = 3789;
							expression();
							}
							break;
						case LCURLY:
							{
							State = 3790;
							map();
							}
							break;
						default:
							throw new NoViableAltException(this);
						}
						State = 3793;
						Match(RBRACKET);
						State = 3794;
						arrowLine();
						State = 3796;
						ErrorHandler.Sync(this);
						_la = TokenStream.LA(1);
						if (_la==GT || _la==ARROW_RIGHT_HEAD) {
							{
							State = 3795;
							rightArrow();
							}
						}

						State = 3798;
						Match(LPAREN);
						State = 3799;
						Match(RPAREN);
						}
						break;
					default:
						throw new NoViableAltException(this);
					}
					}
					break;
				}
				}
				break;
			case FROM:
			case TO:
				break;
			default:
				break;
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GraphQualifierTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public RelTokenContext relToken() {
			return GetRuleContext<RelTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public NodeTokenContext nodeToken() {
			return GetRuleContext<NodeTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ElementTokenContext elementToken() {
			return GetRuleContext<ElementTokenContext>(0);
		}
		public GraphQualifierTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_graphQualifierToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGraphQualifierToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GraphQualifierTokenContext graphQualifierToken() {
		GraphQualifierTokenContext _localctx = new GraphQualifierTokenContext(Context, State);
		EnterRule(_localctx, 632, RULE_graphQualifierToken);
		try {
			State = 3810;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case RELATIONSHIP:
			case RELATIONSHIPS:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3807;
				relToken();
				}
				break;
			case NODE:
			case NODES:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3808;
				nodeToken();
				}
				break;
			case ELEMENT:
			case ELEMENTS:
				EnterOuterAlt(_localctx, 3);
				{
				State = 3809;
				elementToken();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RelTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELATIONSHIP() { return GetToken(CypherParser.RELATIONSHIP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELATIONSHIPS() { return GetToken(CypherParser.RELATIONSHIPS, 0); }
		public RelTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_relToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRelToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RelTokenContext relToken() {
		RelTokenContext _localctx = new RelTokenContext(Context, State);
		EnterRule(_localctx, 634, RULE_relToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3812;
			_la = TokenStream.LA(1);
			if ( !(_la==RELATIONSHIP || _la==RELATIONSHIPS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ElementTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELEMENT() { return GetToken(CypherParser.ELEMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELEMENTS() { return GetToken(CypherParser.ELEMENTS, 0); }
		public ElementTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_elementToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitElementToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ElementTokenContext elementToken() {
		ElementTokenContext _localctx = new ElementTokenContext(Context, State);
		EnterRule(_localctx, 636, RULE_elementToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3814;
			_la = TokenStream.LA(1);
			if ( !(_la==ELEMENT || _la==ELEMENTS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class NodeTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NODE() { return GetToken(CypherParser.NODE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NODES() { return GetToken(CypherParser.NODES, 0); }
		public NodeTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_nodeToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitNodeToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public NodeTokenContext nodeToken() {
		NodeTokenContext _localctx = new NodeTokenContext(Context, State);
		EnterRule(_localctx, 638, RULE_nodeToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3816;
			_la = TokenStream.LA(1);
			if ( !(_la==NODE || _la==NODES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DatabaseScopeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HOME() { return GetToken(CypherParser.HOME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASES() { return GetToken(CypherParser.DATABASES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMES() { return GetToken(CypherParser.TIMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicAliasNameListContext symbolicAliasNameList() {
			return GetRuleContext<SymbolicAliasNameListContext>(0);
		}
		public DatabaseScopeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_databaseScope; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDatabaseScope(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DatabaseScopeContext databaseScope() {
		DatabaseScopeContext _localctx = new DatabaseScopeContext(Context, State);
		EnterRule(_localctx, 640, RULE_databaseScope);
		int _la;
		try {
			State = 3825;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case HOME:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3818;
				Match(HOME);
				State = 3819;
				Match(DATABASE);
				}
				break;
			case DATABASE:
			case DATABASES:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3820;
				_la = TokenStream.LA(1);
				if ( !(_la==DATABASE || _la==DATABASES) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3823;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case TIMES:
					{
					State = 3821;
					Match(TIMES);
					}
					break;
				case ESCAPED_SYMBOLIC_NAME:
				case ACCESS:
				case ACTIVE:
				case ADD:
				case ADMIN:
				case ADMINISTRATOR:
				case ALIAS:
				case ALIASES:
				case ALL_SHORTEST_PATHS:
				case ALL:
				case ALLREDUCE:
				case ALTER:
				case AND:
				case ANY:
				case ARRAY:
				case AS:
				case ASC:
				case ASCENDING:
				case ASSIGN:
				case AT:
				case AUTH:
				case BINDINGS:
				case BOOL:
				case BOOLEAN:
				case BOOSTED:
				case BOTH:
				case BREAK:
				case BUILT:
				case BY:
				case CALL:
				case CASCADE:
				case CASE:
				case CHANGE:
				case CIDR:
				case COLLECT:
				case COMMAND:
				case COMMANDS:
				case COMPOSITE:
				case CONCURRENT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONTAINS:
				case COPY:
				case CONTINUE:
				case COSINE:
				case COUNT:
				case CREATE:
				case CREDENTIAL:
				case CSV:
				case CURRENT:
				case CYPHER:
				case DATA:
				case DATABASE:
				case DATABASES:
				case DATE:
				case DATETIME:
				case DBMS:
				case DEALLOCATE:
				case DEFAULT:
				case DEFINED:
				case DELETE:
				case DENY:
				case DESC:
				case DESCENDING:
				case DESTROY:
				case DETACH:
				case DIFFERENT:
				case DOLLAR:
				case DISTINCT:
				case DOT_METRIC:
				case DRIVER:
				case DROP:
				case DRYRUN:
				case DUMP:
				case DURATION:
				case EACH:
				case EDGE:
				case ENABLE:
				case ELEMENT:
				case ELEMENTS:
				case ELSE:
				case ENCRYPTED:
				case EUCLIDEAN:
				case EUCLIDEAN_SQUARED:
				case END:
				case ENDS:
				case EXECUTABLE:
				case EXECUTE:
				case EXIST:
				case EXISTENCE:
				case EXISTS:
				case ERROR:
				case FAIL:
				case FALSE:
				case FIELDTERMINATOR:
				case FILTER:
				case FINISH:
				case FLOAT:
				case FLOAT64:
				case FLOAT32:
				case FOR:
				case FOREACH:
				case FORWARDING:
				case FROM:
				case FULLTEXT:
				case FUNCTION:
				case FUNCTIONS:
				case GRANT:
				case GRAPH:
				case GRAPHS:
				case GROUP:
				case GROUPS:
				case HAMMING:
				case HEADERS:
				case HOME:
				case ID:
				case IF:
				case IMPERSONATE:
				case IMMUTABLE:
				case IN:
				case INDEX:
				case INDEXES:
				case INF:
				case INFINITY:
				case INSERT:
				case INT:
				case INT64:
				case INT32:
				case INT16:
				case INT8:
				case INTEGER:
				case INTEGER64:
				case INTEGER32:
				case INTEGER16:
				case INTEGER8:
				case IS:
				case JOIN:
				case KEY:
				case LABEL:
				case LABELS:
				case LANGUAGE:
				case LEADING:
				case LET:
				case LIMITROWS:
				case LIST:
				case LOAD:
				case LOCAL:
				case LOOKUP:
				case MANAGEMENT:
				case MANHATTAN:
				case MAP:
				case MATCH:
				case MERGE:
				case IMPLIES:
				case NAME:
				case NAMES:
				case NAN:
				case NFC:
				case NFD:
				case NFKC:
				case NFKD:
				case NEW:
				case NEXT:
				case NODE:
				case NODETACH:
				case NODES:
				case NONE:
				case NORMALIZE:
				case NORMALIZED:
				case NOT:
				case NOTHING:
				case NOWAIT:
				case NULL:
				case OF:
				case OFFSET:
				case OIDC:
				case ON:
				case ONLY:
				case OPTIONAL:
				case OPTIONS:
				case OPTION:
				case OR:
				case ORDER:
				case PASSWORD:
				case PASSWORDS:
				case PATH:
				case PATHS:
				case PLAINTEXT:
				case POINT:
				case POPULATED:
				case PRIMARY:
				case PRIMARIES:
				case PRIVILEGE:
				case PRIVILEGES:
				case PROCEDURE:
				case PROCEDURES:
				case PROPERTIES:
				case PROPERTY:
				case PROVIDER:
				case PROVIDERS:
				case RANGE:
				case READ:
				case REALLOCATE:
				case REDUCE:
				case RENAME:
				case REL:
				case RELATIONSHIP:
				case RELATIONSHIPS:
				case REMOVE:
				case REPEATABLE:
				case REPLACE:
				case REPLICA:
				case REPLICAS:
				case REPORT:
				case REQUIRE:
				case REQUIRED:
				case RESTRICT:
				case RETRY:
				case RETURN:
				case REVOKE:
				case ROLE:
				case ROLES:
				case ROW:
				case ROWS:
				case SCAN:
				case SEC:
				case SECOND:
				case SECONDARY:
				case SECONDARIES:
				case SECONDS:
				case SEEK:
				case SERVER:
				case SERVERS:
				case SET:
				case SETTING:
				case SETTINGS:
				case SHARD:
				case SHARDS:
				case SHORTEST_PATH:
				case SHORTEST:
				case SHOW:
				case SIGNED:
				case SINGLE:
				case SKIPROWS:
				case START:
				case STARTS:
				case STATUS:
				case STOP:
				case STRING:
				case SUPPORTED:
				case SUSPENDED:
				case TARGET:
				case TERMINATE:
				case TEXT:
				case THEN:
				case TIME:
				case TIMESTAMP:
				case TIMEZONE:
				case TO:
				case TOPOLOGY:
				case TRAILING:
				case TRANSACTION:
				case TRANSACTIONS:
				case TRAVERSE:
				case TRIM:
				case TRUE:
				case TYPE:
				case TYPED:
				case TYPES:
				case UNION:
				case UNIQUE:
				case UNIQUENESS:
				case UNWIND:
				case URL:
				case USE:
				case USER:
				case USERS:
				case USING:
				case VALUE:
				case VARCHAR:
				case VECTOR:
				case VECTOR_DISTANCE:
				case VECTOR_NORM:
				case VERTEX:
				case WAIT:
				case WHEN:
				case WHERE:
				case WITH:
				case WITHOUT:
				case WRITE:
				case XOR:
				case YIELD:
				case ZONE:
				case ZONED:
				case IDENTIFIER:
					{
					State = 3822;
					symbolicAliasNameList();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GraphScopeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HOME() { return GetToken(CypherParser.HOME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GRAPH() { return GetToken(CypherParser.GRAPH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GRAPHS() { return GetToken(CypherParser.GRAPHS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMES() { return GetToken(CypherParser.TIMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicAliasNameListContext symbolicAliasNameList() {
			return GetRuleContext<SymbolicAliasNameListContext>(0);
		}
		public GraphScopeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_graphScope; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGraphScope(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GraphScopeContext graphScope() {
		GraphScopeContext _localctx = new GraphScopeContext(Context, State);
		EnterRule(_localctx, 642, RULE_graphScope);
		int _la;
		try {
			State = 3834;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case HOME:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3827;
				Match(HOME);
				State = 3828;
				Match(GRAPH);
				}
				break;
			case GRAPH:
			case GRAPHS:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3829;
				_la = TokenStream.LA(1);
				if ( !(_la==GRAPH || _la==GRAPHS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3832;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case TIMES:
					{
					State = 3830;
					Match(TIMES);
					}
					break;
				case ESCAPED_SYMBOLIC_NAME:
				case ACCESS:
				case ACTIVE:
				case ADD:
				case ADMIN:
				case ADMINISTRATOR:
				case ALIAS:
				case ALIASES:
				case ALL_SHORTEST_PATHS:
				case ALL:
				case ALLREDUCE:
				case ALTER:
				case AND:
				case ANY:
				case ARRAY:
				case AS:
				case ASC:
				case ASCENDING:
				case ASSIGN:
				case AT:
				case AUTH:
				case BINDINGS:
				case BOOL:
				case BOOLEAN:
				case BOOSTED:
				case BOTH:
				case BREAK:
				case BUILT:
				case BY:
				case CALL:
				case CASCADE:
				case CASE:
				case CHANGE:
				case CIDR:
				case COLLECT:
				case COMMAND:
				case COMMANDS:
				case COMPOSITE:
				case CONCURRENT:
				case CONSTRAINT:
				case CONSTRAINTS:
				case CONTAINS:
				case COPY:
				case CONTINUE:
				case COSINE:
				case COUNT:
				case CREATE:
				case CREDENTIAL:
				case CSV:
				case CURRENT:
				case CYPHER:
				case DATA:
				case DATABASE:
				case DATABASES:
				case DATE:
				case DATETIME:
				case DBMS:
				case DEALLOCATE:
				case DEFAULT:
				case DEFINED:
				case DELETE:
				case DENY:
				case DESC:
				case DESCENDING:
				case DESTROY:
				case DETACH:
				case DIFFERENT:
				case DOLLAR:
				case DISTINCT:
				case DOT_METRIC:
				case DRIVER:
				case DROP:
				case DRYRUN:
				case DUMP:
				case DURATION:
				case EACH:
				case EDGE:
				case ENABLE:
				case ELEMENT:
				case ELEMENTS:
				case ELSE:
				case ENCRYPTED:
				case EUCLIDEAN:
				case EUCLIDEAN_SQUARED:
				case END:
				case ENDS:
				case EXECUTABLE:
				case EXECUTE:
				case EXIST:
				case EXISTENCE:
				case EXISTS:
				case ERROR:
				case FAIL:
				case FALSE:
				case FIELDTERMINATOR:
				case FILTER:
				case FINISH:
				case FLOAT:
				case FLOAT64:
				case FLOAT32:
				case FOR:
				case FOREACH:
				case FORWARDING:
				case FROM:
				case FULLTEXT:
				case FUNCTION:
				case FUNCTIONS:
				case GRANT:
				case GRAPH:
				case GRAPHS:
				case GROUP:
				case GROUPS:
				case HAMMING:
				case HEADERS:
				case HOME:
				case ID:
				case IF:
				case IMPERSONATE:
				case IMMUTABLE:
				case IN:
				case INDEX:
				case INDEXES:
				case INF:
				case INFINITY:
				case INSERT:
				case INT:
				case INT64:
				case INT32:
				case INT16:
				case INT8:
				case INTEGER:
				case INTEGER64:
				case INTEGER32:
				case INTEGER16:
				case INTEGER8:
				case IS:
				case JOIN:
				case KEY:
				case LABEL:
				case LABELS:
				case LANGUAGE:
				case LEADING:
				case LET:
				case LIMITROWS:
				case LIST:
				case LOAD:
				case LOCAL:
				case LOOKUP:
				case MANAGEMENT:
				case MANHATTAN:
				case MAP:
				case MATCH:
				case MERGE:
				case IMPLIES:
				case NAME:
				case NAMES:
				case NAN:
				case NFC:
				case NFD:
				case NFKC:
				case NFKD:
				case NEW:
				case NEXT:
				case NODE:
				case NODETACH:
				case NODES:
				case NONE:
				case NORMALIZE:
				case NORMALIZED:
				case NOT:
				case NOTHING:
				case NOWAIT:
				case NULL:
				case OF:
				case OFFSET:
				case OIDC:
				case ON:
				case ONLY:
				case OPTIONAL:
				case OPTIONS:
				case OPTION:
				case OR:
				case ORDER:
				case PASSWORD:
				case PASSWORDS:
				case PATH:
				case PATHS:
				case PLAINTEXT:
				case POINT:
				case POPULATED:
				case PRIMARY:
				case PRIMARIES:
				case PRIVILEGE:
				case PRIVILEGES:
				case PROCEDURE:
				case PROCEDURES:
				case PROPERTIES:
				case PROPERTY:
				case PROVIDER:
				case PROVIDERS:
				case RANGE:
				case READ:
				case REALLOCATE:
				case REDUCE:
				case RENAME:
				case REL:
				case RELATIONSHIP:
				case RELATIONSHIPS:
				case REMOVE:
				case REPEATABLE:
				case REPLACE:
				case REPLICA:
				case REPLICAS:
				case REPORT:
				case REQUIRE:
				case REQUIRED:
				case RESTRICT:
				case RETRY:
				case RETURN:
				case REVOKE:
				case ROLE:
				case ROLES:
				case ROW:
				case ROWS:
				case SCAN:
				case SEC:
				case SECOND:
				case SECONDARY:
				case SECONDARIES:
				case SECONDS:
				case SEEK:
				case SERVER:
				case SERVERS:
				case SET:
				case SETTING:
				case SETTINGS:
				case SHARD:
				case SHARDS:
				case SHORTEST_PATH:
				case SHORTEST:
				case SHOW:
				case SIGNED:
				case SINGLE:
				case SKIPROWS:
				case START:
				case STARTS:
				case STATUS:
				case STOP:
				case STRING:
				case SUPPORTED:
				case SUSPENDED:
				case TARGET:
				case TERMINATE:
				case TEXT:
				case THEN:
				case TIME:
				case TIMESTAMP:
				case TIMEZONE:
				case TO:
				case TOPOLOGY:
				case TRAILING:
				case TRANSACTION:
				case TRANSACTIONS:
				case TRAVERSE:
				case TRIM:
				case TRUE:
				case TYPE:
				case TYPED:
				case TYPES:
				case UNION:
				case UNIQUE:
				case UNIQUENESS:
				case UNWIND:
				case URL:
				case USE:
				case USER:
				case USERS:
				case USING:
				case VALUE:
				case VARCHAR:
				case VECTOR:
				case VECTOR_DISTANCE:
				case VECTOR_NORM:
				case VERTEX:
				case WAIT:
				case WHEN:
				case WHERE:
				case WITH:
				case WITHOUT:
				case WRITE:
				case XOR:
				case YIELD:
				case ZONE:
				case ZONED:
				case IDENTIFIER:
					{
					State = 3831;
					symbolicAliasNameList();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateCompositeDatabaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPOSITE() { return GetToken(CypherParser.COMPOSITE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicAliasNameOrParameterContext symbolicAliasNameOrParameter() {
			return GetRuleContext<SymbolicAliasNameOrParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CypherParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(CypherParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DefaultLanguageSpecificationContext defaultLanguageSpecification() {
			return GetRuleContext<DefaultLanguageSpecificationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommandOptionsContext commandOptions() {
			return GetRuleContext<CommandOptionsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WaitClauseContext waitClause() {
			return GetRuleContext<WaitClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(CypherParser.SET, 0); }
		public CreateCompositeDatabaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createCompositeDatabase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateCompositeDatabase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateCompositeDatabaseContext createCompositeDatabase() {
		CreateCompositeDatabaseContext _localctx = new CreateCompositeDatabaseContext(Context, State);
		EnterRule(_localctx, 644, RULE_createCompositeDatabase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3836;
			Match(COMPOSITE);
			State = 3837;
			Match(DATABASE);
			State = 3838;
			symbolicAliasNameOrParameter();
			State = 3842;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 3839;
				Match(IF);
				State = 3840;
				Match(NOT);
				State = 3841;
				Match(EXISTS);
				}
			}

			State = 3848;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DEFAULT || _la==SET) {
				{
				State = 3845;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SET) {
					{
					State = 3844;
					Match(SET);
					}
				}

				State = 3847;
				defaultLanguageSpecification();
				}
			}

			State = 3851;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OPTIONS) {
				{
				State = 3850;
				commandOptions();
				}
			}

			State = 3854;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOWAIT || _la==WAIT) {
				{
				State = 3853;
				waitClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateDatabaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicAliasNameOrParameterContext symbolicAliasNameOrParameter() {
			return GetRuleContext<SymbolicAliasNameOrParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CypherParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(CypherParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DefaultLanguageSpecificationContext defaultLanguageSpecification() {
			return GetRuleContext<DefaultLanguageSpecificationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public TopologyContext topology() {
			return GetRuleContext<TopologyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShardsContext shards() {
			return GetRuleContext<ShardsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommandOptionsContext commandOptions() {
			return GetRuleContext<CommandOptionsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WaitClauseContext waitClause() {
			return GetRuleContext<WaitClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(CypherParser.SET, 0); }
		public CreateDatabaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createDatabase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateDatabase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateDatabaseContext createDatabase() {
		CreateDatabaseContext _localctx = new CreateDatabaseContext(Context, State);
		EnterRule(_localctx, 646, RULE_createDatabase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3856;
			Match(DATABASE);
			State = 3857;
			symbolicAliasNameOrParameter();
			State = 3861;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 3858;
				Match(IF);
				State = 3859;
				Match(NOT);
				State = 3860;
				Match(EXISTS);
				}
			}

			State = 3867;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,474,Context) ) {
			case 1:
				{
				State = 3864;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SET) {
					{
					State = 3863;
					Match(SET);
					}
				}

				State = 3866;
				defaultLanguageSpecification();
				}
				break;
			}
			State = 3871;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,475,Context) ) {
			case 1:
				{
				State = 3869;
				topology();
				}
				break;
			case 2:
				{
				State = 3870;
				shards();
				}
				break;
			}
			State = 3874;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==OPTIONS) {
				{
				State = 3873;
				commandOptions();
				}
			}

			State = 3877;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOWAIT || _la==WAIT) {
				{
				State = 3876;
				waitClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShardsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public PropertyShardContext propertyShard() {
			return GetRuleContext<PropertyShardContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public GraphShardContext graphShard() {
			return GetRuleContext<GraphShardContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] SET() { return GetTokens(CypherParser.SET); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET(int i) {
			return GetToken(CypherParser.SET, i);
		}
		public ShardsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_shards; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShards(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShardsContext shards() {
		ShardsContext _localctx = new ShardsContext(Context, State);
		EnterRule(_localctx, 648, RULE_shards);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3883;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,479,Context) ) {
			case 1:
				{
				State = 3880;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SET) {
					{
					State = 3879;
					Match(SET);
					}
				}

				State = 3882;
				graphShard();
				}
				break;
			}
			State = 3886;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SET) {
				{
				State = 3885;
				Match(SET);
				}
			}

			State = 3888;
			propertyShard();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class GraphShardContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GRAPH() { return GetToken(CypherParser.GRAPH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARD() { return GetToken(CypherParser.SHARD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CypherParser.LCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CypherParser.RCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public TopologyContext topology() {
			return GetRuleContext<TopologyContext>(0);
		}
		public GraphShardContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_graphShard; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitGraphShard(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public GraphShardContext graphShard() {
		GraphShardContext _localctx = new GraphShardContext(Context, State);
		EnterRule(_localctx, 650, RULE_graphShard);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3890;
			Match(GRAPH);
			State = 3891;
			Match(SHARD);
			State = 3892;
			Match(LCURLY);
			State = 3894;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SET || _la==TOPOLOGY) {
				{
				State = 3893;
				topology();
				}
			}

			State = 3896;
			Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PropertyShardContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROPERTY() { return GetToken(CypherParser.PROPERTY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CypherParser.LCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COUNT() { return GetToken(CypherParser.COUNT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNSIGNED_DECIMAL_INTEGER() { return GetToken(CypherParser.UNSIGNED_DECIMAL_INTEGER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CypherParser.RCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARD() { return GetToken(CypherParser.SHARD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARDS() { return GetToken(CypherParser.SHARDS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TOPOLOGY() { return GetToken(CypherParser.TOPOLOGY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UIntOrIntParameterContext uIntOrIntParameter() {
			return GetRuleContext<UIntOrIntParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REPLICA() { return GetToken(CypherParser.REPLICA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REPLICAS() { return GetToken(CypherParser.REPLICAS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(CypherParser.SET, 0); }
		public PropertyShardContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_propertyShard; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPropertyShard(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PropertyShardContext propertyShard() {
		PropertyShardContext _localctx = new PropertyShardContext(Context, State);
		EnterRule(_localctx, 652, RULE_propertyShard);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3898;
			Match(PROPERTY);
			State = 3899;
			_la = TokenStream.LA(1);
			if ( !(_la==SHARD || _la==SHARDS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 3900;
			Match(LCURLY);
			State = 3901;
			Match(COUNT);
			State = 3902;
			Match(UNSIGNED_DECIMAL_INTEGER);
			State = 3910;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SET || _la==TOPOLOGY) {
				{
				State = 3904;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==SET) {
					{
					State = 3903;
					Match(SET);
					}
				}

				State = 3906;
				Match(TOPOLOGY);
				State = 3907;
				uIntOrIntParameter();
				State = 3908;
				_la = TokenStream.LA(1);
				if ( !(_la==REPLICA || _la==REPLICAS) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
			}

			State = 3912;
			Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TopologyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TOPOLOGY() { return GetToken(CypherParser.TOPOLOGY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(CypherParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PrimaryTopologyContext[] primaryTopology() {
			return GetRuleContexts<PrimaryTopologyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PrimaryTopologyContext primaryTopology(int i) {
			return GetRuleContext<PrimaryTopologyContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SecondaryTopologyContext[] secondaryTopology() {
			return GetRuleContexts<SecondaryTopologyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SecondaryTopologyContext secondaryTopology(int i) {
			return GetRuleContext<SecondaryTopologyContext>(i);
		}
		public TopologyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_topology; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTopology(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TopologyContext topology() {
		TopologyContext _localctx = new TopologyContext(Context, State);
		EnterRule(_localctx, 654, RULE_topology);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3915;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==SET) {
				{
				State = 3914;
				Match(SET);
				}
			}

			State = 3917;
			Match(TOPOLOGY);
			State = 3920;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 3920;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,485,Context) ) {
				case 1:
					{
					State = 3918;
					primaryTopology();
					}
					break;
				case 2:
					{
					State = 3919;
					secondaryTopology();
					}
					break;
				}
				}
				State = 3922;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==UNSIGNED_DECIMAL_INTEGER || _la==DOLLAR );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrimaryTopologyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public UIntOrIntParameterContext uIntOrIntParameter() {
			return GetRuleContext<UIntOrIntParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public PrimaryTokenContext primaryToken() {
			return GetRuleContext<PrimaryTokenContext>(0);
		}
		public PrimaryTopologyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_primaryTopology; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimaryTopology(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrimaryTopologyContext primaryTopology() {
		PrimaryTopologyContext _localctx = new PrimaryTopologyContext(Context, State);
		EnterRule(_localctx, 656, RULE_primaryTopology);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3924;
			uIntOrIntParameter();
			State = 3925;
			primaryToken();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class PrimaryTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIMARY() { return GetToken(CypherParser.PRIMARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIMARIES() { return GetToken(CypherParser.PRIMARIES, 0); }
		public PrimaryTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_primaryToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitPrimaryToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public PrimaryTokenContext primaryToken() {
		PrimaryTokenContext _localctx = new PrimaryTokenContext(Context, State);
		EnterRule(_localctx, 658, RULE_primaryToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3927;
			_la = TokenStream.LA(1);
			if ( !(_la==PRIMARY || _la==PRIMARIES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SecondaryTopologyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public UIntOrIntParameterContext uIntOrIntParameter() {
			return GetRuleContext<UIntOrIntParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SecondaryTokenContext secondaryToken() {
			return GetRuleContext<SecondaryTokenContext>(0);
		}
		public SecondaryTopologyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_secondaryTopology; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSecondaryTopology(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SecondaryTopologyContext secondaryTopology() {
		SecondaryTopologyContext _localctx = new SecondaryTopologyContext(Context, State);
		EnterRule(_localctx, 660, RULE_secondaryTopology);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3929;
			uIntOrIntParameter();
			State = 3930;
			secondaryToken();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SecondaryTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SECONDARY() { return GetToken(CypherParser.SECONDARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SECONDARIES() { return GetToken(CypherParser.SECONDARIES, 0); }
		public SecondaryTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_secondaryToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSecondaryToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SecondaryTokenContext secondaryToken() {
		SecondaryTokenContext _localctx = new SecondaryTokenContext(Context, State);
		EnterRule(_localctx, 662, RULE_secondaryToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3932;
			_la = TokenStream.LA(1);
			if ( !(_la==SECONDARY || _la==SECONDARIES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ReplicaTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REPLICA() { return GetToken(CypherParser.REPLICA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REPLICAS() { return GetToken(CypherParser.REPLICAS, 0); }
		public ReplicaTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_replicaToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitReplicaToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ReplicaTokenContext replicaToken() {
		ReplicaTokenContext _localctx = new ReplicaTokenContext(Context, State);
		EnterRule(_localctx, 664, RULE_replicaToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3934;
			_la = TokenStream.LA(1);
			if ( !(_la==REPLICA || _la==REPLICAS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DefaultLanguageSpecificationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(CypherParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LANGUAGE() { return GetToken(CypherParser.LANGUAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CYPHER() { return GetToken(CypherParser.CYPHER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNSIGNED_DECIMAL_INTEGER() { return GetToken(CypherParser.UNSIGNED_DECIMAL_INTEGER, 0); }
		public DefaultLanguageSpecificationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_defaultLanguageSpecification; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDefaultLanguageSpecification(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DefaultLanguageSpecificationContext defaultLanguageSpecification() {
		DefaultLanguageSpecificationContext _localctx = new DefaultLanguageSpecificationContext(Context, State);
		EnterRule(_localctx, 666, RULE_defaultLanguageSpecification);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3936;
			Match(DEFAULT);
			State = 3937;
			Match(LANGUAGE);
			State = 3938;
			Match(CYPHER);
			State = 3939;
			Match(UNSIGNED_DECIMAL_INTEGER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropDatabaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicAliasNameOrParameterContext symbolicAliasNameOrParameter() {
			return GetRuleContext<SymbolicAliasNameOrParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPOSITE() { return GetToken(CypherParser.COMPOSITE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CypherParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AliasActionContext aliasAction() {
			return GetRuleContext<AliasActionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATA() { return GetToken(CypherParser.DATA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public WaitClauseContext waitClause() {
			return GetRuleContext<WaitClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DUMP() { return GetToken(CypherParser.DUMP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DESTROY() { return GetToken(CypherParser.DESTROY, 0); }
		public DropDatabaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropDatabase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDropDatabase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DropDatabaseContext dropDatabase() {
		DropDatabaseContext _localctx = new DropDatabaseContext(Context, State);
		EnterRule(_localctx, 668, RULE_dropDatabase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3942;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==COMPOSITE) {
				{
				State = 3941;
				Match(COMPOSITE);
				}
			}

			State = 3944;
			Match(DATABASE);
			State = 3945;
			symbolicAliasNameOrParameter();
			State = 3948;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 3946;
				Match(IF);
				State = 3947;
				Match(EXISTS);
				}
			}

			State = 3951;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==CASCADE || _la==RESTRICT) {
				{
				State = 3950;
				aliasAction();
				}
			}

			State = 3955;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==DESTROY || _la==DUMP) {
				{
				State = 3953;
				_la = TokenStream.LA(1);
				if ( !(_la==DESTROY || _la==DUMP) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 3954;
				Match(DATA);
				}
			}

			State = 3958;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOWAIT || _la==WAIT) {
				{
				State = 3957;
				waitClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AliasActionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RESTRICT() { return GetToken(CypherParser.RESTRICT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASCADE() { return GetToken(CypherParser.CASCADE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALIAS() { return GetToken(CypherParser.ALIAS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALIASES() { return GetToken(CypherParser.ALIASES, 0); }
		public AliasActionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_aliasAction; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAliasAction(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AliasActionContext aliasAction() {
		AliasActionContext _localctx = new AliasActionContext(Context, State);
		EnterRule(_localctx, 670, RULE_aliasAction);
		int _la;
		try {
			State = 3963;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case RESTRICT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 3960;
				Match(RESTRICT);
				}
				break;
			case CASCADE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 3961;
				Match(CASCADE);
				State = 3962;
				_la = TokenStream.LA(1);
				if ( !(_la==ALIAS || _la==ALIASES) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterDatabaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicAliasNameOrParameterContext symbolicAliasNameOrParameter() {
			return GetRuleContext<SymbolicAliasNameOrParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CypherParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public WaitClauseContext waitClause() {
			return GetRuleContext<WaitClauseContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] SET() { return GetTokens(CypherParser.SET); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET(int i) {
			return GetToken(CypherParser.SET, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] REMOVE() { return GetTokens(CypherParser.REMOVE); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REMOVE(int i) {
			return GetToken(CypherParser.REMOVE, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] OPTION() { return GetTokens(CypherParser.OPTION); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPTION(int i) {
			return GetToken(CypherParser.OPTION, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext[] symbolicNameString() {
			return GetRuleContexts<SymbolicNameStringContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString(int i) {
			return GetRuleContext<SymbolicNameStringContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterDatabaseAccessContext[] alterDatabaseAccess() {
			return GetRuleContexts<AlterDatabaseAccessContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterDatabaseAccessContext alterDatabaseAccess(int i) {
			return GetRuleContext<AlterDatabaseAccessContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterDatabaseTopologyContext[] alterDatabaseTopology() {
			return GetRuleContexts<AlterDatabaseTopologyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterDatabaseTopologyContext alterDatabaseTopology(int i) {
			return GetRuleContext<AlterDatabaseTopologyContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterReplicaTopologyContext[] alterReplicaTopology() {
			return GetRuleContexts<AlterReplicaTopologyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterReplicaTopologyContext alterReplicaTopology(int i) {
			return GetRuleContext<AlterReplicaTopologyContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterGraphShardContext[] alterGraphShard() {
			return GetRuleContexts<AlterGraphShardContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterGraphShardContext alterGraphShard(int i) {
			return GetRuleContext<AlterGraphShardContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterPropertyShardsContext[] alterPropertyShards() {
			return GetRuleContexts<AlterPropertyShardsContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterPropertyShardsContext alterPropertyShards(int i) {
			return GetRuleContext<AlterPropertyShardsContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterDatabaseOptionContext[] alterDatabaseOption() {
			return GetRuleContexts<AlterDatabaseOptionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterDatabaseOptionContext alterDatabaseOption(int i) {
			return GetRuleContext<AlterDatabaseOptionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultLanguageSpecificationContext[] defaultLanguageSpecification() {
			return GetRuleContexts<DefaultLanguageSpecificationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultLanguageSpecificationContext defaultLanguageSpecification(int i) {
			return GetRuleContext<DefaultLanguageSpecificationContext>(i);
		}
		public AlterDatabaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterDatabase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterDatabase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterDatabaseContext alterDatabase() {
		AlterDatabaseContext _localctx = new AlterDatabaseContext(Context, State);
		EnterRule(_localctx, 672, RULE_alterDatabase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3965;
			Match(DATABASE);
			State = 3966;
			symbolicAliasNameOrParameter();
			State = 3969;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 3967;
				Match(IF);
				State = 3968;
				Match(EXISTS);
				}
			}

			State = 3992;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case SET:
				{
				State = 3981;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 3971;
					Match(SET);
					State = 3979;
					ErrorHandler.Sync(this);
					switch ( Interpreter.AdaptivePredict(TokenStream,494,Context) ) {
					case 1:
						{
						State = 3972;
						alterDatabaseAccess();
						}
						break;
					case 2:
						{
						State = 3973;
						alterDatabaseTopology();
						}
						break;
					case 3:
						{
						State = 3974;
						alterReplicaTopology();
						}
						break;
					case 4:
						{
						State = 3975;
						alterGraphShard();
						}
						break;
					case 5:
						{
						State = 3976;
						alterPropertyShards();
						}
						break;
					case 6:
						{
						State = 3977;
						alterDatabaseOption();
						}
						break;
					case 7:
						{
						State = 3978;
						defaultLanguageSpecification();
						}
						break;
					}
					}
					}
					State = 3983;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==SET );
				}
				break;
			case REMOVE:
				{
				State = 3988;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				do {
					{
					{
					State = 3985;
					Match(REMOVE);
					State = 3986;
					Match(OPTION);
					State = 3987;
					symbolicNameString();
					}
					}
					State = 3990;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				} while ( _la==REMOVE );
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
			State = 3995;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOWAIT || _la==WAIT) {
				{
				State = 3994;
				waitClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterDatabaseAccessContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ACCESS() { return GetToken(CypherParser.ACCESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode READ() { return GetToken(CypherParser.READ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ONLY() { return GetToken(CypherParser.ONLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WRITE() { return GetToken(CypherParser.WRITE, 0); }
		public AlterDatabaseAccessContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterDatabaseAccess; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterDatabaseAccess(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterDatabaseAccessContext alterDatabaseAccess() {
		AlterDatabaseAccessContext _localctx = new AlterDatabaseAccessContext(Context, State);
		EnterRule(_localctx, 674, RULE_alterDatabaseAccess);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 3997;
			Match(ACCESS);
			State = 3998;
			Match(READ);
			State = 3999;
			_la = TokenStream.LA(1);
			if ( !(_la==ONLY || _la==WRITE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterDatabaseTopologyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TOPOLOGY() { return GetToken(CypherParser.TOPOLOGY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PrimaryTopologyContext[] primaryTopology() {
			return GetRuleContexts<PrimaryTopologyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PrimaryTopologyContext primaryTopology(int i) {
			return GetRuleContext<PrimaryTopologyContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public SecondaryTopologyContext[] secondaryTopology() {
			return GetRuleContexts<SecondaryTopologyContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SecondaryTopologyContext secondaryTopology(int i) {
			return GetRuleContext<SecondaryTopologyContext>(i);
		}
		public AlterDatabaseTopologyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterDatabaseTopology; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterDatabaseTopology(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterDatabaseTopologyContext alterDatabaseTopology() {
		AlterDatabaseTopologyContext _localctx = new AlterDatabaseTopologyContext(Context, State);
		EnterRule(_localctx, 676, RULE_alterDatabaseTopology);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4001;
			Match(TOPOLOGY);
			State = 4004;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 4004;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,499,Context) ) {
				case 1:
					{
					State = 4002;
					primaryTopology();
					}
					break;
				case 2:
					{
					State = 4003;
					secondaryTopology();
					}
					break;
				}
				}
				State = 4006;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==UNSIGNED_DECIMAL_INTEGER || _la==DOLLAR );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterDatabaseOptionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPTION() { return GetToken(CypherParser.OPTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString() {
			return GetRuleContext<SymbolicNameStringContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		public AlterDatabaseOptionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterDatabaseOption; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterDatabaseOption(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterDatabaseOptionContext alterDatabaseOption() {
		AlterDatabaseOptionContext _localctx = new AlterDatabaseOptionContext(Context, State);
		EnterRule(_localctx, 678, RULE_alterDatabaseOption);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4008;
			Match(OPTION);
			State = 4009;
			symbolicNameString();
			State = 4010;
			expression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterGraphShardContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GRAPH() { return GetToken(CypherParser.GRAPH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARD() { return GetToken(CypherParser.SHARD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CypherParser.LCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(CypherParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AlterDatabaseTopologyContext alterDatabaseTopology() {
			return GetRuleContext<AlterDatabaseTopologyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CypherParser.RCURLY, 0); }
		public AlterGraphShardContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterGraphShard; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterGraphShard(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterGraphShardContext alterGraphShard() {
		AlterGraphShardContext _localctx = new AlterGraphShardContext(Context, State);
		EnterRule(_localctx, 680, RULE_alterGraphShard);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4012;
			Match(GRAPH);
			State = 4013;
			Match(SHARD);
			State = 4014;
			Match(LCURLY);
			State = 4015;
			Match(SET);
			State = 4016;
			alterDatabaseTopology();
			State = 4017;
			Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterPropertyShardsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROPERTY() { return GetToken(CypherParser.PROPERTY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CypherParser.LCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(CypherParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AlterReplicaTopologyContext alterReplicaTopology() {
			return GetRuleContext<AlterReplicaTopologyContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CypherParser.RCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARD() { return GetToken(CypherParser.SHARD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARDS() { return GetToken(CypherParser.SHARDS, 0); }
		public AlterPropertyShardsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterPropertyShards; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterPropertyShards(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterPropertyShardsContext alterPropertyShards() {
		AlterPropertyShardsContext _localctx = new AlterPropertyShardsContext(Context, State);
		EnterRule(_localctx, 682, RULE_alterPropertyShards);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4019;
			Match(PROPERTY);
			State = 4020;
			_la = TokenStream.LA(1);
			if ( !(_la==SHARD || _la==SHARDS) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4021;
			Match(LCURLY);
			State = 4022;
			Match(SET);
			State = 4023;
			alterReplicaTopology();
			State = 4024;
			Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterReplicaTopologyContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TOPOLOGY() { return GetToken(CypherParser.TOPOLOGY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public UIntOrIntParameterContext uIntOrIntParameter() {
			return GetRuleContext<UIntOrIntParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ReplicaTokenContext replicaToken() {
			return GetRuleContext<ReplicaTokenContext>(0);
		}
		public AlterReplicaTopologyContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterReplicaTopology; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterReplicaTopology(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterReplicaTopologyContext alterReplicaTopology() {
		AlterReplicaTopologyContext _localctx = new AlterReplicaTopologyContext(Context, State);
		EnterRule(_localctx, 684, RULE_alterReplicaTopology);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4026;
			Match(TOPOLOGY);
			State = 4027;
			uIntOrIntParameter();
			State = 4028;
			replicaToken();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StartDatabaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode START() { return GetToken(CypherParser.START, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicAliasNameOrParameterContext symbolicAliasNameOrParameter() {
			return GetRuleContext<SymbolicAliasNameOrParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WaitClauseContext waitClause() {
			return GetRuleContext<WaitClauseContext>(0);
		}
		public StartDatabaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_startDatabase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStartDatabase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StartDatabaseContext startDatabase() {
		StartDatabaseContext _localctx = new StartDatabaseContext(Context, State);
		EnterRule(_localctx, 686, RULE_startDatabase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4030;
			Match(START);
			State = 4031;
			Match(DATABASE);
			State = 4032;
			symbolicAliasNameOrParameter();
			State = 4034;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOWAIT || _la==WAIT) {
				{
				State = 4033;
				waitClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StopDatabaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STOP() { return GetToken(CypherParser.STOP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicAliasNameOrParameterContext symbolicAliasNameOrParameter() {
			return GetRuleContext<SymbolicAliasNameOrParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public WaitClauseContext waitClause() {
			return GetRuleContext<WaitClauseContext>(0);
		}
		public StopDatabaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stopDatabase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStopDatabase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StopDatabaseContext stopDatabase() {
		StopDatabaseContext _localctx = new StopDatabaseContext(Context, State);
		EnterRule(_localctx, 688, RULE_stopDatabase);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4036;
			Match(STOP);
			State = 4037;
			Match(DATABASE);
			State = 4038;
			symbolicAliasNameOrParameter();
			State = 4040;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==NOWAIT || _la==WAIT) {
				{
				State = 4039;
				waitClause();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class WaitClauseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WAIT() { return GetToken(CypherParser.WAIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNSIGNED_DECIMAL_INTEGER() { return GetToken(CypherParser.UNSIGNED_DECIMAL_INTEGER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SecondsTokenContext secondsToken() {
			return GetRuleContext<SecondsTokenContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOWAIT() { return GetToken(CypherParser.NOWAIT, 0); }
		public WaitClauseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_waitClause; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitWaitClause(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public WaitClauseContext waitClause() {
		WaitClauseContext _localctx = new WaitClauseContext(Context, State);
		EnterRule(_localctx, 690, RULE_waitClause);
		int _la;
		try {
			State = 4050;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case WAIT:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4042;
				Match(WAIT);
				State = 4047;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==UNSIGNED_DECIMAL_INTEGER) {
					{
					State = 4043;
					Match(UNSIGNED_DECIMAL_INTEGER);
					State = 4045;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
					if (((((_la - 265)) & ~0x3f) == 0 && ((1L << (_la - 265)) & ((1L << (SEC - 265)) | (1L << (SECOND - 265)) | (1L << (SECONDS - 265)))) != 0)) {
						{
						State = 4044;
						secondsToken();
						}
					}

					}
				}

				}
				break;
			case NOWAIT:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4049;
				Match(NOWAIT);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SecondsTokenContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEC() { return GetToken(CypherParser.SEC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SECOND() { return GetToken(CypherParser.SECOND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SECONDS() { return GetToken(CypherParser.SECONDS, 0); }
		public SecondsTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_secondsToken; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSecondsToken(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SecondsTokenContext secondsToken() {
		SecondsTokenContext _localctx = new SecondsTokenContext(Context, State);
		EnterRule(_localctx, 692, RULE_secondsToken);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4052;
			_la = TokenStream.LA(1);
			if ( !(((((_la - 265)) & ~0x3f) == 0 && ((1L << (_la - 265)) & ((1L << (SEC - 265)) | (1L << (SECOND - 265)) | (1L << (SECONDS - 265)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowDatabaseContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(CypherParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HOME() { return GetToken(CypherParser.HOME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ShowCommandYieldContext showCommandYield() {
			return GetRuleContext<ShowCommandYieldContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASES() { return GetToken(CypherParser.DATABASES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicAliasNameOrParameterContext symbolicAliasNameOrParameter() {
			return GetRuleContext<SymbolicAliasNameOrParameterContext>(0);
		}
		public ShowDatabaseContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showDatabase; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowDatabase(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowDatabaseContext showDatabase() {
		ShowDatabaseContext _localctx = new ShowDatabaseContext(Context, State);
		EnterRule(_localctx, 694, RULE_showDatabase);
		int _la;
		try {
			State = 4066;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case DEFAULT:
			case HOME:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4054;
				_la = TokenStream.LA(1);
				if ( !(_la==DEFAULT || _la==HOME) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4055;
				Match(DATABASE);
				State = 4057;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHERE || _la==YIELD) {
					{
					State = 4056;
					showCommandYield();
					}
				}

				}
				break;
			case DATABASE:
			case DATABASES:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4059;
				_la = TokenStream.LA(1);
				if ( !(_la==DATABASE || _la==DATABASES) ) {
				ErrorHandler.RecoverInline(this);
				}
				else {
					ErrorHandler.ReportMatch(this);
				    Consume();
				}
				State = 4061;
				ErrorHandler.Sync(this);
				switch ( Interpreter.AdaptivePredict(TokenStream,507,Context) ) {
				case 1:
					{
					State = 4060;
					symbolicAliasNameOrParameter();
					}
					break;
				}
				State = 4064;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==WHERE || _la==YIELD) {
					{
					State = 4063;
					showCommandYield();
					}
				}

				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AliasNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicAliasNameOrParameterContext symbolicAliasNameOrParameter() {
			return GetRuleContext<SymbolicAliasNameOrParameterContext>(0);
		}
		public AliasNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_aliasName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAliasName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AliasNameContext aliasName() {
		AliasNameContext _localctx = new AliasNameContext(Context, State);
		EnterRule(_localctx, 696, RULE_aliasName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4068;
			symbolicAliasNameOrParameter();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AliasTargetNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicAliasNameOrParameterContext symbolicAliasNameOrParameter() {
			return GetRuleContext<SymbolicAliasNameOrParameterContext>(0);
		}
		public AliasTargetNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_aliasTargetName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAliasTargetName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AliasTargetNameContext aliasTargetName() {
		AliasTargetNameContext _localctx = new AliasTargetNameContext(Context, State);
		EnterRule(_localctx, 698, RULE_aliasTargetName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4070;
			symbolicAliasNameOrParameter();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CreateAliasContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALIAS() { return GetToken(CypherParser.ALIAS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AliasNameContext aliasName() {
			return GetRuleContext<AliasNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(CypherParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AliasTargetNameContext aliasTargetName() {
			return GetRuleContext<AliasTargetNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CypherParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(CypherParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AT() { return GetToken(CypherParser.AT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StringOrParameterContext stringOrParameter() {
			return GetRuleContext<StringOrParameterContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public RemoteTargetConnectionCredentialsContext remoteTargetConnectionCredentials() {
			return GetRuleContext<RemoteTargetConnectionCredentialsContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROPERTIES() { return GetToken(CypherParser.PROPERTIES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public MapOrParameterContext[] mapOrParameter() {
			return GetRuleContexts<MapOrParameterContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public MapOrParameterContext mapOrParameter(int i) {
			return GetRuleContext<MapOrParameterContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DRIVER() { return GetToken(CypherParser.DRIVER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DefaultLanguageSpecificationContext defaultLanguageSpecification() {
			return GetRuleContext<DefaultLanguageSpecificationContext>(0);
		}
		public CreateAliasContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_createAlias; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCreateAlias(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CreateAliasContext createAlias() {
		CreateAliasContext _localctx = new CreateAliasContext(Context, State);
		EnterRule(_localctx, 700, RULE_createAlias);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4072;
			Match(ALIAS);
			State = 4073;
			aliasName();
			State = 4077;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 4074;
				Match(IF);
				State = 4075;
				Match(NOT);
				State = 4076;
				Match(EXISTS);
				}
			}

			State = 4079;
			Match(FOR);
			State = 4080;
			Match(DATABASE);
			State = 4081;
			aliasTargetName();
			State = 4092;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AT) {
				{
				State = 4082;
				Match(AT);
				State = 4083;
				stringOrParameter();
				State = 4084;
				remoteTargetConnectionCredentials();
				State = 4087;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DRIVER) {
					{
					State = 4085;
					Match(DRIVER);
					State = 4086;
					mapOrParameter();
					}
				}

				State = 4090;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				if (_la==DEFAULT) {
					{
					State = 4089;
					defaultLanguageSpecification();
					}
				}

				}
			}

			State = 4096;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==PROPERTIES) {
				{
				State = 4094;
				Match(PROPERTIES);
				State = 4095;
				mapOrParameter();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class RemoteTargetConnectionCredentialsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(CypherParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CommandNameExpressionContext commandNameExpression() {
			return GetRuleContext<CommandNameExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSWORD() { return GetToken(CypherParser.PASSWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PasswordExpressionContext passwordExpression() {
			return GetRuleContext<PasswordExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OIDC() { return GetToken(CypherParser.OIDC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CREDENTIAL() { return GetToken(CypherParser.CREDENTIAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORWARDING() { return GetToken(CypherParser.FORWARDING, 0); }
		public RemoteTargetConnectionCredentialsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_remoteTargetConnectionCredentials; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitRemoteTargetConnectionCredentials(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public RemoteTargetConnectionCredentialsContext remoteTargetConnectionCredentials() {
		RemoteTargetConnectionCredentialsContext _localctx = new RemoteTargetConnectionCredentialsContext(Context, State);
		EnterRule(_localctx, 702, RULE_remoteTargetConnectionCredentials);
		try {
			State = 4106;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case USER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4098;
				Match(USER);
				State = 4099;
				commandNameExpression();
				State = 4100;
				Match(PASSWORD);
				State = 4101;
				passwordExpression();
				}
				break;
			case OIDC:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4103;
				Match(OIDC);
				State = 4104;
				Match(CREDENTIAL);
				State = 4105;
				Match(FORWARDING);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DropAliasContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALIAS() { return GetToken(CypherParser.ALIAS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AliasNameContext aliasName() {
			return GetRuleContext<AliasNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(CypherParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CypherParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		public DropAliasContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dropAlias; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDropAlias(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DropAliasContext dropAlias() {
		DropAliasContext _localctx = new DropAliasContext(Context, State);
		EnterRule(_localctx, 704, RULE_dropAlias);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4108;
			Match(ALIAS);
			State = 4109;
			aliasName();
			State = 4112;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 4110;
				Match(IF);
				State = 4111;
				Match(EXISTS);
				}
			}

			State = 4114;
			Match(FOR);
			State = 4115;
			Match(DATABASE);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterAliasContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALIAS() { return GetToken(CypherParser.ALIAS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AliasNameContext aliasName() {
			return GetRuleContext<AliasNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(CypherParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CypherParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AlterAliasTargetContext[] alterAliasTarget() {
			return GetRuleContexts<AlterAliasTargetContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterAliasTargetContext alterAliasTarget(int i) {
			return GetRuleContext<AlterAliasTargetContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterAliasUserContext[] alterAliasUser() {
			return GetRuleContexts<AlterAliasUserContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterAliasUserContext alterAliasUser(int i) {
			return GetRuleContext<AlterAliasUserContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterAliasPasswordContext[] alterAliasPassword() {
			return GetRuleContexts<AlterAliasPasswordContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterAliasPasswordContext alterAliasPassword(int i) {
			return GetRuleContext<AlterAliasPasswordContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterAliasDriverContext[] alterAliasDriver() {
			return GetRuleContexts<AlterAliasDriverContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterAliasDriverContext alterAliasDriver(int i) {
			return GetRuleContext<AlterAliasDriverContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterAliasPropertiesContext[] alterAliasProperties() {
			return GetRuleContexts<AlterAliasPropertiesContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public AlterAliasPropertiesContext alterAliasProperties(int i) {
			return GetRuleContext<AlterAliasPropertiesContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultLanguageSpecificationContext[] defaultLanguageSpecification() {
			return GetRuleContexts<DefaultLanguageSpecificationContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DefaultLanguageSpecificationContext defaultLanguageSpecification(int i) {
			return GetRuleContext<DefaultLanguageSpecificationContext>(i);
		}
		public AlterAliasContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterAlias; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterAlias(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterAliasContext alterAlias() {
		AlterAliasContext _localctx = new AlterAliasContext(Context, State);
		EnterRule(_localctx, 706, RULE_alterAlias);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4117;
			Match(ALIAS);
			State = 4118;
			aliasName();
			State = 4121;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==IF) {
				{
				State = 4119;
				Match(IF);
				State = 4120;
				Match(EXISTS);
				}
			}

			State = 4123;
			Match(SET);
			State = 4124;
			Match(DATABASE);
			State = 4131;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				State = 4131;
				ErrorHandler.Sync(this);
				switch (TokenStream.LA(1)) {
				case TARGET:
					{
					State = 4125;
					alterAliasTarget();
					}
					break;
				case USER:
					{
					State = 4126;
					alterAliasUser();
					}
					break;
				case PASSWORD:
					{
					State = 4127;
					alterAliasPassword();
					}
					break;
				case DRIVER:
					{
					State = 4128;
					alterAliasDriver();
					}
					break;
				case PROPERTIES:
					{
					State = 4129;
					alterAliasProperties();
					}
					break;
				case DEFAULT:
					{
					State = 4130;
					defaultLanguageSpecification();
					}
					break;
				default:
					throw new NoViableAltException(this);
				}
				}
				State = 4133;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==DEFAULT || _la==DRIVER || _la==PASSWORD || _la==PROPERTIES || _la==TARGET || _la==USER );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterAliasTargetContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TARGET() { return GetToken(CypherParser.TARGET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AliasTargetNameContext aliasTargetName() {
			return GetRuleContext<AliasTargetNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AT() { return GetToken(CypherParser.AT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StringOrParameterContext stringOrParameter() {
			return GetRuleContext<StringOrParameterContext>(0);
		}
		public AlterAliasTargetContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterAliasTarget; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterAliasTarget(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterAliasTargetContext alterAliasTarget() {
		AlterAliasTargetContext _localctx = new AlterAliasTargetContext(Context, State);
		EnterRule(_localctx, 708, RULE_alterAliasTarget);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4135;
			Match(TARGET);
			State = 4136;
			aliasTargetName();
			State = 4139;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==AT) {
				{
				State = 4137;
				Match(AT);
				State = 4138;
				stringOrParameter();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterAliasUserContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(CypherParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public CommandNameExpressionContext commandNameExpression() {
			return GetRuleContext<CommandNameExpressionContext>(0);
		}
		public AlterAliasUserContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterAliasUser; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterAliasUser(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterAliasUserContext alterAliasUser() {
		AlterAliasUserContext _localctx = new AlterAliasUserContext(Context, State);
		EnterRule(_localctx, 710, RULE_alterAliasUser);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4141;
			Match(USER);
			State = 4142;
			commandNameExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterAliasPasswordContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSWORD() { return GetToken(CypherParser.PASSWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PasswordExpressionContext passwordExpression() {
			return GetRuleContext<PasswordExpressionContext>(0);
		}
		public AlterAliasPasswordContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterAliasPassword; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterAliasPassword(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterAliasPasswordContext alterAliasPassword() {
		AlterAliasPasswordContext _localctx = new AlterAliasPasswordContext(Context, State);
		EnterRule(_localctx, 712, RULE_alterAliasPassword);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4144;
			Match(PASSWORD);
			State = 4145;
			passwordExpression();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterAliasDriverContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DRIVER() { return GetToken(CypherParser.DRIVER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public MapOrParameterContext mapOrParameter() {
			return GetRuleContext<MapOrParameterContext>(0);
		}
		public AlterAliasDriverContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterAliasDriver; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterAliasDriver(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterAliasDriverContext alterAliasDriver() {
		AlterAliasDriverContext _localctx = new AlterAliasDriverContext(Context, State);
		EnterRule(_localctx, 714, RULE_alterAliasDriver);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4147;
			Match(DRIVER);
			State = 4148;
			mapOrParameter();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AlterAliasPropertiesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROPERTIES() { return GetToken(CypherParser.PROPERTIES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public MapOrParameterContext mapOrParameter() {
			return GetRuleContext<MapOrParameterContext>(0);
		}
		public AlterAliasPropertiesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_alterAliasProperties; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitAlterAliasProperties(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public AlterAliasPropertiesContext alterAliasProperties() {
		AlterAliasPropertiesContext _localctx = new AlterAliasPropertiesContext(Context, State);
		EnterRule(_localctx, 716, RULE_alterAliasProperties);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4150;
			Match(PROPERTIES);
			State = 4151;
			mapOrParameter();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ShowAliasesContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(CypherParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALIAS() { return GetToken(CypherParser.ALIAS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALIASES() { return GetToken(CypherParser.ALIASES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASES() { return GetToken(CypherParser.DATABASES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public AliasNameContext aliasName() {
			return GetRuleContext<AliasNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ShowCommandYieldContext showCommandYield() {
			return GetRuleContext<ShowCommandYieldContext>(0);
		}
		public ShowAliasesContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_showAliases; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitShowAliases(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ShowAliasesContext showAliases() {
		ShowAliasesContext _localctx = new ShowAliasesContext(Context, State);
		EnterRule(_localctx, 718, RULE_showAliases);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4153;
			_la = TokenStream.LA(1);
			if ( !(_la==ALIAS || _la==ALIASES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4155;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,521,Context) ) {
			case 1:
				{
				State = 4154;
				aliasName();
				}
				break;
			}
			State = 4157;
			Match(FOR);
			State = 4158;
			_la = TokenStream.LA(1);
			if ( !(_la==DATABASE || _la==DATABASES) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 4160;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==WHERE || _la==YIELD) {
				{
				State = 4159;
				showCommandYield();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SymbolicNameOrStringParameterContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString() {
			return GetRuleContext<SymbolicNameStringContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParameterContext parameter() {
			return GetRuleContext<ParameterContext>(0);
		}
		public SymbolicNameOrStringParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_symbolicNameOrStringParameter; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSymbolicNameOrStringParameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SymbolicNameOrStringParameterContext symbolicNameOrStringParameter() {
		SymbolicNameOrStringParameterContext _localctx = new SymbolicNameOrStringParameterContext(Context, State);
		EnterRule(_localctx, 720, RULE_symbolicNameOrStringParameter);
		try {
			State = 4164;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ESCAPED_SYMBOLIC_NAME:
			case ACCESS:
			case ACTIVE:
			case ADD:
			case ADMIN:
			case ADMINISTRATOR:
			case ALIAS:
			case ALIASES:
			case ALL_SHORTEST_PATHS:
			case ALL:
			case ALLREDUCE:
			case ALTER:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASCENDING:
			case ASSIGN:
			case AT:
			case AUTH:
			case BINDINGS:
			case BOOL:
			case BOOLEAN:
			case BOOSTED:
			case BOTH:
			case BREAK:
			case BUILT:
			case BY:
			case CALL:
			case CASCADE:
			case CASE:
			case CHANGE:
			case CIDR:
			case COLLECT:
			case COMMAND:
			case COMMANDS:
			case COMPOSITE:
			case CONCURRENT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONTAINS:
			case COPY:
			case CONTINUE:
			case COSINE:
			case COUNT:
			case CREATE:
			case CREDENTIAL:
			case CSV:
			case CURRENT:
			case CYPHER:
			case DATA:
			case DATABASE:
			case DATABASES:
			case DATE:
			case DATETIME:
			case DBMS:
			case DEALLOCATE:
			case DEFAULT:
			case DEFINED:
			case DELETE:
			case DENY:
			case DESC:
			case DESCENDING:
			case DESTROY:
			case DETACH:
			case DIFFERENT:
			case DISTINCT:
			case DOT_METRIC:
			case DRIVER:
			case DROP:
			case DRYRUN:
			case DUMP:
			case DURATION:
			case EACH:
			case EDGE:
			case ENABLE:
			case ELEMENT:
			case ELEMENTS:
			case ELSE:
			case ENCRYPTED:
			case EUCLIDEAN:
			case EUCLIDEAN_SQUARED:
			case END:
			case ENDS:
			case EXECUTABLE:
			case EXECUTE:
			case EXIST:
			case EXISTENCE:
			case EXISTS:
			case ERROR:
			case FAIL:
			case FALSE:
			case FIELDTERMINATOR:
			case FILTER:
			case FINISH:
			case FLOAT:
			case FLOAT64:
			case FLOAT32:
			case FOR:
			case FOREACH:
			case FORWARDING:
			case FROM:
			case FULLTEXT:
			case FUNCTION:
			case FUNCTIONS:
			case GRANT:
			case GRAPH:
			case GRAPHS:
			case GROUP:
			case GROUPS:
			case HAMMING:
			case HEADERS:
			case HOME:
			case ID:
			case IF:
			case IMPERSONATE:
			case IMMUTABLE:
			case IN:
			case INDEX:
			case INDEXES:
			case INF:
			case INFINITY:
			case INSERT:
			case INT:
			case INT64:
			case INT32:
			case INT16:
			case INT8:
			case INTEGER:
			case INTEGER64:
			case INTEGER32:
			case INTEGER16:
			case INTEGER8:
			case IS:
			case JOIN:
			case KEY:
			case LABEL:
			case LABELS:
			case LANGUAGE:
			case LEADING:
			case LET:
			case LIMITROWS:
			case LIST:
			case LOAD:
			case LOCAL:
			case LOOKUP:
			case MANAGEMENT:
			case MANHATTAN:
			case MAP:
			case MATCH:
			case MERGE:
			case IMPLIES:
			case NAME:
			case NAMES:
			case NAN:
			case NFC:
			case NFD:
			case NFKC:
			case NFKD:
			case NEW:
			case NEXT:
			case NODE:
			case NODETACH:
			case NODES:
			case NONE:
			case NORMALIZE:
			case NORMALIZED:
			case NOT:
			case NOTHING:
			case NOWAIT:
			case NULL:
			case OF:
			case OFFSET:
			case OIDC:
			case ON:
			case ONLY:
			case OPTIONAL:
			case OPTIONS:
			case OPTION:
			case OR:
			case ORDER:
			case PASSWORD:
			case PASSWORDS:
			case PATH:
			case PATHS:
			case PLAINTEXT:
			case POINT:
			case POPULATED:
			case PRIMARY:
			case PRIMARIES:
			case PRIVILEGE:
			case PRIVILEGES:
			case PROCEDURE:
			case PROCEDURES:
			case PROPERTIES:
			case PROPERTY:
			case PROVIDER:
			case PROVIDERS:
			case RANGE:
			case READ:
			case REALLOCATE:
			case REDUCE:
			case RENAME:
			case REL:
			case RELATIONSHIP:
			case RELATIONSHIPS:
			case REMOVE:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case REPLICAS:
			case REPORT:
			case REQUIRE:
			case REQUIRED:
			case RESTRICT:
			case RETRY:
			case RETURN:
			case REVOKE:
			case ROLE:
			case ROLES:
			case ROW:
			case ROWS:
			case SCAN:
			case SEC:
			case SECOND:
			case SECONDARY:
			case SECONDARIES:
			case SECONDS:
			case SEEK:
			case SERVER:
			case SERVERS:
			case SET:
			case SETTING:
			case SETTINGS:
			case SHARD:
			case SHARDS:
			case SHORTEST_PATH:
			case SHORTEST:
			case SHOW:
			case SIGNED:
			case SINGLE:
			case SKIPROWS:
			case START:
			case STARTS:
			case STATUS:
			case STOP:
			case STRING:
			case SUPPORTED:
			case SUSPENDED:
			case TARGET:
			case TERMINATE:
			case TEXT:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE:
			case TO:
			case TOPOLOGY:
			case TRAILING:
			case TRANSACTION:
			case TRANSACTIONS:
			case TRAVERSE:
			case TRIM:
			case TRUE:
			case TYPE:
			case TYPED:
			case TYPES:
			case UNION:
			case UNIQUE:
			case UNIQUENESS:
			case UNWIND:
			case URL:
			case USE:
			case USER:
			case USERS:
			case USING:
			case VALUE:
			case VARCHAR:
			case VECTOR:
			case VECTOR_DISTANCE:
			case VECTOR_NORM:
			case VERTEX:
			case WAIT:
			case WHEN:
			case WHERE:
			case WITH:
			case WITHOUT:
			case WRITE:
			case XOR:
			case YIELD:
			case ZONE:
			case ZONED:
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4162;
				symbolicNameString();
				}
				break;
			case DOLLAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4163;
				parameter("STRING");
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class CommandNameExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString() {
			return GetRuleContext<SymbolicNameStringContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParameterContext parameter() {
			return GetRuleContext<ParameterContext>(0);
		}
		public CommandNameExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_commandNameExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitCommandNameExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public CommandNameExpressionContext commandNameExpression() {
		CommandNameExpressionContext _localctx = new CommandNameExpressionContext(Context, State);
		EnterRule(_localctx, 722, RULE_commandNameExpression);
		try {
			State = 4168;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ESCAPED_SYMBOLIC_NAME:
			case ACCESS:
			case ACTIVE:
			case ADD:
			case ADMIN:
			case ADMINISTRATOR:
			case ALIAS:
			case ALIASES:
			case ALL_SHORTEST_PATHS:
			case ALL:
			case ALLREDUCE:
			case ALTER:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASCENDING:
			case ASSIGN:
			case AT:
			case AUTH:
			case BINDINGS:
			case BOOL:
			case BOOLEAN:
			case BOOSTED:
			case BOTH:
			case BREAK:
			case BUILT:
			case BY:
			case CALL:
			case CASCADE:
			case CASE:
			case CHANGE:
			case CIDR:
			case COLLECT:
			case COMMAND:
			case COMMANDS:
			case COMPOSITE:
			case CONCURRENT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONTAINS:
			case COPY:
			case CONTINUE:
			case COSINE:
			case COUNT:
			case CREATE:
			case CREDENTIAL:
			case CSV:
			case CURRENT:
			case CYPHER:
			case DATA:
			case DATABASE:
			case DATABASES:
			case DATE:
			case DATETIME:
			case DBMS:
			case DEALLOCATE:
			case DEFAULT:
			case DEFINED:
			case DELETE:
			case DENY:
			case DESC:
			case DESCENDING:
			case DESTROY:
			case DETACH:
			case DIFFERENT:
			case DISTINCT:
			case DOT_METRIC:
			case DRIVER:
			case DROP:
			case DRYRUN:
			case DUMP:
			case DURATION:
			case EACH:
			case EDGE:
			case ENABLE:
			case ELEMENT:
			case ELEMENTS:
			case ELSE:
			case ENCRYPTED:
			case EUCLIDEAN:
			case EUCLIDEAN_SQUARED:
			case END:
			case ENDS:
			case EXECUTABLE:
			case EXECUTE:
			case EXIST:
			case EXISTENCE:
			case EXISTS:
			case ERROR:
			case FAIL:
			case FALSE:
			case FIELDTERMINATOR:
			case FILTER:
			case FINISH:
			case FLOAT:
			case FLOAT64:
			case FLOAT32:
			case FOR:
			case FOREACH:
			case FORWARDING:
			case FROM:
			case FULLTEXT:
			case FUNCTION:
			case FUNCTIONS:
			case GRANT:
			case GRAPH:
			case GRAPHS:
			case GROUP:
			case GROUPS:
			case HAMMING:
			case HEADERS:
			case HOME:
			case ID:
			case IF:
			case IMPERSONATE:
			case IMMUTABLE:
			case IN:
			case INDEX:
			case INDEXES:
			case INF:
			case INFINITY:
			case INSERT:
			case INT:
			case INT64:
			case INT32:
			case INT16:
			case INT8:
			case INTEGER:
			case INTEGER64:
			case INTEGER32:
			case INTEGER16:
			case INTEGER8:
			case IS:
			case JOIN:
			case KEY:
			case LABEL:
			case LABELS:
			case LANGUAGE:
			case LEADING:
			case LET:
			case LIMITROWS:
			case LIST:
			case LOAD:
			case LOCAL:
			case LOOKUP:
			case MANAGEMENT:
			case MANHATTAN:
			case MAP:
			case MATCH:
			case MERGE:
			case IMPLIES:
			case NAME:
			case NAMES:
			case NAN:
			case NFC:
			case NFD:
			case NFKC:
			case NFKD:
			case NEW:
			case NEXT:
			case NODE:
			case NODETACH:
			case NODES:
			case NONE:
			case NORMALIZE:
			case NORMALIZED:
			case NOT:
			case NOTHING:
			case NOWAIT:
			case NULL:
			case OF:
			case OFFSET:
			case OIDC:
			case ON:
			case ONLY:
			case OPTIONAL:
			case OPTIONS:
			case OPTION:
			case OR:
			case ORDER:
			case PASSWORD:
			case PASSWORDS:
			case PATH:
			case PATHS:
			case PLAINTEXT:
			case POINT:
			case POPULATED:
			case PRIMARY:
			case PRIMARIES:
			case PRIVILEGE:
			case PRIVILEGES:
			case PROCEDURE:
			case PROCEDURES:
			case PROPERTIES:
			case PROPERTY:
			case PROVIDER:
			case PROVIDERS:
			case RANGE:
			case READ:
			case REALLOCATE:
			case REDUCE:
			case RENAME:
			case REL:
			case RELATIONSHIP:
			case RELATIONSHIPS:
			case REMOVE:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case REPLICAS:
			case REPORT:
			case REQUIRE:
			case REQUIRED:
			case RESTRICT:
			case RETRY:
			case RETURN:
			case REVOKE:
			case ROLE:
			case ROLES:
			case ROW:
			case ROWS:
			case SCAN:
			case SEC:
			case SECOND:
			case SECONDARY:
			case SECONDARIES:
			case SECONDS:
			case SEEK:
			case SERVER:
			case SERVERS:
			case SET:
			case SETTING:
			case SETTINGS:
			case SHARD:
			case SHARDS:
			case SHORTEST_PATH:
			case SHORTEST:
			case SHOW:
			case SIGNED:
			case SINGLE:
			case SKIPROWS:
			case START:
			case STARTS:
			case STATUS:
			case STOP:
			case STRING:
			case SUPPORTED:
			case SUSPENDED:
			case TARGET:
			case TERMINATE:
			case TEXT:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE:
			case TO:
			case TOPOLOGY:
			case TRAILING:
			case TRANSACTION:
			case TRANSACTIONS:
			case TRAVERSE:
			case TRIM:
			case TRUE:
			case TYPE:
			case TYPED:
			case TYPES:
			case UNION:
			case UNIQUE:
			case UNIQUENESS:
			case UNWIND:
			case URL:
			case USE:
			case USER:
			case USERS:
			case USING:
			case VALUE:
			case VARCHAR:
			case VECTOR:
			case VECTOR_DISTANCE:
			case VECTOR_NORM:
			case VERTEX:
			case WAIT:
			case WHEN:
			case WHERE:
			case WITH:
			case WITHOUT:
			case WRITE:
			case XOR:
			case YIELD:
			case ZONE:
			case ZONED:
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4166;
				symbolicNameString();
				}
				break;
			case DOLLAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4167;
				parameter("STRING");
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SymbolicNameOrStringParameterListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public CommandNameExpressionContext[] commandNameExpression() {
			return GetRuleContexts<CommandNameExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public CommandNameExpressionContext commandNameExpression(int i) {
			return GetRuleContext<CommandNameExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public SymbolicNameOrStringParameterListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_symbolicNameOrStringParameterList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSymbolicNameOrStringParameterList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SymbolicNameOrStringParameterListContext symbolicNameOrStringParameterList() {
		SymbolicNameOrStringParameterListContext _localctx = new SymbolicNameOrStringParameterListContext(Context, State);
		EnterRule(_localctx, 724, RULE_symbolicNameOrStringParameterList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4170;
			commandNameExpression();
			State = 4175;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4171;
				Match(COMMA);
				State = 4172;
				commandNameExpression();
				}
				}
				State = 4177;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SymbolicAliasNameListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicAliasNameOrParameterContext[] symbolicAliasNameOrParameter() {
			return GetRuleContexts<SymbolicAliasNameOrParameterContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicAliasNameOrParameterContext symbolicAliasNameOrParameter(int i) {
			return GetRuleContext<SymbolicAliasNameOrParameterContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public SymbolicAliasNameListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_symbolicAliasNameList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSymbolicAliasNameList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SymbolicAliasNameListContext symbolicAliasNameList() {
		SymbolicAliasNameListContext _localctx = new SymbolicAliasNameListContext(Context, State);
		EnterRule(_localctx, 726, RULE_symbolicAliasNameList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4178;
			symbolicAliasNameOrParameter();
			State = 4183;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==COMMA) {
				{
				{
				State = 4179;
				Match(COMMA);
				State = 4180;
				symbolicAliasNameOrParameter();
				}
				}
				State = 4185;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SymbolicAliasNameOrParameterContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicAliasNameContext symbolicAliasName() {
			return GetRuleContext<SymbolicAliasNameContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParameterContext parameter() {
			return GetRuleContext<ParameterContext>(0);
		}
		public SymbolicAliasNameOrParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_symbolicAliasNameOrParameter; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSymbolicAliasNameOrParameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SymbolicAliasNameOrParameterContext symbolicAliasNameOrParameter() {
		SymbolicAliasNameOrParameterContext _localctx = new SymbolicAliasNameOrParameterContext(Context, State);
		EnterRule(_localctx, 728, RULE_symbolicAliasNameOrParameter);
		try {
			State = 4188;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ESCAPED_SYMBOLIC_NAME:
			case ACCESS:
			case ACTIVE:
			case ADD:
			case ADMIN:
			case ADMINISTRATOR:
			case ALIAS:
			case ALIASES:
			case ALL_SHORTEST_PATHS:
			case ALL:
			case ALLREDUCE:
			case ALTER:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASCENDING:
			case ASSIGN:
			case AT:
			case AUTH:
			case BINDINGS:
			case BOOL:
			case BOOLEAN:
			case BOOSTED:
			case BOTH:
			case BREAK:
			case BUILT:
			case BY:
			case CALL:
			case CASCADE:
			case CASE:
			case CHANGE:
			case CIDR:
			case COLLECT:
			case COMMAND:
			case COMMANDS:
			case COMPOSITE:
			case CONCURRENT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONTAINS:
			case COPY:
			case CONTINUE:
			case COSINE:
			case COUNT:
			case CREATE:
			case CREDENTIAL:
			case CSV:
			case CURRENT:
			case CYPHER:
			case DATA:
			case DATABASE:
			case DATABASES:
			case DATE:
			case DATETIME:
			case DBMS:
			case DEALLOCATE:
			case DEFAULT:
			case DEFINED:
			case DELETE:
			case DENY:
			case DESC:
			case DESCENDING:
			case DESTROY:
			case DETACH:
			case DIFFERENT:
			case DISTINCT:
			case DOT_METRIC:
			case DRIVER:
			case DROP:
			case DRYRUN:
			case DUMP:
			case DURATION:
			case EACH:
			case EDGE:
			case ENABLE:
			case ELEMENT:
			case ELEMENTS:
			case ELSE:
			case ENCRYPTED:
			case EUCLIDEAN:
			case EUCLIDEAN_SQUARED:
			case END:
			case ENDS:
			case EXECUTABLE:
			case EXECUTE:
			case EXIST:
			case EXISTENCE:
			case EXISTS:
			case ERROR:
			case FAIL:
			case FALSE:
			case FIELDTERMINATOR:
			case FILTER:
			case FINISH:
			case FLOAT:
			case FLOAT64:
			case FLOAT32:
			case FOR:
			case FOREACH:
			case FORWARDING:
			case FROM:
			case FULLTEXT:
			case FUNCTION:
			case FUNCTIONS:
			case GRANT:
			case GRAPH:
			case GRAPHS:
			case GROUP:
			case GROUPS:
			case HAMMING:
			case HEADERS:
			case HOME:
			case ID:
			case IF:
			case IMPERSONATE:
			case IMMUTABLE:
			case IN:
			case INDEX:
			case INDEXES:
			case INF:
			case INFINITY:
			case INSERT:
			case INT:
			case INT64:
			case INT32:
			case INT16:
			case INT8:
			case INTEGER:
			case INTEGER64:
			case INTEGER32:
			case INTEGER16:
			case INTEGER8:
			case IS:
			case JOIN:
			case KEY:
			case LABEL:
			case LABELS:
			case LANGUAGE:
			case LEADING:
			case LET:
			case LIMITROWS:
			case LIST:
			case LOAD:
			case LOCAL:
			case LOOKUP:
			case MANAGEMENT:
			case MANHATTAN:
			case MAP:
			case MATCH:
			case MERGE:
			case IMPLIES:
			case NAME:
			case NAMES:
			case NAN:
			case NFC:
			case NFD:
			case NFKC:
			case NFKD:
			case NEW:
			case NEXT:
			case NODE:
			case NODETACH:
			case NODES:
			case NONE:
			case NORMALIZE:
			case NORMALIZED:
			case NOT:
			case NOTHING:
			case NOWAIT:
			case NULL:
			case OF:
			case OFFSET:
			case OIDC:
			case ON:
			case ONLY:
			case OPTIONAL:
			case OPTIONS:
			case OPTION:
			case OR:
			case ORDER:
			case PASSWORD:
			case PASSWORDS:
			case PATH:
			case PATHS:
			case PLAINTEXT:
			case POINT:
			case POPULATED:
			case PRIMARY:
			case PRIMARIES:
			case PRIVILEGE:
			case PRIVILEGES:
			case PROCEDURE:
			case PROCEDURES:
			case PROPERTIES:
			case PROPERTY:
			case PROVIDER:
			case PROVIDERS:
			case RANGE:
			case READ:
			case REALLOCATE:
			case REDUCE:
			case RENAME:
			case REL:
			case RELATIONSHIP:
			case RELATIONSHIPS:
			case REMOVE:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case REPLICAS:
			case REPORT:
			case REQUIRE:
			case REQUIRED:
			case RESTRICT:
			case RETRY:
			case RETURN:
			case REVOKE:
			case ROLE:
			case ROLES:
			case ROW:
			case ROWS:
			case SCAN:
			case SEC:
			case SECOND:
			case SECONDARY:
			case SECONDARIES:
			case SECONDS:
			case SEEK:
			case SERVER:
			case SERVERS:
			case SET:
			case SETTING:
			case SETTINGS:
			case SHARD:
			case SHARDS:
			case SHORTEST_PATH:
			case SHORTEST:
			case SHOW:
			case SIGNED:
			case SINGLE:
			case SKIPROWS:
			case START:
			case STARTS:
			case STATUS:
			case STOP:
			case STRING:
			case SUPPORTED:
			case SUSPENDED:
			case TARGET:
			case TERMINATE:
			case TEXT:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE:
			case TO:
			case TOPOLOGY:
			case TRAILING:
			case TRANSACTION:
			case TRANSACTIONS:
			case TRAVERSE:
			case TRIM:
			case TRUE:
			case TYPE:
			case TYPED:
			case TYPES:
			case UNION:
			case UNIQUE:
			case UNIQUENESS:
			case UNWIND:
			case URL:
			case USE:
			case USER:
			case USERS:
			case USING:
			case VALUE:
			case VARCHAR:
			case VECTOR:
			case VECTOR_DISTANCE:
			case VECTOR_NORM:
			case VERTEX:
			case WAIT:
			case WHEN:
			case WHERE:
			case WITH:
			case WITHOUT:
			case WRITE:
			case XOR:
			case YIELD:
			case ZONE:
			case ZONED:
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4186;
				symbolicAliasName();
				}
				break;
			case DOLLAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4187;
				parameter("STRING");
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SymbolicAliasNameContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext[] symbolicNameString() {
			return GetRuleContexts<SymbolicNameStringContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public SymbolicNameStringContext symbolicNameString(int i) {
			return GetRuleContext<SymbolicNameStringContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] DOT() { return GetTokens(CypherParser.DOT); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT(int i) {
			return GetToken(CypherParser.DOT, i);
		}
		public SymbolicAliasNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_symbolicAliasName; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSymbolicAliasName(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SymbolicAliasNameContext symbolicAliasName() {
		SymbolicAliasNameContext _localctx = new SymbolicAliasNameContext(Context, State);
		EnterRule(_localctx, 730, RULE_symbolicAliasName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4190;
			symbolicNameString();
			State = 4195;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==DOT) {
				{
				{
				State = 4191;
				Match(DOT);
				State = 4192;
				symbolicNameString();
				}
				}
				State = 4197;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringListLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LBRACKET() { return GetToken(CypherParser.LBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RBRACKET() { return GetToken(CypherParser.RBRACKET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StringLiteralContext[] stringLiteral() {
			return GetRuleContexts<StringLiteralContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StringLiteralContext stringLiteral(int i) {
			return GetRuleContext<StringLiteralContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public StringListLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stringListLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStringListLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StringListLiteralContext stringListLiteral() {
		StringListLiteralContext _localctx = new StringListLiteralContext(Context, State);
		EnterRule(_localctx, 732, RULE_stringListLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4198;
			Match(LBRACKET);
			State = 4207;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if (_la==STRING_LITERAL1 || _la==STRING_LITERAL2) {
				{
				State = 4199;
				stringLiteral();
				State = 4204;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4200;
					Match(COMMA);
					State = 4201;
					stringLiteral();
					}
					}
					State = 4206;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 4209;
			Match(RBRACKET);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringListContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StringLiteralContext[] stringLiteral() {
			return GetRuleContexts<StringLiteralContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StringLiteralContext stringLiteral(int i) {
			return GetRuleContext<StringLiteralContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public StringListContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stringList; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStringList(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StringListContext stringList() {
		StringListContext _localctx = new StringListContext(Context, State);
		EnterRule(_localctx, 734, RULE_stringList);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4211;
			stringLiteral();
			State = 4214;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 4212;
				Match(COMMA);
				State = 4213;
				stringLiteral();
				}
				}
				State = 4216;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==COMMA );
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringLiteralContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STRING_LITERAL1() { return GetToken(CypherParser.STRING_LITERAL1, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STRING_LITERAL2() { return GetToken(CypherParser.STRING_LITERAL2, 0); }
		public StringLiteralContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stringLiteral; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStringLiteral(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StringLiteralContext stringLiteral() {
		StringLiteralContext _localctx = new StringLiteralContext(Context, State);
		EnterRule(_localctx, 736, RULE_stringLiteral);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4218;
			_la = TokenStream.LA(1);
			if ( !(_la==STRING_LITERAL1 || _la==STRING_LITERAL2) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringOrParameterExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StringLiteralContext stringLiteral() {
			return GetRuleContext<StringLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParameterContext parameter() {
			return GetRuleContext<ParameterContext>(0);
		}
		public StringOrParameterExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stringOrParameterExpression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStringOrParameterExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StringOrParameterExpressionContext stringOrParameterExpression() {
		StringOrParameterExpressionContext _localctx = new StringOrParameterExpressionContext(Context, State);
		EnterRule(_localctx, 738, RULE_stringOrParameterExpression);
		try {
			State = 4222;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STRING_LITERAL1:
			case STRING_LITERAL2:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4220;
				stringLiteral();
				}
				break;
			case DOLLAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4221;
				parameter("STRING");
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StringOrParameterContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public StringLiteralContext stringLiteral() {
			return GetRuleContext<StringLiteralContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParameterContext parameter() {
			return GetRuleContext<ParameterContext>(0);
		}
		public StringOrParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_stringOrParameter; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStringOrParameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StringOrParameterContext stringOrParameter() {
		StringOrParameterContext _localctx = new StringOrParameterContext(Context, State);
		EnterRule(_localctx, 740, RULE_stringOrParameter);
		try {
			State = 4226;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case STRING_LITERAL1:
			case STRING_LITERAL2:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4224;
				stringLiteral();
				}
				break;
			case DOLLAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4225;
				parameter("STRING");
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UIntOrIntParameterContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNSIGNED_DECIMAL_INTEGER() { return GetToken(CypherParser.UNSIGNED_DECIMAL_INTEGER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ParameterContext parameter() {
			return GetRuleContext<ParameterContext>(0);
		}
		public UIntOrIntParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_uIntOrIntParameter; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUIntOrIntParameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UIntOrIntParameterContext uIntOrIntParameter() {
		UIntOrIntParameterContext _localctx = new UIntOrIntParameterContext(Context, State);
		EnterRule(_localctx, 742, RULE_uIntOrIntParameter);
		try {
			State = 4230;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case UNSIGNED_DECIMAL_INTEGER:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4228;
				Match(UNSIGNED_DECIMAL_INTEGER);
				}
				break;
			case DOLLAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4229;
				parameter("INTEGER");
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MapOrParameterContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public MapContext map() {
			return GetRuleContext<MapContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ParameterContext parameter() {
			return GetRuleContext<ParameterContext>(0);
		}
		public MapOrParameterContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_mapOrParameter; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMapOrParameter(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MapOrParameterContext mapOrParameter() {
		MapOrParameterContext _localctx = new MapOrParameterContext(Context, State);
		EnterRule(_localctx, 744, RULE_mapOrParameter);
		try {
			State = 4234;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case LCURLY:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4232;
				map();
				}
				break;
			case DOLLAR:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4233;
				parameter("MAP");
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class MapContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LCURLY() { return GetToken(CypherParser.LCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RCURLY() { return GetToken(CypherParser.RCURLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public PropertyKeyNameContext[] propertyKeyName() {
			return GetRuleContexts<PropertyKeyNameContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public PropertyKeyNameContext propertyKeyName(int i) {
			return GetRuleContext<PropertyKeyNameContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COLON() { return GetTokens(CypherParser.COLON); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLON(int i) {
			return GetToken(CypherParser.COLON, i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext[] expression() {
			return GetRuleContexts<ExpressionContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression(int i) {
			return GetRuleContext<ExpressionContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode[] COMMA() { return GetTokens(CypherParser.COMMA); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMA(int i) {
			return GetToken(CypherParser.COMMA, i);
		}
		public MapContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_map; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitMap(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public MapContext map() {
		MapContext _localctx = new MapContext(Context, State);
		EnterRule(_localctx, 746, RULE_map);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4236;
			Match(LCURLY);
			State = 4250;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ESCAPED_SYMBOLIC_NAME) | (1L << ACCESS) | (1L << ACTIVE) | (1L << ADD) | (1L << ADMIN) | (1L << ADMINISTRATOR) | (1L << ALIAS) | (1L << ALIASES) | (1L << ALL_SHORTEST_PATHS) | (1L << ALL) | (1L << ALLREDUCE) | (1L << ALTER) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASCENDING) | (1L << ASSIGN) | (1L << AT) | (1L << AUTH) | (1L << BINDINGS) | (1L << BOOL) | (1L << BOOLEAN) | (1L << BOOSTED) | (1L << BOTH) | (1L << BREAK) | (1L << BUILT) | (1L << BY) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CHANGE) | (1L << CIDR) | (1L << COLLECT) | (1L << COMMAND) | (1L << COMMANDS) | (1L << COMPOSITE) | (1L << CONCURRENT) | (1L << CONSTRAINT) | (1L << CONSTRAINTS) | (1L << CONTAINS) | (1L << COPY) | (1L << CONTINUE) | (1L << COSINE) | (1L << COUNT) | (1L << CREATE) | (1L << CREDENTIAL) | (1L << CSV) | (1L << CURRENT))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CYPHER - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATABASES - 64)) | (1L << (DATE - 64)) | (1L << (DATETIME - 64)) | (1L << (DBMS - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFINED - 64)) | (1L << (DELETE - 64)) | (1L << (DENY - 64)) | (1L << (DESC - 64)) | (1L << (DESCENDING - 64)) | (1L << (DESTROY - 64)) | (1L << (DETACH - 64)) | (1L << (DIFFERENT - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOT_METRIC - 64)) | (1L << (DRIVER - 64)) | (1L << (DROP - 64)) | (1L << (DRYRUN - 64)) | (1L << (DUMP - 64)) | (1L << (DURATION - 64)) | (1L << (EACH - 64)) | (1L << (EDGE - 64)) | (1L << (ENABLE - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELEMENTS - 64)) | (1L << (ELSE - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (EUCLIDEAN - 64)) | (1L << (EUCLIDEAN_SQUARED - 64)) | (1L << (END - 64)) | (1L << (ENDS - 64)) | (1L << (EXECUTABLE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXIST - 64)) | (1L << (EXISTENCE - 64)) | (1L << (EXISTS - 64)) | (1L << (ERROR - 64)) | (1L << (FAIL - 64)) | (1L << (FALSE - 64)) | (1L << (FIELDTERMINATOR - 64)) | (1L << (FILTER - 64)) | (1L << (FINISH - 64)) | (1L << (FLOAT - 64)) | (1L << (FLOAT64 - 64)) | (1L << (FLOAT32 - 64)) | (1L << (FOR - 64)) | (1L << (FOREACH - 64)) | (1L << (FORWARDING - 64)) | (1L << (FROM - 64)) | (1L << (FULLTEXT - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GRANT - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (GRAPH - 128)) | (1L << (GRAPHS - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPS - 128)) | (1L << (HAMMING - 128)) | (1L << (HEADERS - 128)) | (1L << (HOME - 128)) | (1L << (ID - 128)) | (1L << (IF - 128)) | (1L << (IMPERSONATE - 128)) | (1L << (IMMUTABLE - 128)) | (1L << (IN - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXES - 128)) | (1L << (INF - 128)) | (1L << (INFINITY - 128)) | (1L << (INSERT - 128)) | (1L << (INT - 128)) | (1L << (INT64 - 128)) | (1L << (INT32 - 128)) | (1L << (INT16 - 128)) | (1L << (INT8 - 128)) | (1L << (INTEGER - 128)) | (1L << (INTEGER64 - 128)) | (1L << (INTEGER32 - 128)) | (1L << (INTEGER16 - 128)) | (1L << (INTEGER8 - 128)) | (1L << (IS - 128)) | (1L << (JOIN - 128)) | (1L << (KEY - 128)) | (1L << (LABEL - 128)) | (1L << (LABELS - 128)) | (1L << (LANGUAGE - 128)) | (1L << (LEADING - 128)) | (1L << (LET - 128)) | (1L << (LIMITROWS - 128)) | (1L << (LIST - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOOKUP - 128)) | (1L << (MANAGEMENT - 128)) | (1L << (MANHATTAN - 128)) | (1L << (MAP - 128)) | (1L << (MATCH - 128)) | (1L << (MERGE - 128)) | (1L << (IMPLIES - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NAN - 128)) | (1L << (NFC - 128)) | (1L << (NFD - 128)) | (1L << (NFKC - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (NFKD - 192)) | (1L << (NEW - 192)) | (1L << (NEXT - 192)) | (1L << (NODE - 192)) | (1L << (NODETACH - 192)) | (1L << (NODES - 192)) | (1L << (NONE - 192)) | (1L << (NORMALIZE - 192)) | (1L << (NORMALIZED - 192)) | (1L << (NOT - 192)) | (1L << (NOTHING - 192)) | (1L << (NOWAIT - 192)) | (1L << (NULL - 192)) | (1L << (OF - 192)) | (1L << (OFFSET - 192)) | (1L << (OIDC - 192)) | (1L << (ON - 192)) | (1L << (ONLY - 192)) | (1L << (OPTIONAL - 192)) | (1L << (OPTIONS - 192)) | (1L << (OPTION - 192)) | (1L << (OR - 192)) | (1L << (ORDER - 192)) | (1L << (PASSWORD - 192)) | (1L << (PASSWORDS - 192)) | (1L << (PATH - 192)) | (1L << (PATHS - 192)) | (1L << (PLAINTEXT - 192)) | (1L << (POINT - 192)) | (1L << (POPULATED - 192)) | (1L << (PRIMARY - 192)) | (1L << (PRIMARIES - 192)) | (1L << (PRIVILEGE - 192)) | (1L << (PRIVILEGES - 192)) | (1L << (PROCEDURE - 192)) | (1L << (PROCEDURES - 192)) | (1L << (PROPERTIES - 192)) | (1L << (PROPERTY - 192)) | (1L << (PROVIDER - 192)) | (1L << (PROVIDERS - 192)) | (1L << (RANGE - 192)) | (1L << (READ - 192)) | (1L << (REALLOCATE - 192)) | (1L << (REDUCE - 192)) | (1L << (RENAME - 192)) | (1L << (REL - 192)) | (1L << (RELATIONSHIP - 192)) | (1L << (RELATIONSHIPS - 192)) | (1L << (REMOVE - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (REPLICAS - 192)) | (1L << (REPORT - 192)) | (1L << (REQUIRE - 192)) | (1L << (REQUIRED - 192)) | (1L << (RESTRICT - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (RETRY - 256)) | (1L << (RETURN - 256)) | (1L << (REVOKE - 256)) | (1L << (ROLE - 256)) | (1L << (ROLES - 256)) | (1L << (ROW - 256)) | (1L << (ROWS - 256)) | (1L << (SCAN - 256)) | (1L << (SEC - 256)) | (1L << (SECOND - 256)) | (1L << (SECONDARY - 256)) | (1L << (SECONDARIES - 256)) | (1L << (SECONDS - 256)) | (1L << (SEEK - 256)) | (1L << (SERVER - 256)) | (1L << (SERVERS - 256)) | (1L << (SET - 256)) | (1L << (SETTING - 256)) | (1L << (SETTINGS - 256)) | (1L << (SHARD - 256)) | (1L << (SHARDS - 256)) | (1L << (SHORTEST_PATH - 256)) | (1L << (SHORTEST - 256)) | (1L << (SHOW - 256)) | (1L << (SIGNED - 256)) | (1L << (SINGLE - 256)) | (1L << (SKIPROWS - 256)) | (1L << (START - 256)) | (1L << (STARTS - 256)) | (1L << (STATUS - 256)) | (1L << (STOP - 256)) | (1L << (STRING - 256)) | (1L << (SUPPORTED - 256)) | (1L << (SUSPENDED - 256)) | (1L << (TARGET - 256)) | (1L << (TERMINATE - 256)) | (1L << (TEXT - 256)) | (1L << (THEN - 256)) | (1L << (TIME - 256)) | (1L << (TIMESTAMP - 256)) | (1L << (TIMEZONE - 256)) | (1L << (TO - 256)) | (1L << (TOPOLOGY - 256)) | (1L << (TRAILING - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSACTIONS - 256)) | (1L << (TRAVERSE - 256)) | (1L << (TRIM - 256)) | (1L << (TRUE - 256)) | (1L << (TYPE - 256)) | (1L << (TYPED - 256)) | (1L << (TYPES - 256)) | (1L << (UNION - 256)) | (1L << (UNIQUE - 256)) | (1L << (UNIQUENESS - 256)) | (1L << (UNWIND - 256)) | (1L << (URL - 256)) | (1L << (USE - 256)) | (1L << (USER - 256)) | (1L << (USERS - 256)) | (1L << (USING - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (VALUE - 320)) | (1L << (VARCHAR - 320)) | (1L << (VECTOR - 320)) | (1L << (VECTOR_DISTANCE - 320)) | (1L << (VECTOR_NORM - 320)) | (1L << (VERTEX - 320)) | (1L << (WAIT - 320)) | (1L << (WHEN - 320)) | (1L << (WHERE - 320)) | (1L << (WITH - 320)) | (1L << (WITHOUT - 320)) | (1L << (WRITE - 320)) | (1L << (XOR - 320)) | (1L << (YIELD - 320)) | (1L << (ZONE - 320)) | (1L << (ZONED - 320)) | (1L << (IDENTIFIER - 320)))) != 0)) {
				{
				State = 4237;
				propertyKeyName();
				State = 4238;
				Match(COLON);
				State = 4239;
				expression();
				State = 4247;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==COMMA) {
					{
					{
					State = 4240;
					Match(COMMA);
					State = 4241;
					propertyKeyName();
					State = 4242;
					Match(COLON);
					State = 4243;
					expression();
					}
					}
					State = 4249;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
			}

			State = 4252;
			Match(RCURLY);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SymbolicVariableNameStringContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public EscapedSymbolicVariableNameStringContext escapedSymbolicVariableNameString() {
			return GetRuleContext<EscapedSymbolicVariableNameStringContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnescapedSymbolicVariableNameStringContext unescapedSymbolicVariableNameString() {
			return GetRuleContext<UnescapedSymbolicVariableNameStringContext>(0);
		}
		public SymbolicVariableNameStringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_symbolicVariableNameString; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSymbolicVariableNameString(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SymbolicVariableNameStringContext symbolicVariableNameString() {
		SymbolicVariableNameStringContext _localctx = new SymbolicVariableNameStringContext(Context, State);
		EnterRule(_localctx, 748, RULE_symbolicVariableNameString);
		try {
			State = 4256;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ESCAPED_SYMBOLIC_NAME:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4254;
				escapedSymbolicVariableNameString();
				}
				break;
			case ACCESS:
			case ACTIVE:
			case ADD:
			case ADMIN:
			case ADMINISTRATOR:
			case ALIAS:
			case ALIASES:
			case ALL_SHORTEST_PATHS:
			case ALL:
			case ALLREDUCE:
			case ALTER:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASCENDING:
			case ASSIGN:
			case AT:
			case AUTH:
			case BINDINGS:
			case BOOL:
			case BOOLEAN:
			case BOOSTED:
			case BOTH:
			case BREAK:
			case BUILT:
			case BY:
			case CALL:
			case CASCADE:
			case CASE:
			case CHANGE:
			case CIDR:
			case COLLECT:
			case COMMAND:
			case COMMANDS:
			case COMPOSITE:
			case CONCURRENT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONTAINS:
			case COPY:
			case CONTINUE:
			case COSINE:
			case COUNT:
			case CREATE:
			case CREDENTIAL:
			case CSV:
			case CURRENT:
			case CYPHER:
			case DATA:
			case DATABASE:
			case DATABASES:
			case DATE:
			case DATETIME:
			case DBMS:
			case DEALLOCATE:
			case DEFAULT:
			case DEFINED:
			case DELETE:
			case DENY:
			case DESC:
			case DESCENDING:
			case DESTROY:
			case DETACH:
			case DIFFERENT:
			case DISTINCT:
			case DOT_METRIC:
			case DRIVER:
			case DROP:
			case DRYRUN:
			case DUMP:
			case DURATION:
			case EACH:
			case EDGE:
			case ENABLE:
			case ELEMENT:
			case ELEMENTS:
			case ELSE:
			case ENCRYPTED:
			case EUCLIDEAN:
			case EUCLIDEAN_SQUARED:
			case END:
			case ENDS:
			case EXECUTABLE:
			case EXECUTE:
			case EXIST:
			case EXISTENCE:
			case EXISTS:
			case ERROR:
			case FAIL:
			case FALSE:
			case FIELDTERMINATOR:
			case FILTER:
			case FINISH:
			case FLOAT:
			case FLOAT64:
			case FLOAT32:
			case FOR:
			case FOREACH:
			case FORWARDING:
			case FROM:
			case FULLTEXT:
			case FUNCTION:
			case FUNCTIONS:
			case GRANT:
			case GRAPH:
			case GRAPHS:
			case GROUP:
			case GROUPS:
			case HAMMING:
			case HEADERS:
			case HOME:
			case ID:
			case IF:
			case IMPERSONATE:
			case IMMUTABLE:
			case IN:
			case INDEX:
			case INDEXES:
			case INF:
			case INFINITY:
			case INSERT:
			case INT:
			case INT64:
			case INT32:
			case INT16:
			case INT8:
			case INTEGER:
			case INTEGER64:
			case INTEGER32:
			case INTEGER16:
			case INTEGER8:
			case IS:
			case JOIN:
			case KEY:
			case LABEL:
			case LABELS:
			case LANGUAGE:
			case LEADING:
			case LET:
			case LIMITROWS:
			case LIST:
			case LOAD:
			case LOCAL:
			case LOOKUP:
			case MANAGEMENT:
			case MANHATTAN:
			case MAP:
			case MATCH:
			case MERGE:
			case IMPLIES:
			case NAME:
			case NAMES:
			case NAN:
			case NFC:
			case NFD:
			case NFKC:
			case NFKD:
			case NEW:
			case NEXT:
			case NODE:
			case NODETACH:
			case NODES:
			case NONE:
			case NORMALIZE:
			case NORMALIZED:
			case NOT:
			case NOTHING:
			case NOWAIT:
			case NULL:
			case OF:
			case OFFSET:
			case OIDC:
			case ON:
			case ONLY:
			case OPTIONAL:
			case OPTIONS:
			case OPTION:
			case OR:
			case ORDER:
			case PASSWORD:
			case PASSWORDS:
			case PATH:
			case PATHS:
			case PLAINTEXT:
			case POINT:
			case POPULATED:
			case PRIMARY:
			case PRIMARIES:
			case PRIVILEGE:
			case PRIVILEGES:
			case PROCEDURE:
			case PROCEDURES:
			case PROPERTIES:
			case PROPERTY:
			case PROVIDER:
			case PROVIDERS:
			case RANGE:
			case READ:
			case REALLOCATE:
			case REDUCE:
			case RENAME:
			case REL:
			case RELATIONSHIP:
			case RELATIONSHIPS:
			case REMOVE:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case REPLICAS:
			case REPORT:
			case REQUIRE:
			case REQUIRED:
			case RESTRICT:
			case RETRY:
			case RETURN:
			case REVOKE:
			case ROLE:
			case ROLES:
			case ROW:
			case ROWS:
			case SCAN:
			case SEC:
			case SECOND:
			case SECONDARY:
			case SECONDARIES:
			case SECONDS:
			case SEEK:
			case SERVER:
			case SERVERS:
			case SET:
			case SETTING:
			case SETTINGS:
			case SHARD:
			case SHARDS:
			case SHORTEST_PATH:
			case SHORTEST:
			case SHOW:
			case SIGNED:
			case SINGLE:
			case SKIPROWS:
			case START:
			case STARTS:
			case STATUS:
			case STOP:
			case STRING:
			case SUPPORTED:
			case SUSPENDED:
			case TARGET:
			case TERMINATE:
			case TEXT:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE:
			case TO:
			case TOPOLOGY:
			case TRAILING:
			case TRANSACTION:
			case TRANSACTIONS:
			case TRAVERSE:
			case TRIM:
			case TRUE:
			case TYPE:
			case TYPED:
			case TYPES:
			case UNION:
			case UNIQUE:
			case UNIQUENESS:
			case UNWIND:
			case URL:
			case USE:
			case USER:
			case USERS:
			case USING:
			case VALUE:
			case VARCHAR:
			case VECTOR:
			case VECTOR_DISTANCE:
			case VECTOR_NORM:
			case VERTEX:
			case WAIT:
			case WHEN:
			case WHERE:
			case WITH:
			case WITHOUT:
			case WRITE:
			case XOR:
			case YIELD:
			case ZONE:
			case ZONED:
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4255;
				unescapedSymbolicVariableNameString();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EscapedSymbolicVariableNameStringContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public EscapedSymbolicNameStringContext escapedSymbolicNameString() {
			return GetRuleContext<EscapedSymbolicNameStringContext>(0);
		}
		public EscapedSymbolicVariableNameStringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_escapedSymbolicVariableNameString; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEscapedSymbolicVariableNameString(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EscapedSymbolicVariableNameStringContext escapedSymbolicVariableNameString() {
		EscapedSymbolicVariableNameStringContext _localctx = new EscapedSymbolicVariableNameStringContext(Context, State);
		EnterRule(_localctx, 750, RULE_escapedSymbolicVariableNameString);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4258;
			escapedSymbolicNameString();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnescapedSymbolicVariableNameStringContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public UnescapedSymbolicNameStringContext unescapedSymbolicNameString() {
			return GetRuleContext<UnescapedSymbolicNameStringContext>(0);
		}
		public UnescapedSymbolicVariableNameStringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unescapedSymbolicVariableNameString; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnescapedSymbolicVariableNameString(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnescapedSymbolicVariableNameStringContext unescapedSymbolicVariableNameString() {
		UnescapedSymbolicVariableNameStringContext _localctx = new UnescapedSymbolicVariableNameStringContext(Context, State);
		EnterRule(_localctx, 752, RULE_unescapedSymbolicVariableNameString);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4260;
			unescapedSymbolicNameString();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class SymbolicNameStringContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public EscapedSymbolicNameStringContext escapedSymbolicNameString() {
			return GetRuleContext<EscapedSymbolicNameStringContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public UnescapedSymbolicNameStringContext unescapedSymbolicNameString() {
			return GetRuleContext<UnescapedSymbolicNameStringContext>(0);
		}
		public SymbolicNameStringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_symbolicNameString; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitSymbolicNameString(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public SymbolicNameStringContext symbolicNameString() {
		SymbolicNameStringContext _localctx = new SymbolicNameStringContext(Context, State);
		EnterRule(_localctx, 754, RULE_symbolicNameString);
		try {
			State = 4264;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case ESCAPED_SYMBOLIC_NAME:
				EnterOuterAlt(_localctx, 1);
				{
				State = 4262;
				escapedSymbolicNameString();
				}
				break;
			case ACCESS:
			case ACTIVE:
			case ADD:
			case ADMIN:
			case ADMINISTRATOR:
			case ALIAS:
			case ALIASES:
			case ALL_SHORTEST_PATHS:
			case ALL:
			case ALLREDUCE:
			case ALTER:
			case AND:
			case ANY:
			case ARRAY:
			case AS:
			case ASC:
			case ASCENDING:
			case ASSIGN:
			case AT:
			case AUTH:
			case BINDINGS:
			case BOOL:
			case BOOLEAN:
			case BOOSTED:
			case BOTH:
			case BREAK:
			case BUILT:
			case BY:
			case CALL:
			case CASCADE:
			case CASE:
			case CHANGE:
			case CIDR:
			case COLLECT:
			case COMMAND:
			case COMMANDS:
			case COMPOSITE:
			case CONCURRENT:
			case CONSTRAINT:
			case CONSTRAINTS:
			case CONTAINS:
			case COPY:
			case CONTINUE:
			case COSINE:
			case COUNT:
			case CREATE:
			case CREDENTIAL:
			case CSV:
			case CURRENT:
			case CYPHER:
			case DATA:
			case DATABASE:
			case DATABASES:
			case DATE:
			case DATETIME:
			case DBMS:
			case DEALLOCATE:
			case DEFAULT:
			case DEFINED:
			case DELETE:
			case DENY:
			case DESC:
			case DESCENDING:
			case DESTROY:
			case DETACH:
			case DIFFERENT:
			case DISTINCT:
			case DOT_METRIC:
			case DRIVER:
			case DROP:
			case DRYRUN:
			case DUMP:
			case DURATION:
			case EACH:
			case EDGE:
			case ENABLE:
			case ELEMENT:
			case ELEMENTS:
			case ELSE:
			case ENCRYPTED:
			case EUCLIDEAN:
			case EUCLIDEAN_SQUARED:
			case END:
			case ENDS:
			case EXECUTABLE:
			case EXECUTE:
			case EXIST:
			case EXISTENCE:
			case EXISTS:
			case ERROR:
			case FAIL:
			case FALSE:
			case FIELDTERMINATOR:
			case FILTER:
			case FINISH:
			case FLOAT:
			case FLOAT64:
			case FLOAT32:
			case FOR:
			case FOREACH:
			case FORWARDING:
			case FROM:
			case FULLTEXT:
			case FUNCTION:
			case FUNCTIONS:
			case GRANT:
			case GRAPH:
			case GRAPHS:
			case GROUP:
			case GROUPS:
			case HAMMING:
			case HEADERS:
			case HOME:
			case ID:
			case IF:
			case IMPERSONATE:
			case IMMUTABLE:
			case IN:
			case INDEX:
			case INDEXES:
			case INF:
			case INFINITY:
			case INSERT:
			case INT:
			case INT64:
			case INT32:
			case INT16:
			case INT8:
			case INTEGER:
			case INTEGER64:
			case INTEGER32:
			case INTEGER16:
			case INTEGER8:
			case IS:
			case JOIN:
			case KEY:
			case LABEL:
			case LABELS:
			case LANGUAGE:
			case LEADING:
			case LET:
			case LIMITROWS:
			case LIST:
			case LOAD:
			case LOCAL:
			case LOOKUP:
			case MANAGEMENT:
			case MANHATTAN:
			case MAP:
			case MATCH:
			case MERGE:
			case IMPLIES:
			case NAME:
			case NAMES:
			case NAN:
			case NFC:
			case NFD:
			case NFKC:
			case NFKD:
			case NEW:
			case NEXT:
			case NODE:
			case NODETACH:
			case NODES:
			case NONE:
			case NORMALIZE:
			case NORMALIZED:
			case NOT:
			case NOTHING:
			case NOWAIT:
			case NULL:
			case OF:
			case OFFSET:
			case OIDC:
			case ON:
			case ONLY:
			case OPTIONAL:
			case OPTIONS:
			case OPTION:
			case OR:
			case ORDER:
			case PASSWORD:
			case PASSWORDS:
			case PATH:
			case PATHS:
			case PLAINTEXT:
			case POINT:
			case POPULATED:
			case PRIMARY:
			case PRIMARIES:
			case PRIVILEGE:
			case PRIVILEGES:
			case PROCEDURE:
			case PROCEDURES:
			case PROPERTIES:
			case PROPERTY:
			case PROVIDER:
			case PROVIDERS:
			case RANGE:
			case READ:
			case REALLOCATE:
			case REDUCE:
			case RENAME:
			case REL:
			case RELATIONSHIP:
			case RELATIONSHIPS:
			case REMOVE:
			case REPEATABLE:
			case REPLACE:
			case REPLICA:
			case REPLICAS:
			case REPORT:
			case REQUIRE:
			case REQUIRED:
			case RESTRICT:
			case RETRY:
			case RETURN:
			case REVOKE:
			case ROLE:
			case ROLES:
			case ROW:
			case ROWS:
			case SCAN:
			case SEC:
			case SECOND:
			case SECONDARY:
			case SECONDARIES:
			case SECONDS:
			case SEEK:
			case SERVER:
			case SERVERS:
			case SET:
			case SETTING:
			case SETTINGS:
			case SHARD:
			case SHARDS:
			case SHORTEST_PATH:
			case SHORTEST:
			case SHOW:
			case SIGNED:
			case SINGLE:
			case SKIPROWS:
			case START:
			case STARTS:
			case STATUS:
			case STOP:
			case STRING:
			case SUPPORTED:
			case SUSPENDED:
			case TARGET:
			case TERMINATE:
			case TEXT:
			case THEN:
			case TIME:
			case TIMESTAMP:
			case TIMEZONE:
			case TO:
			case TOPOLOGY:
			case TRAILING:
			case TRANSACTION:
			case TRANSACTIONS:
			case TRAVERSE:
			case TRIM:
			case TRUE:
			case TYPE:
			case TYPED:
			case TYPES:
			case UNION:
			case UNIQUE:
			case UNIQUENESS:
			case UNWIND:
			case URL:
			case USE:
			case USER:
			case USERS:
			case USING:
			case VALUE:
			case VARCHAR:
			case VECTOR:
			case VECTOR_DISTANCE:
			case VECTOR_NORM:
			case VERTEX:
			case WAIT:
			case WHEN:
			case WHERE:
			case WITH:
			case WITHOUT:
			case WRITE:
			case XOR:
			case YIELD:
			case ZONE:
			case ZONED:
			case IDENTIFIER:
				EnterOuterAlt(_localctx, 2);
				{
				State = 4263;
				unescapedSymbolicNameString();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EscapedSymbolicNameStringContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ESCAPED_SYMBOLIC_NAME() { return GetToken(CypherParser.ESCAPED_SYMBOLIC_NAME, 0); }
		public EscapedSymbolicNameStringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_escapedSymbolicNameString; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEscapedSymbolicNameString(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EscapedSymbolicNameStringContext escapedSymbolicNameString() {
		EscapedSymbolicNameStringContext _localctx = new EscapedSymbolicNameStringContext(Context, State);
		EnterRule(_localctx, 756, RULE_escapedSymbolicNameString);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4266;
			Match(ESCAPED_SYMBOLIC_NAME);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnescapedSymbolicNameStringContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public UnescapedSymbolicNameString_Context unescapedSymbolicNameString_() {
			return GetRuleContext<UnescapedSymbolicNameString_Context>(0);
		}
		public UnescapedSymbolicNameStringContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unescapedSymbolicNameString; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnescapedSymbolicNameString(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnescapedSymbolicNameStringContext unescapedSymbolicNameString() {
		UnescapedSymbolicNameStringContext _localctx = new UnescapedSymbolicNameStringContext(Context, State);
		EnterRule(_localctx, 758, RULE_unescapedSymbolicNameString);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4268;
			unescapedSymbolicNameString_();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class UnescapedSymbolicNameString_Context : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IDENTIFIER() { return GetToken(CypherParser.IDENTIFIER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ACCESS() { return GetToken(CypherParser.ACCESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ACTIVE() { return GetToken(CypherParser.ACTIVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADD() { return GetToken(CypherParser.ADD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADMIN() { return GetToken(CypherParser.ADMIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ADMINISTRATOR() { return GetToken(CypherParser.ADMINISTRATOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALIAS() { return GetToken(CypherParser.ALIAS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALIASES() { return GetToken(CypherParser.ALIASES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL_SHORTEST_PATHS() { return GetToken(CypherParser.ALL_SHORTEST_PATHS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALL() { return GetToken(CypherParser.ALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALLREDUCE() { return GetToken(CypherParser.ALLREDUCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ALTER() { return GetToken(CypherParser.ALTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AND() { return GetToken(CypherParser.AND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ANY() { return GetToken(CypherParser.ANY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ARRAY() { return GetToken(CypherParser.ARRAY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AS() { return GetToken(CypherParser.AS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASC() { return GetToken(CypherParser.ASC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASCENDING() { return GetToken(CypherParser.ASCENDING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ASSIGN() { return GetToken(CypherParser.ASSIGN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AT() { return GetToken(CypherParser.AT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode AUTH() { return GetToken(CypherParser.AUTH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BINDINGS() { return GetToken(CypherParser.BINDINGS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BOOL() { return GetToken(CypherParser.BOOL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BOOLEAN() { return GetToken(CypherParser.BOOLEAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BOOSTED() { return GetToken(CypherParser.BOOSTED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BOTH() { return GetToken(CypherParser.BOTH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BREAK() { return GetToken(CypherParser.BREAK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BUILT() { return GetToken(CypherParser.BUILT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BY() { return GetToken(CypherParser.BY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CALL() { return GetToken(CypherParser.CALL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASCADE() { return GetToken(CypherParser.CASCADE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CASE() { return GetToken(CypherParser.CASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CHANGE() { return GetToken(CypherParser.CHANGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CIDR() { return GetToken(CypherParser.CIDR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COLLECT() { return GetToken(CypherParser.COLLECT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMAND() { return GetToken(CypherParser.COMMAND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMMANDS() { return GetToken(CypherParser.COMMANDS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COMPOSITE() { return GetToken(CypherParser.COMPOSITE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONCURRENT() { return GetToken(CypherParser.CONCURRENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTRAINT() { return GetToken(CypherParser.CONSTRAINT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONSTRAINTS() { return GetToken(CypherParser.CONSTRAINTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTAINS() { return GetToken(CypherParser.CONTAINS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CONTINUE() { return GetToken(CypherParser.CONTINUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COPY() { return GetToken(CypherParser.COPY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COSINE() { return GetToken(CypherParser.COSINE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode COUNT() { return GetToken(CypherParser.COUNT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CREATE() { return GetToken(CypherParser.CREATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CREDENTIAL() { return GetToken(CypherParser.CREDENTIAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CSV() { return GetToken(CypherParser.CSV, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CURRENT() { return GetToken(CypherParser.CURRENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode CYPHER() { return GetToken(CypherParser.CYPHER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATA() { return GetToken(CypherParser.DATA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASE() { return GetToken(CypherParser.DATABASE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATABASES() { return GetToken(CypherParser.DATABASES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATE() { return GetToken(CypherParser.DATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DATETIME() { return GetToken(CypherParser.DATETIME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DBMS() { return GetToken(CypherParser.DBMS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEALLOCATE() { return GetToken(CypherParser.DEALLOCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFAULT() { return GetToken(CypherParser.DEFAULT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DEFINED() { return GetToken(CypherParser.DEFINED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DELETE() { return GetToken(CypherParser.DELETE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DENY() { return GetToken(CypherParser.DENY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DESC() { return GetToken(CypherParser.DESC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DESCENDING() { return GetToken(CypherParser.DESCENDING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DESTROY() { return GetToken(CypherParser.DESTROY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DETACH() { return GetToken(CypherParser.DETACH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DIFFERENT() { return GetToken(CypherParser.DIFFERENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DISTINCT() { return GetToken(CypherParser.DISTINCT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DRIVER() { return GetToken(CypherParser.DRIVER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DOT_METRIC() { return GetToken(CypherParser.DOT_METRIC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DROP() { return GetToken(CypherParser.DROP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DRYRUN() { return GetToken(CypherParser.DRYRUN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DUMP() { return GetToken(CypherParser.DUMP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode DURATION() { return GetToken(CypherParser.DURATION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EACH() { return GetToken(CypherParser.EACH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EDGE() { return GetToken(CypherParser.EDGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELEMENT() { return GetToken(CypherParser.ELEMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELEMENTS() { return GetToken(CypherParser.ELEMENTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ELSE() { return GetToken(CypherParser.ELSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENABLE() { return GetToken(CypherParser.ENABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENCRYPTED() { return GetToken(CypherParser.ENCRYPTED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode END() { return GetToken(CypherParser.END, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ENDS() { return GetToken(CypherParser.ENDS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ERROR() { return GetToken(CypherParser.ERROR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EUCLIDEAN() { return GetToken(CypherParser.EUCLIDEAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EUCLIDEAN_SQUARED() { return GetToken(CypherParser.EUCLIDEAN_SQUARED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXECUTABLE() { return GetToken(CypherParser.EXECUTABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXECUTE() { return GetToken(CypherParser.EXECUTE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXIST() { return GetToken(CypherParser.EXIST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTENCE() { return GetToken(CypherParser.EXISTENCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode EXISTS() { return GetToken(CypherParser.EXISTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FAIL() { return GetToken(CypherParser.FAIL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FALSE() { return GetToken(CypherParser.FALSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FIELDTERMINATOR() { return GetToken(CypherParser.FIELDTERMINATOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FILTER() { return GetToken(CypherParser.FILTER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FINISH() { return GetToken(CypherParser.FINISH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FLOAT() { return GetToken(CypherParser.FLOAT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FLOAT64() { return GetToken(CypherParser.FLOAT64, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FLOAT32() { return GetToken(CypherParser.FLOAT32, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOREACH() { return GetToken(CypherParser.FOREACH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FOR() { return GetToken(CypherParser.FOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FORWARDING() { return GetToken(CypherParser.FORWARDING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FROM() { return GetToken(CypherParser.FROM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FULLTEXT() { return GetToken(CypherParser.FULLTEXT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUNCTION() { return GetToken(CypherParser.FUNCTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FUNCTIONS() { return GetToken(CypherParser.FUNCTIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GRANT() { return GetToken(CypherParser.GRANT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GRAPH() { return GetToken(CypherParser.GRAPH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GRAPHS() { return GetToken(CypherParser.GRAPHS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GROUP() { return GetToken(CypherParser.GROUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode GROUPS() { return GetToken(CypherParser.GROUPS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HAMMING() { return GetToken(CypherParser.HAMMING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HEADERS() { return GetToken(CypherParser.HEADERS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HOME() { return GetToken(CypherParser.HOME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(CypherParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IF() { return GetToken(CypherParser.IF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMMUTABLE() { return GetToken(CypherParser.IMMUTABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMPERSONATE() { return GetToken(CypherParser.IMPERSONATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IMPLIES() { return GetToken(CypherParser.IMPLIES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IN() { return GetToken(CypherParser.IN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEX() { return GetToken(CypherParser.INDEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INDEXES() { return GetToken(CypherParser.INDEXES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INF() { return GetToken(CypherParser.INF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INFINITY() { return GetToken(CypherParser.INFINITY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INSERT() { return GetToken(CypherParser.INSERT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT() { return GetToken(CypherParser.INT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT64() { return GetToken(CypherParser.INT64, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT32() { return GetToken(CypherParser.INT32, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT16() { return GetToken(CypherParser.INT16, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT8() { return GetToken(CypherParser.INT8, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER() { return GetToken(CypherParser.INTEGER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER64() { return GetToken(CypherParser.INTEGER64, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER32() { return GetToken(CypherParser.INTEGER32, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER16() { return GetToken(CypherParser.INTEGER16, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INTEGER8() { return GetToken(CypherParser.INTEGER8, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode IS() { return GetToken(CypherParser.IS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode JOIN() { return GetToken(CypherParser.JOIN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode KEY() { return GetToken(CypherParser.KEY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LABEL() { return GetToken(CypherParser.LABEL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LABELS() { return GetToken(CypherParser.LABELS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LANGUAGE() { return GetToken(CypherParser.LANGUAGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LEADING() { return GetToken(CypherParser.LEADING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LET() { return GetToken(CypherParser.LET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIMITROWS() { return GetToken(CypherParser.LIMITROWS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LIST() { return GetToken(CypherParser.LIST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOAD() { return GetToken(CypherParser.LOAD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOCAL() { return GetToken(CypherParser.LOCAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode LOOKUP() { return GetToken(CypherParser.LOOKUP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MATCH() { return GetToken(CypherParser.MATCH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MANAGEMENT() { return GetToken(CypherParser.MANAGEMENT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MANHATTAN() { return GetToken(CypherParser.MANHATTAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MAP() { return GetToken(CypherParser.MAP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MERGE() { return GetToken(CypherParser.MERGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NAME() { return GetToken(CypherParser.NAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NAMES() { return GetToken(CypherParser.NAMES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NAN() { return GetToken(CypherParser.NAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEW() { return GetToken(CypherParser.NEW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NEXT() { return GetToken(CypherParser.NEXT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NFC() { return GetToken(CypherParser.NFC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NFD() { return GetToken(CypherParser.NFD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NFKC() { return GetToken(CypherParser.NFKC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NFKD() { return GetToken(CypherParser.NFKD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NODE() { return GetToken(CypherParser.NODE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NODETACH() { return GetToken(CypherParser.NODETACH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NODES() { return GetToken(CypherParser.NODES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NONE() { return GetToken(CypherParser.NONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NORMALIZE() { return GetToken(CypherParser.NORMALIZE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NORMALIZED() { return GetToken(CypherParser.NORMALIZED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOT() { return GetToken(CypherParser.NOT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOTHING() { return GetToken(CypherParser.NOTHING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NOWAIT() { return GetToken(CypherParser.NOWAIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NULL() { return GetToken(CypherParser.NULL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OF() { return GetToken(CypherParser.OF, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OFFSET() { return GetToken(CypherParser.OFFSET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OIDC() { return GetToken(CypherParser.OIDC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ON() { return GetToken(CypherParser.ON, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ONLY() { return GetToken(CypherParser.ONLY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPTIONAL() { return GetToken(CypherParser.OPTIONAL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPTIONS() { return GetToken(CypherParser.OPTIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OPTION() { return GetToken(CypherParser.OPTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode OR() { return GetToken(CypherParser.OR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ORDER() { return GetToken(CypherParser.ORDER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSWORD() { return GetToken(CypherParser.PASSWORD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PASSWORDS() { return GetToken(CypherParser.PASSWORDS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PATH() { return GetToken(CypherParser.PATH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PATHS() { return GetToken(CypherParser.PATHS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PLAINTEXT() { return GetToken(CypherParser.PLAINTEXT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode POINT() { return GetToken(CypherParser.POINT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode POPULATED() { return GetToken(CypherParser.POPULATED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIMARY() { return GetToken(CypherParser.PRIMARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIMARIES() { return GetToken(CypherParser.PRIMARIES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIVILEGE() { return GetToken(CypherParser.PRIVILEGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PRIVILEGES() { return GetToken(CypherParser.PRIVILEGES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROCEDURE() { return GetToken(CypherParser.PROCEDURE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROCEDURES() { return GetToken(CypherParser.PROCEDURES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROPERTIES() { return GetToken(CypherParser.PROPERTIES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROPERTY() { return GetToken(CypherParser.PROPERTY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROVIDER() { return GetToken(CypherParser.PROVIDER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PROVIDERS() { return GetToken(CypherParser.PROVIDERS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RANGE() { return GetToken(CypherParser.RANGE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode READ() { return GetToken(CypherParser.READ, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REALLOCATE() { return GetToken(CypherParser.REALLOCATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REDUCE() { return GetToken(CypherParser.REDUCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REL() { return GetToken(CypherParser.REL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELATIONSHIP() { return GetToken(CypherParser.RELATIONSHIP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RELATIONSHIPS() { return GetToken(CypherParser.RELATIONSHIPS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REMOVE() { return GetToken(CypherParser.REMOVE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RENAME() { return GetToken(CypherParser.RENAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REPEATABLE() { return GetToken(CypherParser.REPEATABLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REPLACE() { return GetToken(CypherParser.REPLACE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REPLICA() { return GetToken(CypherParser.REPLICA, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REPLICAS() { return GetToken(CypherParser.REPLICAS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REPORT() { return GetToken(CypherParser.REPORT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REQUIRE() { return GetToken(CypherParser.REQUIRE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REQUIRED() { return GetToken(CypherParser.REQUIRED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RESTRICT() { return GetToken(CypherParser.RESTRICT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETRY() { return GetToken(CypherParser.RETRY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode RETURN() { return GetToken(CypherParser.RETURN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode REVOKE() { return GetToken(CypherParser.REVOKE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLE() { return GetToken(CypherParser.ROLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROLES() { return GetToken(CypherParser.ROLES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROW() { return GetToken(CypherParser.ROW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ROWS() { return GetToken(CypherParser.ROWS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SCAN() { return GetToken(CypherParser.SCAN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SECONDARY() { return GetToken(CypherParser.SECONDARY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SECONDARIES() { return GetToken(CypherParser.SECONDARIES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEC() { return GetToken(CypherParser.SEC, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SECOND() { return GetToken(CypherParser.SECOND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SECONDS() { return GetToken(CypherParser.SECONDS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SEEK() { return GetToken(CypherParser.SEEK, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERVER() { return GetToken(CypherParser.SERVER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SERVERS() { return GetToken(CypherParser.SERVERS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SET() { return GetToken(CypherParser.SET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SETTING() { return GetToken(CypherParser.SETTING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SETTINGS() { return GetToken(CypherParser.SETTINGS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARD() { return GetToken(CypherParser.SHARD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHARDS() { return GetToken(CypherParser.SHARDS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHORTEST() { return GetToken(CypherParser.SHORTEST, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHORTEST_PATH() { return GetToken(CypherParser.SHORTEST_PATH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SHOW() { return GetToken(CypherParser.SHOW, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SIGNED() { return GetToken(CypherParser.SIGNED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SINGLE() { return GetToken(CypherParser.SINGLE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SKIPROWS() { return GetToken(CypherParser.SKIPROWS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode START() { return GetToken(CypherParser.START, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STARTS() { return GetToken(CypherParser.STARTS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STATUS() { return GetToken(CypherParser.STATUS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STOP() { return GetToken(CypherParser.STOP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VARCHAR() { return GetToken(CypherParser.VARCHAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode STRING() { return GetToken(CypherParser.STRING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUPPORTED() { return GetToken(CypherParser.SUPPORTED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode SUSPENDED() { return GetToken(CypherParser.SUSPENDED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TARGET() { return GetToken(CypherParser.TARGET, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TERMINATE() { return GetToken(CypherParser.TERMINATE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TEXT() { return GetToken(CypherParser.TEXT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode THEN() { return GetToken(CypherParser.THEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIME() { return GetToken(CypherParser.TIME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMESTAMP() { return GetToken(CypherParser.TIMESTAMP, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TIMEZONE() { return GetToken(CypherParser.TIMEZONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TO() { return GetToken(CypherParser.TO, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TOPOLOGY() { return GetToken(CypherParser.TOPOLOGY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRAILING() { return GetToken(CypherParser.TRAILING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRANSACTION() { return GetToken(CypherParser.TRANSACTION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRANSACTIONS() { return GetToken(CypherParser.TRANSACTIONS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRAVERSE() { return GetToken(CypherParser.TRAVERSE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRIM() { return GetToken(CypherParser.TRIM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TRUE() { return GetToken(CypherParser.TRUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPE() { return GetToken(CypherParser.TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPED() { return GetToken(CypherParser.TYPED, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TYPES() { return GetToken(CypherParser.TYPES, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNION() { return GetToken(CypherParser.UNION, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIQUE() { return GetToken(CypherParser.UNIQUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNIQUENESS() { return GetToken(CypherParser.UNIQUENESS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode UNWIND() { return GetToken(CypherParser.UNWIND, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode URL() { return GetToken(CypherParser.URL, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USE() { return GetToken(CypherParser.USE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USER() { return GetToken(CypherParser.USER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USERS() { return GetToken(CypherParser.USERS, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode USING() { return GetToken(CypherParser.USING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VALUE() { return GetToken(CypherParser.VALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VECTOR() { return GetToken(CypherParser.VECTOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VECTOR_DISTANCE() { return GetToken(CypherParser.VECTOR_DISTANCE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VECTOR_NORM() { return GetToken(CypherParser.VECTOR_NORM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode VERTEX() { return GetToken(CypherParser.VERTEX, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WAIT() { return GetToken(CypherParser.WAIT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHEN() { return GetToken(CypherParser.WHEN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WHERE() { return GetToken(CypherParser.WHERE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITH() { return GetToken(CypherParser.WITH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WITHOUT() { return GetToken(CypherParser.WITHOUT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode WRITE() { return GetToken(CypherParser.WRITE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode XOR() { return GetToken(CypherParser.XOR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode YIELD() { return GetToken(CypherParser.YIELD, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ZONE() { return GetToken(CypherParser.ZONE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ZONED() { return GetToken(CypherParser.ZONED, 0); }
		public UnescapedSymbolicNameString_Context(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_unescapedSymbolicNameString_; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitUnescapedSymbolicNameString_(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public UnescapedSymbolicNameString_Context unescapedSymbolicNameString_() {
		UnescapedSymbolicNameString_Context _localctx = new UnescapedSymbolicNameString_Context(Context, State);
		EnterRule(_localctx, 760, RULE_unescapedSymbolicNameString_);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4270;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & ((1L << ACCESS) | (1L << ACTIVE) | (1L << ADD) | (1L << ADMIN) | (1L << ADMINISTRATOR) | (1L << ALIAS) | (1L << ALIASES) | (1L << ALL_SHORTEST_PATHS) | (1L << ALL) | (1L << ALLREDUCE) | (1L << ALTER) | (1L << AND) | (1L << ANY) | (1L << ARRAY) | (1L << AS) | (1L << ASC) | (1L << ASCENDING) | (1L << ASSIGN) | (1L << AT) | (1L << AUTH) | (1L << BINDINGS) | (1L << BOOL) | (1L << BOOLEAN) | (1L << BOOSTED) | (1L << BOTH) | (1L << BREAK) | (1L << BUILT) | (1L << BY) | (1L << CALL) | (1L << CASCADE) | (1L << CASE) | (1L << CHANGE) | (1L << CIDR) | (1L << COLLECT) | (1L << COMMAND) | (1L << COMMANDS) | (1L << COMPOSITE) | (1L << CONCURRENT) | (1L << CONSTRAINT) | (1L << CONSTRAINTS) | (1L << CONTAINS) | (1L << COPY) | (1L << CONTINUE) | (1L << COSINE) | (1L << COUNT) | (1L << CREATE) | (1L << CREDENTIAL) | (1L << CSV) | (1L << CURRENT))) != 0) || ((((_la - 64)) & ~0x3f) == 0 && ((1L << (_la - 64)) & ((1L << (CYPHER - 64)) | (1L << (DATA - 64)) | (1L << (DATABASE - 64)) | (1L << (DATABASES - 64)) | (1L << (DATE - 64)) | (1L << (DATETIME - 64)) | (1L << (DBMS - 64)) | (1L << (DEALLOCATE - 64)) | (1L << (DEFAULT - 64)) | (1L << (DEFINED - 64)) | (1L << (DELETE - 64)) | (1L << (DENY - 64)) | (1L << (DESC - 64)) | (1L << (DESCENDING - 64)) | (1L << (DESTROY - 64)) | (1L << (DETACH - 64)) | (1L << (DIFFERENT - 64)) | (1L << (DISTINCT - 64)) | (1L << (DOT_METRIC - 64)) | (1L << (DRIVER - 64)) | (1L << (DROP - 64)) | (1L << (DRYRUN - 64)) | (1L << (DUMP - 64)) | (1L << (DURATION - 64)) | (1L << (EACH - 64)) | (1L << (EDGE - 64)) | (1L << (ENABLE - 64)) | (1L << (ELEMENT - 64)) | (1L << (ELEMENTS - 64)) | (1L << (ELSE - 64)) | (1L << (ENCRYPTED - 64)) | (1L << (EUCLIDEAN - 64)) | (1L << (EUCLIDEAN_SQUARED - 64)) | (1L << (END - 64)) | (1L << (ENDS - 64)) | (1L << (EXECUTABLE - 64)) | (1L << (EXECUTE - 64)) | (1L << (EXIST - 64)) | (1L << (EXISTENCE - 64)) | (1L << (EXISTS - 64)) | (1L << (ERROR - 64)) | (1L << (FAIL - 64)) | (1L << (FALSE - 64)) | (1L << (FIELDTERMINATOR - 64)) | (1L << (FILTER - 64)) | (1L << (FINISH - 64)) | (1L << (FLOAT - 64)) | (1L << (FLOAT64 - 64)) | (1L << (FLOAT32 - 64)) | (1L << (FOR - 64)) | (1L << (FOREACH - 64)) | (1L << (FORWARDING - 64)) | (1L << (FROM - 64)) | (1L << (FULLTEXT - 64)) | (1L << (FUNCTION - 64)) | (1L << (FUNCTIONS - 64)) | (1L << (GRANT - 64)))) != 0) || ((((_la - 128)) & ~0x3f) == 0 && ((1L << (_la - 128)) & ((1L << (GRAPH - 128)) | (1L << (GRAPHS - 128)) | (1L << (GROUP - 128)) | (1L << (GROUPS - 128)) | (1L << (HAMMING - 128)) | (1L << (HEADERS - 128)) | (1L << (HOME - 128)) | (1L << (ID - 128)) | (1L << (IF - 128)) | (1L << (IMPERSONATE - 128)) | (1L << (IMMUTABLE - 128)) | (1L << (IN - 128)) | (1L << (INDEX - 128)) | (1L << (INDEXES - 128)) | (1L << (INF - 128)) | (1L << (INFINITY - 128)) | (1L << (INSERT - 128)) | (1L << (INT - 128)) | (1L << (INT64 - 128)) | (1L << (INT32 - 128)) | (1L << (INT16 - 128)) | (1L << (INT8 - 128)) | (1L << (INTEGER - 128)) | (1L << (INTEGER64 - 128)) | (1L << (INTEGER32 - 128)) | (1L << (INTEGER16 - 128)) | (1L << (INTEGER8 - 128)) | (1L << (IS - 128)) | (1L << (JOIN - 128)) | (1L << (KEY - 128)) | (1L << (LABEL - 128)) | (1L << (LABELS - 128)) | (1L << (LANGUAGE - 128)) | (1L << (LEADING - 128)) | (1L << (LET - 128)) | (1L << (LIMITROWS - 128)) | (1L << (LIST - 128)) | (1L << (LOAD - 128)) | (1L << (LOCAL - 128)) | (1L << (LOOKUP - 128)) | (1L << (MANAGEMENT - 128)) | (1L << (MANHATTAN - 128)) | (1L << (MAP - 128)) | (1L << (MATCH - 128)) | (1L << (MERGE - 128)) | (1L << (IMPLIES - 128)) | (1L << (NAME - 128)) | (1L << (NAMES - 128)) | (1L << (NAN - 128)) | (1L << (NFC - 128)) | (1L << (NFD - 128)) | (1L << (NFKC - 128)))) != 0) || ((((_la - 192)) & ~0x3f) == 0 && ((1L << (_la - 192)) & ((1L << (NFKD - 192)) | (1L << (NEW - 192)) | (1L << (NEXT - 192)) | (1L << (NODE - 192)) | (1L << (NODETACH - 192)) | (1L << (NODES - 192)) | (1L << (NONE - 192)) | (1L << (NORMALIZE - 192)) | (1L << (NORMALIZED - 192)) | (1L << (NOT - 192)) | (1L << (NOTHING - 192)) | (1L << (NOWAIT - 192)) | (1L << (NULL - 192)) | (1L << (OF - 192)) | (1L << (OFFSET - 192)) | (1L << (OIDC - 192)) | (1L << (ON - 192)) | (1L << (ONLY - 192)) | (1L << (OPTIONAL - 192)) | (1L << (OPTIONS - 192)) | (1L << (OPTION - 192)) | (1L << (OR - 192)) | (1L << (ORDER - 192)) | (1L << (PASSWORD - 192)) | (1L << (PASSWORDS - 192)) | (1L << (PATH - 192)) | (1L << (PATHS - 192)) | (1L << (PLAINTEXT - 192)) | (1L << (POINT - 192)) | (1L << (POPULATED - 192)) | (1L << (PRIMARY - 192)) | (1L << (PRIMARIES - 192)) | (1L << (PRIVILEGE - 192)) | (1L << (PRIVILEGES - 192)) | (1L << (PROCEDURE - 192)) | (1L << (PROCEDURES - 192)) | (1L << (PROPERTIES - 192)) | (1L << (PROPERTY - 192)) | (1L << (PROVIDER - 192)) | (1L << (PROVIDERS - 192)) | (1L << (RANGE - 192)) | (1L << (READ - 192)) | (1L << (REALLOCATE - 192)) | (1L << (REDUCE - 192)) | (1L << (RENAME - 192)) | (1L << (REL - 192)) | (1L << (RELATIONSHIP - 192)) | (1L << (RELATIONSHIPS - 192)) | (1L << (REMOVE - 192)) | (1L << (REPEATABLE - 192)) | (1L << (REPLACE - 192)) | (1L << (REPLICA - 192)) | (1L << (REPLICAS - 192)) | (1L << (REPORT - 192)) | (1L << (REQUIRE - 192)) | (1L << (REQUIRED - 192)) | (1L << (RESTRICT - 192)))) != 0) || ((((_la - 256)) & ~0x3f) == 0 && ((1L << (_la - 256)) & ((1L << (RETRY - 256)) | (1L << (RETURN - 256)) | (1L << (REVOKE - 256)) | (1L << (ROLE - 256)) | (1L << (ROLES - 256)) | (1L << (ROW - 256)) | (1L << (ROWS - 256)) | (1L << (SCAN - 256)) | (1L << (SEC - 256)) | (1L << (SECOND - 256)) | (1L << (SECONDARY - 256)) | (1L << (SECONDARIES - 256)) | (1L << (SECONDS - 256)) | (1L << (SEEK - 256)) | (1L << (SERVER - 256)) | (1L << (SERVERS - 256)) | (1L << (SET - 256)) | (1L << (SETTING - 256)) | (1L << (SETTINGS - 256)) | (1L << (SHARD - 256)) | (1L << (SHARDS - 256)) | (1L << (SHORTEST_PATH - 256)) | (1L << (SHORTEST - 256)) | (1L << (SHOW - 256)) | (1L << (SIGNED - 256)) | (1L << (SINGLE - 256)) | (1L << (SKIPROWS - 256)) | (1L << (START - 256)) | (1L << (STARTS - 256)) | (1L << (STATUS - 256)) | (1L << (STOP - 256)) | (1L << (STRING - 256)) | (1L << (SUPPORTED - 256)) | (1L << (SUSPENDED - 256)) | (1L << (TARGET - 256)) | (1L << (TERMINATE - 256)) | (1L << (TEXT - 256)) | (1L << (THEN - 256)) | (1L << (TIME - 256)) | (1L << (TIMESTAMP - 256)) | (1L << (TIMEZONE - 256)) | (1L << (TO - 256)) | (1L << (TOPOLOGY - 256)) | (1L << (TRAILING - 256)) | (1L << (TRANSACTION - 256)) | (1L << (TRANSACTIONS - 256)) | (1L << (TRAVERSE - 256)) | (1L << (TRIM - 256)) | (1L << (TRUE - 256)) | (1L << (TYPE - 256)) | (1L << (TYPED - 256)) | (1L << (TYPES - 256)) | (1L << (UNION - 256)) | (1L << (UNIQUE - 256)) | (1L << (UNIQUENESS - 256)) | (1L << (UNWIND - 256)) | (1L << (URL - 256)) | (1L << (USE - 256)) | (1L << (USER - 256)) | (1L << (USERS - 256)) | (1L << (USING - 256)))) != 0) || ((((_la - 320)) & ~0x3f) == 0 && ((1L << (_la - 320)) & ((1L << (VALUE - 320)) | (1L << (VARCHAR - 320)) | (1L << (VECTOR - 320)) | (1L << (VECTOR_DISTANCE - 320)) | (1L << (VECTOR_NORM - 320)) | (1L << (VERTEX - 320)) | (1L << (WAIT - 320)) | (1L << (WHEN - 320)) | (1L << (WHERE - 320)) | (1L << (WITH - 320)) | (1L << (WITHOUT - 320)) | (1L << (WRITE - 320)) | (1L << (XOR - 320)) | (1L << (YIELD - 320)) | (1L << (ZONE - 320)) | (1L << (ZONED - 320)) | (1L << (IDENTIFIER - 320)))) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class EndOfFileContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(CypherParser.Eof, 0); }
		public EndOfFileContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_endOfFile; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICypherParserVisitor<TResult> typedVisitor = visitor as ICypherParserVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitEndOfFile(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public EndOfFileContext endOfFile() {
		EndOfFileContext _localctx = new EndOfFileContext(Context, State);
		EnterRule(_localctx, 762, RULE_endOfFile);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 4272;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static char[] _serializedATN = {
		'\x3', '\x608B', '\xA72A', '\x8133', '\xB9ED', '\x417C', '\x3BE7', '\x7786', 
		'\x5964', '\x3', '\x157', '\x10B5', '\x4', '\x2', '\t', '\x2', '\x4', 
		'\x3', '\t', '\x3', '\x4', '\x4', '\t', '\x4', '\x4', '\x5', '\t', '\x5', 
		'\x4', '\x6', '\t', '\x6', '\x4', '\a', '\t', '\a', '\x4', '\b', '\t', 
		'\b', '\x4', '\t', '\t', '\t', '\x4', '\n', '\t', '\n', '\x4', '\v', '\t', 
		'\v', '\x4', '\f', '\t', '\f', '\x4', '\r', '\t', '\r', '\x4', '\xE', 
		'\t', '\xE', '\x4', '\xF', '\t', '\xF', '\x4', '\x10', '\t', '\x10', '\x4', 
		'\x11', '\t', '\x11', '\x4', '\x12', '\t', '\x12', '\x4', '\x13', '\t', 
		'\x13', '\x4', '\x14', '\t', '\x14', '\x4', '\x15', '\t', '\x15', '\x4', 
		'\x16', '\t', '\x16', '\x4', '\x17', '\t', '\x17', '\x4', '\x18', '\t', 
		'\x18', '\x4', '\x19', '\t', '\x19', '\x4', '\x1A', '\t', '\x1A', '\x4', 
		'\x1B', '\t', '\x1B', '\x4', '\x1C', '\t', '\x1C', '\x4', '\x1D', '\t', 
		'\x1D', '\x4', '\x1E', '\t', '\x1E', '\x4', '\x1F', '\t', '\x1F', '\x4', 
		' ', '\t', ' ', '\x4', '!', '\t', '!', '\x4', '\"', '\t', '\"', '\x4', 
		'#', '\t', '#', '\x4', '$', '\t', '$', '\x4', '%', '\t', '%', '\x4', '&', 
		'\t', '&', '\x4', '\'', '\t', '\'', '\x4', '(', '\t', '(', '\x4', ')', 
		'\t', ')', '\x4', '*', '\t', '*', '\x4', '+', '\t', '+', '\x4', ',', '\t', 
		',', '\x4', '-', '\t', '-', '\x4', '.', '\t', '.', '\x4', '/', '\t', '/', 
		'\x4', '\x30', '\t', '\x30', '\x4', '\x31', '\t', '\x31', '\x4', '\x32', 
		'\t', '\x32', '\x4', '\x33', '\t', '\x33', '\x4', '\x34', '\t', '\x34', 
		'\x4', '\x35', '\t', '\x35', '\x4', '\x36', '\t', '\x36', '\x4', '\x37', 
		'\t', '\x37', '\x4', '\x38', '\t', '\x38', '\x4', '\x39', '\t', '\x39', 
		'\x4', ':', '\t', ':', '\x4', ';', '\t', ';', '\x4', '<', '\t', '<', '\x4', 
		'=', '\t', '=', '\x4', '>', '\t', '>', '\x4', '?', '\t', '?', '\x4', '@', 
		'\t', '@', '\x4', '\x41', '\t', '\x41', '\x4', '\x42', '\t', '\x42', '\x4', 
		'\x43', '\t', '\x43', '\x4', '\x44', '\t', '\x44', '\x4', '\x45', '\t', 
		'\x45', '\x4', '\x46', '\t', '\x46', '\x4', 'G', '\t', 'G', '\x4', 'H', 
		'\t', 'H', '\x4', 'I', '\t', 'I', '\x4', 'J', '\t', 'J', '\x4', 'K', '\t', 
		'K', '\x4', 'L', '\t', 'L', '\x4', 'M', '\t', 'M', '\x4', 'N', '\t', 'N', 
		'\x4', 'O', '\t', 'O', '\x4', 'P', '\t', 'P', '\x4', 'Q', '\t', 'Q', '\x4', 
		'R', '\t', 'R', '\x4', 'S', '\t', 'S', '\x4', 'T', '\t', 'T', '\x4', 'U', 
		'\t', 'U', '\x4', 'V', '\t', 'V', '\x4', 'W', '\t', 'W', '\x4', 'X', '\t', 
		'X', '\x4', 'Y', '\t', 'Y', '\x4', 'Z', '\t', 'Z', '\x4', '[', '\t', '[', 
		'\x4', '\\', '\t', '\\', '\x4', ']', '\t', ']', '\x4', '^', '\t', '^', 
		'\x4', '_', '\t', '_', '\x4', '`', '\t', '`', '\x4', '\x61', '\t', '\x61', 
		'\x4', '\x62', '\t', '\x62', '\x4', '\x63', '\t', '\x63', '\x4', '\x64', 
		'\t', '\x64', '\x4', '\x65', '\t', '\x65', '\x4', '\x66', '\t', '\x66', 
		'\x4', 'g', '\t', 'g', '\x4', 'h', '\t', 'h', '\x4', 'i', '\t', 'i', '\x4', 
		'j', '\t', 'j', '\x4', 'k', '\t', 'k', '\x4', 'l', '\t', 'l', '\x4', 'm', 
		'\t', 'm', '\x4', 'n', '\t', 'n', '\x4', 'o', '\t', 'o', '\x4', 'p', '\t', 
		'p', '\x4', 'q', '\t', 'q', '\x4', 'r', '\t', 'r', '\x4', 's', '\t', 's', 
		'\x4', 't', '\t', 't', '\x4', 'u', '\t', 'u', '\x4', 'v', '\t', 'v', '\x4', 
		'w', '\t', 'w', '\x4', 'x', '\t', 'x', '\x4', 'y', '\t', 'y', '\x4', 'z', 
		'\t', 'z', '\x4', '{', '\t', '{', '\x4', '|', '\t', '|', '\x4', '}', '\t', 
		'}', '\x4', '~', '\t', '~', '\x4', '\x7F', '\t', '\x7F', '\x4', '\x80', 
		'\t', '\x80', '\x4', '\x81', '\t', '\x81', '\x4', '\x82', '\t', '\x82', 
		'\x4', '\x83', '\t', '\x83', '\x4', '\x84', '\t', '\x84', '\x4', '\x85', 
		'\t', '\x85', '\x4', '\x86', '\t', '\x86', '\x4', '\x87', '\t', '\x87', 
		'\x4', '\x88', '\t', '\x88', '\x4', '\x89', '\t', '\x89', '\x4', '\x8A', 
		'\t', '\x8A', '\x4', '\x8B', '\t', '\x8B', '\x4', '\x8C', '\t', '\x8C', 
		'\x4', '\x8D', '\t', '\x8D', '\x4', '\x8E', '\t', '\x8E', '\x4', '\x8F', 
		'\t', '\x8F', '\x4', '\x90', '\t', '\x90', '\x4', '\x91', '\t', '\x91', 
		'\x4', '\x92', '\t', '\x92', '\x4', '\x93', '\t', '\x93', '\x4', '\x94', 
		'\t', '\x94', '\x4', '\x95', '\t', '\x95', '\x4', '\x96', '\t', '\x96', 
		'\x4', '\x97', '\t', '\x97', '\x4', '\x98', '\t', '\x98', '\x4', '\x99', 
		'\t', '\x99', '\x4', '\x9A', '\t', '\x9A', '\x4', '\x9B', '\t', '\x9B', 
		'\x4', '\x9C', '\t', '\x9C', '\x4', '\x9D', '\t', '\x9D', '\x4', '\x9E', 
		'\t', '\x9E', '\x4', '\x9F', '\t', '\x9F', '\x4', '\xA0', '\t', '\xA0', 
		'\x4', '\xA1', '\t', '\xA1', '\x4', '\xA2', '\t', '\xA2', '\x4', '\xA3', 
		'\t', '\xA3', '\x4', '\xA4', '\t', '\xA4', '\x4', '\xA5', '\t', '\xA5', 
		'\x4', '\xA6', '\t', '\xA6', '\x4', '\xA7', '\t', '\xA7', '\x4', '\xA8', 
		'\t', '\xA8', '\x4', '\xA9', '\t', '\xA9', '\x4', '\xAA', '\t', '\xAA', 
		'\x4', '\xAB', '\t', '\xAB', '\x4', '\xAC', '\t', '\xAC', '\x4', '\xAD', 
		'\t', '\xAD', '\x4', '\xAE', '\t', '\xAE', '\x4', '\xAF', '\t', '\xAF', 
		'\x4', '\xB0', '\t', '\xB0', '\x4', '\xB1', '\t', '\xB1', '\x4', '\xB2', 
		'\t', '\xB2', '\x4', '\xB3', '\t', '\xB3', '\x4', '\xB4', '\t', '\xB4', 
		'\x4', '\xB5', '\t', '\xB5', '\x4', '\xB6', '\t', '\xB6', '\x4', '\xB7', 
		'\t', '\xB7', '\x4', '\xB8', '\t', '\xB8', '\x4', '\xB9', '\t', '\xB9', 
		'\x4', '\xBA', '\t', '\xBA', '\x4', '\xBB', '\t', '\xBB', '\x4', '\xBC', 
		'\t', '\xBC', '\x4', '\xBD', '\t', '\xBD', '\x4', '\xBE', '\t', '\xBE', 
		'\x4', '\xBF', '\t', '\xBF', '\x4', '\xC0', '\t', '\xC0', '\x4', '\xC1', 
		'\t', '\xC1', '\x4', '\xC2', '\t', '\xC2', '\x4', '\xC3', '\t', '\xC3', 
		'\x4', '\xC4', '\t', '\xC4', '\x4', '\xC5', '\t', '\xC5', '\x4', '\xC6', 
		'\t', '\xC6', '\x4', '\xC7', '\t', '\xC7', '\x4', '\xC8', '\t', '\xC8', 
		'\x4', '\xC9', '\t', '\xC9', '\x4', '\xCA', '\t', '\xCA', '\x4', '\xCB', 
		'\t', '\xCB', '\x4', '\xCC', '\t', '\xCC', '\x4', '\xCD', '\t', '\xCD', 
		'\x4', '\xCE', '\t', '\xCE', '\x4', '\xCF', '\t', '\xCF', '\x4', '\xD0', 
		'\t', '\xD0', '\x4', '\xD1', '\t', '\xD1', '\x4', '\xD2', '\t', '\xD2', 
		'\x4', '\xD3', '\t', '\xD3', '\x4', '\xD4', '\t', '\xD4', '\x4', '\xD5', 
		'\t', '\xD5', '\x4', '\xD6', '\t', '\xD6', '\x4', '\xD7', '\t', '\xD7', 
		'\x4', '\xD8', '\t', '\xD8', '\x4', '\xD9', '\t', '\xD9', '\x4', '\xDA', 
		'\t', '\xDA', '\x4', '\xDB', '\t', '\xDB', '\x4', '\xDC', '\t', '\xDC', 
		'\x4', '\xDD', '\t', '\xDD', '\x4', '\xDE', '\t', '\xDE', '\x4', '\xDF', 
		'\t', '\xDF', '\x4', '\xE0', '\t', '\xE0', '\x4', '\xE1', '\t', '\xE1', 
		'\x4', '\xE2', '\t', '\xE2', '\x4', '\xE3', '\t', '\xE3', '\x4', '\xE4', 
		'\t', '\xE4', '\x4', '\xE5', '\t', '\xE5', '\x4', '\xE6', '\t', '\xE6', 
		'\x4', '\xE7', '\t', '\xE7', '\x4', '\xE8', '\t', '\xE8', '\x4', '\xE9', 
		'\t', '\xE9', '\x4', '\xEA', '\t', '\xEA', '\x4', '\xEB', '\t', '\xEB', 
		'\x4', '\xEC', '\t', '\xEC', '\x4', '\xED', '\t', '\xED', '\x4', '\xEE', 
		'\t', '\xEE', '\x4', '\xEF', '\t', '\xEF', '\x4', '\xF0', '\t', '\xF0', 
		'\x4', '\xF1', '\t', '\xF1', '\x4', '\xF2', '\t', '\xF2', '\x4', '\xF3', 
		'\t', '\xF3', '\x4', '\xF4', '\t', '\xF4', '\x4', '\xF5', '\t', '\xF5', 
		'\x4', '\xF6', '\t', '\xF6', '\x4', '\xF7', '\t', '\xF7', '\x4', '\xF8', 
		'\t', '\xF8', '\x4', '\xF9', '\t', '\xF9', '\x4', '\xFA', '\t', '\xFA', 
		'\x4', '\xFB', '\t', '\xFB', '\x4', '\xFC', '\t', '\xFC', '\x4', '\xFD', 
		'\t', '\xFD', '\x4', '\xFE', '\t', '\xFE', '\x4', '\xFF', '\t', '\xFF', 
		'\x4', '\x100', '\t', '\x100', '\x4', '\x101', '\t', '\x101', '\x4', '\x102', 
		'\t', '\x102', '\x4', '\x103', '\t', '\x103', '\x4', '\x104', '\t', '\x104', 
		'\x4', '\x105', '\t', '\x105', '\x4', '\x106', '\t', '\x106', '\x4', '\x107', 
		'\t', '\x107', '\x4', '\x108', '\t', '\x108', '\x4', '\x109', '\t', '\x109', 
		'\x4', '\x10A', '\t', '\x10A', '\x4', '\x10B', '\t', '\x10B', '\x4', '\x10C', 
		'\t', '\x10C', '\x4', '\x10D', '\t', '\x10D', '\x4', '\x10E', '\t', '\x10E', 
		'\x4', '\x10F', '\t', '\x10F', '\x4', '\x110', '\t', '\x110', '\x4', '\x111', 
		'\t', '\x111', '\x4', '\x112', '\t', '\x112', '\x4', '\x113', '\t', '\x113', 
		'\x4', '\x114', '\t', '\x114', '\x4', '\x115', '\t', '\x115', '\x4', '\x116', 
		'\t', '\x116', '\x4', '\x117', '\t', '\x117', '\x4', '\x118', '\t', '\x118', 
		'\x4', '\x119', '\t', '\x119', '\x4', '\x11A', '\t', '\x11A', '\x4', '\x11B', 
		'\t', '\x11B', '\x4', '\x11C', '\t', '\x11C', '\x4', '\x11D', '\t', '\x11D', 
		'\x4', '\x11E', '\t', '\x11E', '\x4', '\x11F', '\t', '\x11F', '\x4', '\x120', 
		'\t', '\x120', '\x4', '\x121', '\t', '\x121', '\x4', '\x122', '\t', '\x122', 
		'\x4', '\x123', '\t', '\x123', '\x4', '\x124', '\t', '\x124', '\x4', '\x125', 
		'\t', '\x125', '\x4', '\x126', '\t', '\x126', '\x4', '\x127', '\t', '\x127', 
		'\x4', '\x128', '\t', '\x128', '\x4', '\x129', '\t', '\x129', '\x4', '\x12A', 
		'\t', '\x12A', '\x4', '\x12B', '\t', '\x12B', '\x4', '\x12C', '\t', '\x12C', 
		'\x4', '\x12D', '\t', '\x12D', '\x4', '\x12E', '\t', '\x12E', '\x4', '\x12F', 
		'\t', '\x12F', '\x4', '\x130', '\t', '\x130', '\x4', '\x131', '\t', '\x131', 
		'\x4', '\x132', '\t', '\x132', '\x4', '\x133', '\t', '\x133', '\x4', '\x134', 
		'\t', '\x134', '\x4', '\x135', '\t', '\x135', '\x4', '\x136', '\t', '\x136', 
		'\x4', '\x137', '\t', '\x137', '\x4', '\x138', '\t', '\x138', '\x4', '\x139', 
		'\t', '\x139', '\x4', '\x13A', '\t', '\x13A', '\x4', '\x13B', '\t', '\x13B', 
		'\x4', '\x13C', '\t', '\x13C', '\x4', '\x13D', '\t', '\x13D', '\x4', '\x13E', 
		'\t', '\x13E', '\x4', '\x13F', '\t', '\x13F', '\x4', '\x140', '\t', '\x140', 
		'\x4', '\x141', '\t', '\x141', '\x4', '\x142', '\t', '\x142', '\x4', '\x143', 
		'\t', '\x143', '\x4', '\x144', '\t', '\x144', '\x4', '\x145', '\t', '\x145', 
		'\x4', '\x146', '\t', '\x146', '\x4', '\x147', '\t', '\x147', '\x4', '\x148', 
		'\t', '\x148', '\x4', '\x149', '\t', '\x149', '\x4', '\x14A', '\t', '\x14A', 
		'\x4', '\x14B', '\t', '\x14B', '\x4', '\x14C', '\t', '\x14C', '\x4', '\x14D', 
		'\t', '\x14D', '\x4', '\x14E', '\t', '\x14E', '\x4', '\x14F', '\t', '\x14F', 
		'\x4', '\x150', '\t', '\x150', '\x4', '\x151', '\t', '\x151', '\x4', '\x152', 
		'\t', '\x152', '\x4', '\x153', '\t', '\x153', '\x4', '\x154', '\t', '\x154', 
		'\x4', '\x155', '\t', '\x155', '\x4', '\x156', '\t', '\x156', '\x4', '\x157', 
		'\t', '\x157', '\x4', '\x158', '\t', '\x158', '\x4', '\x159', '\t', '\x159', 
		'\x4', '\x15A', '\t', '\x15A', '\x4', '\x15B', '\t', '\x15B', '\x4', '\x15C', 
		'\t', '\x15C', '\x4', '\x15D', '\t', '\x15D', '\x4', '\x15E', '\t', '\x15E', 
		'\x4', '\x15F', '\t', '\x15F', '\x4', '\x160', '\t', '\x160', '\x4', '\x161', 
		'\t', '\x161', '\x4', '\x162', '\t', '\x162', '\x4', '\x163', '\t', '\x163', 
		'\x4', '\x164', '\t', '\x164', '\x4', '\x165', '\t', '\x165', '\x4', '\x166', 
		'\t', '\x166', '\x4', '\x167', '\t', '\x167', '\x4', '\x168', '\t', '\x168', 
		'\x4', '\x169', '\t', '\x169', '\x4', '\x16A', '\t', '\x16A', '\x4', '\x16B', 
		'\t', '\x16B', '\x4', '\x16C', '\t', '\x16C', '\x4', '\x16D', '\t', '\x16D', 
		'\x4', '\x16E', '\t', '\x16E', '\x4', '\x16F', '\t', '\x16F', '\x4', '\x170', 
		'\t', '\x170', '\x4', '\x171', '\t', '\x171', '\x4', '\x172', '\t', '\x172', 
		'\x4', '\x173', '\t', '\x173', '\x4', '\x174', '\t', '\x174', '\x4', '\x175', 
		'\t', '\x175', '\x4', '\x176', '\t', '\x176', '\x4', '\x177', '\t', '\x177', 
		'\x4', '\x178', '\t', '\x178', '\x4', '\x179', '\t', '\x179', '\x4', '\x17A', 
		'\t', '\x17A', '\x4', '\x17B', '\t', '\x17B', '\x4', '\x17C', '\t', '\x17C', 
		'\x4', '\x17D', '\t', '\x17D', '\x4', '\x17E', '\t', '\x17E', '\x4', '\x17F', 
		'\t', '\x17F', '\x3', '\x2', '\x3', '\x2', '\x3', '\x2', '\a', '\x2', 
		'\x302', '\n', '\x2', '\f', '\x2', '\xE', '\x2', '\x305', '\v', '\x2', 
		'\x3', '\x2', '\x5', '\x2', '\x308', '\n', '\x2', '\x3', '\x2', '\x3', 
		'\x2', '\x3', '\x3', '\x3', '\x3', '\x5', '\x3', '\x30E', '\n', '\x3', 
		'\x3', '\x4', '\x3', '\x4', '\x3', '\x4', '\a', '\x4', '\x313', '\n', 
		'\x4', '\f', '\x4', '\xE', '\x4', '\x316', '\v', '\x4', '\x3', '\x5', 
		'\x3', '\x5', '\x5', '\x5', '\x31A', '\n', '\x5', '\x3', '\x6', '\x3', 
		'\x6', '\x3', '\x6', '\x5', '\x6', '\x31F', '\n', '\x6', '\x3', '\x6', 
		'\a', '\x6', '\x322', '\n', '\x6', '\f', '\x6', '\xE', '\x6', '\x325', 
		'\v', '\x6', '\x3', '\a', '\x6', '\a', '\x328', '\n', '\a', '\r', '\a', 
		'\xE', '\a', '\x329', '\x3', '\a', '\x5', '\a', '\x32D', '\n', '\a', '\x3', 
		'\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\b', '\x3', '\t', 
		'\x3', '\t', '\x3', '\t', '\x3', '\n', '\x6', '\n', '\x338', '\n', '\n', 
		'\r', '\n', '\xE', '\n', '\x339', '\x3', '\n', '\x5', '\n', '\x33D', '\n', 
		'\n', '\x3', '\n', '\x3', '\n', '\x3', '\n', '\x3', '\n', '\x5', '\n', 
		'\x343', '\n', '\n', '\x3', '\v', '\x3', '\v', '\x3', '\v', '\x3', '\v', 
		'\x3', '\v', '\x3', '\v', '\x3', '\v', '\x3', '\v', '\x3', '\v', '\x3', 
		'\v', '\x3', '\v', '\x3', '\v', '\x3', '\v', '\x3', '\v', '\x3', '\v', 
		'\x3', '\v', '\x3', '\v', '\x3', '\v', '\x3', '\v', '\x5', '\v', '\x358', 
		'\n', '\v', '\x3', '\f', '\x3', '\f', '\x5', '\f', '\x35C', '\n', '\f', 
		'\x3', '\f', '\x3', '\f', '\x3', '\r', '\x3', '\r', '\x3', '\r', '\x3', 
		'\r', '\x3', '\r', '\x3', '\r', '\x5', '\r', '\x366', '\n', '\r', '\x3', 
		'\xE', '\x3', '\xE', '\x3', '\xF', '\x3', '\xF', '\x3', '\xF', '\x3', 
		'\x10', '\x5', '\x10', '\x36E', '\n', '\x10', '\x3', '\x10', '\x3', '\x10', 
		'\x5', '\x10', '\x372', '\n', '\x10', '\x3', '\x10', '\x5', '\x10', '\x375', 
		'\n', '\x10', '\x3', '\x10', '\x5', '\x10', '\x378', '\n', '\x10', '\x3', 
		'\x11', '\x3', '\x11', '\x3', '\x11', '\x5', '\x11', '\x37D', '\n', '\x11', 
		'\x3', '\x12', '\x3', '\x12', '\x5', '\x12', '\x381', '\n', '\x12', '\x3', 
		'\x12', '\x3', '\x12', '\a', '\x12', '\x385', '\n', '\x12', '\f', '\x12', 
		'\xE', '\x12', '\x388', '\v', '\x12', '\x3', '\x13', '\x3', '\x13', '\x3', 
		'\x13', '\x5', '\x13', '\x38D', '\n', '\x13', '\x3', '\x14', '\x3', '\x14', 
		'\x3', '\x15', '\x3', '\x15', '\x3', '\x16', '\x3', '\x16', '\x3', '\x16', 
		'\x3', '\x16', '\x3', '\x16', '\a', '\x16', '\x398', '\n', '\x16', '\f', 
		'\x16', '\xE', '\x16', '\x39B', '\v', '\x16', '\x3', '\x17', '\x3', '\x17', 
		'\x3', '\x17', '\x3', '\x18', '\x3', '\x18', '\x3', '\x18', '\x3', '\x19', 
		'\x3', '\x19', '\x3', '\x19', '\x3', '\x1A', '\x3', '\x1A', '\x3', '\x1A', 
		'\x5', '\x1A', '\x3A9', '\n', '\x1A', '\x3', '\x1B', '\x3', '\x1B', '\x3', 
		'\x1B', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1C', '\x3', '\x1D', '\x3', 
		'\x1D', '\x3', '\x1D', '\x3', '\x1D', '\a', '\x1D', '\x3B5', '\n', '\x1D', 
		'\f', '\x1D', '\xE', '\x1D', '\x3B8', '\v', '\x1D', '\x3', '\x1E', '\x3', 
		'\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', 
		'\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', 
		'\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', 
		'\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', '\x1E', '\x3', 
		'\x1E', '\x5', '\x1E', '\x3D0', '\n', '\x1E', '\x3', '\x1F', '\x3', '\x1F', 
		'\x3', '\x1F', '\x3', '\x1F', '\a', '\x1F', '\x3D6', '\n', '\x1F', '\f', 
		'\x1F', '\xE', '\x1F', '\x3D9', '\v', '\x1F', '\x3', ' ', '\x3', ' ', 
		'\x3', ' ', '\x3', ' ', '\x3', ' ', '\x3', ' ', '\x3', ' ', '\x3', ' ', 
		'\x5', ' ', '\x3E3', '\n', ' ', '\x3', '!', '\x5', '!', '\x3E6', '\n', 
		'!', '\x3', '!', '\x3', '!', '\x3', '!', '\x3', '!', '\a', '!', '\x3EC', 
		'\n', '!', '\f', '!', '\xE', '!', '\x3EF', '\v', '!', '\x3', '\"', '\x5', 
		'\"', '\x3F2', '\n', '\"', '\x3', '\"', '\x3', '\"', '\x5', '\"', '\x3F6', 
		'\n', '\"', '\x3', '\"', '\x3', '\"', '\a', '\"', '\x3FA', '\n', '\"', 
		'\f', '\"', '\xE', '\"', '\x3FD', '\v', '\"', '\x3', '\"', '\x5', '\"', 
		'\x400', '\n', '\"', '\x3', '#', '\x3', '#', '\x3', '#', '\x5', '#', '\x405', 
		'\n', '#', '\x3', '#', '\x5', '#', '\x408', '\n', '#', '\x3', '#', '\x3', 
		'#', '\x3', '#', '\x5', '#', '\x40D', '\n', '#', '\x3', '#', '\x5', '#', 
		'\x410', '\n', '#', '\x5', '#', '\x412', '\n', '#', '\x3', '$', '\x3', 
		'$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', 
		'$', '\x5', '$', '\x41C', '\n', '$', '\x3', '$', '\x5', '$', '\x41F', 
		'\n', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', 
		'\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', '\x3', '$', 
		'\x3', '$', '\x3', '$', '\x5', '$', '\x42E', '\n', '$', '\x3', '%', '\x3', 
		'%', '\x3', '%', '\a', '%', '\x433', '\n', '%', '\f', '%', '\xE', '%', 
		'\x436', '\v', '%', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', '&', '\x3', 
		'\'', '\x3', '\'', '\x5', '\'', '\x43E', '\n', '\'', '\x3', '\'', '\x3', 
		'\'', '\x3', '(', '\x3', '(', '\x3', '(', '\x3', '(', '\x3', '(', '\x3', 
		')', '\x3', ')', '\x3', ')', '\x3', ')', '\a', ')', '\x44B', '\n', ')', 
		'\f', ')', '\xE', ')', '\x44E', '\v', ')', '\x3', '*', '\x3', '*', '\x3', 
		'*', '\x3', '*', '\x3', '+', '\x5', '+', '\x455', '\n', '+', '\x3', '+', 
		'\x3', '+', '\x3', '+', '\x3', '+', '\x3', '+', '\x3', '+', '\a', '+', 
		'\x45D', '\n', '+', '\f', '+', '\xE', '+', '\x460', '\v', '+', '\x5', 
		'+', '\x462', '\n', '+', '\x3', '+', '\x5', '+', '\x465', '\n', '+', '\x3', 
		'+', '\x3', '+', '\x3', '+', '\x3', '+', '\x3', '+', '\a', '+', '\x46C', 
		'\n', '+', '\f', '+', '\xE', '+', '\x46F', '\v', '+', '\x3', '+', '\x5', 
		'+', '\x472', '\n', '+', '\x5', '+', '\x474', '\n', '+', '\x5', '+', '\x476', 
		'\n', '+', '\x3', ',', '\x3', ',', '\x3', ',', '\x3', '-', '\x3', '-', 
		'\x3', '.', '\x3', '.', '\x3', '.', '\x5', '.', '\x480', '\n', '.', '\x3', 
		'/', '\x3', '/', '\x3', '/', '\x3', '/', '\x5', '/', '\x486', '\n', '/', 
		'\x3', '/', '\x3', '/', '\x3', '/', '\x3', '/', '\x3', '/', '\x3', '/', 
		'\x5', '/', '\x48E', '\n', '/', '\x3', '\x30', '\x3', '\x30', '\x3', '\x30', 
		'\x3', '\x30', '\x3', '\x30', '\x3', '\x30', '\x3', '\x30', '\x6', '\x30', 
		'\x497', '\n', '\x30', '\r', '\x30', '\xE', '\x30', '\x498', '\x3', '\x30', 
		'\x3', '\x30', '\x3', '\x31', '\x5', '\x31', '\x49E', '\n', '\x31', '\x3', 
		'\x31', '\x3', '\x31', '\x5', '\x31', '\x4A2', '\n', '\x31', '\x3', '\x31', 
		'\x3', '\x31', '\x3', '\x31', '\x3', '\x31', '\x5', '\x31', '\x4A8', '\n', 
		'\x31', '\x3', '\x32', '\x3', '\x32', '\x3', '\x32', '\x3', '\x32', '\x3', 
		'\x32', '\a', '\x32', '\x4AF', '\n', '\x32', '\f', '\x32', '\xE', '\x32', 
		'\x4B2', '\v', '\x32', '\x5', '\x32', '\x4B4', '\n', '\x32', '\x3', '\x32', 
		'\x3', '\x32', '\x3', '\x33', '\x3', '\x33', '\x5', '\x33', '\x4BA', '\n', 
		'\x33', '\x3', '\x33', '\x5', '\x33', '\x4BD', '\n', '\x33', '\x3', '\x33', 
		'\x3', '\x33', '\x3', '\x33', '\x3', '\x33', '\a', '\x33', '\x4C3', '\n', 
		'\x33', '\f', '\x33', '\xE', '\x33', '\x4C6', '\v', '\x33', '\x3', '\x34', 
		'\x3', '\x34', '\x3', '\x34', '\x3', '\x34', '\x3', '\x35', '\x3', '\x35', 
		'\x3', '\x35', '\x3', '\x35', '\x5', '\x35', '\x4D0', '\n', '\x35', '\x3', 
		'\x35', '\x3', '\x35', '\x5', '\x35', '\x4D4', '\n', '\x35', '\x3', '\x35', 
		'\x3', '\x35', '\x3', '\x35', '\x5', '\x35', '\x4D9', '\n', '\x35', '\x3', 
		'\x36', '\x5', '\x36', '\x4DC', '\n', '\x36', '\x3', '\x36', '\x3', '\x36', 
		'\x3', '\x36', '\x3', '\x37', '\x3', '\x37', '\x3', '\x37', '\x3', '\x37', 
		'\x3', '\x37', '\x3', '\x38', '\x3', '\x38', '\x5', '\x38', '\x4E8', '\n', 
		'\x38', '\x3', '\x38', '\x5', '\x38', '\x4EB', '\n', '\x38', '\x3', '\x38', 
		'\x3', '\x38', '\x5', '\x38', '\x4EF', '\n', '\x38', '\x3', '\x38', '\x5', 
		'\x38', '\x4F2', '\n', '\x38', '\x3', '\x39', '\x3', '\x39', '\x3', '\x39', 
		'\a', '\x39', '\x4F7', '\n', '\x39', '\f', '\x39', '\xE', '\x39', '\x4FA', 
		'\v', '\x39', '\x3', ':', '\x3', ':', '\x3', ':', '\a', ':', '\x4FF', 
		'\n', ':', '\f', ':', '\xE', ':', '\x502', '\v', ':', '\x3', ';', '\x3', 
		';', '\x3', ';', '\x5', ';', '\x507', '\n', ';', '\x3', ';', '\x5', ';', 
		'\x50A', '\n', ';', '\x3', ';', '\x3', ';', '\x3', '<', '\x3', '<', '\x3', 
		'<', '\x5', '<', '\x511', '\n', '<', '\x3', '<', '\x3', '<', '\x3', '<', 
		'\x3', '<', '\a', '<', '\x517', '\n', '<', '\f', '<', '\xE', '<', '\x51A', 
		'\v', '<', '\x3', '=', '\x3', '=', '\x3', '=', '\x3', '=', '\x3', '=', 
		'\x5', '=', '\x521', '\n', '=', '\x3', '=', '\x3', '=', '\x5', '=', '\x525', 
		'\n', '=', '\x3', '=', '\x3', '=', '\x3', '=', '\x5', '=', '\x52A', '\n', 
		'=', '\x3', '>', '\x3', '>', '\x5', '>', '\x52E', '\n', '>', '\x3', '?', 
		'\x3', '?', '\x3', '?', '\x3', '?', '\x3', '?', '\x3', '@', '\x3', '@', 
		'\x3', '@', '\x5', '@', '\x538', '\n', '@', '\x3', '@', '\x3', '@', '\a', 
		'@', '\x53C', '\n', '@', '\f', '@', '\xE', '@', '\x53F', '\v', '@', '\x3', 
		'@', '\x6', '@', '\x542', '\n', '@', '\r', '@', '\xE', '@', '\x543', '\x3', 
		'\x41', '\x3', '\x41', '\x3', '\x41', '\x5', '\x41', '\x549', '\n', '\x41', 
		'\x3', '\x41', '\x3', '\x41', '\x3', '\x41', '\x5', '\x41', '\x54E', '\n', 
		'\x41', '\x3', '\x41', '\x3', '\x41', '\x5', '\x41', '\x552', '\n', '\x41', 
		'\x3', '\x41', '\x5', '\x41', '\x555', '\n', '\x41', '\x3', '\x41', '\x3', 
		'\x41', '\x5', '\x41', '\x559', '\n', '\x41', '\x3', '\x41', '\x3', '\x41', 
		'\x5', '\x41', '\x55D', '\n', '\x41', '\x3', '\x41', '\x5', '\x41', '\x560', 
		'\n', '\x41', '\x3', '\x41', '\x3', '\x41', '\x3', '\x41', '\x3', '\x41', 
		'\x5', '\x41', '\x566', '\n', '\x41', '\x5', '\x41', '\x568', '\n', '\x41', 
		'\x3', '\x42', '\x3', '\x42', '\x5', '\x42', '\x56C', '\n', '\x42', '\x3', 
		'\x43', '\x3', '\x43', '\x3', '\x44', '\x3', '\x44', '\x3', '\x45', '\x3', 
		'\x45', '\x3', '\x45', '\x3', '\x45', '\x6', '\x45', '\x576', '\n', '\x45', 
		'\r', '\x45', '\xE', '\x45', '\x577', '\x3', '\x46', '\x3', '\x46', '\x3', 
		'\x46', '\x3', '\x46', '\x3', '\x46', '\x3', '\x46', '\x3', '\x46', '\x5', 
		'\x46', '\x581', '\n', '\x46', '\x3', '\x46', '\x5', '\x46', '\x584', 
		'\n', '\x46', '\x3', '\x46', '\x5', '\x46', '\x587', '\n', '\x46', '\x3', 
		'\x46', '\x3', '\x46', '\x5', '\x46', '\x58B', '\n', '\x46', '\x3', '\x46', 
		'\x5', '\x46', '\x58E', '\n', '\x46', '\x3', 'G', '\x3', 'G', '\x3', 'G', 
		'\x3', 'G', '\x3', 'G', '\x3', 'G', '\x3', 'G', '\x5', 'G', '\x597', '\n', 
		'G', '\x3', 'G', '\x5', 'G', '\x59A', '\n', 'G', '\x3', 'G', '\x5', 'G', 
		'\x59D', '\n', 'G', '\x3', 'G', '\x5', 'G', '\x5A0', '\n', 'G', '\x3', 
		'H', '\x3', 'H', '\x3', 'H', '\x3', 'H', '\x5', 'H', '\x5A6', '\n', 'H', 
		'\x3', 'H', '\x3', 'H', '\x5', 'H', '\x5AA', '\n', 'H', '\x3', 'I', '\x3', 
		'I', '\x6', 'I', '\x5AE', '\n', 'I', '\r', 'I', '\xE', 'I', '\x5AF', '\x3', 
		'J', '\x3', 'J', '\x3', 'J', '\x5', 'J', '\x5B5', '\n', 'J', '\x3', 'J', 
		'\x3', 'J', '\a', 'J', '\x5B9', '\n', 'J', '\f', 'J', '\xE', 'J', '\x5BC', 
		'\v', 'J', '\x3', 'K', '\x3', 'K', '\x3', 'K', '\x3', 'K', '\x3', 'K', 
		'\x3', 'L', '\x3', 'L', '\x5', 'L', '\x5C5', '\n', 'L', '\x3', 'L', '\x3', 
		'L', '\x3', 'L', '\x3', 'L', '\x3', 'M', '\x3', 'M', '\x3', 'M', '\x3', 
		'N', '\x3', 'N', '\x3', 'N', '\x3', 'O', '\x3', 'O', '\x3', 'O', '\x3', 
		'P', '\x3', 'P', '\x3', 'P', '\x3', 'Q', '\x3', 'Q', '\x5', 'Q', '\x5D9', 
		'\n', 'Q', '\x3', 'R', '\x5', 'R', '\x5DC', '\n', 'R', '\x3', 'R', '\x3', 
		'R', '\x3', 'R', '\x3', 'R', '\x3', 'R', '\x3', 'R', '\x3', 'R', '\x3', 
		'R', '\x5', 'R', '\x5E6', '\n', 'R', '\x3', 'R', '\x5', 'R', '\x5E9', 
		'\n', 'R', '\x3', 'R', '\x5', 'R', '\x5EC', '\n', 'R', '\x3', 'R', '\x5', 
		'R', '\x5EF', '\n', 'R', '\x3', 'R', '\x3', 'R', '\x5', 'R', '\x5F3', 
		'\n', 'R', '\x3', 'R', '\x5', 'R', '\x5F6', '\n', 'R', '\x3', 'R', '\x3', 
		'R', '\x5', 'R', '\x5FA', '\n', 'R', '\x3', 'S', '\x5', 'S', '\x5FD', 
		'\n', 'S', '\x3', 'S', '\x3', 'S', '\x3', 'S', '\x3', 'S', '\x3', 'S', 
		'\x3', 'S', '\x3', 'S', '\x3', 'S', '\x5', 'S', '\x607', '\n', 'S', '\x3', 
		'S', '\x3', 'S', '\x5', 'S', '\x60B', '\n', 'S', '\x3', 'S', '\x3', 'S', 
		'\x5', 'S', '\x60F', '\n', 'S', '\x3', 'S', '\x3', 'S', '\x5', 'S', '\x613', 
		'\n', 'S', '\x3', 'T', '\x3', 'T', '\x3', 'U', '\x3', 'U', '\x3', 'V', 
		'\x3', 'V', '\x3', 'W', '\x3', 'W', '\x5', 'W', '\x61D', '\n', 'W', '\x3', 
		'W', '\x3', 'W', '\x5', 'W', '\x621', '\n', 'W', '\x3', 'W', '\x5', 'W', 
		'\x624', '\n', 'W', '\x3', 'X', '\x3', 'X', '\x3', 'X', '\x3', 'Y', '\x3', 
		'Y', '\x3', 'Y', '\x5', 'Y', '\x62C', '\n', 'Y', '\x3', 'Y', '\a', 'Y', 
		'\x62F', '\n', 'Y', '\f', 'Y', '\xE', 'Y', '\x632', '\v', 'Y', '\x3', 
		'Z', '\x3', 'Z', '\x3', 'Z', '\a', 'Z', '\x637', '\n', 'Z', '\f', 'Z', 
		'\xE', 'Z', '\x63A', '\v', 'Z', '\x3', '[', '\a', '[', '\x63D', '\n', 
		'[', '\f', '[', '\xE', '[', '\x640', '\v', '[', '\x3', '[', '\x3', '[', 
		'\x3', '\\', '\x3', '\\', '\x3', '\\', '\x3', '\\', '\x3', '\\', '\x3', 
		'\\', '\x3', '\\', '\x5', '\\', '\x64B', '\n', '\\', '\x3', ']', '\x3', 
		']', '\x3', ']', '\x3', ']', '\a', ']', '\x651', '\n', ']', '\f', ']', 
		'\xE', ']', '\x654', '\v', ']', '\x3', '^', '\x3', '^', '\x3', '^', '\x3', 
		'_', '\x3', '_', '\x3', '_', '\a', '_', '\x65C', '\n', '_', '\f', '_', 
		'\xE', '_', '\x65F', '\v', '_', '\x3', '`', '\x3', '`', '\x3', '`', '\a', 
		'`', '\x664', '\n', '`', '\f', '`', '\xE', '`', '\x667', '\v', '`', '\x3', 
		'\x61', '\x3', '\x61', '\x3', '\x61', '\a', '\x61', '\x66C', '\n', '\x61', 
		'\f', '\x61', '\xE', '\x61', '\x66F', '\v', '\x61', '\x3', '\x62', '\a', 
		'\x62', '\x672', '\n', '\x62', '\f', '\x62', '\xE', '\x62', '\x675', '\v', 
		'\x62', '\x3', '\x62', '\x3', '\x62', '\x3', '\x63', '\x3', '\x63', '\x3', 
		'\x63', '\a', '\x63', '\x67C', '\n', '\x63', '\f', '\x63', '\xE', '\x63', 
		'\x67F', '\v', '\x63', '\x3', '\x64', '\x3', '\x64', '\x5', '\x64', '\x683', 
		'\n', '\x64', '\x3', '\x65', '\x3', '\x65', '\x3', '\x65', '\x3', '\x65', 
		'\x3', '\x65', '\x3', '\x65', '\x3', '\x65', '\x5', '\x65', '\x68C', '\n', 
		'\x65', '\x3', '\x65', '\x3', '\x65', '\x3', '\x65', '\x5', '\x65', '\x691', 
		'\n', '\x65', '\x3', '\x65', '\x3', '\x65', '\x3', '\x65', '\x5', '\x65', 
		'\x696', '\n', '\x65', '\x3', '\x65', '\x3', '\x65', '\x5', '\x65', '\x69A', 
		'\n', '\x65', '\x3', '\x65', '\x3', '\x65', '\x3', '\x65', '\x5', '\x65', 
		'\x69F', '\n', '\x65', '\x3', '\x65', '\x5', '\x65', '\x6A2', '\n', '\x65', 
		'\x3', '\x65', '\x3', '\x65', '\x5', '\x65', '\x6A6', '\n', '\x65', '\x3', 
		'\x66', '\x3', '\x66', '\x3', 'g', '\x3', 'g', '\x3', 'g', '\a', 'g', 
		'\x6AD', '\n', 'g', '\f', 'g', '\xE', 'g', '\x6B0', '\v', 'g', '\x3', 
		'h', '\x3', 'h', '\x3', 'h', '\a', 'h', '\x6B5', '\n', 'h', '\f', 'h', 
		'\xE', 'h', '\x6B8', '\v', 'h', '\x3', 'i', '\x3', 'i', '\x3', 'i', '\a', 
		'i', '\x6BD', '\n', 'i', '\f', 'i', '\xE', 'i', '\x6C0', '\v', 'i', '\x3', 
		'j', '\x3', 'j', '\x3', 'j', '\x5', 'j', '\x6C5', '\n', 'j', '\x3', 'k', 
		'\x3', 'k', '\a', 'k', '\x6C9', '\n', 'k', '\f', 'k', '\xE', 'k', '\x6CC', 
		'\v', 'k', '\x3', 'l', '\x3', 'l', '\x3', 'l', '\x3', 'l', '\x3', 'l', 
		'\x3', 'l', '\x3', 'l', '\x5', 'l', '\x6D5', '\n', 'l', '\x3', 'l', '\x3', 
		'l', '\x5', 'l', '\x6D9', '\n', 'l', '\x3', 'l', '\x5', 'l', '\x6DC', 
		'\n', 'l', '\x3', 'm', '\x3', 'm', '\x3', 'm', '\x3', 'n', '\x3', 'n', 
		'\x3', 'n', '\x3', 'n', '\x3', 'o', '\x3', 'o', '\x6', 'o', '\x6E7', '\n', 
		'o', '\r', 'o', '\xE', 'o', '\x6E8', '\x3', 'p', '\x3', 'p', '\x3', 'p', 
		'\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', 
		'\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', 
		'\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', 
		'\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', '\x3', 'q', 
		'\x3', 'q', '\x5', 'q', '\x707', '\n', 'q', '\x3', 'r', '\x3', 'r', '\x3', 
		'r', '\x3', 'r', '\x3', 'r', '\x3', 'r', '\x3', 'r', '\x3', 'r', '\x3', 
		'r', '\x5', 'r', '\x712', '\n', 'r', '\x3', 's', '\x3', 's', '\x6', 's', 
		'\x716', '\n', 's', '\r', 's', '\xE', 's', '\x717', '\x3', 's', '\x3', 
		's', '\x5', 's', '\x71C', '\n', 's', '\x3', 's', '\x3', 's', '\x3', 't', 
		'\x3', 't', '\x3', 't', '\x3', 't', '\x3', 't', '\x3', 'u', '\x3', 'u', 
		'\x3', 'u', '\x6', 'u', '\x728', '\n', 'u', '\r', 'u', '\xE', 'u', '\x729', 
		'\x3', 'u', '\x3', 'u', '\x5', 'u', '\x72E', '\n', 'u', '\x3', 'u', '\x3', 
		'u', '\x3', 'v', '\x3', 'v', '\x3', 'v', '\x3', 'v', '\a', 'v', '\x736', 
		'\n', 'v', '\f', 'v', '\xE', 'v', '\x739', '\v', 'v', '\x3', 'v', '\x3', 
		'v', '\x3', 'v', '\x3', 'w', '\x3', 'w', '\x3', 'w', '\x3', 'w', '\x5', 
		'w', '\x742', '\n', 'w', '\x3', 'x', '\x3', 'x', '\x3', 'x', '\x3', 'x', 
		'\x3', 'x', '\x3', 'x', '\x5', 'x', '\x74A', '\n', 'x', '\x3', 'x', '\x3', 
		'x', '\x3', 'x', '\x3', 'x', '\x5', 'x', '\x750', '\n', 'x', '\x5', 'x', 
		'\x752', '\n', 'x', '\x3', 'x', '\x3', 'x', '\x3', 'y', '\x3', 'y', '\x3', 
		'y', '\x3', 'y', '\x5', 'y', '\x75A', '\n', 'y', '\x3', 'y', '\x3', 'y', 
		'\x3', 'y', '\x5', 'y', '\x75F', '\n', 'y', '\x3', 'y', '\x3', 'y', '\x3', 
		'y', '\x3', 'y', '\x3', 'z', '\x3', 'z', '\x3', 'z', '\x3', 'z', '\x3', 
		'z', '\x3', 'z', '\x3', 'z', '\x3', 'z', '\x3', 'z', '\x3', 'z', '\x3', 
		'z', '\x3', 'z', '\x3', 'z', '\x3', '{', '\x3', '{', '\x5', '{', '\x774', 
		'\n', '{', '\x3', '|', '\x3', '|', '\x3', '|', '\x3', '|', '\x3', '|', 
		'\x3', '|', '\x3', '|', '\x3', '|', '\x3', '|', '\x3', '|', '\x3', '|', 
		'\x3', '|', '\x3', '|', '\x3', '|', '\x3', '|', '\x3', '}', '\x3', '}', 
		'\x3', '}', '\x3', '}', '\x3', '}', '\a', '}', '\x78A', '\n', '}', '\f', 
		'}', '\xE', '}', '\x78D', '\v', '}', '\x3', '}', '\x3', '}', '\x3', '~', 
		'\x3', '~', '\x3', '~', '\x3', '~', '\x3', '~', '\x3', '~', '\x3', '~', 
		'\x5', '~', '\x798', '\n', '~', '\x3', '~', '\x3', '~', '\x3', '\x7F', 
		'\x3', '\x7F', '\x3', '\x7F', '\x3', '\x7F', '\x3', '\x7F', '\x5', '\x7F', 
		'\x7A1', '\n', '\x7F', '\x3', '\x7F', '\x3', '\x7F', '\x3', '\x80', '\x3', 
		'\x80', '\x3', '\x80', '\x3', '\x80', '\x3', '\x80', '\x3', '\x80', '\x3', 
		'\x80', '\x3', '\x80', '\x3', '\x80', '\x3', '\x81', '\x3', '\x81', '\x3', 
		'\x81', '\x3', '\x81', '\x3', '\x81', '\x3', '\x81', '\x3', '\x81', '\x3', 
		'\x81', '\x3', '\x81', '\x3', '\x82', '\x3', '\x82', '\x3', '\x82', '\x3', 
		'\x82', '\x3', '\x82', '\x3', '\x82', '\x3', '\x82', '\x3', '\x83', '\x3', 
		'\x83', '\x3', '\x84', '\x3', '\x84', '\x3', '\x85', '\x3', '\x85', '\x3', 
		'\x85', '\x5', '\x85', '\x7C5', '\n', '\x85', '\x3', '\x85', '\x5', '\x85', 
		'\x7C8', '\n', '\x85', '\x3', '\x85', '\x5', '\x85', '\x7CB', '\n', '\x85', 
		'\x3', '\x85', '\x3', '\x85', '\x3', '\x85', '\x3', '\x86', '\x3', '\x86', 
		'\x3', '\x87', '\x3', '\x87', '\x3', '\x88', '\x3', '\x88', '\x3', '\x88', 
		'\x3', '\x88', '\x3', '\x89', '\x3', '\x89', '\x3', '\x89', '\x3', '\x89', 
		'\x3', '\x89', '\a', '\x89', '\x7DD', '\n', '\x89', '\f', '\x89', '\xE', 
		'\x89', '\x7E0', '\v', '\x89', '\x5', '\x89', '\x7E2', '\n', '\x89', '\x3', 
		'\x89', '\x3', '\x89', '\x3', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x3', 
		'\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x3', '\x8A', '\x5', 
		'\x8A', '\x7EE', '\n', '\x8A', '\x3', '\x8B', '\x3', '\x8B', '\x3', '\x8B', 
		'\x3', '\x8B', '\x3', '\x8B', '\x3', '\x8C', '\x3', '\x8C', '\x3', '\x8C', 
		'\x3', '\x8C', '\x5', '\x8C', '\x7F9', '\n', '\x8C', '\x3', '\x8C', '\x3', 
		'\x8C', '\x5', '\x8C', '\x7FD', '\n', '\x8C', '\x5', '\x8C', '\x7FF', 
		'\n', '\x8C', '\x3', '\x8C', '\x3', '\x8C', '\x3', '\x8D', '\x3', '\x8D', 
		'\x3', '\x8D', '\x3', '\x8D', '\x5', '\x8D', '\x807', '\n', '\x8D', '\x3', 
		'\x8D', '\x3', '\x8D', '\x5', '\x8D', '\x80B', '\n', '\x8D', '\x5', '\x8D', 
		'\x80D', '\n', '\x8D', '\x3', '\x8D', '\x3', '\x8D', '\x3', '\x8E', '\x3', 
		'\x8E', '\x3', '\x8E', '\x3', '\x8E', '\x3', '\x8E', '\x3', '\x8F', '\x5', 
		'\x8F', '\x817', '\n', '\x8F', '\x3', '\x8F', '\x3', '\x8F', '\x3', '\x90', 
		'\x5', '\x90', '\x81C', '\n', '\x90', '\x3', '\x90', '\x3', '\x90', '\x3', 
		'\x91', '\x3', '\x91', '\x3', '\x91', '\x3', '\x91', '\a', '\x91', '\x824', 
		'\n', '\x91', '\f', '\x91', '\xE', '\x91', '\x827', '\v', '\x91', '\x5', 
		'\x91', '\x829', '\n', '\x91', '\x3', '\x91', '\x3', '\x91', '\x3', '\x92', 
		'\x3', '\x92', '\x3', '\x93', '\x3', '\x93', '\x3', '\x93', '\x3', '\x94', 
		'\x3', '\x94', '\x3', '\x94', '\x3', '\x94', '\x5', '\x94', '\x836', '\n', 
		'\x94', '\x3', '\x95', '\x3', '\x95', '\x3', '\x95', '\x5', '\x95', '\x83B', 
		'\n', '\x95', '\x3', '\x95', '\x3', '\x95', '\x3', '\x95', '\a', '\x95', 
		'\x840', '\n', '\x95', '\f', '\x95', '\xE', '\x95', '\x843', '\v', '\x95', 
		'\x5', '\x95', '\x845', '\n', '\x95', '\x3', '\x95', '\x3', '\x95', '\x3', 
		'\x96', '\x3', '\x96', '\x3', '\x97', '\x3', '\x97', '\x3', '\x97', '\x3', 
		'\x98', '\x3', '\x98', '\x3', '\x98', '\a', '\x98', '\x851', '\n', '\x98', 
		'\f', '\x98', '\xE', '\x98', '\x854', '\v', '\x98', '\x3', '\x99', '\x3', 
		'\x99', '\x3', '\x9A', '\x3', '\x9A', '\x3', '\x9A', '\a', '\x9A', '\x85B', 
		'\n', '\x9A', '\f', '\x9A', '\xE', '\x9A', '\x85E', '\v', '\x9A', '\x3', 
		'\x9B', '\x3', '\x9B', '\x3', '\x9B', '\a', '\x9B', '\x863', '\n', '\x9B', 
		'\f', '\x9B', '\xE', '\x9B', '\x866', '\v', '\x9B', '\x3', '\x9C', '\x3', 
		'\x9C', '\x5', '\x9C', '\x86A', '\n', '\x9C', '\x3', '\x9C', '\a', '\x9C', 
		'\x86D', '\n', '\x9C', '\f', '\x9C', '\xE', '\x9C', '\x870', '\v', '\x9C', 
		'\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', 
		'\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x5', '\x9D', '\x87A', '\n', 
		'\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', 
		'\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', 
		'\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', 
		'\x9D', '\x5', '\x9D', '\x88B', '\n', '\x9D', '\x3', '\x9D', '\x3', '\x9D', 
		'\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x5', '\x9D', '\x892', '\n', 
		'\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', 
		'\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', 
		'\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', 
		'\x9D', '\x5', '\x9D', '\x8A3', '\n', '\x9D', '\x3', '\x9D', '\x3', '\x9D', 
		'\x3', '\x9D', '\x3', '\x9D', '\x5', '\x9D', '\x8A9', '\n', '\x9D', '\x3', 
		'\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', 
		'\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', 
		'\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', 
		'\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', 
		'\x9D', '\x3', '\x9D', '\x5', '\x9D', '\x8C1', '\n', '\x9D', '\x3', '\x9D', 
		'\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x3', '\x9D', '\x5', '\x9D', 
		'\x8C8', '\n', '\x9D', '\x5', '\x9D', '\x8CA', '\n', '\x9D', '\x3', '\x9E', 
		'\x3', '\x9E', '\x3', '\x9E', '\x5', '\x9E', '\x8CF', '\n', '\x9E', '\x3', 
		'\x9F', '\x3', '\x9F', '\x5', '\x9F', '\x8D3', '\n', '\x9F', '\x3', '\xA0', 
		'\x3', '\xA0', '\x5', '\xA0', '\x8D7', '\n', '\xA0', '\x3', '\xA0', '\x3', 
		'\xA0', '\x3', '\xA0', '\x3', '\xA0', '\x3', '\xA0', '\x3', '\xA0', '\x3', 
		'\xA0', '\x3', '\xA0', '\x3', '\xA0', '\x3', '\xA0', '\x3', '\xA0', '\x3', 
		'\xA0', '\x5', '\xA0', '\x8E5', '\n', '\xA0', '\x3', '\xA0', '\x5', '\xA0', 
		'\x8E8', '\n', '\xA0', '\x3', '\xA1', '\x5', '\xA1', '\x8EB', '\n', '\xA1', 
		'\x3', '\xA1', '\x3', '\xA1', '\x3', '\xA1', '\x3', '\xA1', '\x3', '\xA1', 
		'\x3', '\xA1', '\x3', '\xA1', '\x3', '\xA1', '\x3', '\xA1', '\x3', '\xA1', 
		'\x3', '\xA1', '\x3', '\xA1', '\x3', '\xA1', '\x5', '\xA1', '\x8FA', '\n', 
		'\xA1', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x5', '\xA2', '\x8FF', 
		'\n', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', 
		'\x3', '\xA2', '\x3', '\xA2', '\x3', '\xA2', '\x5', '\xA2', '\x908', '\n', 
		'\xA2', '\x3', '\xA3', '\x3', '\xA3', '\x3', '\xA3', '\x3', '\xA3', '\x3', 
		'\xA3', '\x3', '\xA3', '\x3', '\xA3', '\x5', '\xA3', '\x911', '\n', '\xA3', 
		'\x3', '\xA4', '\x3', '\xA4', '\x3', '\xA4', '\x3', '\xA4', '\x3', '\xA4', 
		'\x3', '\xA4', '\x3', '\xA4', '\x3', '\xA4', '\x5', '\xA4', '\x91B', '\n', 
		'\xA4', '\x3', '\xA5', '\x3', '\xA5', '\x3', '\xA5', '\x3', '\xA5', '\x3', 
		'\xA5', '\x3', '\xA5', '\x3', '\xA5', '\x3', '\xA5', '\x3', '\xA5', '\x3', 
		'\xA5', '\x3', '\xA5', '\x3', '\xA5', '\x3', '\xA5', '\x3', '\xA5', '\x3', 
		'\xA5', '\x3', '\xA5', '\x3', '\xA5', '\x3', '\xA5', '\x5', '\xA5', '\x92F', 
		'\n', '\xA5', '\x3', '\xA6', '\x3', '\xA6', '\x5', '\xA6', '\x933', '\n', 
		'\xA6', '\x3', '\xA6', '\x5', '\xA6', '\x936', '\n', '\xA6', '\x3', '\xA7', 
		'\x3', '\xA7', '\x3', '\xA7', '\x5', '\xA7', '\x93B', '\n', '\xA7', '\x3', 
		'\xA8', '\x3', '\xA8', '\x3', '\xA8', '\x3', '\xA9', '\x3', '\xA9', '\x3', 
		'\xA9', '\x3', '\xAA', '\x3', '\xAA', '\x3', '\xAA', '\x3', '\xAA', '\x3', 
		'\xAA', '\a', '\xAA', '\x948', '\n', '\xAA', '\f', '\xAA', '\xE', '\xAA', 
		'\x94B', '\v', '\xAA', '\x5', '\xAA', '\x94D', '\n', '\xAA', '\x3', '\xAA', 
		'\x5', '\xAA', '\x950', '\n', '\xAA', '\x3', '\xAA', '\x5', '\xAA', '\x953', 
		'\n', '\xAA', '\x3', '\xAA', '\x5', '\xAA', '\x956', '\n', '\xAA', '\x3', 
		'\xAA', '\x5', '\xAA', '\x959', '\n', '\xAA', '\x3', '\xAB', '\x3', '\xAB', 
		'\x3', '\xAB', '\x3', '\xAC', '\x3', '\xAC', '\x3', '\xAC', '\x3', '\xAD', 
		'\x3', '\xAD', '\x5', '\xAD', '\x963', '\n', '\xAD', '\x3', '\xAE', '\x3', 
		'\xAE', '\x3', '\xAE', '\x3', '\xAE', '\x3', '\xAE', '\x3', '\xAE', '\x3', 
		'\xAE', '\x3', '\xAE', '\x5', '\xAE', '\x96D', '\n', '\xAE', '\x3', '\xAF', 
		'\x5', '\xAF', '\x970', '\n', '\xAF', '\x3', '\xAF', '\x3', '\xAF', '\x3', 
		'\xB0', '\x3', '\xB0', '\x3', '\xB1', '\x3', '\xB1', '\x5', '\xB1', '\x978', 
		'\n', '\xB1', '\x3', '\xB1', '\x5', '\xB1', '\x97B', '\n', '\xB1', '\x3', 
		'\xB2', '\x5', '\xB2', '\x97E', '\n', '\xB2', '\x3', '\xB2', '\x3', '\xB2', 
		'\x5', '\xB2', '\x982', '\n', '\xB2', '\x3', '\xB2', '\x3', '\xB2', '\x3', 
		'\xB2', '\x3', '\xB2', '\x5', '\xB2', '\x988', '\n', '\xB2', '\x3', '\xB2', 
		'\x3', '\xB2', '\x3', '\xB2', '\x5', '\xB2', '\x98D', '\n', '\xB2', '\x3', 
		'\xB2', '\x3', '\xB2', '\x3', '\xB2', '\x3', '\xB2', '\x5', '\xB2', '\x993', 
		'\n', '\xB2', '\x3', '\xB2', '\x5', '\xB2', '\x996', '\n', '\xB2', '\x3', 
		'\xB2', '\x3', '\xB2', '\x5', '\xB2', '\x99A', '\n', '\xB2', '\x3', '\xB3', 
		'\x3', '\xB3', '\x5', '\xB3', '\x99E', '\n', '\xB3', '\x3', '\xB4', '\x3', 
		'\xB4', '\x3', '\xB4', '\x3', '\xB4', '\x3', '\xB4', '\x3', '\xB4', '\x5', 
		'\xB4', '\x9A6', '\n', '\xB4', '\x3', '\xB5', '\x3', '\xB5', '\x5', '\xB5', 
		'\x9AA', '\n', '\xB5', '\x3', '\xB5', '\x5', '\xB5', '\x9AD', '\n', '\xB5', 
		'\x3', '\xB6', '\x3', '\xB6', '\x3', '\xB6', '\x3', '\xB6', '\x5', '\xB6', 
		'\x9B3', '\n', '\xB6', '\x3', '\xB6', '\x5', '\xB6', '\x9B6', '\n', '\xB6', 
		'\x3', '\xB7', '\x3', '\xB7', '\x5', '\xB7', '\x9BA', '\n', '\xB7', '\x3', 
		'\xB7', '\x5', '\xB7', '\x9BD', '\n', '\xB7', '\x3', '\xB7', '\x5', '\xB7', 
		'\x9C0', '\n', '\xB7', '\x3', '\xB8', '\x5', '\xB8', '\x9C3', '\n', '\xB8', 
		'\x3', '\xB8', '\x3', '\xB8', '\x5', '\xB8', '\x9C7', '\n', '\xB8', '\x3', 
		'\xB8', '\x5', '\xB8', '\x9CA', '\n', '\xB8', '\x3', '\xB8', '\x5', '\xB8', 
		'\x9CD', '\n', '\xB8', '\x3', '\xB9', '\x3', '\xB9', '\x3', '\xBA', '\x3', 
		'\xBA', '\x3', '\xBA', '\x3', '\xBA', '\x3', '\xBA', '\x5', '\xBA', '\x9D6', 
		'\n', '\xBA', '\x5', '\xBA', '\x9D8', '\n', '\xBA', '\x3', '\xBB', '\x3', 
		'\xBB', '\x3', '\xBB', '\x3', '\xBB', '\x3', '\xBB', '\x5', '\xBB', '\x9DF', 
		'\n', '\xBB', '\x3', '\xBC', '\x3', '\xBC', '\x3', '\xBC', '\x3', '\xBD', 
		'\x3', '\xBD', '\x3', '\xBD', '\x5', '\xBD', '\x9E7', '\n', '\xBD', '\x3', 
		'\xBD', '\x5', '\xBD', '\x9EA', '\n', '\xBD', '\x3', '\xBE', '\x3', '\xBE', 
		'\x3', '\xBE', '\x3', '\xBF', '\x3', '\xBF', '\x3', '\xC0', '\x5', '\xC0', 
		'\x9F2', '\n', '\xC0', '\x3', '\xC0', '\x3', '\xC0', '\x5', '\xC0', '\x9F6', 
		'\n', '\xC0', '\x5', '\xC0', '\x9F8', '\n', '\xC0', '\x3', '\xC0', '\x5', 
		'\xC0', '\x9FB', '\n', '\xC0', '\x3', '\xC1', '\x3', '\xC1', '\x5', '\xC1', 
		'\x9FF', '\n', '\xC1', '\x3', '\xC2', '\x3', '\xC2', '\x3', '\xC2', '\x3', 
		'\xC2', '\x3', '\xC2', '\x3', '\xC3', '\x3', '\xC3', '\x3', '\xC3', '\x5', 
		'\xC3', '\xA09', '\n', '\xC3', '\x3', '\xC3', '\x3', '\xC3', '\x3', '\xC3', 
		'\x3', '\xC3', '\x3', '\xC3', '\x3', '\xC3', '\x3', '\xC3', '\x5', '\xC3', 
		'\xA12', '\n', '\xC3', '\x3', '\xC3', '\x3', '\xC3', '\x3', '\xC3', '\x3', 
		'\xC4', '\x3', '\xC4', '\x5', '\xC4', '\xA19', '\n', '\xC4', '\x3', '\xC4', 
		'\x3', '\xC4', '\x3', '\xC4', '\x5', '\xC4', '\xA1E', '\n', '\xC4', '\x3', 
		'\xC4', '\x3', '\xC4', '\x3', '\xC4', '\x5', '\xC4', '\xA23', '\n', '\xC4', 
		'\x3', '\xC4', '\x3', '\xC4', '\x5', '\xC4', '\xA27', '\n', '\xC4', '\x3', 
		'\xC5', '\x3', '\xC5', '\x3', '\xC5', '\x3', '\xC5', '\x3', '\xC5', '\x5', 
		'\xC5', '\xA2E', '\n', '\xC5', '\x3', '\xC5', '\x3', '\xC5', '\x3', '\xC5', 
		'\x3', '\xC5', '\x3', '\xC5', '\x3', '\xC5', '\x5', '\xC5', '\xA36', '\n', 
		'\xC5', '\x3', '\xC5', '\x3', '\xC5', '\x3', '\xC5', '\x3', '\xC5', '\x3', 
		'\xC5', '\x3', '\xC5', '\x5', '\xC5', '\xA3E', '\n', '\xC5', '\x3', '\xC5', 
		'\x3', '\xC5', '\x3', '\xC5', '\x3', '\xC5', '\x3', '\xC5', '\x3', '\xC5', 
		'\x3', '\xC5', '\x3', '\xC5', '\x5', '\xC5', '\xA48', '\n', '\xC5', '\x3', 
		'\xC6', '\x3', '\xC6', '\x3', '\xC6', '\x3', '\xC6', '\x5', '\xC6', '\xA4E', 
		'\n', '\xC6', '\x3', '\xC7', '\x3', '\xC7', '\x3', '\xC7', '\x3', '\xC7', 
		'\x3', '\xC7', '\x3', '\xC7', '\x3', '\xC7', '\x3', '\xC7', '\x3', '\xC7', 
		'\x3', '\xC7', '\x3', '\xC7', '\x3', '\xC7', '\x3', '\xC7', '\x3', '\xC7', 
		'\x3', '\xC7', '\x3', '\xC7', '\x3', '\xC7', '\x3', '\xC7', '\x3', '\xC7', 
		'\x3', '\xC7', '\x5', '\xC7', '\xA64', '\n', '\xC7', '\x3', '\xC8', '\x5', 
		'\xC8', '\xA67', '\n', '\xC8', '\x3', '\xC8', '\x3', '\xC8', '\x3', '\xC8', 
		'\x5', '\xC8', '\xA6C', '\n', '\xC8', '\x3', '\xC8', '\x3', '\xC8', '\x3', 
		'\xC8', '\x5', '\xC8', '\xA71', '\n', '\xC8', '\x3', '\xC8', '\x3', '\xC8', 
		'\x3', '\xC8', '\x5', '\xC8', '\xA76', '\n', '\xC8', '\x3', '\xC9', '\x5', 
		'\xC9', '\xA79', '\n', '\xC9', '\x3', '\xC9', '\x3', '\xC9', '\x3', '\xC9', 
		'\x5', '\xC9', '\xA7E', '\n', '\xC9', '\x3', '\xC9', '\x3', '\xC9', '\x3', 
		'\xC9', '\x5', '\xC9', '\xA83', '\n', '\xC9', '\x3', '\xC9', '\x3', '\xC9', 
		'\x3', '\xC9', '\x3', '\xC9', '\x3', '\xC9', '\x3', '\xC9', '\x5', '\xC9', 
		'\xA8B', '\n', '\xC9', '\x3', '\xCA', '\x3', '\xCA', '\x3', '\xCA', '\x3', 
		'\xCA', '\x3', '\xCA', '\x3', '\xCA', '\a', '\xCA', '\xA93', '\n', '\xCA', 
		'\f', '\xCA', '\xE', '\xCA', '\xA96', '\v', '\xCA', '\x3', '\xCA', '\x3', 
		'\xCA', '\x3', '\xCB', '\x3', '\xCB', '\x3', '\xCB', '\x5', '\xCB', '\xA9D', 
		'\n', '\xCB', '\x3', '\xCB', '\x3', '\xCB', '\x3', '\xCB', '\x3', '\xCB', 
		'\x3', '\xCB', '\x3', '\xCB', '\x3', '\xCB', '\a', '\xCB', '\xAA6', '\n', 
		'\xCB', '\f', '\xCB', '\xE', '\xCB', '\xAA9', '\v', '\xCB', '\x3', '\xCB', 
		'\x3', '\xCB', '\x3', '\xCB', '\x5', '\xCB', '\xAAE', '\n', '\xCB', '\x3', 
		'\xCB', '\x3', '\xCB', '\x3', '\xCB', '\x3', '\xCC', '\x5', '\xCC', '\xAB4', 
		'\n', '\xCC', '\x3', '\xCC', '\x3', '\xCC', '\x3', '\xCC', '\x5', '\xCC', 
		'\xAB9', '\n', '\xCC', '\x3', '\xCC', '\x3', '\xCC', '\x3', '\xCC', '\x5', 
		'\xCC', '\xABE', '\n', '\xCC', '\x3', '\xCC', '\x3', '\xCC', '\x3', '\xCC', 
		'\x3', '\xCC', '\x3', '\xCC', '\x5', '\xCC', '\xAC5', '\n', '\xCC', '\x3', 
		'\xCD', '\x3', '\xCD', '\x3', '\xCD', '\x3', '\xCD', '\x3', '\xCD', '\x3', 
		'\xCD', '\x3', '\xCE', '\x3', '\xCE', '\x3', '\xCE', '\x5', '\xCE', '\xAD0', 
		'\n', '\xCE', '\x3', '\xCE', '\x3', '\xCE', '\x3', '\xCE', '\x3', '\xCE', 
		'\x3', '\xCE', '\x3', '\xCE', '\x5', '\xCE', '\xAD8', '\n', '\xCE', '\x3', 
		'\xCE', '\x3', '\xCE', '\x3', '\xCE', '\x3', '\xCE', '\x5', '\xCE', '\xADE', 
		'\n', '\xCE', '\x3', '\xCF', '\x3', '\xCF', '\x3', '\xCF', '\x3', '\xCF', 
		'\x5', '\xCF', '\xAE4', '\n', '\xCF', '\x3', '\xD0', '\x3', '\xD0', '\x3', 
		'\xD0', '\x3', '\xD0', '\x3', '\xD0', '\x3', '\xD0', '\x3', '\xD0', '\x5', 
		'\xD0', '\xAED', '\n', '\xD0', '\x3', '\xD1', '\x3', '\xD1', '\x3', '\xD1', 
		'\x3', '\xD1', '\x3', '\xD1', '\x3', '\xD1', '\a', '\xD1', '\xAF5', '\n', 
		'\xD1', '\f', '\xD1', '\xE', '\xD1', '\xAF8', '\v', '\xD1', '\x3', '\xD2', 
		'\x3', '\xD2', '\x3', '\xD2', '\x3', '\xD2', '\x3', '\xD2', '\x3', '\xD2', 
		'\x3', '\xD2', '\x5', '\xD2', '\xB01', '\n', '\xD2', '\x3', '\xD3', '\x3', 
		'\xD3', '\x5', '\xD3', '\xB05', '\n', '\xD3', '\x3', '\xD3', '\x3', '\xD3', 
		'\x3', '\xD4', '\x3', '\xD4', '\x5', '\xD4', '\xB0B', '\n', '\xD4', '\x3', 
		'\xD4', '\x3', '\xD4', '\x3', '\xD5', '\x3', '\xD5', '\x3', '\xD5', '\a', 
		'\xD5', '\xB12', '\n', '\xD5', '\f', '\xD5', '\xE', '\xD5', '\xB15', '\v', 
		'\xD5', '\x3', '\xD6', '\x3', '\xD6', '\x3', '\xD6', '\a', '\xD6', '\xB1A', 
		'\n', '\xD6', '\f', '\xD6', '\xE', '\xD6', '\xB1D', '\v', '\xD6', '\x3', 
		'\xD7', '\x3', '\xD7', '\x3', '\xD7', '\x5', '\xD7', '\xB22', '\n', '\xD7', 
		'\x3', '\xD8', '\x3', '\xD8', '\x3', '\xD8', '\x3', '\xD8', '\x5', '\xD8', 
		'\xB28', '\n', '\xD8', '\x3', '\xD9', '\x3', '\xD9', '\x5', '\xD9', '\xB2C', 
		'\n', '\xD9', '\x6', '\xD9', '\xB2E', '\n', '\xD9', '\r', '\xD9', '\xE', 
		'\xD9', '\xB2F', '\x3', '\xDA', '\x3', '\xDA', '\x5', '\xDA', '\xB34', 
		'\n', '\xDA', '\x6', '\xDA', '\xB36', '\n', '\xDA', '\r', '\xDA', '\xE', 
		'\xDA', '\xB37', '\x3', '\xDB', '\x3', '\xDB', '\x3', '\xDB', '\x5', '\xDB', 
		'\xB3D', '\n', '\xDB', '\x3', '\xDC', '\x3', '\xDC', '\x5', '\xDC', '\xB41', 
		'\n', '\xDC', '\x3', '\xDC', '\x3', '\xDC', '\x5', '\xDC', '\xB45', '\n', 
		'\xDC', '\x3', '\xDC', '\x5', '\xDC', '\xB48', '\n', '\xDC', '\x3', '\xDC', 
		'\x3', '\xDC', '\x5', '\xDC', '\xB4C', '\n', '\xDC', '\x3', '\xDD', '\x3', 
		'\xDD', '\x3', '\xDD', '\a', '\xDD', '\xB51', '\n', '\xDD', '\f', '\xDD', 
		'\xE', '\xDD', '\xB54', '\v', '\xDD', '\x3', '\xDE', '\x3', '\xDE', '\x3', 
		'\xDE', '\x3', '\xDF', '\x3', '\xDF', '\x5', '\xDF', '\xB5B', '\n', '\xDF', 
		'\x3', '\xE0', '\x3', '\xE0', '\x3', '\xE0', '\x3', '\xE0', '\x3', '\xE1', 
		'\x3', '\xE1', '\x5', '\xE1', '\xB63', '\n', '\xE1', '\x3', '\xE1', '\x3', 
		'\xE1', '\x5', '\xE1', '\xB67', '\n', '\xE1', '\x5', '\xE1', '\xB69', 
		'\n', '\xE1', '\x3', '\xE1', '\x3', '\xE1', '\x3', '\xE2', '\x3', '\xE2', 
		'\x3', '\xE2', '\x3', '\xE2', '\x5', '\xE2', '\xB71', '\n', '\xE2', '\x3', 
		'\xE3', '\x3', '\xE3', '\x3', '\xE3', '\x5', '\xE3', '\xB76', '\n', '\xE3', 
		'\x3', '\xE3', '\x3', '\xE3', '\x5', '\xE3', '\xB7A', '\n', '\xE3', '\x3', 
		'\xE3', '\x3', '\xE3', '\x3', '\xE3', '\x3', '\xE3', '\x3', '\xE4', '\x3', 
		'\xE4', '\x3', '\xE4', '\x3', '\xE5', '\x3', '\xE5', '\x5', '\xE5', '\xB85', 
		'\n', '\xE5', '\x3', '\xE6', '\x3', '\xE6', '\x3', '\xE6', '\x3', '\xE6', 
		'\x3', '\xE6', '\x3', '\xE6', '\x3', '\xE6', '\x3', '\xE6', '\x3', '\xE6', 
		'\x3', '\xE6', '\x3', '\xE6', '\x3', '\xE7', '\x3', '\xE7', '\x3', '\xE7', 
		'\x3', '\xE7', '\x3', '\xE7', '\x5', '\xE7', '\xB97', '\n', '\xE7', '\x3', 
		'\xE7', '\x3', '\xE7', '\x5', '\xE7', '\xB9B', '\n', '\xE7', '\x3', '\xE7', 
		'\x3', '\xE7', '\x3', '\xE7', '\x3', '\xE7', '\x3', '\xE7', '\x3', '\xE7', 
		'\x3', '\xE8', '\x3', '\xE8', '\x3', '\xE8', '\x3', '\xE8', '\a', '\xE8', 
		'\xBA7', '\n', '\xE8', '\f', '\xE8', '\xE', '\xE8', '\xBAA', '\v', '\xE8', 
		'\x5', '\xE8', '\xBAC', '\n', '\xE8', '\x3', '\xE8', '\x3', '\xE8', '\x3', 
		'\xE9', '\x3', '\xE9', '\x5', '\xE9', '\xBB2', '\n', '\xE9', '\x3', '\xE9', 
		'\x3', '\xE9', '\x5', '\xE9', '\xBB6', '\n', '\xE9', '\x3', '\xEA', '\x3', 
		'\xEA', '\x5', '\xEA', '\xBBA', '\n', '\xEA', '\x3', '\xEA', '\x3', '\xEA', 
		'\x3', '\xEB', '\x3', '\xEB', '\x3', '\xEC', '\x3', '\xEC', '\x5', '\xEC', 
		'\xBC2', '\n', '\xEC', '\x3', '\xEC', '\x3', '\xEC', '\x3', '\xEC', '\x5', 
		'\xEC', '\xBC7', '\n', '\xEC', '\x3', '\xEC', '\x3', '\xEC', '\x5', '\xEC', 
		'\xBCB', '\n', '\xEC', '\x3', '\xED', '\x3', '\xED', '\x3', '\xED', '\x3', 
		'\xED', '\x5', '\xED', '\xBD1', '\n', '\xED', '\x3', '\xEE', '\x3', '\xEE', 
		'\x5', '\xEE', '\xBD5', '\n', '\xEE', '\x3', '\xEE', '\x3', '\xEE', '\x3', 
		'\xEE', '\x3', '\xEE', '\x3', '\xEE', '\x3', '\xEE', '\x3', '\xEE', '\x5', 
		'\xEE', '\xBDE', '\n', '\xEE', '\x3', '\xEF', '\x3', '\xEF', '\x5', '\xEF', 
		'\xBE2', '\n', '\xEF', '\x3', '\xEF', '\x3', '\xEF', '\x3', '\xEF', '\x3', 
		'\xEF', '\x3', '\xF0', '\x3', '\xF0', '\x5', '\xF0', '\xBEA', '\n', '\xF0', 
		'\x3', '\xF0', '\x5', '\xF0', '\xBED', '\n', '\xF0', '\x3', '\xF0', '\x3', 
		'\xF0', '\x3', '\xF0', '\x3', '\xF0', '\x3', '\xF0', '\x3', '\xF0', '\x3', 
		'\xF0', '\x5', '\xF0', '\xBF6', '\n', '\xF0', '\x3', '\xF1', '\x3', '\xF1', 
		'\x3', '\xF2', '\x3', '\xF2', '\x3', '\xF3', '\x3', '\xF3', '\x3', '\xF4', 
		'\x3', '\xF4', '\x3', '\xF4', '\x3', '\xF4', '\x5', '\xF4', '\xC02', '\n', 
		'\xF4', '\x3', '\xF5', '\x3', '\xF5', '\x3', '\xF5', '\x3', '\xF5', '\x3', 
		'\xF5', '\x3', '\xF6', '\x3', '\xF6', '\x3', '\xF6', '\x3', '\xF6', '\x3', 
		'\xF6', '\x3', '\xF7', '\x3', '\xF7', '\x3', '\xF7', '\x3', '\xF8', '\x3', 
		'\xF8', '\x5', '\xF8', '\xC13', '\n', '\xF8', '\x3', '\xF9', '\x5', '\xF9', 
		'\xC16', '\n', '\xF9', '\x3', '\xF9', '\x3', '\xF9', '\x5', '\xF9', '\xC1A', 
		'\n', '\xF9', '\x3', '\xFA', '\x3', '\xFA', '\x3', '\xFA', '\x3', '\xFA', 
		'\x3', '\xFA', '\x3', '\xFA', '\x3', '\xFA', '\a', '\xFA', '\xC23', '\n', 
		'\xFA', '\f', '\xFA', '\xE', '\xFA', '\xC26', '\v', '\xFA', '\x3', '\xFB', 
		'\x3', '\xFB', '\x3', '\xFB', '\x3', '\xFC', '\x5', '\xFC', '\xC2C', '\n', 
		'\xFC', '\x3', '\xFC', '\x3', '\xFC', '\x3', '\xFC', '\x3', '\xFC', '\x3', 
		'\xFC', '\x5', '\xFC', '\xC33', '\n', '\xFC', '\x3', '\xFC', '\x3', '\xFC', 
		'\x3', '\xFC', '\x3', '\xFC', '\x5', '\xFC', '\xC39', '\n', '\xFC', '\x3', 
		'\xFD', '\x3', '\xFD', '\x3', '\xFD', '\x3', '\xFD', '\x5', '\xFD', '\xC3F', 
		'\n', '\xFD', '\x3', '\xFE', '\x3', '\xFE', '\x3', '\xFE', '\x3', '\xFE', 
		'\x5', '\xFE', '\xC45', '\n', '\xFE', '\x3', '\xFE', '\x3', '\xFE', '\x3', 
		'\xFE', '\x3', '\xFF', '\x5', '\xFF', '\xC4B', '\n', '\xFF', '\x3', '\xFF', 
		'\x3', '\xFF', '\x3', '\xFF', '\x5', '\xFF', '\xC50', '\n', '\xFF', '\x3', 
		'\xFF', '\x5', '\xFF', '\xC53', '\n', '\xFF', '\x3', '\x100', '\x3', '\x100', 
		'\x3', '\x100', '\x3', '\x100', '\x3', '\x101', '\x3', '\x101', '\x3', 
		'\x101', '\x3', '\x101', '\x3', '\x102', '\x3', '\x102', '\x3', '\x102', 
		'\x3', '\x102', '\x3', '\x102', '\x5', '\x102', '\xC62', '\n', '\x102', 
		'\x3', '\x102', '\x3', '\x102', '\x3', '\x102', '\x3', '\x102', '\x3', 
		'\x102', '\x3', '\x102', '\x3', '\x102', '\x5', '\x102', '\xC6B', '\n', 
		'\x102', '\x6', '\x102', '\xC6D', '\n', '\x102', '\r', '\x102', '\xE', 
		'\x102', '\xC6E', '\x3', '\x103', '\x3', '\x103', '\x3', '\x103', '\x3', 
		'\x103', '\x5', '\x103', '\xC75', '\n', '\x103', '\x3', '\x104', '\x3', 
		'\x104', '\x3', '\x104', '\x3', '\x104', '\x5', '\x104', '\xC7B', '\n', 
		'\x104', '\x3', '\x104', '\x3', '\x104', '\x3', '\x104', '\x3', '\x105', 
		'\x3', '\x105', '\x3', '\x105', '\x3', '\x105', '\x3', '\x105', '\x3', 
		'\x105', '\x3', '\x105', '\x3', '\x105', '\x3', '\x105', '\x3', '\x106', 
		'\x3', '\x106', '\x3', '\x106', '\x3', '\x106', '\x5', '\x106', '\xC8D', 
		'\n', '\x106', '\x3', '\x106', '\x3', '\x106', '\x3', '\x106', '\x3', 
		'\x106', '\x3', '\x106', '\x3', '\x106', '\x5', '\x106', '\xC95', '\n', 
		'\x106', '\x3', '\x106', '\x5', '\x106', '\xC98', '\n', '\x106', '\a', 
		'\x106', '\xC9A', '\n', '\x106', '\f', '\x106', '\xE', '\x106', '\xC9D', 
		'\v', '\x106', '\x3', '\x106', '\x3', '\x106', '\x3', '\x106', '\x3', 
		'\x106', '\x3', '\x106', '\x3', '\x106', '\x3', '\x106', '\x5', '\x106', 
		'\xCA6', '\n', '\x106', '\a', '\x106', '\xCA8', '\n', '\x106', '\f', '\x106', 
		'\xE', '\x106', '\xCAB', '\v', '\x106', '\x3', '\x107', '\x3', '\x107', 
		'\x5', '\x107', '\xCAF', '\n', '\x107', '\x3', '\x107', '\x3', '\x107', 
		'\x3', '\x107', '\x5', '\x107', '\xCB4', '\n', '\x107', '\x3', '\x108', 
		'\x5', '\x108', '\xCB7', '\n', '\x108', '\x3', '\x108', '\x3', '\x108', 
		'\x3', '\x108', '\x5', '\x108', '\xCBC', '\n', '\x108', '\x3', '\x109', 
		'\x5', '\x109', '\xCBF', '\n', '\x109', '\x3', '\x109', '\x3', '\x109', 
		'\x3', '\x109', '\x3', '\x10A', '\x3', '\x10A', '\x5', '\x10A', '\xCC6', 
		'\n', '\x10A', '\x3', '\x10B', '\x3', '\x10B', '\x5', '\x10B', '\xCCA', 
		'\n', '\x10B', '\x3', '\x10B', '\x3', '\x10B', '\x3', '\x10C', '\x3', 
		'\x10C', '\x3', '\x10C', '\x3', '\x10D', '\x3', '\x10D', '\x3', '\x10D', 
		'\x3', '\x10D', '\x3', '\x10E', '\x3', '\x10E', '\x5', '\x10E', '\xCD7', 
		'\n', '\x10E', '\x3', '\x10E', '\x3', '\x10E', '\x3', '\x10E', '\x3', 
		'\x10E', '\x6', '\x10E', '\xCDD', '\n', '\x10E', '\r', '\x10E', '\xE', 
		'\x10E', '\xCDE', '\x3', '\x10E', '\x3', '\x10E', '\x3', '\x10F', '\x3', 
		'\x10F', '\x3', '\x10F', '\x3', '\x10F', '\x3', '\x10F', '\x5', '\x10F', 
		'\xCE8', '\n', '\x10F', '\x3', '\x110', '\x3', '\x110', '\x3', '\x110', 
		'\x5', '\x110', '\xCED', '\n', '\x110', '\x3', '\x110', '\x5', '\x110', 
		'\xCF0', '\n', '\x110', '\x3', '\x111', '\x3', '\x111', '\x3', '\x111', 
		'\x5', '\x111', '\xCF5', '\n', '\x111', '\x3', '\x112', '\x3', '\x112', 
		'\x3', '\x112', '\x5', '\x112', '\xCFA', '\n', '\x112', '\x3', '\x113', 
		'\x5', '\x113', '\xCFD', '\n', '\x113', '\x3', '\x113', '\x3', '\x113', 
		'\x5', '\x113', '\xD01', '\n', '\x113', '\x3', '\x113', '\x5', '\x113', 
		'\xD04', '\n', '\x113', '\x3', '\x114', '\x3', '\x114', '\x3', '\x114', 
		'\x3', '\x114', '\x5', '\x114', '\xD0A', '\n', '\x114', '\x3', '\x114', 
		'\x5', '\x114', '\xD0D', '\n', '\x114', '\x3', '\x115', '\x3', '\x115', 
		'\x5', '\x115', '\xD11', '\n', '\x115', '\x3', '\x115', '\x3', '\x115', 
		'\x5', '\x115', '\xD15', '\n', '\x115', '\x3', '\x115', '\x5', '\x115', 
		'\xD18', '\n', '\x115', '\x3', '\x116', '\x3', '\x116', '\x5', '\x116', 
		'\xD1C', '\n', '\x116', '\x3', '\x116', '\x3', '\x116', '\x3', '\x117', 
		'\x3', '\x117', '\x3', '\x118', '\x3', '\x118', '\x3', '\x118', '\x3', 
		'\x118', '\x3', '\x118', '\x3', '\x118', '\x3', '\x118', '\x3', '\x118', 
		'\x3', '\x118', '\x3', '\x118', '\x3', '\x118', '\x5', '\x118', '\xD2D', 
		'\n', '\x118', '\x3', '\x119', '\x3', '\x119', '\x5', '\x119', '\xD31', 
		'\n', '\x119', '\x3', '\x119', '\x3', '\x119', '\x3', '\x119', '\x3', 
		'\x11A', '\x5', '\x11A', '\xD37', '\n', '\x11A', '\x3', '\x11A', '\x3', 
		'\x11A', '\x3', '\x11B', '\x3', '\x11B', '\x3', '\x11B', '\x3', '\x11B', 
		'\x3', '\x11B', '\x5', '\x11B', '\xD40', '\n', '\x11B', '\x3', '\x11B', 
		'\x3', '\x11B', '\x3', '\x11B', '\x5', '\x11B', '\xD45', '\n', '\x11B', 
		'\x3', '\x11B', '\x5', '\x11B', '\xD48', '\n', '\x11B', '\x3', '\x11C', 
		'\x3', '\x11C', '\x3', '\x11C', '\x3', '\x11C', '\x3', '\x11C', '\x3', 
		'\x11C', '\x3', '\x11C', '\x3', '\x11C', '\x3', '\x11C', '\x3', '\x11C', 
		'\x3', '\x11C', '\x3', '\x11C', '\x3', '\x11C', '\x5', '\x11C', '\xD57', 
		'\n', '\x11C', '\x3', '\x11D', '\x3', '\x11D', '\x3', '\x11D', '\x3', 
		'\x11D', '\x3', '\x11D', '\x5', '\x11D', '\xD5E', '\n', '\x11D', '\x3', 
		'\x11E', '\x3', '\x11E', '\x5', '\x11E', '\xD62', '\n', '\x11E', '\x3', 
		'\x11E', '\x3', '\x11E', '\x3', '\x11F', '\x3', '\x11F', '\x5', '\x11F', 
		'\xD68', '\n', '\x11F', '\x3', '\x11F', '\x3', '\x11F', '\x3', '\x120', 
		'\x3', '\x120', '\x5', '\x120', '\xD6E', '\n', '\x120', '\x3', '\x120', 
		'\x3', '\x120', '\x3', '\x121', '\x3', '\x121', '\x5', '\x121', '\xD74', 
		'\n', '\x121', '\x3', '\x121', '\x3', '\x121', '\x3', '\x121', '\x5', 
		'\x121', '\xD79', '\n', '\x121', '\x3', '\x122', '\x3', '\x122', '\x3', 
		'\x122', '\x5', '\x122', '\xD7E', '\n', '\x122', '\x3', '\x122', '\x3', 
		'\x122', '\x3', '\x122', '\x3', '\x122', '\x3', '\x122', '\x3', '\x122', 
		'\x3', '\x122', '\x5', '\x122', '\xD87', '\n', '\x122', '\x3', '\x123', 
		'\x3', '\x123', '\x3', '\x123', '\x3', '\x123', '\x3', '\x123', '\x3', 
		'\x123', '\x5', '\x123', '\xD8F', '\n', '\x123', '\x3', '\x124', '\x3', 
		'\x124', '\x3', '\x124', '\x3', '\x124', '\x3', '\x124', '\x5', '\x124', 
		'\xD96', '\n', '\x124', '\x5', '\x124', '\xD98', '\n', '\x124', '\x3', 
		'\x124', '\x3', '\x124', '\x3', '\x124', '\x3', '\x124', '\x3', '\x124', 
		'\x3', '\x124', '\x3', '\x124', '\x3', '\x124', '\x3', '\x124', '\x3', 
		'\x124', '\x3', '\x124', '\x3', '\x124', '\x5', '\x124', '\xDA6', '\n', 
		'\x124', '\x3', '\x124', '\x3', '\x124', '\x5', '\x124', '\xDAA', '\n', 
		'\x124', '\x3', '\x125', '\x3', '\x125', '\x3', '\x125', '\x3', '\x125', 
		'\x3', '\x125', '\x3', '\x125', '\x5', '\x125', '\xDB2', '\n', '\x125', 
		'\x3', '\x125', '\x3', '\x125', '\x3', '\x125', '\x3', '\x125', '\x5', 
		'\x125', '\xDB8', '\n', '\x125', '\x3', '\x125', '\x5', '\x125', '\xDBB', 
		'\n', '\x125', '\x3', '\x125', '\x3', '\x125', '\x3', '\x125', '\x3', 
		'\x125', '\x3', '\x125', '\x3', '\x125', '\x5', '\x125', '\xDC3', '\n', 
		'\x125', '\x3', '\x125', '\x3', '\x125', '\x3', '\x125', '\x3', '\x125', 
		'\x3', '\x125', '\x3', '\x125', '\x3', '\x125', '\x3', '\x125', '\x3', 
		'\x125', '\x3', '\x125', '\x3', '\x125', '\x3', '\x125', '\x3', '\x125', 
		'\x5', '\x125', '\xDD2', '\n', '\x125', '\x3', '\x126', '\x3', '\x126', 
		'\x3', '\x127', '\x3', '\x127', '\x3', '\x127', '\x3', '\x127', '\x3', 
		'\x127', '\x3', '\x127', '\x3', '\x127', '\x3', '\x127', '\x3', '\x127', 
		'\x5', '\x127', '\xDDF', '\n', '\x127', '\x3', '\x128', '\x3', '\x128', 
		'\x3', '\x128', '\x3', '\x128', '\x3', '\x129', '\x3', '\x129', '\x3', 
		'\x129', '\x5', '\x129', '\xDE8', '\n', '\x129', '\x3', '\x129', '\x3', 
		'\x129', '\x3', '\x129', '\x3', '\x129', '\x3', '\x129', '\x3', '\x129', 
		'\x5', '\x129', '\xDF0', '\n', '\x129', '\x3', '\x129', '\x5', '\x129', 
		'\xDF3', '\n', '\x129', '\x3', '\x129', '\x3', '\x129', '\x5', '\x129', 
		'\xDF7', '\n', '\x129', '\x3', '\x129', '\x3', '\x129', '\x5', '\x129', 
		'\xDFB', '\n', '\x129', '\x3', '\x129', '\x5', '\x129', '\xDFE', '\n', 
		'\x129', '\x5', '\x129', '\xE00', '\n', '\x129', '\x3', '\x129', '\x3', 
		'\x129', '\x3', '\x129', '\x3', '\x12A', '\x3', '\x12A', '\x3', '\x12A', 
		'\x5', '\x12A', '\xE08', '\n', '\x12A', '\x3', '\x12A', '\x3', '\x12A', 
		'\x5', '\x12A', '\xE0C', '\n', '\x12A', '\x3', '\x12A', '\x3', '\x12A', 
		'\x3', '\x12A', '\x3', '\x12A', '\x5', '\x12A', '\xE12', '\n', '\x12A', 
		'\x3', '\x12A', '\x3', '\x12A', '\x3', '\x12A', '\x3', '\x12A', '\x3', 
		'\x12A', '\x5', '\x12A', '\xE19', '\n', '\x12A', '\x3', '\x12A', '\x3', 
		'\x12A', '\x3', '\x12A', '\x3', '\x12A', '\x3', '\x12A', '\x3', '\x12A', 
		'\x5', '\x12A', '\xE21', '\n', '\x12A', '\x5', '\x12A', '\xE23', '\n', 
		'\x12A', '\x3', '\x12A', '\x3', '\x12A', '\x3', '\x12A', '\x3', '\x12B', 
		'\x3', '\x12B', '\x3', '\x12B', '\x3', '\x12B', '\x3', '\x12B', '\x5', 
		'\x12B', '\xE2D', '\n', '\x12B', '\x3', '\x12B', '\x3', '\x12B', '\x3', 
		'\x12B', '\x3', '\x12B', '\x3', '\x12B', '\x5', '\x12B', '\xE34', '\n', 
		'\x12B', '\x5', '\x12B', '\xE36', '\n', '\x12B', '\x3', '\x12B', '\x3', 
		'\x12B', '\x3', '\x12B', '\x5', '\x12B', '\xE3B', '\n', '\x12B', '\x5', 
		'\x12B', '\xE3D', '\n', '\x12B', '\x3', '\x12C', '\x3', '\x12C', '\x3', 
		'\x12D', '\x3', '\x12D', '\x3', '\x12E', '\x3', '\x12E', '\x3', '\x12F', 
		'\x3', '\x12F', '\x3', '\x130', '\x3', '\x130', '\x3', '\x131', '\x3', 
		'\x131', '\x3', '\x131', '\x5', '\x131', '\xE4C', '\n', '\x131', '\x3', 
		'\x131', '\x3', '\x131', '\x3', '\x132', '\x3', '\x132', '\x3', '\x133', 
		'\x3', '\x133', '\x3', '\x134', '\x3', '\x134', '\x3', '\x135', '\x3', 
		'\x135', '\x3', '\x135', '\a', '\x135', '\xE59', '\n', '\x135', '\f', 
		'\x135', '\xE', '\x135', '\xE5C', '\v', '\x135', '\x3', '\x136', '\x3', 
		'\x136', '\x5', '\x136', '\xE60', '\n', '\x136', '\x3', '\x136', '\x5', 
		'\x136', '\xE63', '\n', '\x136', '\x3', '\x137', '\x3', '\x137', '\x5', 
		'\x137', '\xE67', '\n', '\x137', '\x3', '\x138', '\x3', '\x138', '\x5', 
		'\x138', '\xE6B', '\n', '\x138', '\x3', '\x138', '\x3', '\x138', '\x3', 
		'\x138', '\x5', '\x138', '\xE70', '\n', '\x138', '\x3', '\x139', '\x3', 
		'\x139', '\x3', '\x139', '\x3', '\x139', '\x5', '\x139', '\xE76', '\n', 
		'\x139', '\x3', '\x139', '\x3', '\x139', '\x3', '\x139', '\x3', '\x139', 
		'\x3', '\x13A', '\x3', '\x13A', '\x5', '\x13A', '\xE7E', '\n', '\x13A', 
		'\x3', '\x13B', '\x3', '\x13B', '\x3', '\x13B', '\x5', '\x13B', '\xE83', 
		'\n', '\x13B', '\x3', '\x13B', '\x3', '\x13B', '\x3', '\x13C', '\x3', 
		'\x13C', '\x3', '\x13C', '\a', '\x13C', '\xE8A', '\n', '\x13C', '\f', 
		'\x13C', '\xE', '\x13C', '\xE8D', '\v', '\x13C', '\x3', '\x13D', '\x3', 
		'\x13D', '\x3', '\x13D', '\x5', '\x13D', '\xE92', '\n', '\x13D', '\x3', 
		'\x13D', '\x3', '\x13D', '\x3', '\x13D', '\x5', '\x13D', '\xE97', '\n', 
		'\x13D', '\x3', '\x13D', '\x3', '\x13D', '\x3', '\x13D', '\x3', '\x13D', 
		'\a', '\x13D', '\xE9D', '\n', '\x13D', '\f', '\x13D', '\xE', '\x13D', 
		'\xEA0', '\v', '\x13D', '\x5', '\x13D', '\xEA2', '\n', '\x13D', '\x3', 
		'\x13D', '\x3', '\x13D', '\x3', '\x13D', '\x3', '\x13D', '\x3', '\x13D', 
		'\x3', '\x13D', '\x5', '\x13D', '\xEAA', '\n', '\x13D', '\x3', '\x13D', 
		'\x3', '\x13D', '\x5', '\x13D', '\xEAE', '\n', '\x13D', '\x3', '\x13D', 
		'\x3', '\x13D', '\x3', '\x13D', '\x5', '\x13D', '\xEB3', '\n', '\x13D', 
		'\x3', '\x13D', '\x3', '\x13D', '\x3', '\x13D', '\x5', '\x13D', '\xEB8', 
		'\n', '\x13D', '\x3', '\x13D', '\x3', '\x13D', '\x3', '\x13D', '\x3', 
		'\x13D', '\a', '\x13D', '\xEBE', '\n', '\x13D', '\f', '\x13D', '\xE', 
		'\x13D', '\xEC1', '\v', '\x13D', '\x5', '\x13D', '\xEC3', '\n', '\x13D', 
		'\x3', '\x13D', '\x3', '\x13D', '\x3', '\x13D', '\x5', '\x13D', '\xEC8', 
		'\n', '\x13D', '\x3', '\x13D', '\x3', '\x13D', '\x3', '\x13D', '\x3', 
		'\x13D', '\x3', '\x13D', '\x3', '\x13D', '\x3', '\x13D', '\x3', '\x13D', 
		'\x5', '\x13D', '\xED2', '\n', '\x13D', '\x3', '\x13D', '\x3', '\x13D', 
		'\x3', '\x13D', '\x5', '\x13D', '\xED7', '\n', '\x13D', '\x3', '\x13D', 
		'\x3', '\x13D', '\x3', '\x13D', '\x5', '\x13D', '\xEDC', '\n', '\x13D', 
		'\x5', '\x13D', '\xEDE', '\n', '\x13D', '\x5', '\x13D', '\xEE0', '\n', 
		'\x13D', '\x3', '\x13E', '\x3', '\x13E', '\x3', '\x13E', '\x5', '\x13E', 
		'\xEE5', '\n', '\x13E', '\x3', '\x13F', '\x3', '\x13F', '\x3', '\x140', 
		'\x3', '\x140', '\x3', '\x141', '\x3', '\x141', '\x3', '\x142', '\x3', 
		'\x142', '\x3', '\x142', '\x3', '\x142', '\x3', '\x142', '\x5', '\x142', 
		'\xEF2', '\n', '\x142', '\x5', '\x142', '\xEF4', '\n', '\x142', '\x3', 
		'\x143', '\x3', '\x143', '\x3', '\x143', '\x3', '\x143', '\x3', '\x143', 
		'\x5', '\x143', '\xEFB', '\n', '\x143', '\x5', '\x143', '\xEFD', '\n', 
		'\x143', '\x3', '\x144', '\x3', '\x144', '\x3', '\x144', '\x3', '\x144', 
		'\x3', '\x144', '\x3', '\x144', '\x5', '\x144', '\xF05', '\n', '\x144', 
		'\x3', '\x144', '\x5', '\x144', '\xF08', '\n', '\x144', '\x3', '\x144', 
		'\x5', '\x144', '\xF0B', '\n', '\x144', '\x3', '\x144', '\x5', '\x144', 
		'\xF0E', '\n', '\x144', '\x3', '\x144', '\x5', '\x144', '\xF11', '\n', 
		'\x144', '\x3', '\x145', '\x3', '\x145', '\x3', '\x145', '\x3', '\x145', 
		'\x3', '\x145', '\x5', '\x145', '\xF18', '\n', '\x145', '\x3', '\x145', 
		'\x5', '\x145', '\xF1B', '\n', '\x145', '\x3', '\x145', '\x5', '\x145', 
		'\xF1E', '\n', '\x145', '\x3', '\x145', '\x3', '\x145', '\x5', '\x145', 
		'\xF22', '\n', '\x145', '\x3', '\x145', '\x5', '\x145', '\xF25', '\n', 
		'\x145', '\x3', '\x145', '\x5', '\x145', '\xF28', '\n', '\x145', '\x3', 
		'\x146', '\x5', '\x146', '\xF2B', '\n', '\x146', '\x3', '\x146', '\x5', 
		'\x146', '\xF2E', '\n', '\x146', '\x3', '\x146', '\x5', '\x146', '\xF31', 
		'\n', '\x146', '\x3', '\x146', '\x3', '\x146', '\x3', '\x147', '\x3', 
		'\x147', '\x3', '\x147', '\x3', '\x147', '\x5', '\x147', '\xF39', '\n', 
		'\x147', '\x3', '\x147', '\x3', '\x147', '\x3', '\x148', '\x3', '\x148', 
		'\x3', '\x148', '\x3', '\x148', '\x3', '\x148', '\x3', '\x148', '\x5', 
		'\x148', '\xF43', '\n', '\x148', '\x3', '\x148', '\x3', '\x148', '\x3', 
		'\x148', '\x3', '\x148', '\x5', '\x148', '\xF49', '\n', '\x148', '\x3', 
		'\x148', '\x3', '\x148', '\x3', '\x149', '\x5', '\x149', '\xF4E', '\n', 
		'\x149', '\x3', '\x149', '\x3', '\x149', '\x3', '\x149', '\x6', '\x149', 
		'\xF53', '\n', '\x149', '\r', '\x149', '\xE', '\x149', '\xF54', '\x3', 
		'\x14A', '\x3', '\x14A', '\x3', '\x14A', '\x3', '\x14B', '\x3', '\x14B', 
		'\x3', '\x14C', '\x3', '\x14C', '\x3', '\x14C', '\x3', '\x14D', '\x3', 
		'\x14D', '\x3', '\x14E', '\x3', '\x14E', '\x3', '\x14F', '\x3', '\x14F', 
		'\x3', '\x14F', '\x3', '\x14F', '\x3', '\x14F', '\x3', '\x150', '\x5', 
		'\x150', '\xF69', '\n', '\x150', '\x3', '\x150', '\x3', '\x150', '\x3', 
		'\x150', '\x3', '\x150', '\x5', '\x150', '\xF6F', '\n', '\x150', '\x3', 
		'\x150', '\x5', '\x150', '\xF72', '\n', '\x150', '\x3', '\x150', '\x3', 
		'\x150', '\x5', '\x150', '\xF76', '\n', '\x150', '\x3', '\x150', '\x5', 
		'\x150', '\xF79', '\n', '\x150', '\x3', '\x151', '\x3', '\x151', '\x3', 
		'\x151', '\x5', '\x151', '\xF7E', '\n', '\x151', '\x3', '\x152', '\x3', 
		'\x152', '\x3', '\x152', '\x3', '\x152', '\x5', '\x152', '\xF84', '\n', 
		'\x152', '\x3', '\x152', '\x3', '\x152', '\x3', '\x152', '\x3', '\x152', 
		'\x3', '\x152', '\x3', '\x152', '\x3', '\x152', '\x3', '\x152', '\x5', 
		'\x152', '\xF8E', '\n', '\x152', '\x6', '\x152', '\xF90', '\n', '\x152', 
		'\r', '\x152', '\xE', '\x152', '\xF91', '\x3', '\x152', '\x3', '\x152', 
		'\x3', '\x152', '\x6', '\x152', '\xF97', '\n', '\x152', '\r', '\x152', 
		'\xE', '\x152', '\xF98', '\x5', '\x152', '\xF9B', '\n', '\x152', '\x3', 
		'\x152', '\x5', '\x152', '\xF9E', '\n', '\x152', '\x3', '\x153', '\x3', 
		'\x153', '\x3', '\x153', '\x3', '\x153', '\x3', '\x154', '\x3', '\x154', 
		'\x3', '\x154', '\x6', '\x154', '\xFA7', '\n', '\x154', '\r', '\x154', 
		'\xE', '\x154', '\xFA8', '\x3', '\x155', '\x3', '\x155', '\x3', '\x155', 
		'\x3', '\x155', '\x3', '\x156', '\x3', '\x156', '\x3', '\x156', '\x3', 
		'\x156', '\x3', '\x156', '\x3', '\x156', '\x3', '\x156', '\x3', '\x157', 
		'\x3', '\x157', '\x3', '\x157', '\x3', '\x157', '\x3', '\x157', '\x3', 
		'\x157', '\x3', '\x157', '\x3', '\x158', '\x3', '\x158', '\x3', '\x158', 
		'\x3', '\x158', '\x3', '\x159', '\x3', '\x159', '\x3', '\x159', '\x3', 
		'\x159', '\x5', '\x159', '\xFC5', '\n', '\x159', '\x3', '\x15A', '\x3', 
		'\x15A', '\x3', '\x15A', '\x3', '\x15A', '\x5', '\x15A', '\xFCB', '\n', 
		'\x15A', '\x3', '\x15B', '\x3', '\x15B', '\x3', '\x15B', '\x5', '\x15B', 
		'\xFD0', '\n', '\x15B', '\x5', '\x15B', '\xFD2', '\n', '\x15B', '\x3', 
		'\x15B', '\x5', '\x15B', '\xFD5', '\n', '\x15B', '\x3', '\x15C', '\x3', 
		'\x15C', '\x3', '\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x5', '\x15D', 
		'\xFDC', '\n', '\x15D', '\x3', '\x15D', '\x3', '\x15D', '\x5', '\x15D', 
		'\xFE0', '\n', '\x15D', '\x3', '\x15D', '\x5', '\x15D', '\xFE3', '\n', 
		'\x15D', '\x5', '\x15D', '\xFE5', '\n', '\x15D', '\x3', '\x15E', '\x3', 
		'\x15E', '\x3', '\x15F', '\x3', '\x15F', '\x3', '\x160', '\x3', '\x160', 
		'\x3', '\x160', '\x3', '\x160', '\x3', '\x160', '\x5', '\x160', '\xFF0', 
		'\n', '\x160', '\x3', '\x160', '\x3', '\x160', '\x3', '\x160', '\x3', 
		'\x160', '\x3', '\x160', '\x3', '\x160', '\x3', '\x160', '\x3', '\x160', 
		'\x5', '\x160', '\xFFA', '\n', '\x160', '\x3', '\x160', '\x5', '\x160', 
		'\xFFD', '\n', '\x160', '\x5', '\x160', '\xFFF', '\n', '\x160', '\x3', 
		'\x160', '\x3', '\x160', '\x5', '\x160', '\x1003', '\n', '\x160', '\x3', 
		'\x161', '\x3', '\x161', '\x3', '\x161', '\x3', '\x161', '\x3', '\x161', 
		'\x3', '\x161', '\x3', '\x161', '\x3', '\x161', '\x5', '\x161', '\x100D', 
		'\n', '\x161', '\x3', '\x162', '\x3', '\x162', '\x3', '\x162', '\x3', 
		'\x162', '\x5', '\x162', '\x1013', '\n', '\x162', '\x3', '\x162', '\x3', 
		'\x162', '\x3', '\x162', '\x3', '\x163', '\x3', '\x163', '\x3', '\x163', 
		'\x3', '\x163', '\x5', '\x163', '\x101C', '\n', '\x163', '\x3', '\x163', 
		'\x3', '\x163', '\x3', '\x163', '\x3', '\x163', '\x3', '\x163', '\x3', 
		'\x163', '\x3', '\x163', '\x3', '\x163', '\x6', '\x163', '\x1026', '\n', 
		'\x163', '\r', '\x163', '\xE', '\x163', '\x1027', '\x3', '\x164', '\x3', 
		'\x164', '\x3', '\x164', '\x3', '\x164', '\x5', '\x164', '\x102E', '\n', 
		'\x164', '\x3', '\x165', '\x3', '\x165', '\x3', '\x165', '\x3', '\x166', 
		'\x3', '\x166', '\x3', '\x166', '\x3', '\x167', '\x3', '\x167', '\x3', 
		'\x167', '\x3', '\x168', '\x3', '\x168', '\x3', '\x168', '\x3', '\x169', 
		'\x3', '\x169', '\x5', '\x169', '\x103E', '\n', '\x169', '\x3', '\x169', 
		'\x3', '\x169', '\x3', '\x169', '\x5', '\x169', '\x1043', '\n', '\x169', 
		'\x3', '\x16A', '\x3', '\x16A', '\x5', '\x16A', '\x1047', '\n', '\x16A', 
		'\x3', '\x16B', '\x3', '\x16B', '\x5', '\x16B', '\x104B', '\n', '\x16B', 
		'\x3', '\x16C', '\x3', '\x16C', '\x3', '\x16C', '\a', '\x16C', '\x1050', 
		'\n', '\x16C', '\f', '\x16C', '\xE', '\x16C', '\x1053', '\v', '\x16C', 
		'\x3', '\x16D', '\x3', '\x16D', '\x3', '\x16D', '\a', '\x16D', '\x1058', 
		'\n', '\x16D', '\f', '\x16D', '\xE', '\x16D', '\x105B', '\v', '\x16D', 
		'\x3', '\x16E', '\x3', '\x16E', '\x5', '\x16E', '\x105F', '\n', '\x16E', 
		'\x3', '\x16F', '\x3', '\x16F', '\x3', '\x16F', '\a', '\x16F', '\x1064', 
		'\n', '\x16F', '\f', '\x16F', '\xE', '\x16F', '\x1067', '\v', '\x16F', 
		'\x3', '\x170', '\x3', '\x170', '\x3', '\x170', '\x3', '\x170', '\a', 
		'\x170', '\x106D', '\n', '\x170', '\f', '\x170', '\xE', '\x170', '\x1070', 
		'\v', '\x170', '\x5', '\x170', '\x1072', '\n', '\x170', '\x3', '\x170', 
		'\x3', '\x170', '\x3', '\x171', '\x3', '\x171', '\x3', '\x171', '\x6', 
		'\x171', '\x1079', '\n', '\x171', '\r', '\x171', '\xE', '\x171', '\x107A', 
		'\x3', '\x172', '\x3', '\x172', '\x3', '\x173', '\x3', '\x173', '\x5', 
		'\x173', '\x1081', '\n', '\x173', '\x3', '\x174', '\x3', '\x174', '\x5', 
		'\x174', '\x1085', '\n', '\x174', '\x3', '\x175', '\x3', '\x175', '\x5', 
		'\x175', '\x1089', '\n', '\x175', '\x3', '\x176', '\x3', '\x176', '\x5', 
		'\x176', '\x108D', '\n', '\x176', '\x3', '\x177', '\x3', '\x177', '\x3', 
		'\x177', '\x3', '\x177', '\x3', '\x177', '\x3', '\x177', '\x3', '\x177', 
		'\x3', '\x177', '\x3', '\x177', '\a', '\x177', '\x1098', '\n', '\x177', 
		'\f', '\x177', '\xE', '\x177', '\x109B', '\v', '\x177', '\x5', '\x177', 
		'\x109D', '\n', '\x177', '\x3', '\x177', '\x3', '\x177', '\x3', '\x178', 
		'\x3', '\x178', '\x5', '\x178', '\x10A3', '\n', '\x178', '\x3', '\x179', 
		'\x3', '\x179', '\x3', '\x17A', '\x3', '\x17A', '\x3', '\x17B', '\x3', 
		'\x17B', '\x5', '\x17B', '\x10AB', '\n', '\x17B', '\x3', '\x17C', '\x3', 
		'\x17C', '\x3', '\x17D', '\x3', '\x17D', '\x3', '\x17E', '\x3', '\x17E', 
		'\x3', '\x17F', '\x3', '\x17F', '\x3', '\x17F', '\x2', '\x2', '\x180', 
		'\x2', '\x4', '\x6', '\b', '\n', '\f', '\xE', '\x10', '\x12', '\x14', 
		'\x16', '\x18', '\x1A', '\x1C', '\x1E', ' ', '\"', '$', '&', '(', '*', 
		',', '.', '\x30', '\x32', '\x34', '\x36', '\x38', ':', '<', '>', '@', 
		'\x42', '\x44', '\x46', 'H', 'J', 'L', 'N', 'P', 'R', 'T', 'V', 'X', 'Z', 
		'\\', '^', '`', '\x62', '\x64', '\x66', 'h', 'j', 'l', 'n', 'p', 'r', 
		't', 'v', 'x', 'z', '|', '~', '\x80', '\x82', '\x84', '\x86', '\x88', 
		'\x8A', '\x8C', '\x8E', '\x90', '\x92', '\x94', '\x96', '\x98', '\x9A', 
		'\x9C', '\x9E', '\xA0', '\xA2', '\xA4', '\xA6', '\xA8', '\xAA', '\xAC', 
		'\xAE', '\xB0', '\xB2', '\xB4', '\xB6', '\xB8', '\xBA', '\xBC', '\xBE', 
		'\xC0', '\xC2', '\xC4', '\xC6', '\xC8', '\xCA', '\xCC', '\xCE', '\xD0', 
		'\xD2', '\xD4', '\xD6', '\xD8', '\xDA', '\xDC', '\xDE', '\xE0', '\xE2', 
		'\xE4', '\xE6', '\xE8', '\xEA', '\xEC', '\xEE', '\xF0', '\xF2', '\xF4', 
		'\xF6', '\xF8', '\xFA', '\xFC', '\xFE', '\x100', '\x102', '\x104', '\x106', 
		'\x108', '\x10A', '\x10C', '\x10E', '\x110', '\x112', '\x114', '\x116', 
		'\x118', '\x11A', '\x11C', '\x11E', '\x120', '\x122', '\x124', '\x126', 
		'\x128', '\x12A', '\x12C', '\x12E', '\x130', '\x132', '\x134', '\x136', 
		'\x138', '\x13A', '\x13C', '\x13E', '\x140', '\x142', '\x144', '\x146', 
		'\x148', '\x14A', '\x14C', '\x14E', '\x150', '\x152', '\x154', '\x156', 
		'\x158', '\x15A', '\x15C', '\x15E', '\x160', '\x162', '\x164', '\x166', 
		'\x168', '\x16A', '\x16C', '\x16E', '\x170', '\x172', '\x174', '\x176', 
		'\x178', '\x17A', '\x17C', '\x17E', '\x180', '\x182', '\x184', '\x186', 
		'\x188', '\x18A', '\x18C', '\x18E', '\x190', '\x192', '\x194', '\x196', 
		'\x198', '\x19A', '\x19C', '\x19E', '\x1A0', '\x1A2', '\x1A4', '\x1A6', 
		'\x1A8', '\x1AA', '\x1AC', '\x1AE', '\x1B0', '\x1B2', '\x1B4', '\x1B6', 
		'\x1B8', '\x1BA', '\x1BC', '\x1BE', '\x1C0', '\x1C2', '\x1C4', '\x1C6', 
		'\x1C8', '\x1CA', '\x1CC', '\x1CE', '\x1D0', '\x1D2', '\x1D4', '\x1D6', 
		'\x1D8', '\x1DA', '\x1DC', '\x1DE', '\x1E0', '\x1E2', '\x1E4', '\x1E6', 
		'\x1E8', '\x1EA', '\x1EC', '\x1EE', '\x1F0', '\x1F2', '\x1F4', '\x1F6', 
		'\x1F8', '\x1FA', '\x1FC', '\x1FE', '\x200', '\x202', '\x204', '\x206', 
		'\x208', '\x20A', '\x20C', '\x20E', '\x210', '\x212', '\x214', '\x216', 
		'\x218', '\x21A', '\x21C', '\x21E', '\x220', '\x222', '\x224', '\x226', 
		'\x228', '\x22A', '\x22C', '\x22E', '\x230', '\x232', '\x234', '\x236', 
		'\x238', '\x23A', '\x23C', '\x23E', '\x240', '\x242', '\x244', '\x246', 
		'\x248', '\x24A', '\x24C', '\x24E', '\x250', '\x252', '\x254', '\x256', 
		'\x258', '\x25A', '\x25C', '\x25E', '\x260', '\x262', '\x264', '\x266', 
		'\x268', '\x26A', '\x26C', '\x26E', '\x270', '\x272', '\x274', '\x276', 
		'\x278', '\x27A', '\x27C', '\x27E', '\x280', '\x282', '\x284', '\x286', 
		'\x288', '\x28A', '\x28C', '\x28E', '\x290', '\x292', '\x294', '\x296', 
		'\x298', '\x29A', '\x29C', '\x29E', '\x2A0', '\x2A2', '\x2A4', '\x2A6', 
		'\x2A8', '\x2AA', '\x2AC', '\x2AE', '\x2B0', '\x2B2', '\x2B4', '\x2B6', 
		'\x2B8', '\x2BA', '\x2BC', '\x2BE', '\x2C0', '\x2C2', '\x2C4', '\x2C6', 
		'\x2C8', '\x2CA', '\x2CC', '\x2CE', '\x2D0', '\x2D2', '\x2D4', '\x2D6', 
		'\x2D8', '\x2DA', '\x2DC', '\x2DE', '\x2E0', '\x2E2', '\x2E4', '\x2E6', 
		'\x2E8', '\x2EA', '\x2EC', '\x2EE', '\x2F0', '\x2F2', '\x2F4', '\x2F6', 
		'\x2F8', '\x2FA', '\x2FC', '\x2', 'S', '\x4', '\x2', '\x15', '\x15', 'T', 
		'T', '\x3', '\x2', '\x1C', '\x1D', '\x3', '\x2', 'N', 'O', '\x4', '\x2', 
		'\xD0', '\xD0', '\x11E', '\x11E', '\x4', '\x2', 'Q', 'Q', '\xC6', '\xC6', 
		'\x4', '\x2', '>', '>', '\xB5', '\xB5', '\x3', '\x2', '\x107', '\x108', 
		'\x5', '\x2', '\'', '\'', ';', ';', 'q', 'q', '\x4', '\x2', '\x14', '\x14', 
		'\x119', '\x119', '\x3', '\x2', '\x84', '\x85', '\x3', '\x2', '\xDB', 
		'\xDC', '\x4', '\x2', '\x15', '\x15', '\x19', '\x19', '\x4', '\x2', '\xB1', 
		'\xB1', '\x155', '\x155', '\x4', '\x2', '\xB7', '\xB7', '\x154', '\x154', 
		'\x4', '\x2', '\x86', '\x86', '\x156', '\x156', '\x4', '\x2', '\x30', 
		'\x30', '\x9E', '\x9E', '\x4', '\x2', '\x30', '\x30', '\xA3', '\xA3', 
		'\b', '\x2', 'j', 'j', '\x80', '\x80', '\x86', '\x86', '\xA8', '\xA8', 
		'\xB1', '\xB1', '\xBA', '\xBB', '\x4', '\x2', '\x31', '\x31', '\x137', 
		'\x137', '\x3', '\x2', '\xBF', '\xC2', '\x5', '\x2', 'Y', 'Y', '\xB7', 
		'\xB7', '\xDE', '\xDE', '\x5', '\x2', 'U', 'U', '\xB8', '\xB8', '\x12B', 
		'\x12B', '\x4', '\x2', '\xB7', '\xB7', '\xDE', '\xDE', '\x4', '\x2', '!', 
		'!', '\x32', '\x32', '\x6', '\x2', '\x15', '\x15', '\x19', '\x19', '\xC8', 
		'\xC8', '\x11D', '\x11D', '\a', '\x2', '<', '<', 'W', 'W', '\x66', 'g', 
		'\x87', '\x87', '\xB3', '\xB3', '\x4', '\x2', '\x66', '\x66', '\xB3', 
		'\xB3', '\x5', '\x2', '&', '&', '\xA9', '\xA9', '\x130', '\x130', '\x3', 
		'\x2', '\x6', '\t', '\x4', '\x2', 'G', 'G', '\x12A', '\x12A', '\x3', '\x2', 
		'\x14B', '\x14C', '\x4', '\x2', '\x1A', '\x1A', '\xAC', '\xAC', '\t', 
		'\x2', '\x15', '\x15', '}', '}', '\xAF', '\xAF', '\xE0', '\xE0', '\xEE', 
		'\xEE', '\x128', '\x128', '\x144', '\x144', '\x3', '\x2', '\x13A', '\x13B', 
		'\x3', '\x2', '\xF6', '\xF7', '\x3', '\x2', '\xE7', '\xE8', '\x3', '\x2', 
		'~', '\x7F', '\x3', '\x2', '\x115', '\x116', '\x4', '\x2', '\xC5', '\xC5', 
		'\xF6', '\xF7', '\x5', '\x2', '\xF', '\xF', '\x17', '\x17', '\x114', '\x114', 
		'\x4', '\x2', '\xA0', '\xA0', '\x13A', '\x13A', '\x4', '\x2', 'M', 'M', 
		'\x81', '\x81', '\x3', '\x2', '\x105', '\x106', '\x3', '\x2', '\x112', 
		'\x113', '\x3', '\x2', '\x44', '\x45', '\x4', '\x2', '\x15', '\x15', '\xE1', 
		'\xE1', '\x3', '\x2', '\x13F', '\x140', '\x3', '\x2', '\xEB', '\xEC', 
		'\x4', '\x2', '\x65', '\x65', '\xDD', '\xDD', '\x4', '\x2', '\xE', '\xE', 
		'\x125', '\x125', '\x3', '\x2', '\x33', '\x34', '\x3', '\x2', '\xE5', 
		'\xE6', '\x5', '\x2', '\x44', '\x44', 'H', 'H', '\x82', '\x82', '\x4', 
		'\x2', '\x44', '\x44', '\x82', '\x82', '\x3', '\x2', '\x82', '\x83', '\x3', 
		'\x2', '\xA1', '\xA2', '\x4', '\x2', '\x136', '\x136', '\x138', '\x138', 
		'\x3', '\x2', '\xBC', '\xBD', '\x4', '\x2', '.', '.', '\x13D', '\x13D', 
		'\x3', '\x2', '\xD9', '\xDA', '\x4', '\x2', '\xE5', '\xE5', '\x105', '\x105', 
		'\x4', '\x2', '\x105', '\x105', '\x13F', '\x13F', '\x3', '\x2', '\x10', 
		'\x11', '\x3', '\x2', '\x8F', '\x90', '\x3', '\x2', '\x37', '\x38', '\x3', 
		'\x2', '\x131', '\x132', '\x4', '\x2', '\xB5', '\xB6', '\xF1', '\xF1', 
		'\x3', '\x2', '\xF7', '\xF8', '\x3', '\x2', '\x62', '\x63', '\x4', '\x2', 
		'\xC5', '\xC5', '\xC7', '\xC7', '\x3', '\x2', '\x117', '\x118', '\x3', 
		'\x2', '\xFC', '\xFD', '\x3', '\x2', '\xE3', '\xE4', '\x3', '\x2', '\x10D', 
		'\x10E', '\x4', '\x2', 'P', 'P', ']', ']', '\x3', '\x2', '\x12', '\x13', 
		'\x4', '\x2', '\xD3', '\xD3', '\x14D', '\x14D', '\x4', '\x2', '\x10B', 
		'\x10C', '\x10F', '\x10F', '\x4', '\x2', 'J', 'J', '\x89', '\x89', '\x3', 
		'\x2', '\n', '\v', '\x18', '\x2', '\r', ' ', '\"', '/', '\x33', 'R', 'T', 
		'T', 'W', 'W', 'Z', 'i', 'k', '\x7F', '\x81', '\x85', '\x87', '\xA2', 
		'\xA5', '\xA5', '\xA9', '\xAF', '\xB2', '\xB6', '\xB9', '\xB9', '\xBC', 
		'\xDD', '\xE0', '\xE1', '\xE3', '\xEC', '\xEE', '\xEE', '\xF1', '\xF4', 
		'\xF6', '\x108', '\x10A', '\x110', '\x112', '\x12A', '\x12C', '\x152', 
		'\x2', '\x1252', '\x2', '\x2FE', '\x3', '\x2', '\x2', '\x2', '\x4', '\x30D', 
		'\x3', '\x2', '\x2', '\x2', '\x6', '\x30F', '\x3', '\x2', '\x2', '\x2', 
		'\b', '\x319', '\x3', '\x2', '\x2', '\x2', '\n', '\x31B', '\x3', '\x2', 
		'\x2', '\x2', '\f', '\x327', '\x3', '\x2', '\x2', '\x2', '\xE', '\x32E', 
		'\x3', '\x2', '\x2', '\x2', '\x10', '\x333', '\x3', '\x2', '\x2', '\x2', 
		'\x12', '\x342', '\x3', '\x2', '\x2', '\x2', '\x14', '\x357', '\x3', '\x2', 
		'\x2', '\x2', '\x16', '\x359', '\x3', '\x2', '\x2', '\x2', '\x18', '\x365', 
		'\x3', '\x2', '\x2', '\x2', '\x1A', '\x367', '\x3', '\x2', '\x2', '\x2', 
		'\x1C', '\x369', '\x3', '\x2', '\x2', '\x2', '\x1E', '\x36D', '\x3', '\x2', 
		'\x2', '\x2', ' ', '\x379', '\x3', '\x2', '\x2', '\x2', '\"', '\x380', 
		'\x3', '\x2', '\x2', '\x2', '$', '\x389', '\x3', '\x2', '\x2', '\x2', 
		'&', '\x38E', '\x3', '\x2', '\x2', '\x2', '(', '\x390', '\x3', '\x2', 
		'\x2', '\x2', '*', '\x392', '\x3', '\x2', '\x2', '\x2', ',', '\x39C', 
		'\x3', '\x2', '\x2', '\x2', '.', '\x39F', '\x3', '\x2', '\x2', '\x2', 
		'\x30', '\x3A2', '\x3', '\x2', '\x2', '\x2', '\x32', '\x3A5', '\x3', '\x2', 
		'\x2', '\x2', '\x34', '\x3AA', '\x3', '\x2', '\x2', '\x2', '\x36', '\x3AD', 
		'\x3', '\x2', '\x2', '\x2', '\x38', '\x3B0', '\x3', '\x2', '\x2', '\x2', 
		':', '\x3CF', '\x3', '\x2', '\x2', '\x2', '<', '\x3D1', '\x3', '\x2', 
		'\x2', '\x2', '>', '\x3E2', '\x3', '\x2', '\x2', '\x2', '@', '\x3E5', 
		'\x3', '\x2', '\x2', '\x2', '\x42', '\x3F1', '\x3', '\x2', '\x2', '\x2', 
		'\x44', '\x411', '\x3', '\x2', '\x2', '\x2', '\x46', '\x413', '\x3', '\x2', 
		'\x2', '\x2', 'H', '\x42F', '\x3', '\x2', '\x2', '\x2', 'J', '\x437', 
		'\x3', '\x2', '\x2', '\x2', 'L', '\x43B', '\x3', '\x2', '\x2', '\x2', 
		'N', '\x441', '\x3', '\x2', '\x2', '\x2', 'P', '\x446', '\x3', '\x2', 
		'\x2', '\x2', 'R', '\x44F', '\x3', '\x2', '\x2', '\x2', 'T', '\x454', 
		'\x3', '\x2', '\x2', '\x2', 'V', '\x477', '\x3', '\x2', '\x2', '\x2', 
		'X', '\x47A', '\x3', '\x2', '\x2', '\x2', 'Z', '\x47C', '\x3', '\x2', 
		'\x2', '\x2', '\\', '\x481', '\x3', '\x2', '\x2', '\x2', '^', '\x48F', 
		'\x3', '\x2', '\x2', '\x2', '`', '\x49D', '\x3', '\x2', '\x2', '\x2', 
		'\x62', '\x4A9', '\x3', '\x2', '\x2', '\x2', '\x64', '\x4B7', '\x3', '\x2', 
		'\x2', '\x2', '\x66', '\x4C7', '\x3', '\x2', '\x2', '\x2', 'h', '\x4D8', 
		'\x3', '\x2', '\x2', '\x2', 'j', '\x4DB', '\x3', '\x2', '\x2', '\x2', 
		'l', '\x4E0', '\x3', '\x2', '\x2', '\x2', 'n', '\x4F1', '\x3', '\x2', 
		'\x2', '\x2', 'p', '\x4F3', '\x3', '\x2', '\x2', '\x2', 'r', '\x4FB', 
		'\x3', '\x2', '\x2', '\x2', 't', '\x506', '\x3', '\x2', '\x2', '\x2', 
		'v', '\x510', '\x3', '\x2', '\x2', '\x2', 'x', '\x529', '\x3', '\x2', 
		'\x2', '\x2', 'z', '\x52D', '\x3', '\x2', '\x2', '\x2', '|', '\x52F', 
		'\x3', '\x2', '\x2', '\x2', '~', '\x541', '\x3', '\x2', '\x2', '\x2', 
		'\x80', '\x567', '\x3', '\x2', '\x2', '\x2', '\x82', '\x56B', '\x3', '\x2', 
		'\x2', '\x2', '\x84', '\x56D', '\x3', '\x2', '\x2', '\x2', '\x86', '\x56F', 
		'\x3', '\x2', '\x2', '\x2', '\x88', '\x571', '\x3', '\x2', '\x2', '\x2', 
		'\x8A', '\x58D', '\x3', '\x2', '\x2', '\x2', '\x8C', '\x59F', '\x3', '\x2', 
		'\x2', '\x2', '\x8E', '\x5A1', '\x3', '\x2', '\x2', '\x2', '\x90', '\x5AD', 
		'\x3', '\x2', '\x2', '\x2', '\x92', '\x5B1', '\x3', '\x2', '\x2', '\x2', 
		'\x94', '\x5BD', '\x3', '\x2', '\x2', '\x2', '\x96', '\x5C2', '\x3', '\x2', 
		'\x2', '\x2', '\x98', '\x5CA', '\x3', '\x2', '\x2', '\x2', '\x9A', '\x5CD', 
		'\x3', '\x2', '\x2', '\x2', '\x9C', '\x5D0', '\x3', '\x2', '\x2', '\x2', 
		'\x9E', '\x5D3', '\x3', '\x2', '\x2', '\x2', '\xA0', '\x5D8', '\x3', '\x2', 
		'\x2', '\x2', '\xA2', '\x5DB', '\x3', '\x2', '\x2', '\x2', '\xA4', '\x5FC', 
		'\x3', '\x2', '\x2', '\x2', '\xA6', '\x614', '\x3', '\x2', '\x2', '\x2', 
		'\xA8', '\x616', '\x3', '\x2', '\x2', '\x2', '\xAA', '\x618', '\x3', '\x2', 
		'\x2', '\x2', '\xAC', '\x61A', '\x3', '\x2', '\x2', '\x2', '\xAE', '\x625', 
		'\x3', '\x2', '\x2', '\x2', '\xB0', '\x628', '\x3', '\x2', '\x2', '\x2', 
		'\xB2', '\x633', '\x3', '\x2', '\x2', '\x2', '\xB4', '\x63E', '\x3', '\x2', 
		'\x2', '\x2', '\xB6', '\x64A', '\x3', '\x2', '\x2', '\x2', '\xB8', '\x64C', 
		'\x3', '\x2', '\x2', '\x2', '\xBA', '\x655', '\x3', '\x2', '\x2', '\x2', 
		'\xBC', '\x658', '\x3', '\x2', '\x2', '\x2', '\xBE', '\x660', '\x3', '\x2', 
		'\x2', '\x2', '\xC0', '\x668', '\x3', '\x2', '\x2', '\x2', '\xC2', '\x673', 
		'\x3', '\x2', '\x2', '\x2', '\xC4', '\x678', '\x3', '\x2', '\x2', '\x2', 
		'\xC6', '\x680', '\x3', '\x2', '\x2', '\x2', '\xC8', '\x6A5', '\x3', '\x2', 
		'\x2', '\x2', '\xCA', '\x6A7', '\x3', '\x2', '\x2', '\x2', '\xCC', '\x6A9', 
		'\x3', '\x2', '\x2', '\x2', '\xCE', '\x6B1', '\x3', '\x2', '\x2', '\x2', 
		'\xD0', '\x6B9', '\x3', '\x2', '\x2', '\x2', '\xD2', '\x6C4', '\x3', '\x2', 
		'\x2', '\x2', '\xD4', '\x6C6', '\x3', '\x2', '\x2', '\x2', '\xD6', '\x6DB', 
		'\x3', '\x2', '\x2', '\x2', '\xD8', '\x6DD', '\x3', '\x2', '\x2', '\x2', 
		'\xDA', '\x6E0', '\x3', '\x2', '\x2', '\x2', '\xDC', '\x6E4', '\x3', '\x2', 
		'\x2', '\x2', '\xDE', '\x6EA', '\x3', '\x2', '\x2', '\x2', '\xE0', '\x706', 
		'\x3', '\x2', '\x2', '\x2', '\xE2', '\x711', '\x3', '\x2', '\x2', '\x2', 
		'\xE4', '\x713', '\x3', '\x2', '\x2', '\x2', '\xE6', '\x71F', '\x3', '\x2', 
		'\x2', '\x2', '\xE8', '\x724', '\x3', '\x2', '\x2', '\x2', '\xEA', '\x731', 
		'\x3', '\x2', '\x2', '\x2', '\xEC', '\x741', '\x3', '\x2', '\x2', '\x2', 
		'\xEE', '\x743', '\x3', '\x2', '\x2', '\x2', '\xF0', '\x755', '\x3', '\x2', 
		'\x2', '\x2', '\xF2', '\x764', '\x3', '\x2', '\x2', '\x2', '\xF4', '\x773', 
		'\x3', '\x2', '\x2', '\x2', '\xF6', '\x775', '\x3', '\x2', '\x2', '\x2', 
		'\xF8', '\x784', '\x3', '\x2', '\x2', '\x2', '\xFA', '\x790', '\x3', '\x2', 
		'\x2', '\x2', '\xFC', '\x79B', '\x3', '\x2', '\x2', '\x2', '\xFE', '\x7A4', 
		'\x3', '\x2', '\x2', '\x2', '\x100', '\x7AD', '\x3', '\x2', '\x2', '\x2', 
		'\x102', '\x7B6', '\x3', '\x2', '\x2', '\x2', '\x104', '\x7BD', '\x3', 
		'\x2', '\x2', '\x2', '\x106', '\x7BF', '\x3', '\x2', '\x2', '\x2', '\x108', 
		'\x7C1', '\x3', '\x2', '\x2', '\x2', '\x10A', '\x7CF', '\x3', '\x2', '\x2', 
		'\x2', '\x10C', '\x7D1', '\x3', '\x2', '\x2', '\x2', '\x10E', '\x7D3', 
		'\x3', '\x2', '\x2', '\x2', '\x110', '\x7D7', '\x3', '\x2', '\x2', '\x2', 
		'\x112', '\x7ED', '\x3', '\x2', '\x2', '\x2', '\x114', '\x7EF', '\x3', 
		'\x2', '\x2', '\x2', '\x116', '\x7F4', '\x3', '\x2', '\x2', '\x2', '\x118', 
		'\x802', '\x3', '\x2', '\x2', '\x2', '\x11A', '\x810', '\x3', '\x2', '\x2', 
		'\x2', '\x11C', '\x816', '\x3', '\x2', '\x2', '\x2', '\x11E', '\x81B', 
		'\x3', '\x2', '\x2', '\x2', '\x120', '\x81F', '\x3', '\x2', '\x2', '\x2', 
		'\x122', '\x82C', '\x3', '\x2', '\x2', '\x2', '\x124', '\x82E', '\x3', 
		'\x2', '\x2', '\x2', '\x126', '\x835', '\x3', '\x2', '\x2', '\x2', '\x128', 
		'\x837', '\x3', '\x2', '\x2', '\x2', '\x12A', '\x848', '\x3', '\x2', '\x2', 
		'\x2', '\x12C', '\x84A', '\x3', '\x2', '\x2', '\x2', '\x12E', '\x852', 
		'\x3', '\x2', '\x2', '\x2', '\x130', '\x855', '\x3', '\x2', '\x2', '\x2', 
		'\x132', '\x857', '\x3', '\x2', '\x2', '\x2', '\x134', '\x85F', '\x3', 
		'\x2', '\x2', '\x2', '\x136', '\x867', '\x3', '\x2', '\x2', '\x2', '\x138', 
		'\x8C9', '\x3', '\x2', '\x2', '\x2', '\x13A', '\x8CE', '\x3', '\x2', '\x2', 
		'\x2', '\x13C', '\x8D0', '\x3', '\x2', '\x2', '\x2', '\x13E', '\x8E4', 
		'\x3', '\x2', '\x2', '\x2', '\x140', '\x8EA', '\x3', '\x2', '\x2', '\x2', 
		'\x142', '\x8FB', '\x3', '\x2', '\x2', '\x2', '\x144', '\x909', '\x3', 
		'\x2', '\x2', '\x2', '\x146', '\x912', '\x3', '\x2', '\x2', '\x2', '\x148', 
		'\x91C', '\x3', '\x2', '\x2', '\x2', '\x14A', '\x935', '\x3', '\x2', '\x2', 
		'\x2', '\x14C', '\x937', '\x3', '\x2', '\x2', '\x2', '\x14E', '\x93C', 
		'\x3', '\x2', '\x2', '\x2', '\x150', '\x93F', '\x3', '\x2', '\x2', '\x2', 
		'\x152', '\x942', '\x3', '\x2', '\x2', '\x2', '\x154', '\x95A', '\x3', 
		'\x2', '\x2', '\x2', '\x156', '\x95D', '\x3', '\x2', '\x2', '\x2', '\x158', 
		'\x962', '\x3', '\x2', '\x2', '\x2', '\x15A', '\x964', '\x3', '\x2', '\x2', 
		'\x2', '\x15C', '\x96F', '\x3', '\x2', '\x2', '\x2', '\x15E', '\x973', 
		'\x3', '\x2', '\x2', '\x2', '\x160', '\x975', '\x3', '\x2', '\x2', '\x2', 
		'\x162', '\x999', '\x3', '\x2', '\x2', '\x2', '\x164', '\x99D', '\x3', 
		'\x2', '\x2', '\x2', '\x166', '\x9A5', '\x3', '\x2', '\x2', '\x2', '\x168', 
		'\x9A7', '\x3', '\x2', '\x2', '\x2', '\x16A', '\x9AE', '\x3', '\x2', '\x2', 
		'\x2', '\x16C', '\x9B7', '\x3', '\x2', '\x2', '\x2', '\x16E', '\x9C2', 
		'\x3', '\x2', '\x2', '\x2', '\x170', '\x9CE', '\x3', '\x2', '\x2', '\x2', 
		'\x172', '\x9D0', '\x3', '\x2', '\x2', '\x2', '\x174', '\x9DE', '\x3', 
		'\x2', '\x2', '\x2', '\x176', '\x9E0', '\x3', '\x2', '\x2', '\x2', '\x178', 
		'\x9E3', '\x3', '\x2', '\x2', '\x2', '\x17A', '\x9EB', '\x3', '\x2', '\x2', 
		'\x2', '\x17C', '\x9EE', '\x3', '\x2', '\x2', '\x2', '\x17E', '\x9F7', 
		'\x3', '\x2', '\x2', '\x2', '\x180', '\x9FE', '\x3', '\x2', '\x2', '\x2', 
		'\x182', '\xA00', '\x3', '\x2', '\x2', '\x2', '\x184', '\xA05', '\x3', 
		'\x2', '\x2', '\x2', '\x186', '\xA16', '\x3', '\x2', '\x2', '\x2', '\x188', 
		'\xA47', '\x3', '\x2', '\x2', '\x2', '\x18A', '\xA49', '\x3', '\x2', '\x2', 
		'\x2', '\x18C', '\xA63', '\x3', '\x2', '\x2', '\x2', '\x18E', '\xA66', 
		'\x3', '\x2', '\x2', '\x2', '\x190', '\xA78', '\x3', '\x2', '\x2', '\x2', 
		'\x192', '\xA8C', '\x3', '\x2', '\x2', '\x2', '\x194', '\xA99', '\x3', 
		'\x2', '\x2', '\x2', '\x196', '\xAB3', '\x3', '\x2', '\x2', '\x2', '\x198', 
		'\xAC6', '\x3', '\x2', '\x2', '\x2', '\x19A', '\xACC', '\x3', '\x2', '\x2', 
		'\x2', '\x19C', '\xADF', '\x3', '\x2', '\x2', '\x2', '\x19E', '\xAEC', 
		'\x3', '\x2', '\x2', '\x2', '\x1A0', '\xAEE', '\x3', '\x2', '\x2', '\x2', 
		'\x1A2', '\xAF9', '\x3', '\x2', '\x2', '\x2', '\x1A4', '\xB02', '\x3', 
		'\x2', '\x2', '\x2', '\x1A6', '\xB08', '\x3', '\x2', '\x2', '\x2', '\x1A8', 
		'\xB0E', '\x3', '\x2', '\x2', '\x2', '\x1AA', '\xB16', '\x3', '\x2', '\x2', 
		'\x2', '\x1AC', '\xB21', '\x3', '\x2', '\x2', '\x2', '\x1AE', '\xB27', 
		'\x3', '\x2', '\x2', '\x2', '\x1B0', '\xB2D', '\x3', '\x2', '\x2', '\x2', 
		'\x1B2', '\xB35', '\x3', '\x2', '\x2', '\x2', '\x1B4', '\xB3C', '\x3', 
		'\x2', '\x2', '\x2', '\x1B6', '\xB3E', '\x3', '\x2', '\x2', '\x2', '\x1B8', 
		'\xB4D', '\x3', '\x2', '\x2', '\x2', '\x1BA', '\xB55', '\x3', '\x2', '\x2', 
		'\x2', '\x1BC', '\xB5A', '\x3', '\x2', '\x2', '\x2', '\x1BE', '\xB5C', 
		'\x3', '\x2', '\x2', '\x2', '\x1C0', '\xB60', '\x3', '\x2', '\x2', '\x2', 
		'\x1C2', '\xB6C', '\x3', '\x2', '\x2', '\x2', '\x1C4', '\xB72', '\x3', 
		'\x2', '\x2', '\x2', '\x1C6', '\xB7F', '\x3', '\x2', '\x2', '\x2', '\x1C8', 
		'\xB84', '\x3', '\x2', '\x2', '\x2', '\x1CA', '\xB86', '\x3', '\x2', '\x2', 
		'\x2', '\x1CC', '\xB91', '\x3', '\x2', '\x2', '\x2', '\x1CE', '\xBA2', 
		'\x3', '\x2', '\x2', '\x2', '\x1D0', '\xBAF', '\x3', '\x2', '\x2', '\x2', 
		'\x1D2', '\xBB7', '\x3', '\x2', '\x2', '\x2', '\x1D4', '\xBBD', '\x3', 
		'\x2', '\x2', '\x2', '\x1D6', '\xBBF', '\x3', '\x2', '\x2', '\x2', '\x1D8', 
		'\xBCC', '\x3', '\x2', '\x2', '\x2', '\x1DA', '\xBD2', '\x3', '\x2', '\x2', 
		'\x2', '\x1DC', '\xBDF', '\x3', '\x2', '\x2', '\x2', '\x1DE', '\xBE7', 
		'\x3', '\x2', '\x2', '\x2', '\x1E0', '\xBF7', '\x3', '\x2', '\x2', '\x2', 
		'\x1E2', '\xBF9', '\x3', '\x2', '\x2', '\x2', '\x1E4', '\xBFB', '\x3', 
		'\x2', '\x2', '\x2', '\x1E6', '\xBFD', '\x3', '\x2', '\x2', '\x2', '\x1E8', 
		'\xC03', '\x3', '\x2', '\x2', '\x2', '\x1EA', '\xC08', '\x3', '\x2', '\x2', 
		'\x2', '\x1EC', '\xC0D', '\x3', '\x2', '\x2', '\x2', '\x1EE', '\xC10', 
		'\x3', '\x2', '\x2', '\x2', '\x1F0', '\xC15', '\x3', '\x2', '\x2', '\x2', 
		'\x1F2', '\xC1B', '\x3', '\x2', '\x2', '\x2', '\x1F4', '\xC27', '\x3', 
		'\x2', '\x2', '\x2', '\x1F6', '\xC2B', '\x3', '\x2', '\x2', '\x2', '\x1F8', 
		'\xC3A', '\x3', '\x2', '\x2', '\x2', '\x1FA', '\xC40', '\x3', '\x2', '\x2', 
		'\x2', '\x1FC', '\xC4A', '\x3', '\x2', '\x2', '\x2', '\x1FE', '\xC54', 
		'\x3', '\x2', '\x2', '\x2', '\x200', '\xC58', '\x3', '\x2', '\x2', '\x2', 
		'\x202', '\xC5C', '\x3', '\x2', '\x2', '\x2', '\x204', '\xC70', '\x3', 
		'\x2', '\x2', '\x2', '\x206', '\xC76', '\x3', '\x2', '\x2', '\x2', '\x208', 
		'\xC7F', '\x3', '\x2', '\x2', '\x2', '\x20A', '\xC88', '\x3', '\x2', '\x2', 
		'\x2', '\x20C', '\xCAC', '\x3', '\x2', '\x2', '\x2', '\x20E', '\xCB6', 
		'\x3', '\x2', '\x2', '\x2', '\x210', '\xCBE', '\x3', '\x2', '\x2', '\x2', 
		'\x212', '\xCC5', '\x3', '\x2', '\x2', '\x2', '\x214', '\xCC7', '\x3', 
		'\x2', '\x2', '\x2', '\x216', '\xCCD', '\x3', '\x2', '\x2', '\x2', '\x218', 
		'\xCD0', '\x3', '\x2', '\x2', '\x2', '\x21A', '\xCD4', '\x3', '\x2', '\x2', 
		'\x2', '\x21C', '\xCE7', '\x3', '\x2', '\x2', '\x2', '\x21E', '\xCE9', 
		'\x3', '\x2', '\x2', '\x2', '\x220', '\xCF1', '\x3', '\x2', '\x2', '\x2', 
		'\x222', '\xCF6', '\x3', '\x2', '\x2', '\x2', '\x224', '\xCFC', '\x3', 
		'\x2', '\x2', '\x2', '\x226', '\xD05', '\x3', '\x2', '\x2', '\x2', '\x228', 
		'\xD0E', '\x3', '\x2', '\x2', '\x2', '\x22A', '\xD19', '\x3', '\x2', '\x2', 
		'\x2', '\x22C', '\xD1F', '\x3', '\x2', '\x2', '\x2', '\x22E', '\xD2C', 
		'\x3', '\x2', '\x2', '\x2', '\x230', '\xD2E', '\x3', '\x2', '\x2', '\x2', 
		'\x232', '\xD36', '\x3', '\x2', '\x2', '\x2', '\x234', '\xD47', '\x3', 
		'\x2', '\x2', '\x2', '\x236', '\xD49', '\x3', '\x2', '\x2', '\x2', '\x238', 
		'\xD5D', '\x3', '\x2', '\x2', '\x2', '\x23A', '\xD5F', '\x3', '\x2', '\x2', 
		'\x2', '\x23C', '\xD65', '\x3', '\x2', '\x2', '\x2', '\x23E', '\xD6B', 
		'\x3', '\x2', '\x2', '\x2', '\x240', '\xD78', '\x3', '\x2', '\x2', '\x2', 
		'\x242', '\xD7A', '\x3', '\x2', '\x2', '\x2', '\x244', '\xD88', '\x3', 
		'\x2', '\x2', '\x2', '\x246', '\xD90', '\x3', '\x2', '\x2', '\x2', '\x248', 
		'\xDAB', '\x3', '\x2', '\x2', '\x2', '\x24A', '\xDD3', '\x3', '\x2', '\x2', 
		'\x2', '\x24C', '\xDD5', '\x3', '\x2', '\x2', '\x2', '\x24E', '\xDE0', 
		'\x3', '\x2', '\x2', '\x2', '\x250', '\xDFF', '\x3', '\x2', '\x2', '\x2', 
		'\x252', '\xE22', '\x3', '\x2', '\x2', '\x2', '\x254', '\xE27', '\x3', 
		'\x2', '\x2', '\x2', '\x256', '\xE3E', '\x3', '\x2', '\x2', '\x2', '\x258', 
		'\xE40', '\x3', '\x2', '\x2', '\x2', '\x25A', '\xE42', '\x3', '\x2', '\x2', 
		'\x2', '\x25C', '\xE44', '\x3', '\x2', '\x2', '\x2', '\x25E', '\xE46', 
		'\x3', '\x2', '\x2', '\x2', '\x260', '\xE48', '\x3', '\x2', '\x2', '\x2', 
		'\x262', '\xE4F', '\x3', '\x2', '\x2', '\x2', '\x264', '\xE51', '\x3', 
		'\x2', '\x2', '\x2', '\x266', '\xE53', '\x3', '\x2', '\x2', '\x2', '\x268', 
		'\xE55', '\x3', '\x2', '\x2', '\x2', '\x26A', '\xE62', '\x3', '\x2', '\x2', 
		'\x2', '\x26C', '\xE64', '\x3', '\x2', '\x2', '\x2', '\x26E', '\xE6F', 
		'\x3', '\x2', '\x2', '\x2', '\x270', '\xE75', '\x3', '\x2', '\x2', '\x2', 
		'\x272', '\xE7D', '\x3', '\x2', '\x2', '\x2', '\x274', '\xE7F', '\x3', 
		'\x2', '\x2', '\x2', '\x276', '\xE86', '\x3', '\x2', '\x2', '\x2', '\x278', 
		'\xEDF', '\x3', '\x2', '\x2', '\x2', '\x27A', '\xEE4', '\x3', '\x2', '\x2', 
		'\x2', '\x27C', '\xEE6', '\x3', '\x2', '\x2', '\x2', '\x27E', '\xEE8', 
		'\x3', '\x2', '\x2', '\x2', '\x280', '\xEEA', '\x3', '\x2', '\x2', '\x2', 
		'\x282', '\xEF3', '\x3', '\x2', '\x2', '\x2', '\x284', '\xEFC', '\x3', 
		'\x2', '\x2', '\x2', '\x286', '\xEFE', '\x3', '\x2', '\x2', '\x2', '\x288', 
		'\xF12', '\x3', '\x2', '\x2', '\x2', '\x28A', '\xF2D', '\x3', '\x2', '\x2', 
		'\x2', '\x28C', '\xF34', '\x3', '\x2', '\x2', '\x2', '\x28E', '\xF3C', 
		'\x3', '\x2', '\x2', '\x2', '\x290', '\xF4D', '\x3', '\x2', '\x2', '\x2', 
		'\x292', '\xF56', '\x3', '\x2', '\x2', '\x2', '\x294', '\xF59', '\x3', 
		'\x2', '\x2', '\x2', '\x296', '\xF5B', '\x3', '\x2', '\x2', '\x2', '\x298', 
		'\xF5E', '\x3', '\x2', '\x2', '\x2', '\x29A', '\xF60', '\x3', '\x2', '\x2', 
		'\x2', '\x29C', '\xF62', '\x3', '\x2', '\x2', '\x2', '\x29E', '\xF68', 
		'\x3', '\x2', '\x2', '\x2', '\x2A0', '\xF7D', '\x3', '\x2', '\x2', '\x2', 
		'\x2A2', '\xF7F', '\x3', '\x2', '\x2', '\x2', '\x2A4', '\xF9F', '\x3', 
		'\x2', '\x2', '\x2', '\x2A6', '\xFA3', '\x3', '\x2', '\x2', '\x2', '\x2A8', 
		'\xFAA', '\x3', '\x2', '\x2', '\x2', '\x2AA', '\xFAE', '\x3', '\x2', '\x2', 
		'\x2', '\x2AC', '\xFB5', '\x3', '\x2', '\x2', '\x2', '\x2AE', '\xFBC', 
		'\x3', '\x2', '\x2', '\x2', '\x2B0', '\xFC0', '\x3', '\x2', '\x2', '\x2', 
		'\x2B2', '\xFC6', '\x3', '\x2', '\x2', '\x2', '\x2B4', '\xFD4', '\x3', 
		'\x2', '\x2', '\x2', '\x2B6', '\xFD6', '\x3', '\x2', '\x2', '\x2', '\x2B8', 
		'\xFE4', '\x3', '\x2', '\x2', '\x2', '\x2BA', '\xFE6', '\x3', '\x2', '\x2', 
		'\x2', '\x2BC', '\xFE8', '\x3', '\x2', '\x2', '\x2', '\x2BE', '\xFEA', 
		'\x3', '\x2', '\x2', '\x2', '\x2C0', '\x100C', '\x3', '\x2', '\x2', '\x2', 
		'\x2C2', '\x100E', '\x3', '\x2', '\x2', '\x2', '\x2C4', '\x1017', '\x3', 
		'\x2', '\x2', '\x2', '\x2C6', '\x1029', '\x3', '\x2', '\x2', '\x2', '\x2C8', 
		'\x102F', '\x3', '\x2', '\x2', '\x2', '\x2CA', '\x1032', '\x3', '\x2', 
		'\x2', '\x2', '\x2CC', '\x1035', '\x3', '\x2', '\x2', '\x2', '\x2CE', 
		'\x1038', '\x3', '\x2', '\x2', '\x2', '\x2D0', '\x103B', '\x3', '\x2', 
		'\x2', '\x2', '\x2D2', '\x1046', '\x3', '\x2', '\x2', '\x2', '\x2D4', 
		'\x104A', '\x3', '\x2', '\x2', '\x2', '\x2D6', '\x104C', '\x3', '\x2', 
		'\x2', '\x2', '\x2D8', '\x1054', '\x3', '\x2', '\x2', '\x2', '\x2DA', 
		'\x105E', '\x3', '\x2', '\x2', '\x2', '\x2DC', '\x1060', '\x3', '\x2', 
		'\x2', '\x2', '\x2DE', '\x1068', '\x3', '\x2', '\x2', '\x2', '\x2E0', 
		'\x1075', '\x3', '\x2', '\x2', '\x2', '\x2E2', '\x107C', '\x3', '\x2', 
		'\x2', '\x2', '\x2E4', '\x1080', '\x3', '\x2', '\x2', '\x2', '\x2E6', 
		'\x1084', '\x3', '\x2', '\x2', '\x2', '\x2E8', '\x1088', '\x3', '\x2', 
		'\x2', '\x2', '\x2EA', '\x108C', '\x3', '\x2', '\x2', '\x2', '\x2EC', 
		'\x108E', '\x3', '\x2', '\x2', '\x2', '\x2EE', '\x10A2', '\x3', '\x2', 
		'\x2', '\x2', '\x2F0', '\x10A4', '\x3', '\x2', '\x2', '\x2', '\x2F2', 
		'\x10A6', '\x3', '\x2', '\x2', '\x2', '\x2F4', '\x10AA', '\x3', '\x2', 
		'\x2', '\x2', '\x2F6', '\x10AC', '\x3', '\x2', '\x2', '\x2', '\x2F8', 
		'\x10AE', '\x3', '\x2', '\x2', '\x2', '\x2FA', '\x10B0', '\x3', '\x2', 
		'\x2', '\x2', '\x2FC', '\x10B2', '\x3', '\x2', '\x2', '\x2', '\x2FE', 
		'\x303', '\x5', '\x4', '\x3', '\x2', '\x2FF', '\x300', '\a', '\x111', 
		'\x2', '\x2', '\x300', '\x302', '\x5', '\x4', '\x3', '\x2', '\x301', '\x2FF', 
		'\x3', '\x2', '\x2', '\x2', '\x302', '\x305', '\x3', '\x2', '\x2', '\x2', 
		'\x303', '\x301', '\x3', '\x2', '\x2', '\x2', '\x303', '\x304', '\x3', 
		'\x2', '\x2', '\x2', '\x304', '\x307', '\x3', '\x2', '\x2', '\x2', '\x305', 
		'\x303', '\x3', '\x2', '\x2', '\x2', '\x306', '\x308', '\a', '\x111', 
		'\x2', '\x2', '\x307', '\x306', '\x3', '\x2', '\x2', '\x2', '\x307', '\x308', 
		'\x3', '\x2', '\x2', '\x2', '\x308', '\x309', '\x3', '\x2', '\x2', '\x2', 
		'\x309', '\x30A', '\a', '\x2', '\x2', '\x3', '\x30A', '\x3', '\x3', '\x2', 
		'\x2', '\x2', '\x30B', '\x30E', '\x5', '\x140', '\xA1', '\x2', '\x30C', 
		'\x30E', '\x5', '\x6', '\x4', '\x2', '\x30D', '\x30B', '\x3', '\x2', '\x2', 
		'\x2', '\x30D', '\x30C', '\x3', '\x2', '\x2', '\x2', '\x30E', '\x5', '\x3', 
		'\x2', '\x2', '\x2', '\x30F', '\x314', '\x5', '\b', '\x5', '\x2', '\x310', 
		'\x311', '\a', '\xC4', '\x2', '\x2', '\x311', '\x313', '\x5', '\b', '\x5', 
		'\x2', '\x312', '\x310', '\x3', '\x2', '\x2', '\x2', '\x313', '\x316', 
		'\x3', '\x2', '\x2', '\x2', '\x314', '\x312', '\x3', '\x2', '\x2', '\x2', 
		'\x314', '\x315', '\x3', '\x2', '\x2', '\x2', '\x315', '\a', '\x3', '\x2', 
		'\x2', '\x2', '\x316', '\x314', '\x3', '\x2', '\x2', '\x2', '\x317', '\x31A', 
		'\x5', '\n', '\x6', '\x2', '\x318', '\x31A', '\x5', '\f', '\a', '\x2', 
		'\x319', '\x317', '\x3', '\x2', '\x2', '\x2', '\x319', '\x318', '\x3', 
		'\x2', '\x2', '\x2', '\x31A', '\t', '\x3', '\x2', '\x2', '\x2', '\x31B', 
		'\x323', '\x5', '\x12', '\n', '\x2', '\x31C', '\x31E', '\a', '\x139', 
		'\x2', '\x2', '\x31D', '\x31F', '\t', '\x2', '\x2', '\x2', '\x31E', '\x31D', 
		'\x3', '\x2', '\x2', '\x2', '\x31E', '\x31F', '\x3', '\x2', '\x2', '\x2', 
		'\x31F', '\x320', '\x3', '\x2', '\x2', '\x2', '\x320', '\x322', '\x5', 
		'\x12', '\n', '\x2', '\x321', '\x31C', '\x3', '\x2', '\x2', '\x2', '\x322', 
		'\x325', '\x3', '\x2', '\x2', '\x2', '\x323', '\x321', '\x3', '\x2', '\x2', 
		'\x2', '\x323', '\x324', '\x3', '\x2', '\x2', '\x2', '\x324', '\v', '\x3', 
		'\x2', '\x2', '\x2', '\x325', '\x323', '\x3', '\x2', '\x2', '\x2', '\x326', 
		'\x328', '\x5', '\xE', '\b', '\x2', '\x327', '\x326', '\x3', '\x2', '\x2', 
		'\x2', '\x328', '\x329', '\x3', '\x2', '\x2', '\x2', '\x329', '\x327', 
		'\x3', '\x2', '\x2', '\x2', '\x329', '\x32A', '\x3', '\x2', '\x2', '\x2', 
		'\x32A', '\x32C', '\x3', '\x2', '\x2', '\x2', '\x32B', '\x32D', '\x5', 
		'\x10', '\t', '\x2', '\x32C', '\x32B', '\x3', '\x2', '\x2', '\x2', '\x32C', 
		'\x32D', '\x3', '\x2', '\x2', '\x2', '\x32D', '\r', '\x3', '\x2', '\x2', 
		'\x2', '\x32E', '\x32F', '\a', '\x149', '\x2', '\x2', '\x32F', '\x330', 
		'\x5', '\xBC', '_', '\x2', '\x330', '\x331', '\a', '\x129', '\x2', '\x2', 
		'\x331', '\x332', '\x5', '\x12', '\n', '\x2', '\x332', '\xF', '\x3', '\x2', 
		'\x2', '\x2', '\x333', '\x334', '\a', '\x64', '\x2', '\x2', '\x334', '\x335', 
		'\x5', '\x12', '\n', '\x2', '\x335', '\x11', '\x3', '\x2', '\x2', '\x2', 
		'\x336', '\x338', '\x5', '\x14', '\v', '\x2', '\x337', '\x336', '\x3', 
		'\x2', '\x2', '\x2', '\x338', '\x339', '\x3', '\x2', '\x2', '\x2', '\x339', 
		'\x337', '\x3', '\x2', '\x2', '\x2', '\x339', '\x33A', '\x3', '\x2', '\x2', 
		'\x2', '\x33A', '\x343', '\x3', '\x2', '\x2', '\x2', '\x33B', '\x33D', 
		'\x5', '\x16', '\f', '\x2', '\x33C', '\x33B', '\x3', '\x2', '\x2', '\x2', 
		'\x33C', '\x33D', '\x3', '\x2', '\x2', '\x2', '\x33D', '\x33E', '\x3', 
		'\x2', '\x2', '\x2', '\x33E', '\x33F', '\a', '\xA7', '\x2', '\x2', '\x33F', 
		'\x340', '\x5', '\x6', '\x4', '\x2', '\x340', '\x341', '\a', '\xF0', '\x2', 
		'\x2', '\x341', '\x343', '\x3', '\x2', '\x2', '\x2', '\x342', '\x337', 
		'\x3', '\x2', '\x2', '\x2', '\x342', '\x33C', '\x3', '\x2', '\x2', '\x2', 
		'\x343', '\x13', '\x3', '\x2', '\x2', '\x2', '\x344', '\x358', '\x5', 
		'\x16', '\f', '\x2', '\x345', '\x358', '\x5', '\x1A', '\xE', '\x2', '\x346', 
		'\x358', '\x5', '\x1C', '\xF', '\x2', '\x347', '\x358', '\x5', '\x34', 
		'\x1B', '\x2', '\x348', '\x358', '\x5', '\x36', '\x1C', '\x2', '\x349', 
		'\x358', '\x5', '@', '!', '\x2', '\x34A', '\x358', '\x5', '\x38', '\x1D', 
		'\x2', '\x34B', '\x358', '\x5', '<', '\x1F', '\x2', '\x34C', '\x358', 
		'\x5', '\x42', '\"', '\x2', '\x34D', '\x358', '\x5', 'H', '%', '\x2', 
		'\x34E', '\x358', '\x5', '\x32', '\x1A', '\x2', '\x34F', '\x358', '\x5', 
		'L', '\'', '\x2', '\x350', '\x358', '\x5', 'N', '(', '\x2', '\x351', '\x358', 
		'\x5', 'P', ')', '\x2', '\x352', '\x358', '\x5', 'T', '+', '\x2', '\x353', 
		'\x358', '\x5', '`', '\x31', '\x2', '\x354', '\x358', '\x5', '\\', '/', 
		'\x2', '\x355', '\x358', '\x5', '^', '\x30', '\x2', '\x356', '\x358', 
		'\x5', 'n', '\x38', '\x2', '\x357', '\x344', '\x3', '\x2', '\x2', '\x2', 
		'\x357', '\x345', '\x3', '\x2', '\x2', '\x2', '\x357', '\x346', '\x3', 
		'\x2', '\x2', '\x2', '\x357', '\x347', '\x3', '\x2', '\x2', '\x2', '\x357', 
		'\x348', '\x3', '\x2', '\x2', '\x2', '\x357', '\x349', '\x3', '\x2', '\x2', 
		'\x2', '\x357', '\x34A', '\x3', '\x2', '\x2', '\x2', '\x357', '\x34B', 
		'\x3', '\x2', '\x2', '\x2', '\x357', '\x34C', '\x3', '\x2', '\x2', '\x2', 
		'\x357', '\x34D', '\x3', '\x2', '\x2', '\x2', '\x357', '\x34E', '\x3', 
		'\x2', '\x2', '\x2', '\x357', '\x34F', '\x3', '\x2', '\x2', '\x2', '\x357', 
		'\x350', '\x3', '\x2', '\x2', '\x2', '\x357', '\x351', '\x3', '\x2', '\x2', 
		'\x2', '\x357', '\x352', '\x3', '\x2', '\x2', '\x2', '\x357', '\x353', 
		'\x3', '\x2', '\x2', '\x2', '\x357', '\x354', '\x3', '\x2', '\x2', '\x2', 
		'\x357', '\x355', '\x3', '\x2', '\x2', '\x2', '\x357', '\x356', '\x3', 
		'\x2', '\x2', '\x2', '\x358', '\x15', '\x3', '\x2', '\x2', '\x2', '\x359', 
		'\x35B', '\a', '\x13E', '\x2', '\x2', '\x35A', '\x35C', '\a', '\x82', 
		'\x2', '\x2', '\x35B', '\x35A', '\x3', '\x2', '\x2', '\x2', '\x35B', '\x35C', 
		'\x3', '\x2', '\x2', '\x2', '\x35C', '\x35D', '\x3', '\x2', '\x2', '\x2', 
		'\x35D', '\x35E', '\x5', '\x18', '\r', '\x2', '\x35E', '\x17', '\x3', 
		'\x2', '\x2', '\x2', '\x35F', '\x360', '\a', '\xB0', '\x2', '\x2', '\x360', 
		'\x361', '\x5', '\x18', '\r', '\x2', '\x361', '\x362', '\a', '\x109', 
		'\x2', '\x2', '\x362', '\x366', '\x3', '\x2', '\x2', '\x2', '\x363', '\x366', 
		'\x5', '\x128', '\x95', '\x2', '\x364', '\x366', '\x5', '\x2DC', '\x16F', 
		'\x2', '\x365', '\x35F', '\x3', '\x2', '\x2', '\x2', '\x365', '\x363', 
		'\x3', '\x2', '\x2', '\x2', '\x365', '\x364', '\x3', '\x2', '\x2', '\x2', 
		'\x366', '\x19', '\x3', '\x2', '\x2', '\x2', '\x367', '\x368', '\a', 'u', 
		'\x2', '\x2', '\x368', '\x1B', '\x3', '\x2', '\x2', '\x2', '\x369', '\x36A', 
		'\a', '\x103', '\x2', '\x2', '\x36A', '\x36B', '\x5', '\x1E', '\x10', 
		'\x2', '\x36B', '\x1D', '\x3', '\x2', '\x2', '\x2', '\x36C', '\x36E', 
		'\t', '\x2', '\x2', '\x2', '\x36D', '\x36C', '\x3', '\x2', '\x2', '\x2', 
		'\x36D', '\x36E', '\x3', '\x2', '\x2', '\x2', '\x36E', '\x36F', '\x3', 
		'\x2', '\x2', '\x2', '\x36F', '\x371', '\x5', '\"', '\x12', '\x2', '\x370', 
		'\x372', '\x5', '*', '\x16', '\x2', '\x371', '\x370', '\x3', '\x2', '\x2', 
		'\x2', '\x371', '\x372', '\x3', '\x2', '\x2', '\x2', '\x372', '\x374', 
		'\x3', '\x2', '\x2', '\x2', '\x373', '\x375', '\x5', ',', '\x17', '\x2', 
		'\x374', '\x373', '\x3', '\x2', '\x2', '\x2', '\x374', '\x375', '\x3', 
		'\x2', '\x2', '\x2', '\x375', '\x377', '\x3', '\x2', '\x2', '\x2', '\x376', 
		'\x378', '\x5', '.', '\x18', '\x2', '\x377', '\x376', '\x3', '\x2', '\x2', 
		'\x2', '\x377', '\x378', '\x3', '\x2', '\x2', '\x2', '\x378', '\x1F', 
		'\x3', '\x2', '\x2', '\x2', '\x379', '\x37C', '\x5', '\xBC', '_', '\x2', 
		'\x37A', '\x37B', '\a', '\x1B', '\x2', '\x2', '\x37B', '\x37D', '\x5', 
		'\x130', '\x99', '\x2', '\x37C', '\x37A', '\x3', '\x2', '\x2', '\x2', 
		'\x37C', '\x37D', '\x3', '\x2', '\x2', '\x2', '\x37D', '!', '\x3', '\x2', 
		'\x2', '\x2', '\x37E', '\x381', '\a', '\x12B', '\x2', '\x2', '\x37F', 
		'\x381', '\x5', ' ', '\x11', '\x2', '\x380', '\x37E', '\x3', '\x2', '\x2', 
		'\x2', '\x380', '\x37F', '\x3', '\x2', '\x2', '\x2', '\x381', '\x386', 
		'\x3', '\x2', '\x2', '\x2', '\x382', '\x383', '\a', '\x32', '\x2', '\x2', 
		'\x383', '\x385', '\x5', ' ', '\x11', '\x2', '\x384', '\x382', '\x3', 
		'\x2', '\x2', '\x2', '\x385', '\x388', '\x3', '\x2', '\x2', '\x2', '\x386', 
		'\x384', '\x3', '\x2', '\x2', '\x2', '\x386', '\x387', '\x3', '\x2', '\x2', 
		'\x2', '\x387', '#', '\x3', '\x2', '\x2', '\x2', '\x388', '\x386', '\x3', 
		'\x2', '\x2', '\x2', '\x389', '\x38C', '\x5', '\xBC', '_', '\x2', '\x38A', 
		'\x38D', '\x5', '&', '\x14', '\x2', '\x38B', '\x38D', '\x5', '(', '\x15', 
		'\x2', '\x38C', '\x38A', '\x3', '\x2', '\x2', '\x2', '\x38C', '\x38B', 
		'\x3', '\x2', '\x2', '\x2', '\x38C', '\x38D', '\x3', '\x2', '\x2', '\x2', 
		'\x38D', '%', '\x3', '\x2', '\x2', '\x2', '\x38E', '\x38F', '\t', '\x3', 
		'\x2', '\x2', '\x38F', '\'', '\x3', '\x2', '\x2', '\x2', '\x390', '\x391', 
		'\t', '\x4', '\x2', '\x2', '\x391', ')', '\x3', '\x2', '\x2', '\x2', '\x392', 
		'\x393', '\a', '\xD8', '\x2', '\x2', '\x393', '\x394', '\a', ')', '\x2', 
		'\x2', '\x394', '\x399', '\x5', '$', '\x13', '\x2', '\x395', '\x396', 
		'\a', '\x32', '\x2', '\x2', '\x396', '\x398', '\x5', '$', '\x13', '\x2', 
		'\x397', '\x395', '\x3', '\x2', '\x2', '\x2', '\x398', '\x39B', '\x3', 
		'\x2', '\x2', '\x2', '\x399', '\x397', '\x3', '\x2', '\x2', '\x2', '\x399', 
		'\x39A', '\x3', '\x2', '\x2', '\x2', '\x39A', '+', '\x3', '\x2', '\x2', 
		'\x2', '\x39B', '\x399', '\x3', '\x2', '\x2', '\x2', '\x39C', '\x39D', 
		'\t', '\x5', '\x2', '\x2', '\x39D', '\x39E', '\x5', '\xBC', '_', '\x2', 
		'\x39E', '-', '\x3', '\x2', '\x2', '\x2', '\x39F', '\x3A0', '\a', '\xAB', 
		'\x2', '\x2', '\x3A0', '\x3A1', '\x5', '\xBC', '_', '\x2', '\x3A1', '/', 
		'\x3', '\x2', '\x2', '\x2', '\x3A2', '\x3A3', '\a', '\x14A', '\x2', '\x2', 
		'\x3A3', '\x3A4', '\x5', '\xBC', '_', '\x2', '\x3A4', '\x31', '\x3', '\x2', 
		'\x2', '\x2', '\x3A5', '\x3A6', '\a', '\x14B', '\x2', '\x2', '\x3A6', 
		'\x3A8', '\x5', '\x1E', '\x10', '\x2', '\x3A7', '\x3A9', '\x5', '\x30', 
		'\x19', '\x2', '\x3A8', '\x3A7', '\x3', '\x2', '\x2', '\x2', '\x3A8', 
		'\x3A9', '\x3', '\x2', '\x2', '\x2', '\x3A9', '\x33', '\x3', '\x2', '\x2', 
		'\x2', '\x3AA', '\x3AB', '\a', '>', '\x2', '\x2', '\x3AB', '\x3AC', '\x5', 
		'p', '\x39', '\x2', '\x3AC', '\x35', '\x3', '\x2', '\x2', '\x2', '\x3AD', 
		'\x3AE', '\a', '\x93', '\x2', '\x2', '\x3AE', '\x3AF', '\x5', 'r', ':', 
		'\x2', '\x3AF', '\x37', '\x3', '\x2', '\x2', '\x2', '\x3B0', '\x3B1', 
		'\a', '\x114', '\x2', '\x2', '\x3B1', '\x3B6', '\x5', ':', '\x1E', '\x2', 
		'\x3B2', '\x3B3', '\a', '\x32', '\x2', '\x2', '\x3B3', '\x3B5', '\x5', 
		':', '\x1E', '\x2', '\x3B4', '\x3B2', '\x3', '\x2', '\x2', '\x2', '\x3B5', 
		'\x3B8', '\x3', '\x2', '\x2', '\x2', '\x3B6', '\x3B4', '\x3', '\x2', '\x2', 
		'\x2', '\x3B6', '\x3B7', '\x3', '\x2', '\x2', '\x2', '\x3B7', '\x39', 
		'\x3', '\x2', '\x2', '\x2', '\x3B8', '\x3B6', '\x3', '\x2', '\x2', '\x2', 
		'\x3B9', '\x3BA', '\x5', '\xDC', 'o', '\x2', '\x3BA', '\x3BB', '\a', 'j', 
		'\x2', '\x2', '\x3BB', '\x3BC', '\x5', '\xBC', '_', '\x2', '\x3BC', '\x3D0', 
		'\x3', '\x2', '\x2', '\x2', '\x3BD', '\x3BE', '\x5', '\xDE', 'p', '\x2', 
		'\x3BE', '\x3BF', '\a', 'j', '\x2', '\x2', '\x3BF', '\x3C0', '\x5', '\xBC', 
		'_', '\x2', '\x3C0', '\x3D0', '\x3', '\x2', '\x2', '\x2', '\x3C1', '\x3C2', 
		'\x5', '\x130', '\x99', '\x2', '\x3C2', '\x3C3', '\a', 'j', '\x2', '\x2', 
		'\x3C3', '\x3C4', '\x5', '\xBC', '_', '\x2', '\x3C4', '\x3D0', '\x3', 
		'\x2', '\x2', '\x2', '\x3C5', '\x3C6', '\x5', '\x130', '\x99', '\x2', 
		'\x3C6', '\x3C7', '\a', '\xDF', '\x2', '\x2', '\x3C7', '\x3C8', '\x5', 
		'\xBC', '_', '\x2', '\x3C8', '\x3D0', '\x3', '\x2', '\x2', '\x2', '\x3C9', 
		'\x3CA', '\x5', '\x130', '\x99', '\x2', '\x3CA', '\x3CB', '\x5', '\x90', 
		'I', '\x2', '\x3CB', '\x3D0', '\x3', '\x2', '\x2', '\x2', '\x3CC', '\x3CD', 
		'\x5', '\x130', '\x99', '\x2', '\x3CD', '\x3CE', '\x5', '\x92', 'J', '\x2', 
		'\x3CE', '\x3D0', '\x3', '\x2', '\x2', '\x2', '\x3CF', '\x3B9', '\x3', 
		'\x2', '\x2', '\x2', '\x3CF', '\x3BD', '\x3', '\x2', '\x2', '\x2', '\x3CF', 
		'\x3C1', '\x3', '\x2', '\x2', '\x2', '\x3CF', '\x3C5', '\x3', '\x2', '\x2', 
		'\x2', '\x3CF', '\x3C9', '\x3', '\x2', '\x2', '\x2', '\x3CF', '\x3CC', 
		'\x3', '\x2', '\x2', '\x2', '\x3D0', ';', '\x3', '\x2', '\x2', '\x2', 
		'\x3D1', '\x3D2', '\a', '\xF9', '\x2', '\x2', '\x3D2', '\x3D7', '\x5', 
		'>', ' ', '\x2', '\x3D3', '\x3D4', '\a', '\x32', '\x2', '\x2', '\x3D4', 
		'\x3D6', '\x5', '>', ' ', '\x2', '\x3D5', '\x3D3', '\x3', '\x2', '\x2', 
		'\x2', '\x3D6', '\x3D9', '\x3', '\x2', '\x2', '\x2', '\x3D7', '\x3D5', 
		'\x3', '\x2', '\x2', '\x2', '\x3D7', '\x3D8', '\x3', '\x2', '\x2', '\x2', 
		'\x3D8', '=', '\x3', '\x2', '\x2', '\x2', '\x3D9', '\x3D7', '\x3', '\x2', 
		'\x2', '\x2', '\x3DA', '\x3E3', '\x5', '\xDC', 'o', '\x2', '\x3DB', '\x3E3', 
		'\x5', '\xDE', 'p', '\x2', '\x3DC', '\x3DD', '\x5', '\x130', '\x99', '\x2', 
		'\x3DD', '\x3DE', '\x5', '\x90', 'I', '\x2', '\x3DE', '\x3E3', '\x3', 
		'\x2', '\x2', '\x2', '\x3DF', '\x3E0', '\x5', '\x130', '\x99', '\x2', 
		'\x3E0', '\x3E1', '\x5', '\x92', 'J', '\x2', '\x3E1', '\x3E3', '\x3', 
		'\x2', '\x2', '\x2', '\x3E2', '\x3DA', '\x3', '\x2', '\x2', '\x2', '\x3E2', 
		'\x3DB', '\x3', '\x2', '\x2', '\x2', '\x3E2', '\x3DC', '\x3', '\x2', '\x2', 
		'\x2', '\x3E2', '\x3DF', '\x3', '\x2', '\x2', '\x2', '\x3E3', '?', '\x3', 
		'\x2', '\x2', '\x2', '\x3E4', '\x3E6', '\t', '\x6', '\x2', '\x2', '\x3E5', 
		'\x3E4', '\x3', '\x2', '\x2', '\x2', '\x3E5', '\x3E6', '\x3', '\x2', '\x2', 
		'\x2', '\x3E6', '\x3E7', '\x3', '\x2', '\x2', '\x2', '\x3E7', '\x3E8', 
		'\a', 'L', '\x2', '\x2', '\x3E8', '\x3ED', '\x5', '\xBC', '_', '\x2', 
		'\x3E9', '\x3EA', '\a', '\x32', '\x2', '\x2', '\x3EA', '\x3EC', '\x5', 
		'\xBC', '_', '\x2', '\x3EB', '\x3E9', '\x3', '\x2', '\x2', '\x2', '\x3EC', 
		'\x3EF', '\x3', '\x2', '\x2', '\x2', '\x3ED', '\x3EB', '\x3', '\x2', '\x2', 
		'\x2', '\x3ED', '\x3EE', '\x3', '\x2', '\x2', '\x2', '\x3EE', '\x41', 
		'\x3', '\x2', '\x2', '\x2', '\x3EF', '\x3ED', '\x3', '\x2', '\x2', '\x2', 
		'\x3F0', '\x3F2', '\a', '\xD4', '\x2', '\x2', '\x3F1', '\x3F0', '\x3', 
		'\x2', '\x2', '\x2', '\x3F1', '\x3F2', '\x3', '\x2', '\x2', '\x2', '\x3F2', 
		'\x3F3', '\x3', '\x2', '\x2', '\x2', '\x3F3', '\x3F5', '\a', '\xB5', '\x2', 
		'\x2', '\x3F4', '\x3F6', '\x5', '\x44', '#', '\x2', '\x3F5', '\x3F4', 
		'\x3', '\x2', '\x2', '\x2', '\x3F5', '\x3F6', '\x3', '\x2', '\x2', '\x2', 
		'\x3F6', '\x3F7', '\x3', '\x2', '\x2', '\x2', '\x3F7', '\x3FB', '\x5', 
		'p', '\x39', '\x2', '\x3F8', '\x3FA', '\x5', '\x46', '$', '\x2', '\x3F9', 
		'\x3F8', '\x3', '\x2', '\x2', '\x2', '\x3FA', '\x3FD', '\x3', '\x2', '\x2', 
		'\x2', '\x3FB', '\x3F9', '\x3', '\x2', '\x2', '\x2', '\x3FB', '\x3FC', 
		'\x3', '\x2', '\x2', '\x2', '\x3FC', '\x3FF', '\x3', '\x2', '\x2', '\x2', 
		'\x3FD', '\x3FB', '\x3', '\x2', '\x2', '\x2', '\x3FE', '\x400', '\x5', 
		'\x30', '\x19', '\x2', '\x3FF', '\x3FE', '\x3', '\x2', '\x2', '\x2', '\x3FF', 
		'\x400', '\x3', '\x2', '\x2', '\x2', '\x400', '\x43', '\x3', '\x2', '\x2', 
		'\x2', '\x401', '\x407', '\a', '\xFA', '\x2', '\x2', '\x402', '\x404', 
		'\a', '\x62', '\x2', '\x2', '\x403', '\x405', '\a', '\"', '\x2', '\x2', 
		'\x404', '\x403', '\x3', '\x2', '\x2', '\x2', '\x404', '\x405', '\x3', 
		'\x2', '\x2', '\x2', '\x405', '\x408', '\x3', '\x2', '\x2', '\x2', '\x406', 
		'\x408', '\a', '\x63', '\x2', '\x2', '\x407', '\x402', '\x3', '\x2', '\x2', 
		'\x2', '\x407', '\x406', '\x3', '\x2', '\x2', '\x2', '\x408', '\x412', 
		'\x3', '\x2', '\x2', '\x2', '\x409', '\x40F', '\a', 'R', '\x2', '\x2', 
		'\x40A', '\x40C', '\a', '\xF7', '\x2', '\x2', '\x40B', '\x40D', '\a', 
		'\"', '\x2', '\x2', '\x40C', '\x40B', '\x3', '\x2', '\x2', '\x2', '\x40C', 
		'\x40D', '\x3', '\x2', '\x2', '\x2', '\x40D', '\x410', '\x3', '\x2', '\x2', 
		'\x2', '\x40E', '\x410', '\a', '\xF8', '\x2', '\x2', '\x40F', '\x40A', 
		'\x3', '\x2', '\x2', '\x2', '\x40F', '\x40E', '\x3', '\x2', '\x2', '\x2', 
		'\x410', '\x412', '\x3', '\x2', '\x2', '\x2', '\x411', '\x401', '\x3', 
		'\x2', '\x2', '\x2', '\x411', '\x409', '\x3', '\x2', '\x2', '\x2', '\x412', 
		'\x45', '\x3', '\x2', '\x2', '\x2', '\x413', '\x42D', '\a', '\x141', '\x2', 
		'\x2', '\x414', '\x41C', '\a', '\x8F', '\x2', '\x2', '\x415', '\x416', 
		'\a', '\x128', '\x2', '\x2', '\x416', '\x41C', '\a', '\x8F', '\x2', '\x2', 
		'\x417', '\x418', '\a', '\xEE', '\x2', '\x2', '\x418', '\x41C', '\a', 
		'\x8F', '\x2', '\x2', '\x419', '\x41A', '\a', '\xE0', '\x2', '\x2', '\x41A', 
		'\x41C', '\a', '\x8F', '\x2', '\x2', '\x41B', '\x414', '\x3', '\x2', '\x2', 
		'\x2', '\x41B', '\x415', '\x3', '\x2', '\x2', '\x2', '\x41B', '\x417', 
		'\x3', '\x2', '\x2', '\x2', '\x41B', '\x419', '\x3', '\x2', '\x2', '\x2', 
		'\x41C', '\x41E', '\x3', '\x2', '\x2', '\x2', '\x41D', '\x41F', '\a', 
		'\x110', '\x2', '\x2', '\x41E', '\x41D', '\x3', '\x2', '\x2', '\x2', '\x41E', 
		'\x41F', '\x3', '\x2', '\x2', '\x2', '\x41F', '\x420', '\x3', '\x2', '\x2', 
		'\x2', '\x420', '\x421', '\x5', '\x130', '\x99', '\x2', '\x421', '\x422', 
		'\x5', '\x9E', 'P', '\x2', '\x422', '\x423', '\a', '\xB0', '\x2', '\x2', 
		'\x423', '\x424', '\x5', '\x132', '\x9A', '\x2', '\x424', '\x425', '\a', 
		'\x109', '\x2', '\x2', '\x425', '\x42E', '\x3', '\x2', '\x2', '\x2', '\x426', 
		'\x427', '\a', '\x9F', '\x2', '\x2', '\x427', '\x428', '\a', '\xD2', '\x2', 
		'\x2', '\x428', '\x42E', '\x5', '\x132', '\x9A', '\x2', '\x429', '\x42A', 
		'\a', '\x10A', '\x2', '\x2', '\x42A', '\x42B', '\x5', '\x130', '\x99', 
		'\x2', '\x42B', '\x42C', '\x5', '\x9E', 'P', '\x2', '\x42C', '\x42E', 
		'\x3', '\x2', '\x2', '\x2', '\x42D', '\x41B', '\x3', '\x2', '\x2', '\x2', 
		'\x42D', '\x426', '\x3', '\x2', '\x2', '\x2', '\x42D', '\x429', '\x3', 
		'\x2', '\x2', '\x2', '\x42E', 'G', '\x3', '\x2', '\x2', '\x2', '\x42F', 
		'\x430', '\a', '\xB6', '\x2', '\x2', '\x430', '\x434', '\x5', 't', ';', 
		'\x2', '\x431', '\x433', '\x5', 'J', '&', '\x2', '\x432', '\x431', '\x3', 
		'\x2', '\x2', '\x2', '\x433', '\x436', '\x3', '\x2', '\x2', '\x2', '\x434', 
		'\x432', '\x3', '\x2', '\x2', '\x2', '\x434', '\x435', '\x3', '\x2', '\x2', 
		'\x2', '\x435', 'I', '\x3', '\x2', '\x2', '\x2', '\x436', '\x434', '\x3', 
		'\x2', '\x2', '\x2', '\x437', '\x438', '\a', '\xD2', '\x2', '\x2', '\x438', 
		'\x439', '\t', '\a', '\x2', '\x2', '\x439', '\x43A', '\x5', '\x38', '\x1D', 
		'\x2', '\x43A', 'K', '\x3', '\x2', '\x2', '\x2', '\x43B', '\x43D', '\a', 
		't', '\x2', '\x2', '\x43C', '\x43E', '\a', '\x14A', '\x2', '\x2', '\x43D', 
		'\x43C', '\x3', '\x2', '\x2', '\x2', '\x43D', '\x43E', '\x3', '\x2', '\x2', 
		'\x2', '\x43E', '\x43F', '\x3', '\x2', '\x2', '\x2', '\x43F', '\x440', 
		'\x5', '\xBC', '_', '\x2', '\x440', 'M', '\x3', '\x2', '\x2', '\x2', '\x441', 
		'\x442', '\a', '\x13C', '\x2', '\x2', '\x442', '\x443', '\x5', '\xBC', 
		'_', '\x2', '\x443', '\x444', '\a', '\x1B', '\x2', '\x2', '\x444', '\x445', 
		'\x5', '\x130', '\x99', '\x2', '\x445', 'O', '\x3', '\x2', '\x2', '\x2', 
		'\x446', '\x447', '\a', '\xAA', '\x2', '\x2', '\x447', '\x44C', '\x5', 
		'R', '*', '\x2', '\x448', '\x449', '\a', '\x32', '\x2', '\x2', '\x449', 
		'\x44B', '\x5', 'R', '*', '\x2', '\x44A', '\x448', '\x3', '\x2', '\x2', 
		'\x2', '\x44B', '\x44E', '\x3', '\x2', '\x2', '\x2', '\x44C', '\x44A', 
		'\x3', '\x2', '\x2', '\x2', '\x44C', '\x44D', '\x3', '\x2', '\x2', '\x2', 
		'\x44D', 'Q', '\x3', '\x2', '\x2', '\x2', '\x44E', '\x44C', '\x3', '\x2', 
		'\x2', '\x2', '\x44F', '\x450', '\x5', '\x130', '\x99', '\x2', '\x450', 
		'\x451', '\a', 'j', '\x2', '\x2', '\x451', '\x452', '\x5', '\xBC', '_', 
		'\x2', '\x452', 'S', '\x3', '\x2', '\x2', '\x2', '\x453', '\x455', '\a', 
		'\xD4', '\x2', '\x2', '\x454', '\x453', '\x3', '\x2', '\x2', '\x2', '\x454', 
		'\x455', '\x3', '\x2', '\x2', '\x2', '\x455', '\x456', '\x3', '\x2', '\x2', 
		'\x2', '\x456', '\x457', '\a', '*', '\x2', '\x2', '\x457', '\x464', '\x5', 
		'V', ',', '\x2', '\x458', '\x461', '\a', '\xB0', '\x2', '\x2', '\x459', 
		'\x45E', '\x5', 'X', '-', '\x2', '\x45A', '\x45B', '\a', '\x32', '\x2', 
		'\x2', '\x45B', '\x45D', '\x5', 'X', '-', '\x2', '\x45C', '\x45A', '\x3', 
		'\x2', '\x2', '\x2', '\x45D', '\x460', '\x3', '\x2', '\x2', '\x2', '\x45E', 
		'\x45C', '\x3', '\x2', '\x2', '\x2', '\x45E', '\x45F', '\x3', '\x2', '\x2', 
		'\x2', '\x45F', '\x462', '\x3', '\x2', '\x2', '\x2', '\x460', '\x45E', 
		'\x3', '\x2', '\x2', '\x2', '\x461', '\x459', '\x3', '\x2', '\x2', '\x2', 
		'\x461', '\x462', '\x3', '\x2', '\x2', '\x2', '\x462', '\x463', '\x3', 
		'\x2', '\x2', '\x2', '\x463', '\x465', '\a', '\x109', '\x2', '\x2', '\x464', 
		'\x458', '\x3', '\x2', '\x2', '\x2', '\x464', '\x465', '\x3', '\x2', '\x2', 
		'\x2', '\x465', '\x475', '\x3', '\x2', '\x2', '\x2', '\x466', '\x473', 
		'\a', '\x14F', '\x2', '\x2', '\x467', '\x474', '\a', '\x12B', '\x2', '\x2', 
		'\x468', '\x46D', '\x5', 'Z', '.', '\x2', '\x469', '\x46A', '\a', '\x32', 
		'\x2', '\x2', '\x46A', '\x46C', '\x5', 'Z', '.', '\x2', '\x46B', '\x469', 
		'\x3', '\x2', '\x2', '\x2', '\x46C', '\x46F', '\x3', '\x2', '\x2', '\x2', 
		'\x46D', '\x46B', '\x3', '\x2', '\x2', '\x2', '\x46D', '\x46E', '\x3', 
		'\x2', '\x2', '\x2', '\x46E', '\x471', '\x3', '\x2', '\x2', '\x2', '\x46F', 
		'\x46D', '\x3', '\x2', '\x2', '\x2', '\x470', '\x472', '\x5', '\x30', 
		'\x19', '\x2', '\x471', '\x470', '\x3', '\x2', '\x2', '\x2', '\x471', 
		'\x472', '\x3', '\x2', '\x2', '\x2', '\x472', '\x474', '\x3', '\x2', '\x2', 
		'\x2', '\x473', '\x467', '\x3', '\x2', '\x2', '\x2', '\x473', '\x468', 
		'\x3', '\x2', '\x2', '\x2', '\x474', '\x476', '\x3', '\x2', '\x2', '\x2', 
		'\x475', '\x466', '\x3', '\x2', '\x2', '\x2', '\x475', '\x476', '\x3', 
		'\x2', '\x2', '\x2', '\x476', 'U', '\x3', '\x2', '\x2', '\x2', '\x477', 
		'\x478', '\x5', '\x12E', '\x98', '\x2', '\x478', '\x479', '\x5', '\x2F4', 
		'\x17B', '\x2', '\x479', 'W', '\x3', '\x2', '\x2', '\x2', '\x47A', '\x47B', 
		'\x5', '\xBC', '_', '\x2', '\x47B', 'Y', '\x3', '\x2', '\x2', '\x2', '\x47C', 
		'\x47F', '\x5', '\x130', '\x99', '\x2', '\x47D', '\x47E', '\a', '\x1B', 
		'\x2', '\x2', '\x47E', '\x480', '\x5', '\x130', '\x99', '\x2', '\x47F', 
		'\x47D', '\x3', '\x2', '\x2', '\x2', '\x47F', '\x480', '\x3', '\x2', '\x2', 
		'\x2', '\x480', '[', '\x3', '\x2', '\x2', '\x2', '\x481', '\x482', '\a', 
		'\xAD', '\x2', '\x2', '\x482', '\x485', '\a', '@', '\x2', '\x2', '\x483', 
		'\x484', '\a', '\x14B', '\x2', '\x2', '\x484', '\x486', '\a', '\x88', 
		'\x2', '\x2', '\x485', '\x483', '\x3', '\x2', '\x2', '\x2', '\x485', '\x486', 
		'\x3', '\x2', '\x2', '\x2', '\x486', '\x487', '\x3', '\x2', '\x2', '\x2', 
		'\x487', '\x488', '\a', '|', '\x2', '\x2', '\x488', '\x489', '\x5', '\xBC', 
		'_', '\x2', '\x489', '\x48A', '\a', '\x1B', '\x2', '\x2', '\x48A', '\x48D', 
		'\x5', '\x130', '\x99', '\x2', '\x48B', '\x48C', '\a', 's', '\x2', '\x2', 
		'\x48C', '\x48E', '\x5', '\x2E2', '\x172', '\x2', '\x48D', '\x48B', '\x3', 
		'\x2', '\x2', '\x2', '\x48D', '\x48E', '\x3', '\x2', '\x2', '\x2', '\x48E', 
		']', '\x3', '\x2', '\x2', '\x2', '\x48F', '\x490', '\a', 'z', '\x2', '\x2', 
		'\x490', '\x491', '\a', '\xB0', '\x2', '\x2', '\x491', '\x492', '\x5', 
		'\x130', '\x99', '\x2', '\x492', '\x493', '\a', '\x8E', '\x2', '\x2', 
		'\x493', '\x494', '\x5', '\xBC', '_', '\x2', '\x494', '\x496', '\a', '!', 
		'\x2', '\x2', '\x495', '\x497', '\x5', '\x14', '\v', '\x2', '\x496', '\x495', 
		'\x3', '\x2', '\x2', '\x2', '\x497', '\x498', '\x3', '\x2', '\x2', '\x2', 
		'\x498', '\x496', '\x3', '\x2', '\x2', '\x2', '\x498', '\x499', '\x3', 
		'\x2', '\x2', '\x2', '\x499', '\x49A', '\x3', '\x2', '\x2', '\x2', '\x49A', 
		'\x49B', '\a', '\x109', '\x2', '\x2', '\x49B', '_', '\x3', '\x2', '\x2', 
		'\x2', '\x49C', '\x49E', '\a', '\xD4', '\x2', '\x2', '\x49D', '\x49C', 
		'\x3', '\x2', '\x2', '\x2', '\x49D', '\x49E', '\x3', '\x2', '\x2', '\x2', 
		'\x49E', '\x49F', '\x3', '\x2', '\x2', '\x2', '\x49F', '\x4A1', '\a', 
		'*', '\x2', '\x2', '\x4A0', '\x4A2', '\x5', '\x62', '\x32', '\x2', '\x4A1', 
		'\x4A0', '\x3', '\x2', '\x2', '\x2', '\x4A1', '\x4A2', '\x3', '\x2', '\x2', 
		'\x2', '\x4A2', '\x4A3', '\x3', '\x2', '\x2', '\x2', '\x4A3', '\x4A4', 
		'\a', '\xA7', '\x2', '\x2', '\x4A4', '\x4A5', '\x5', '\x6', '\x4', '\x2', 
		'\x4A5', '\x4A7', '\a', '\xF0', '\x2', '\x2', '\x4A6', '\x4A8', '\x5', 
		'\x64', '\x33', '\x2', '\x4A7', '\x4A6', '\x3', '\x2', '\x2', '\x2', '\x4A7', 
		'\x4A8', '\x3', '\x2', '\x2', '\x2', '\x4A8', '\x61', '\x3', '\x2', '\x2', 
		'\x2', '\x4A9', '\x4B3', '\a', '\xB0', '\x2', '\x2', '\x4AA', '\x4B4', 
		'\a', '\x12B', '\x2', '\x2', '\x4AB', '\x4B0', '\x5', '\x130', '\x99', 
		'\x2', '\x4AC', '\x4AD', '\a', '\x32', '\x2', '\x2', '\x4AD', '\x4AF', 
		'\x5', '\x130', '\x99', '\x2', '\x4AE', '\x4AC', '\x3', '\x2', '\x2', 
		'\x2', '\x4AF', '\x4B2', '\x3', '\x2', '\x2', '\x2', '\x4B0', '\x4AE', 
		'\x3', '\x2', '\x2', '\x2', '\x4B0', '\x4B1', '\x3', '\x2', '\x2', '\x2', 
		'\x4B1', '\x4B4', '\x3', '\x2', '\x2', '\x2', '\x4B2', '\x4B0', '\x3', 
		'\x2', '\x2', '\x2', '\x4B3', '\x4AA', '\x3', '\x2', '\x2', '\x2', '\x4B3', 
		'\x4AB', '\x3', '\x2', '\x2', '\x2', '\x4B3', '\x4B4', '\x3', '\x2', '\x2', 
		'\x2', '\x4B4', '\x4B5', '\x3', '\x2', '\x2', '\x2', '\x4B5', '\x4B6', 
		'\a', '\x109', '\x2', '\x2', '\x4B6', '\x63', '\x3', '\x2', '\x2', '\x2', 
		'\x4B7', '\x4BC', '\a', '\x8E', '\x2', '\x2', '\x4B8', '\x4BA', '\x5', 
		'\xBC', '_', '\x2', '\x4B9', '\x4B8', '\x3', '\x2', '\x2', '\x2', '\x4B9', 
		'\x4BA', '\x3', '\x2', '\x2', '\x2', '\x4BA', '\x4BB', '\x3', '\x2', '\x2', 
		'\x2', '\x4BB', '\x4BD', '\a', '\x36', '\x2', '\x2', '\x4BC', '\x4B9', 
		'\x3', '\x2', '\x2', '\x2', '\x4BC', '\x4BD', '\x3', '\x2', '\x2', '\x2', 
		'\x4BD', '\x4BE', '\x3', '\x2', '\x2', '\x2', '\x4BE', '\x4C4', '\a', 
		'\x132', '\x2', '\x2', '\x4BF', '\x4C3', '\x5', '\x66', '\x34', '\x2', 
		'\x4C0', '\x4C3', '\x5', 'h', '\x35', '\x2', '\x4C1', '\x4C3', '\x5', 
		'l', '\x37', '\x2', '\x4C2', '\x4BF', '\x3', '\x2', '\x2', '\x2', '\x4C2', 
		'\x4C0', '\x3', '\x2', '\x2', '\x2', '\x4C2', '\x4C1', '\x3', '\x2', '\x2', 
		'\x2', '\x4C3', '\x4C6', '\x3', '\x2', '\x2', '\x2', '\x4C4', '\x4C2', 
		'\x3', '\x2', '\x2', '\x2', '\x4C4', '\x4C5', '\x3', '\x2', '\x2', '\x2', 
		'\x4C5', '\x65', '\x3', '\x2', '\x2', '\x2', '\x4C6', '\x4C4', '\x3', 
		'\x2', '\x2', '\x2', '\x4C7', '\x4C8', '\a', '\xCF', '\x2', '\x2', '\x4C8', 
		'\x4C9', '\x5', '\xBC', '_', '\x2', '\x4C9', '\x4CA', '\t', '\b', '\x2', 
		'\x2', '\x4CA', 'g', '\x3', '\x2', '\x2', '\x2', '\x4CB', '\x4CC', '\a', 
		'\xD2', '\x2', '\x2', '\x4CC', '\x4CD', '\a', 'p', '\x2', '\x2', '\x4CD', 
		'\x4CF', '\a', '\x102', '\x2', '\x2', '\x4CE', '\x4D0', '\x5', 'j', '\x36', 
		'\x2', '\x4CF', '\x4CE', '\x3', '\x2', '\x2', '\x2', '\x4CF', '\x4D0', 
		'\x3', '\x2', '\x2', '\x2', '\x4D0', '\x4D3', '\x3', '\x2', '\x2', '\x2', 
		'\x4D1', '\x4D2', '\a', '\x129', '\x2', '\x2', '\x4D2', '\x4D4', '\t', 
		'\t', '\x2', '\x2', '\x4D3', '\x4D1', '\x3', '\x2', '\x2', '\x2', '\x4D3', 
		'\x4D4', '\x3', '\x2', '\x2', '\x2', '\x4D4', '\x4D9', '\x3', '\x2', '\x2', 
		'\x2', '\x4D5', '\x4D6', '\a', '\xD2', '\x2', '\x2', '\x4D6', '\x4D7', 
		'\a', 'p', '\x2', '\x2', '\x4D7', '\x4D9', '\t', '\t', '\x2', '\x2', '\x4D8', 
		'\x4CB', '\x3', '\x2', '\x2', '\x2', '\x4D8', '\x4D5', '\x3', '\x2', '\x2', 
		'\x2', '\x4D9', 'i', '\x3', '\x2', '\x2', '\x2', '\x4DA', '\x4DC', '\a', 
		'y', '\x2', '\x2', '\x4DB', '\x4DA', '\x3', '\x2', '\x2', '\x2', '\x4DB', 
		'\x4DC', '\x3', '\x2', '\x2', '\x2', '\x4DC', '\x4DD', '\x3', '\x2', '\x2', 
		'\x2', '\x4DD', '\x4DE', '\x5', '\xBC', '_', '\x2', '\x4DE', '\x4DF', 
		'\x5', '\x2B6', '\x15C', '\x2', '\x4DF', 'k', '\x3', '\x2', '\x2', '\x2', 
		'\x4E0', '\x4E1', '\a', '\xFE', '\x2', '\x2', '\x4E1', '\x4E2', '\a', 
		'\x121', '\x2', '\x2', '\x4E2', '\x4E3', '\a', '\x1B', '\x2', '\x2', '\x4E3', 
		'\x4E4', '\x5', '\x130', '\x99', '\x2', '\x4E4', 'm', '\x3', '\x2', '\x2', 
		'\x2', '\x4E5', '\x4E7', '\x5', '*', '\x16', '\x2', '\x4E6', '\x4E8', 
		'\x5', ',', '\x17', '\x2', '\x4E7', '\x4E6', '\x3', '\x2', '\x2', '\x2', 
		'\x4E7', '\x4E8', '\x3', '\x2', '\x2', '\x2', '\x4E8', '\x4EA', '\x3', 
		'\x2', '\x2', '\x2', '\x4E9', '\x4EB', '\x5', '.', '\x18', '\x2', '\x4EA', 
		'\x4E9', '\x3', '\x2', '\x2', '\x2', '\x4EA', '\x4EB', '\x3', '\x2', '\x2', 
		'\x2', '\x4EB', '\x4F2', '\x3', '\x2', '\x2', '\x2', '\x4EC', '\x4EE', 
		'\x5', ',', '\x17', '\x2', '\x4ED', '\x4EF', '\x5', '.', '\x18', '\x2', 
		'\x4EE', '\x4ED', '\x3', '\x2', '\x2', '\x2', '\x4EE', '\x4EF', '\x3', 
		'\x2', '\x2', '\x2', '\x4EF', '\x4F2', '\x3', '\x2', '\x2', '\x2', '\x4F0', 
		'\x4F2', '\x5', '.', '\x18', '\x2', '\x4F1', '\x4E5', '\x3', '\x2', '\x2', 
		'\x2', '\x4F1', '\x4EC', '\x3', '\x2', '\x2', '\x2', '\x4F1', '\x4F0', 
		'\x3', '\x2', '\x2', '\x2', '\x4F2', 'o', '\x3', '\x2', '\x2', '\x2', 
		'\x4F3', '\x4F8', '\x5', 't', ';', '\x2', '\x4F4', '\x4F5', '\a', '\x32', 
		'\x2', '\x2', '\x4F5', '\x4F7', '\x5', 't', ';', '\x2', '\x4F6', '\x4F4', 
		'\x3', '\x2', '\x2', '\x2', '\x4F7', '\x4FA', '\x3', '\x2', '\x2', '\x2', 
		'\x4F8', '\x4F6', '\x3', '\x2', '\x2', '\x2', '\x4F8', '\x4F9', '\x3', 
		'\x2', '\x2', '\x2', '\x4F9', 'q', '\x3', '\x2', '\x2', '\x2', '\x4FA', 
		'\x4F8', '\x3', '\x2', '\x2', '\x2', '\x4FB', '\x500', '\x5', 'v', '<', 
		'\x2', '\x4FC', '\x4FD', '\a', '\x32', '\x2', '\x2', '\x4FD', '\x4FF', 
		'\x5', 'v', '<', '\x2', '\x4FE', '\x4FC', '\x3', '\x2', '\x2', '\x2', 
		'\x4FF', '\x502', '\x3', '\x2', '\x2', '\x2', '\x500', '\x4FE', '\x3', 
		'\x2', '\x2', '\x2', '\x500', '\x501', '\x3', '\x2', '\x2', '\x2', '\x501', 
		's', '\x3', '\x2', '\x2', '\x2', '\x502', '\x500', '\x3', '\x2', '\x2', 
		'\x2', '\x503', '\x504', '\x5', '\x130', '\x99', '\x2', '\x504', '\x505', 
		'\a', 'j', '\x2', '\x2', '\x505', '\x507', '\x3', '\x2', '\x2', '\x2', 
		'\x506', '\x503', '\x3', '\x2', '\x2', '\x2', '\x506', '\x507', '\x3', 
		'\x2', '\x2', '\x2', '\x507', '\x509', '\x3', '\x2', '\x2', '\x2', '\x508', 
		'\x50A', '\x5', '\x80', '\x41', '\x2', '\x509', '\x508', '\x3', '\x2', 
		'\x2', '\x2', '\x509', '\x50A', '\x3', '\x2', '\x2', '\x2', '\x50A', '\x50B', 
		'\x3', '\x2', '\x2', '\x2', '\x50B', '\x50C', '\x5', 'z', '>', '\x2', 
		'\x50C', 'u', '\x3', '\x2', '\x2', '\x2', '\x50D', '\x50E', '\x5', '\x2F4', 
		'\x17B', '\x2', '\x50E', '\x50F', '\a', 'j', '\x2', '\x2', '\x50F', '\x511', 
		'\x3', '\x2', '\x2', '\x2', '\x510', '\x50D', '\x3', '\x2', '\x2', '\x2', 
		'\x510', '\x511', '\x3', '\x2', '\x2', '\x2', '\x511', '\x512', '\x3', 
		'\x2', '\x2', '\x2', '\x512', '\x518', '\x5', '\x8C', 'G', '\x2', '\x513', 
		'\x514', '\x5', '\xA4', 'S', '\x2', '\x514', '\x515', '\x5', '\x8C', 'G', 
		'\x2', '\x515', '\x517', '\x3', '\x2', '\x2', '\x2', '\x516', '\x513', 
		'\x3', '\x2', '\x2', '\x2', '\x517', '\x51A', '\x3', '\x2', '\x2', '\x2', 
		'\x518', '\x516', '\x3', '\x2', '\x2', '\x2', '\x518', '\x519', '\x3', 
		'\x2', '\x2', '\x2', '\x519', 'w', '\x3', '\x2', '\x2', '\x2', '\x51A', 
		'\x518', '\x3', '\x2', '\x2', '\x2', '\x51B', '\x51C', '\a', '\xA7', '\x2', 
		'\x2', '\x51C', '\x51D', '\a', '\a', '\x2', '\x2', '\x51D', '\x52A', '\a', 
		'\xF0', '\x2', '\x2', '\x51E', '\x520', '\a', '\xA7', '\x2', '\x2', '\x51F', 
		'\x521', '\a', '\a', '\x2', '\x2', '\x520', '\x51F', '\x3', '\x2', '\x2', 
		'\x2', '\x520', '\x521', '\x3', '\x2', '\x2', '\x2', '\x521', '\x522', 
		'\x3', '\x2', '\x2', '\x2', '\x522', '\x524', '\a', '\x32', '\x2', '\x2', 
		'\x523', '\x525', '\a', '\a', '\x2', '\x2', '\x524', '\x523', '\x3', '\x2', 
		'\x2', '\x2', '\x524', '\x525', '\x3', '\x2', '\x2', '\x2', '\x525', '\x526', 
		'\x3', '\x2', '\x2', '\x2', '\x526', '\x52A', '\a', '\xF0', '\x2', '\x2', 
		'\x527', '\x52A', '\a', '\xDE', '\x2', '\x2', '\x528', '\x52A', '\a', 
		'\x12B', '\x2', '\x2', '\x529', '\x51B', '\x3', '\x2', '\x2', '\x2', '\x529', 
		'\x51E', '\x3', '\x2', '\x2', '\x2', '\x529', '\x527', '\x3', '\x2', '\x2', 
		'\x2', '\x529', '\x528', '\x3', '\x2', '\x2', '\x2', '\x52A', 'y', '\x3', 
		'\x2', '\x2', '\x2', '\x52B', '\x52E', '\x5', '|', '?', '\x2', '\x52C', 
		'\x52E', '\x5', '~', '@', '\x2', '\x52D', '\x52B', '\x3', '\x2', '\x2', 
		'\x2', '\x52D', '\x52C', '\x3', '\x2', '\x2', '\x2', '\x52E', '{', '\x3', 
		'\x2', '\x2', '\x2', '\x52F', '\x530', '\t', '\n', '\x2', '\x2', '\x530', 
		'\x531', '\a', '\xB0', '\x2', '\x2', '\x531', '\x532', '\x5', '~', '@', 
		'\x2', '\x532', '\x533', '\a', '\x109', '\x2', '\x2', '\x533', '}', '\x3', 
		'\x2', '\x2', '\x2', '\x534', '\x53D', '\x5', '\x8A', '\x46', '\x2', '\x535', 
		'\x537', '\x5', '\xA2', 'R', '\x2', '\x536', '\x538', '\x5', 'x', '=', 
		'\x2', '\x537', '\x536', '\x3', '\x2', '\x2', '\x2', '\x537', '\x538', 
		'\x3', '\x2', '\x2', '\x2', '\x538', '\x539', '\x3', '\x2', '\x2', '\x2', 
		'\x539', '\x53A', '\x5', '\x8A', '\x46', '\x2', '\x53A', '\x53C', '\x3', 
		'\x2', '\x2', '\x2', '\x53B', '\x535', '\x3', '\x2', '\x2', '\x2', '\x53C', 
		'\x53F', '\x3', '\x2', '\x2', '\x2', '\x53D', '\x53B', '\x3', '\x2', '\x2', 
		'\x2', '\x53D', '\x53E', '\x3', '\x2', '\x2', '\x2', '\x53E', '\x542', 
		'\x3', '\x2', '\x2', '\x2', '\x53F', '\x53D', '\x3', '\x2', '\x2', '\x2', 
		'\x540', '\x542', '\x5', '\x8E', 'H', '\x2', '\x541', '\x534', '\x3', 
		'\x2', '\x2', '\x2', '\x541', '\x540', '\x3', '\x2', '\x2', '\x2', '\x542', 
		'\x543', '\x3', '\x2', '\x2', '\x2', '\x543', '\x541', '\x3', '\x2', '\x2', 
		'\x2', '\x543', '\x544', '\x3', '\x2', '\x2', '\x2', '\x544', '\x7F', 
		'\x3', '\x2', '\x2', '\x2', '\x545', '\x546', '\a', '\x19', '\x2', '\x2', 
		'\x546', '\x548', '\a', '\x11A', '\x2', '\x2', '\x547', '\x549', '\x5', 
		'\x86', '\x44', '\x2', '\x548', '\x547', '\x3', '\x2', '\x2', '\x2', '\x548', 
		'\x549', '\x3', '\x2', '\x2', '\x2', '\x549', '\x568', '\x3', '\x2', '\x2', 
		'\x2', '\x54A', '\x54B', '\a', '\x15', '\x2', '\x2', '\x54B', '\x54D', 
		'\a', '\x11A', '\x2', '\x2', '\x54C', '\x54E', '\x5', '\x86', '\x44', 
		'\x2', '\x54D', '\x54C', '\x3', '\x2', '\x2', '\x2', '\x54D', '\x54E', 
		'\x3', '\x2', '\x2', '\x2', '\x54E', '\x568', '\x3', '\x2', '\x2', '\x2', 
		'\x54F', '\x551', '\a', '\x19', '\x2', '\x2', '\x550', '\x552', '\x5', 
		'\x82', '\x42', '\x2', '\x551', '\x550', '\x3', '\x2', '\x2', '\x2', '\x551', 
		'\x552', '\x3', '\x2', '\x2', '\x2', '\x552', '\x554', '\x3', '\x2', '\x2', 
		'\x2', '\x553', '\x555', '\x5', '\x86', '\x44', '\x2', '\x554', '\x553', 
		'\x3', '\x2', '\x2', '\x2', '\x554', '\x555', '\x3', '\x2', '\x2', '\x2', 
		'\x555', '\x568', '\x3', '\x2', '\x2', '\x2', '\x556', '\x558', '\a', 
		'\x15', '\x2', '\x2', '\x557', '\x559', '\x5', '\x86', '\x44', '\x2', 
		'\x558', '\x557', '\x3', '\x2', '\x2', '\x2', '\x558', '\x559', '\x3', 
		'\x2', '\x2', '\x2', '\x559', '\x568', '\x3', '\x2', '\x2', '\x2', '\x55A', 
		'\x55C', '\a', '\x11A', '\x2', '\x2', '\x55B', '\x55D', '\x5', '\x82', 
		'\x42', '\x2', '\x55C', '\x55B', '\x3', '\x2', '\x2', '\x2', '\x55C', 
		'\x55D', '\x3', '\x2', '\x2', '\x2', '\x55D', '\x55F', '\x3', '\x2', '\x2', 
		'\x2', '\x55E', '\x560', '\x5', '\x86', '\x44', '\x2', '\x55F', '\x55E', 
		'\x3', '\x2', '\x2', '\x2', '\x55F', '\x560', '\x3', '\x2', '\x2', '\x2', 
		'\x560', '\x561', '\x3', '\x2', '\x2', '\x2', '\x561', '\x568', '\x5', 
		'\x84', '\x43', '\x2', '\x562', '\x563', '\a', '\x11A', '\x2', '\x2', 
		'\x563', '\x565', '\x5', '\x82', '\x42', '\x2', '\x564', '\x566', '\x5', 
		'\x86', '\x44', '\x2', '\x565', '\x564', '\x3', '\x2', '\x2', '\x2', '\x565', 
		'\x566', '\x3', '\x2', '\x2', '\x2', '\x566', '\x568', '\x3', '\x2', '\x2', 
		'\x2', '\x567', '\x545', '\x3', '\x2', '\x2', '\x2', '\x567', '\x54A', 
		'\x3', '\x2', '\x2', '\x2', '\x567', '\x54F', '\x3', '\x2', '\x2', '\x2', 
		'\x567', '\x556', '\x3', '\x2', '\x2', '\x2', '\x567', '\x55A', '\x3', 
		'\x2', '\x2', '\x2', '\x567', '\x562', '\x3', '\x2', '\x2', '\x2', '\x568', 
		'\x81', '\x3', '\x2', '\x2', '\x2', '\x569', '\x56C', '\a', '\a', '\x2', 
		'\x2', '\x56A', '\x56C', '\x5', '\x124', '\x93', '\x2', '\x56B', '\x569', 
		'\x3', '\x2', '\x2', '\x2', '\x56B', '\x56A', '\x3', '\x2', '\x2', '\x2', 
		'\x56C', '\x83', '\x3', '\x2', '\x2', '\x2', '\x56D', '\x56E', '\t', '\v', 
		'\x2', '\x2', '\x56E', '\x85', '\x3', '\x2', '\x2', '\x2', '\x56F', '\x570', 
		'\t', '\f', '\x2', '\x2', '\x570', '\x87', '\x3', '\x2', '\x2', '\x2', 
		'\x571', '\x575', '\x5', '\x8A', '\x46', '\x2', '\x572', '\x573', '\x5', 
		'\xA2', 'R', '\x2', '\x573', '\x574', '\x5', '\x8A', '\x46', '\x2', '\x574', 
		'\x576', '\x3', '\x2', '\x2', '\x2', '\x575', '\x572', '\x3', '\x2', '\x2', 
		'\x2', '\x576', '\x577', '\x3', '\x2', '\x2', '\x2', '\x577', '\x575', 
		'\x3', '\x2', '\x2', '\x2', '\x577', '\x578', '\x3', '\x2', '\x2', '\x2', 
		'\x578', '\x89', '\x3', '\x2', '\x2', '\x2', '\x579', '\x57A', '\a', '\xB0', 
		'\x2', '\x2', '\x57A', '\x57B', '\a', '\x14A', '\x2', '\x2', '\x57B', 
		'\x57C', '\x5', '\xBC', '_', '\x2', '\x57C', '\x57D', '\a', '\x109', '\x2', 
		'\x2', '\x57D', '\x58E', '\x3', '\x2', '\x2', '\x2', '\x57E', '\x580', 
		'\a', '\xB0', '\x2', '\x2', '\x57F', '\x581', '\x5', '\x130', '\x99', 
		'\x2', '\x580', '\x57F', '\x3', '\x2', '\x2', '\x2', '\x580', '\x581', 
		'\x3', '\x2', '\x2', '\x2', '\x581', '\x583', '\x3', '\x2', '\x2', '\x2', 
		'\x582', '\x584', '\x5', '\xAE', 'X', '\x2', '\x583', '\x582', '\x3', 
		'\x2', '\x2', '\x2', '\x583', '\x584', '\x3', '\x2', '\x2', '\x2', '\x584', 
		'\x586', '\x3', '\x2', '\x2', '\x2', '\x585', '\x587', '\x5', '\xA0', 
		'Q', '\x2', '\x586', '\x585', '\x3', '\x2', '\x2', '\x2', '\x586', '\x587', 
		'\x3', '\x2', '\x2', '\x2', '\x587', '\x58A', '\x3', '\x2', '\x2', '\x2', 
		'\x588', '\x589', '\a', '\x14A', '\x2', '\x2', '\x589', '\x58B', '\x5', 
		'\xBC', '_', '\x2', '\x58A', '\x588', '\x3', '\x2', '\x2', '\x2', '\x58A', 
		'\x58B', '\x3', '\x2', '\x2', '\x2', '\x58B', '\x58C', '\x3', '\x2', '\x2', 
		'\x2', '\x58C', '\x58E', '\a', '\x109', '\x2', '\x2', '\x58D', '\x579', 
		'\x3', '\x2', '\x2', '\x2', '\x58D', '\x57E', '\x3', '\x2', '\x2', '\x2', 
		'\x58E', '\x8B', '\x3', '\x2', '\x2', '\x2', '\x58F', '\x590', '\a', '\xB0', 
		'\x2', '\x2', '\x590', '\x591', '\a', '\x14A', '\x2', '\x2', '\x591', 
		'\x592', '\x5', '\xBC', '_', '\x2', '\x592', '\x593', '\a', '\x109', '\x2', 
		'\x2', '\x593', '\x5A0', '\x3', '\x2', '\x2', '\x2', '\x594', '\x596', 
		'\a', '\xB0', '\x2', '\x2', '\x595', '\x597', '\x5', '\x130', '\x99', 
		'\x2', '\x596', '\x595', '\x3', '\x2', '\x2', '\x2', '\x596', '\x597', 
		'\x3', '\x2', '\x2', '\x2', '\x597', '\x599', '\x3', '\x2', '\x2', '\x2', 
		'\x598', '\x59A', '\x5', '\xB8', ']', '\x2', '\x599', '\x598', '\x3', 
		'\x2', '\x2', '\x2', '\x599', '\x59A', '\x3', '\x2', '\x2', '\x2', '\x59A', 
		'\x59C', '\x3', '\x2', '\x2', '\x2', '\x59B', '\x59D', '\x5', '\x2EC', 
		'\x177', '\x2', '\x59C', '\x59B', '\x3', '\x2', '\x2', '\x2', '\x59C', 
		'\x59D', '\x3', '\x2', '\x2', '\x2', '\x59D', '\x59E', '\x3', '\x2', '\x2', 
		'\x2', '\x59E', '\x5A0', '\a', '\x109', '\x2', '\x2', '\x59F', '\x58F', 
		'\x3', '\x2', '\x2', '\x2', '\x59F', '\x594', '\x3', '\x2', '\x2', '\x2', 
		'\x5A0', '\x8D', '\x3', '\x2', '\x2', '\x2', '\x5A1', '\x5A2', '\a', '\xB0', 
		'\x2', '\x2', '\x5A2', '\x5A5', '\x5', 't', ';', '\x2', '\x5A3', '\x5A4', 
		'\a', '\x14A', '\x2', '\x2', '\x5A4', '\x5A6', '\x5', '\xBC', '_', '\x2', 
		'\x5A5', '\x5A3', '\x3', '\x2', '\x2', '\x2', '\x5A5', '\x5A6', '\x3', 
		'\x2', '\x2', '\x2', '\x5A6', '\x5A7', '\x3', '\x2', '\x2', '\x2', '\x5A7', 
		'\x5A9', '\a', '\x109', '\x2', '\x2', '\x5A8', '\x5AA', '\x5', 'x', '=', 
		'\x2', '\x5A9', '\x5A8', '\x3', '\x2', '\x2', '\x2', '\x5A9', '\x5AA', 
		'\x3', '\x2', '\x2', '\x2', '\x5AA', '\x8F', '\x3', '\x2', '\x2', '\x2', 
		'\x5AB', '\x5AE', '\x5', '\x9A', 'N', '\x2', '\x5AC', '\x5AE', '\x5', 
		'\x98', 'M', '\x2', '\x5AD', '\x5AB', '\x3', '\x2', '\x2', '\x2', '\x5AD', 
		'\x5AC', '\x3', '\x2', '\x2', '\x2', '\x5AE', '\x5AF', '\x3', '\x2', '\x2', 
		'\x2', '\x5AF', '\x5AD', '\x3', '\x2', '\x2', '\x2', '\x5AF', '\x5B0', 
		'\x3', '\x2', '\x2', '\x2', '\x5B0', '\x91', '\x3', '\x2', '\x2', '\x2', 
		'\x5B1', '\x5B4', '\a', '\x9E', '\x2', '\x2', '\x5B2', '\x5B5', '\x5', 
		'\x2F4', '\x17B', '\x2', '\x5B3', '\x5B5', '\x5', '\x94', 'K', '\x2', 
		'\x5B4', '\x5B2', '\x3', '\x2', '\x2', '\x2', '\x5B4', '\x5B3', '\x3', 
		'\x2', '\x2', '\x2', '\x5B5', '\x5BA', '\x3', '\x2', '\x2', '\x2', '\x5B6', 
		'\x5B9', '\x5', '\x9A', 'N', '\x2', '\x5B7', '\x5B9', '\x5', '\x98', 'M', 
		'\x2', '\x5B8', '\x5B6', '\x3', '\x2', '\x2', '\x2', '\x5B8', '\x5B7', 
		'\x3', '\x2', '\x2', '\x2', '\x5B9', '\x5BC', '\x3', '\x2', '\x2', '\x2', 
		'\x5BA', '\x5B8', '\x3', '\x2', '\x2', '\x2', '\x5BA', '\x5BB', '\x3', 
		'\x2', '\x2', '\x2', '\x5BB', '\x93', '\x3', '\x2', '\x2', '\x2', '\x5BC', 
		'\x5BA', '\x3', '\x2', '\x2', '\x2', '\x5BD', '\x5BE', '\a', 'S', '\x2', 
		'\x2', '\x5BE', '\x5BF', '\a', '\xB0', '\x2', '\x2', '\x5BF', '\x5C0', 
		'\x5', '\xBC', '_', '\x2', '\x5C0', '\x5C1', '\a', '\x109', '\x2', '\x2', 
		'\x5C1', '\x95', '\x3', '\x2', '\x2', '\x2', '\x5C2', '\x5C4', '\a', 'S', 
		'\x2', '\x2', '\x5C3', '\x5C5', '\t', '\r', '\x2', '\x2', '\x5C4', '\x5C3', 
		'\x3', '\x2', '\x2', '\x2', '\x5C4', '\x5C5', '\x3', '\x2', '\x2', '\x2', 
		'\x5C5', '\x5C6', '\x3', '\x2', '\x2', '\x2', '\x5C6', '\x5C7', '\a', 
		'\xB0', '\x2', '\x2', '\x5C7', '\x5C8', '\x5', '\xBC', '_', '\x2', '\x5C8', 
		'\x5C9', '\a', '\x109', '\x2', '\x2', '\x5C9', '\x97', '\x3', '\x2', '\x2', 
		'\x2', '\x5CA', '\x5CB', '\a', '\x30', '\x2', '\x2', '\x5CB', '\x5CC', 
		'\x5', '\x94', 'K', '\x2', '\x5CC', '\x99', '\x3', '\x2', '\x2', '\x2', 
		'\x5CD', '\x5CE', '\a', '\x30', '\x2', '\x2', '\x5CE', '\x5CF', '\x5', 
		'\x2F4', '\x17B', '\x2', '\x5CF', '\x9B', '\x3', '\x2', '\x2', '\x2', 
		'\x5D0', '\x5D1', '\a', '\x30', '\x2', '\x2', '\x5D1', '\x5D2', '\x5', 
		'\x2F4', '\x17B', '\x2', '\x5D2', '\x9D', '\x3', '\x2', '\x2', '\x2', 
		'\x5D3', '\x5D4', '\a', '\x30', '\x2', '\x2', '\x5D4', '\x5D5', '\x5', 
		'\x2F4', '\x17B', '\x2', '\x5D5', '\x9F', '\x3', '\x2', '\x2', '\x2', 
		'\x5D6', '\x5D9', '\x5', '\x2EC', '\x177', '\x2', '\x5D7', '\x5D9', '\x5', 
		'\x124', '\x93', '\x2', '\x5D8', '\x5D6', '\x3', '\x2', '\x2', '\x2', 
		'\x5D8', '\x5D7', '\x3', '\x2', '\x2', '\x2', '\x5D9', '\xA1', '\x3', 
		'\x2', '\x2', '\x2', '\x5DA', '\x5DC', '\x5', '\xA6', 'T', '\x2', '\x5DB', 
		'\x5DA', '\x3', '\x2', '\x2', '\x2', '\x5DB', '\x5DC', '\x3', '\x2', '\x2', 
		'\x2', '\x5DC', '\x5DD', '\x3', '\x2', '\x2', '\x2', '\x5DD', '\x5F5', 
		'\x5', '\xA8', 'U', '\x2', '\x5DE', '\x5DF', '\a', '\xA6', '\x2', '\x2', 
		'\x5DF', '\x5E0', '\a', '\x14A', '\x2', '\x2', '\x5E0', '\x5E1', '\x5', 
		'\xBC', '_', '\x2', '\x5E1', '\x5E2', '\a', '\xEF', '\x2', '\x2', '\x5E2', 
		'\x5F6', '\x3', '\x2', '\x2', '\x2', '\x5E3', '\x5E5', '\a', '\xA6', '\x2', 
		'\x2', '\x5E4', '\x5E6', '\x5', '\x130', '\x99', '\x2', '\x5E5', '\x5E4', 
		'\x3', '\x2', '\x2', '\x2', '\x5E5', '\x5E6', '\x3', '\x2', '\x2', '\x2', 
		'\x5E6', '\x5E8', '\x3', '\x2', '\x2', '\x2', '\x5E7', '\x5E9', '\x5', 
		'\xAE', 'X', '\x2', '\x5E8', '\x5E7', '\x3', '\x2', '\x2', '\x2', '\x5E8', 
		'\x5E9', '\x3', '\x2', '\x2', '\x2', '\x5E9', '\x5EB', '\x3', '\x2', '\x2', 
		'\x2', '\x5EA', '\x5EC', '\x5', '\xAC', 'W', '\x2', '\x5EB', '\x5EA', 
		'\x3', '\x2', '\x2', '\x2', '\x5EB', '\x5EC', '\x3', '\x2', '\x2', '\x2', 
		'\x5EC', '\x5EE', '\x3', '\x2', '\x2', '\x2', '\x5ED', '\x5EF', '\x5', 
		'\xA0', 'Q', '\x2', '\x5EE', '\x5ED', '\x3', '\x2', '\x2', '\x2', '\x5EE', 
		'\x5EF', '\x3', '\x2', '\x2', '\x2', '\x5EF', '\x5F2', '\x3', '\x2', '\x2', 
		'\x2', '\x5F0', '\x5F1', '\a', '\x14A', '\x2', '\x2', '\x5F1', '\x5F3', 
		'\x5', '\xBC', '_', '\x2', '\x5F2', '\x5F0', '\x3', '\x2', '\x2', '\x2', 
		'\x5F2', '\x5F3', '\x3', '\x2', '\x2', '\x2', '\x5F3', '\x5F4', '\x3', 
		'\x2', '\x2', '\x2', '\x5F4', '\x5F6', '\a', '\xEF', '\x2', '\x2', '\x5F5', 
		'\x5DE', '\x3', '\x2', '\x2', '\x2', '\x5F5', '\x5E3', '\x3', '\x2', '\x2', 
		'\x2', '\x5F5', '\x5F6', '\x3', '\x2', '\x2', '\x2', '\x5F6', '\x5F7', 
		'\x3', '\x2', '\x2', '\x2', '\x5F7', '\x5F9', '\x5', '\xA8', 'U', '\x2', 
		'\x5F8', '\x5FA', '\x5', '\xAA', 'V', '\x2', '\x5F9', '\x5F8', '\x3', 
		'\x2', '\x2', '\x2', '\x5F9', '\x5FA', '\x3', '\x2', '\x2', '\x2', '\x5FA', 
		'\xA3', '\x3', '\x2', '\x2', '\x2', '\x5FB', '\x5FD', '\x5', '\xA6', 'T', 
		'\x2', '\x5FC', '\x5FB', '\x3', '\x2', '\x2', '\x2', '\x5FC', '\x5FD', 
		'\x3', '\x2', '\x2', '\x2', '\x5FD', '\x5FE', '\x3', '\x2', '\x2', '\x2', 
		'\x5FE', '\x60E', '\x5', '\xA8', 'U', '\x2', '\x5FF', '\x600', '\a', '\xA6', 
		'\x2', '\x2', '\x600', '\x601', '\a', '\x14A', '\x2', '\x2', '\x601', 
		'\x602', '\x5', '\xBC', '_', '\x2', '\x602', '\x603', '\a', '\xEF', '\x2', 
		'\x2', '\x603', '\x60F', '\x3', '\x2', '\x2', '\x2', '\x604', '\x606', 
		'\a', '\xA6', '\x2', '\x2', '\x605', '\x607', '\x5', '\x130', '\x99', 
		'\x2', '\x606', '\x605', '\x3', '\x2', '\x2', '\x2', '\x606', '\x607', 
		'\x3', '\x2', '\x2', '\x2', '\x607', '\x608', '\x3', '\x2', '\x2', '\x2', 
		'\x608', '\x60A', '\x5', '\xBA', '^', '\x2', '\x609', '\x60B', '\x5', 
		'\x2EC', '\x177', '\x2', '\x60A', '\x609', '\x3', '\x2', '\x2', '\x2', 
		'\x60A', '\x60B', '\x3', '\x2', '\x2', '\x2', '\x60B', '\x60C', '\x3', 
		'\x2', '\x2', '\x2', '\x60C', '\x60D', '\a', '\xEF', '\x2', '\x2', '\x60D', 
		'\x60F', '\x3', '\x2', '\x2', '\x2', '\x60E', '\x5FF', '\x3', '\x2', '\x2', 
		'\x2', '\x60E', '\x604', '\x3', '\x2', '\x2', '\x2', '\x60F', '\x610', 
		'\x3', '\x2', '\x2', '\x2', '\x610', '\x612', '\x5', '\xA8', 'U', '\x2', 
		'\x611', '\x613', '\x5', '\xAA', 'V', '\x2', '\x612', '\x611', '\x3', 
		'\x2', '\x2', '\x2', '\x612', '\x613', '\x3', '\x2', '\x2', '\x2', '\x613', 
		'\xA5', '\x3', '\x2', '\x2', '\x2', '\x614', '\x615', '\t', '\xE', '\x2', 
		'\x2', '\x615', '\xA7', '\x3', '\x2', '\x2', '\x2', '\x616', '\x617', 
		'\t', '\xF', '\x2', '\x2', '\x617', '\xA9', '\x3', '\x2', '\x2', '\x2', 
		'\x618', '\x619', '\t', '\x10', '\x2', '\x2', '\x619', '\xAB', '\x3', 
		'\x2', '\x2', '\x2', '\x61A', '\x623', '\a', '\x12B', '\x2', '\x2', '\x61B', 
		'\x61D', '\a', '\a', '\x2', '\x2', '\x61C', '\x61B', '\x3', '\x2', '\x2', 
		'\x2', '\x61C', '\x61D', '\x3', '\x2', '\x2', '\x2', '\x61D', '\x61E', 
		'\x3', '\x2', '\x2', '\x2', '\x61E', '\x620', '\a', 'X', '\x2', '\x2', 
		'\x61F', '\x621', '\a', '\a', '\x2', '\x2', '\x620', '\x61F', '\x3', '\x2', 
		'\x2', '\x2', '\x620', '\x621', '\x3', '\x2', '\x2', '\x2', '\x621', '\x624', 
		'\x3', '\x2', '\x2', '\x2', '\x622', '\x624', '\a', '\a', '\x2', '\x2', 
		'\x623', '\x61C', '\x3', '\x2', '\x2', '\x2', '\x623', '\x622', '\x3', 
		'\x2', '\x2', '\x2', '\x623', '\x624', '\x3', '\x2', '\x2', '\x2', '\x624', 
		'\xAD', '\x3', '\x2', '\x2', '\x2', '\x625', '\x626', '\t', '\x11', '\x2', 
		'\x2', '\x626', '\x627', '\x5', '\xB0', 'Y', '\x2', '\x627', '\xAF', '\x3', 
		'\x2', '\x2', '\x2', '\x628', '\x630', '\x5', '\xB2', 'Z', '\x2', '\x629', 
		'\x62B', '\a', '!', '\x2', '\x2', '\x62A', '\x62C', '\a', '\x30', '\x2', 
		'\x2', '\x62B', '\x62A', '\x3', '\x2', '\x2', '\x2', '\x62B', '\x62C', 
		'\x3', '\x2', '\x2', '\x2', '\x62C', '\x62D', '\x3', '\x2', '\x2', '\x2', 
		'\x62D', '\x62F', '\x5', '\xB2', 'Z', '\x2', '\x62E', '\x629', '\x3', 
		'\x2', '\x2', '\x2', '\x62F', '\x632', '\x3', '\x2', '\x2', '\x2', '\x630', 
		'\x62E', '\x3', '\x2', '\x2', '\x2', '\x630', '\x631', '\x3', '\x2', '\x2', 
		'\x2', '\x631', '\xB1', '\x3', '\x2', '\x2', '\x2', '\x632', '\x630', 
		'\x3', '\x2', '\x2', '\x2', '\x633', '\x638', '\x5', '\xB4', '[', '\x2', 
		'\x634', '\x635', '\t', '\x12', '\x2', '\x2', '\x635', '\x637', '\x5', 
		'\xB4', '[', '\x2', '\x636', '\x634', '\x3', '\x2', '\x2', '\x2', '\x637', 
		'\x63A', '\x3', '\x2', '\x2', '\x2', '\x638', '\x636', '\x3', '\x2', '\x2', 
		'\x2', '\x638', '\x639', '\x3', '\x2', '\x2', '\x2', '\x639', '\xB3', 
		'\x3', '\x2', '\x2', '\x2', '\x63A', '\x638', '\x3', '\x2', '\x2', '\x2', 
		'\x63B', '\x63D', '\a', '\xA4', '\x2', '\x2', '\x63C', '\x63B', '\x3', 
		'\x2', '\x2', '\x2', '\x63D', '\x640', '\x3', '\x2', '\x2', '\x2', '\x63E', 
		'\x63C', '\x3', '\x2', '\x2', '\x2', '\x63E', '\x63F', '\x3', '\x2', '\x2', 
		'\x2', '\x63F', '\x641', '\x3', '\x2', '\x2', '\x2', '\x640', '\x63E', 
		'\x3', '\x2', '\x2', '\x2', '\x641', '\x642', '\x5', '\xB6', '\\', '\x2', 
		'\x642', '\xB5', '\x3', '\x2', '\x2', '\x2', '\x643', '\x644', '\a', '\xB0', 
		'\x2', '\x2', '\x644', '\x645', '\x5', '\xB0', 'Y', '\x2', '\x645', '\x646', 
		'\a', '\x109', '\x2', '\x2', '\x646', '\x64B', '\x3', '\x2', '\x2', '\x2', 
		'\x647', '\x64B', '\a', '\xB8', '\x2', '\x2', '\x648', '\x64B', '\x5', 
		'\x96', 'L', '\x2', '\x649', '\x64B', '\x5', '\x2F4', '\x17B', '\x2', 
		'\x64A', '\x643', '\x3', '\x2', '\x2', '\x2', '\x64A', '\x647', '\x3', 
		'\x2', '\x2', '\x2', '\x64A', '\x648', '\x3', '\x2', '\x2', '\x2', '\x64A', 
		'\x649', '\x3', '\x2', '\x2', '\x2', '\x64B', '\xB7', '\x3', '\x2', '\x2', 
		'\x2', '\x64C', '\x64D', '\t', '\x11', '\x2', '\x2', '\x64D', '\x652', 
		'\x5', '\x2F4', '\x17B', '\x2', '\x64E', '\x64F', '\t', '\x12', '\x2', 
		'\x2', '\x64F', '\x651', '\x5', '\x2F4', '\x17B', '\x2', '\x650', '\x64E', 
		'\x3', '\x2', '\x2', '\x2', '\x651', '\x654', '\x3', '\x2', '\x2', '\x2', 
		'\x652', '\x650', '\x3', '\x2', '\x2', '\x2', '\x652', '\x653', '\x3', 
		'\x2', '\x2', '\x2', '\x653', '\xB9', '\x3', '\x2', '\x2', '\x2', '\x654', 
		'\x652', '\x3', '\x2', '\x2', '\x2', '\x655', '\x656', '\t', '\x11', '\x2', 
		'\x2', '\x656', '\x657', '\x5', '\x2F4', '\x17B', '\x2', '\x657', '\xBB', 
		'\x3', '\x2', '\x2', '\x2', '\x658', '\x65D', '\x5', '\xBE', '`', '\x2', 
		'\x659', '\x65A', '\a', '\xD7', '\x2', '\x2', '\x65A', '\x65C', '\x5', 
		'\xBE', '`', '\x2', '\x65B', '\x659', '\x3', '\x2', '\x2', '\x2', '\x65C', 
		'\x65F', '\x3', '\x2', '\x2', '\x2', '\x65D', '\x65B', '\x3', '\x2', '\x2', 
		'\x2', '\x65D', '\x65E', '\x3', '\x2', '\x2', '\x2', '\x65E', '\xBD', 
		'\x3', '\x2', '\x2', '\x2', '\x65F', '\x65D', '\x3', '\x2', '\x2', '\x2', 
		'\x660', '\x665', '\x5', '\xC0', '\x61', '\x2', '\x661', '\x662', '\a', 
		'\x14E', '\x2', '\x2', '\x662', '\x664', '\x5', '\xC0', '\x61', '\x2', 
		'\x663', '\x661', '\x3', '\x2', '\x2', '\x2', '\x664', '\x667', '\x3', 
		'\x2', '\x2', '\x2', '\x665', '\x663', '\x3', '\x2', '\x2', '\x2', '\x665', 
		'\x666', '\x3', '\x2', '\x2', '\x2', '\x666', '\xBF', '\x3', '\x2', '\x2', 
		'\x2', '\x667', '\x665', '\x3', '\x2', '\x2', '\x2', '\x668', '\x66D', 
		'\x5', '\xC2', '\x62', '\x2', '\x669', '\x66A', '\a', '\x18', '\x2', '\x2', 
		'\x66A', '\x66C', '\x5', '\xC2', '\x62', '\x2', '\x66B', '\x669', '\x3', 
		'\x2', '\x2', '\x2', '\x66C', '\x66F', '\x3', '\x2', '\x2', '\x2', '\x66D', 
		'\x66B', '\x3', '\x2', '\x2', '\x2', '\x66D', '\x66E', '\x3', '\x2', '\x2', 
		'\x2', '\x66E', '\xC1', '\x3', '\x2', '\x2', '\x2', '\x66F', '\x66D', 
		'\x3', '\x2', '\x2', '\x2', '\x670', '\x672', '\a', '\xCB', '\x2', '\x2', 
		'\x671', '\x670', '\x3', '\x2', '\x2', '\x2', '\x672', '\x675', '\x3', 
		'\x2', '\x2', '\x2', '\x673', '\x671', '\x3', '\x2', '\x2', '\x2', '\x673', 
		'\x674', '\x3', '\x2', '\x2', '\x2', '\x674', '\x676', '\x3', '\x2', '\x2', 
		'\x2', '\x675', '\x673', '\x3', '\x2', '\x2', '\x2', '\x676', '\x677', 
		'\x5', '\xC4', '\x63', '\x2', '\x677', '\xC3', '\x3', '\x2', '\x2', '\x2', 
		'\x678', '\x67D', '\x5', '\xC6', '\x64', '\x2', '\x679', '\x67A', '\t', 
		'\x13', '\x2', '\x2', '\x67A', '\x67C', '\x5', '\xC6', '\x64', '\x2', 
		'\x67B', '\x679', '\x3', '\x2', '\x2', '\x2', '\x67C', '\x67F', '\x3', 
		'\x2', '\x2', '\x2', '\x67D', '\x67B', '\x3', '\x2', '\x2', '\x2', '\x67D', 
		'\x67E', '\x3', '\x2', '\x2', '\x2', '\x67E', '\xC5', '\x3', '\x2', '\x2', 
		'\x2', '\x67F', '\x67D', '\x3', '\x2', '\x2', '\x2', '\x680', '\x682', 
		'\x5', '\xCC', 'g', '\x2', '\x681', '\x683', '\x5', '\xC8', '\x65', '\x2', 
		'\x682', '\x681', '\x3', '\x2', '\x2', '\x2', '\x682', '\x683', '\x3', 
		'\x2', '\x2', '\x2', '\x683', '\xC7', '\x3', '\x2', '\x2', '\x2', '\x684', 
		'\x68C', '\a', '\xF5', '\x2', '\x2', '\x685', '\x686', '\a', '\x120', 
		'\x2', '\x2', '\x686', '\x68C', '\a', '\x14B', '\x2', '\x2', '\x687', 
		'\x688', '\a', 'i', '\x2', '\x2', '\x688', '\x68C', '\a', '\x14B', '\x2', 
		'\x2', '\x689', '\x68C', '\a', '\x39', '\x2', '\x2', '\x68A', '\x68C', 
		'\a', '\x8E', '\x2', '\x2', '\x68B', '\x684', '\x3', '\x2', '\x2', '\x2', 
		'\x68B', '\x685', '\x3', '\x2', '\x2', '\x2', '\x68B', '\x687', '\x3', 
		'\x2', '\x2', '\x2', '\x68B', '\x689', '\x3', '\x2', '\x2', '\x2', '\x68B', 
		'\x68A', '\x3', '\x2', '\x2', '\x2', '\x68C', '\x68D', '\x3', '\x2', '\x2', 
		'\x2', '\x68D', '\x6A6', '\x5', '\xCC', 'g', '\x2', '\x68E', '\x690', 
		'\a', '\x9E', '\x2', '\x2', '\x68F', '\x691', '\a', '\xCB', '\x2', '\x2', 
		'\x690', '\x68F', '\x3', '\x2', '\x2', '\x2', '\x690', '\x691', '\x3', 
		'\x2', '\x2', '\x2', '\x691', '\x692', '\x3', '\x2', '\x2', '\x2', '\x692', 
		'\x6A6', '\a', '\xCE', '\x2', '\x2', '\x693', '\x695', '\a', '\x9E', '\x2', 
		'\x2', '\x694', '\x696', '\a', '\xCB', '\x2', '\x2', '\x695', '\x694', 
		'\x3', '\x2', '\x2', '\x2', '\x695', '\x696', '\x3', '\x2', '\x2', '\x2', 
		'\x696', '\x697', '\x3', '\x2', '\x2', '\x2', '\x697', '\x69A', '\t', 
		'\x14', '\x2', '\x2', '\x698', '\x69A', '\a', '\x31', '\x2', '\x2', '\x699', 
		'\x693', '\x3', '\x2', '\x2', '\x2', '\x699', '\x698', '\x3', '\x2', '\x2', 
		'\x2', '\x69A', '\x69B', '\x3', '\x2', '\x2', '\x2', '\x69B', '\x6A6', 
		'\x5', '\x134', '\x9B', '\x2', '\x69C', '\x69E', '\a', '\x9E', '\x2', 
		'\x2', '\x69D', '\x69F', '\a', '\xCB', '\x2', '\x2', '\x69E', '\x69D', 
		'\x3', '\x2', '\x2', '\x2', '\x69E', '\x69F', '\x3', '\x2', '\x2', '\x2', 
		'\x69F', '\x6A1', '\x3', '\x2', '\x2', '\x2', '\x6A0', '\x6A2', '\x5', 
		'\xCA', '\x66', '\x2', '\x6A1', '\x6A0', '\x3', '\x2', '\x2', '\x2', '\x6A1', 
		'\x6A2', '\x3', '\x2', '\x2', '\x2', '\x6A2', '\x6A3', '\x3', '\x2', '\x2', 
		'\x2', '\x6A3', '\x6A6', '\a', '\xCA', '\x2', '\x2', '\x6A4', '\x6A6', 
		'\x5', '\xAE', 'X', '\x2', '\x6A5', '\x68B', '\x3', '\x2', '\x2', '\x2', 
		'\x6A5', '\x68E', '\x3', '\x2', '\x2', '\x2', '\x6A5', '\x699', '\x3', 
		'\x2', '\x2', '\x2', '\x6A5', '\x69C', '\x3', '\x2', '\x2', '\x2', '\x6A5', 
		'\x6A4', '\x3', '\x2', '\x2', '\x2', '\x6A6', '\xC9', '\x3', '\x2', '\x2', 
		'\x2', '\x6A7', '\x6A8', '\t', '\x15', '\x2', '\x2', '\x6A8', '\xCB', 
		'\x3', '\x2', '\x2', '\x2', '\x6A9', '\x6AE', '\x5', '\xCE', 'h', '\x2', 
		'\x6AA', '\x6AB', '\t', '\x16', '\x2', '\x2', '\x6AB', '\x6AD', '\x5', 
		'\xCE', 'h', '\x2', '\x6AC', '\x6AA', '\x3', '\x2', '\x2', '\x2', '\x6AD', 
		'\x6B0', '\x3', '\x2', '\x2', '\x2', '\x6AE', '\x6AC', '\x3', '\x2', '\x2', 
		'\x2', '\x6AE', '\x6AF', '\x3', '\x2', '\x2', '\x2', '\x6AF', '\xCD', 
		'\x3', '\x2', '\x2', '\x2', '\x6B0', '\x6AE', '\x3', '\x2', '\x2', '\x2', 
		'\x6B1', '\x6B6', '\x5', '\xD0', 'i', '\x2', '\x6B2', '\x6B3', '\t', '\x17', 
		'\x2', '\x2', '\x6B3', '\x6B5', '\x5', '\xD0', 'i', '\x2', '\x6B4', '\x6B2', 
		'\x3', '\x2', '\x2', '\x2', '\x6B5', '\x6B8', '\x3', '\x2', '\x2', '\x2', 
		'\x6B6', '\x6B4', '\x3', '\x2', '\x2', '\x2', '\x6B6', '\x6B7', '\x3', 
		'\x2', '\x2', '\x2', '\x6B7', '\xCF', '\x3', '\x2', '\x2', '\x2', '\x6B8', 
		'\x6B6', '\x3', '\x2', '\x2', '\x2', '\x6B9', '\x6BE', '\x5', '\xD2', 
		'j', '\x2', '\x6BA', '\x6BB', '\a', '\xE2', '\x2', '\x2', '\x6BB', '\x6BD', 
		'\x5', '\xD2', 'j', '\x2', '\x6BC', '\x6BA', '\x3', '\x2', '\x2', '\x2', 
		'\x6BD', '\x6C0', '\x3', '\x2', '\x2', '\x2', '\x6BE', '\x6BC', '\x3', 
		'\x2', '\x2', '\x2', '\x6BE', '\x6BF', '\x3', '\x2', '\x2', '\x2', '\x6BF', 
		'\xD1', '\x3', '\x2', '\x2', '\x2', '\x6C0', '\x6BE', '\x3', '\x2', '\x2', 
		'\x2', '\x6C1', '\x6C5', '\x5', '\xD4', 'k', '\x2', '\x6C2', '\x6C3', 
		'\t', '\x18', '\x2', '\x2', '\x6C3', '\x6C5', '\x5', '\xD4', 'k', '\x2', 
		'\x6C4', '\x6C1', '\x3', '\x2', '\x2', '\x2', '\x6C4', '\x6C2', '\x3', 
		'\x2', '\x2', '\x2', '\x6C5', '\xD3', '\x3', '\x2', '\x2', '\x2', '\x6C6', 
		'\x6CA', '\x5', '\xE0', 'q', '\x2', '\x6C7', '\x6C9', '\x5', '\xD6', 'l', 
		'\x2', '\x6C8', '\x6C7', '\x3', '\x2', '\x2', '\x2', '\x6C9', '\x6CC', 
		'\x3', '\x2', '\x2', '\x2', '\x6CA', '\x6C8', '\x3', '\x2', '\x2', '\x2', 
		'\x6CA', '\x6CB', '\x3', '\x2', '\x2', '\x2', '\x6CB', '\xD5', '\x3', 
		'\x2', '\x2', '\x2', '\x6CC', '\x6CA', '\x3', '\x2', '\x2', '\x2', '\x6CD', 
		'\x6DC', '\x5', '\xD8', 'm', '\x2', '\x6CE', '\x6CF', '\a', '\xA6', '\x2', 
		'\x2', '\x6CF', '\x6D0', '\x5', '\xBC', '_', '\x2', '\x6D0', '\x6D1', 
		'\a', '\xEF', '\x2', '\x2', '\x6D1', '\x6DC', '\x3', '\x2', '\x2', '\x2', 
		'\x6D2', '\x6D4', '\a', '\xA6', '\x2', '\x2', '\x6D3', '\x6D5', '\x5', 
		'\xBC', '_', '\x2', '\x6D4', '\x6D3', '\x3', '\x2', '\x2', '\x2', '\x6D4', 
		'\x6D5', '\x3', '\x2', '\x2', '\x2', '\x6D5', '\x6D6', '\x3', '\x2', '\x2', 
		'\x2', '\x6D6', '\x6D8', '\a', 'X', '\x2', '\x2', '\x6D7', '\x6D9', '\x5', 
		'\xBC', '_', '\x2', '\x6D8', '\x6D7', '\x3', '\x2', '\x2', '\x2', '\x6D8', 
		'\x6D9', '\x3', '\x2', '\x2', '\x2', '\x6D9', '\x6DA', '\x3', '\x2', '\x2', 
		'\x2', '\x6DA', '\x6DC', '\a', '\xEF', '\x2', '\x2', '\x6DB', '\x6CD', 
		'\x3', '\x2', '\x2', '\x2', '\x6DB', '\x6CE', '\x3', '\x2', '\x2', '\x2', 
		'\x6DB', '\x6D2', '\x3', '\x2', '\x2', '\x2', '\x6DC', '\xD7', '\x3', 
		'\x2', '\x2', '\x2', '\x6DD', '\x6DE', '\a', 'V', '\x2', '\x2', '\x6DE', 
		'\x6DF', '\x5', '\x122', '\x92', '\x2', '\x6DF', '\xD9', '\x3', '\x2', 
		'\x2', '\x2', '\x6E0', '\x6E1', '\a', '\xA6', '\x2', '\x2', '\x6E1', '\x6E2', 
		'\x5', '\xBC', '_', '\x2', '\x6E2', '\x6E3', '\a', '\xEF', '\x2', '\x2', 
		'\x6E3', '\xDB', '\x3', '\x2', '\x2', '\x2', '\x6E4', '\x6E6', '\x5', 
		'\xE0', 'q', '\x2', '\x6E5', '\x6E7', '\x5', '\xD8', 'm', '\x2', '\x6E6', 
		'\x6E5', '\x3', '\x2', '\x2', '\x2', '\x6E7', '\x6E8', '\x3', '\x2', '\x2', 
		'\x2', '\x6E8', '\x6E6', '\x3', '\x2', '\x2', '\x2', '\x6E8', '\x6E9', 
		'\x3', '\x2', '\x2', '\x2', '\x6E9', '\xDD', '\x3', '\x2', '\x2', '\x2', 
		'\x6EA', '\x6EB', '\x5', '\xE0', 'q', '\x2', '\x6EB', '\x6EC', '\x5', 
		'\xDA', 'n', '\x2', '\x6EC', '\xDF', '\x3', '\x2', '\x2', '\x2', '\x6ED', 
		'\x707', '\x5', '\xE2', 'r', '\x2', '\x6EE', '\x707', '\x5', '\x124', 
		'\x93', '\x2', '\x6EF', '\x707', '\x5', '\xE4', 's', '\x2', '\x6F0', '\x707', 
		'\x5', '\xE8', 'u', '\x2', '\x6F1', '\x707', '\x5', '\x114', '\x8B', '\x2', 
		'\x6F2', '\x707', '\x5', '\x116', '\x8C', '\x2', '\x6F3', '\x707', '\x5', 
		'\x118', '\x8D', '\x2', '\x6F4', '\x707', '\x5', '\x11A', '\x8E', '\x2', 
		'\x6F5', '\x707', '\x5', '\x110', '\x89', '\x2', '\x6F6', '\x707', '\x5', 
		'\xEE', 'x', '\x2', '\x6F7', '\x707', '\x5', '\x120', '\x91', '\x2', '\x6F8', 
		'\x707', '\x5', '\xF0', 'y', '\x2', '\x6F9', '\x707', '\x5', '\xF2', 'z', 
		'\x2', '\x6FA', '\x707', '\x5', '\xF4', '{', '\x2', '\x6FB', '\x707', 
		'\x5', '\xFA', '~', '\x2', '\x6FC', '\x707', '\x5', '\xFC', '\x7F', '\x2', 
		'\x6FD', '\x707', '\x5', '\xFE', '\x80', '\x2', '\x6FE', '\x707', '\x5', 
		'\x100', '\x81', '\x2', '\x6FF', '\x707', '\x5', '\x102', '\x82', '\x2', 
		'\x700', '\x707', '\x5', '\x108', '\x85', '\x2', '\x701', '\x707', '\x5', 
		'\x10A', '\x86', '\x2', '\x702', '\x707', '\x5', '\x10C', '\x87', '\x2', 
		'\x703', '\x707', '\x5', '\x10E', '\x88', '\x2', '\x704', '\x707', '\x5', 
		'\x128', '\x95', '\x2', '\x705', '\x707', '\x5', '\x130', '\x99', '\x2', 
		'\x706', '\x6ED', '\x3', '\x2', '\x2', '\x2', '\x706', '\x6EE', '\x3', 
		'\x2', '\x2', '\x2', '\x706', '\x6EF', '\x3', '\x2', '\x2', '\x2', '\x706', 
		'\x6F0', '\x3', '\x2', '\x2', '\x2', '\x706', '\x6F1', '\x3', '\x2', '\x2', 
		'\x2', '\x706', '\x6F2', '\x3', '\x2', '\x2', '\x2', '\x706', '\x6F3', 
		'\x3', '\x2', '\x2', '\x2', '\x706', '\x6F4', '\x3', '\x2', '\x2', '\x2', 
		'\x706', '\x6F5', '\x3', '\x2', '\x2', '\x2', '\x706', '\x6F6', '\x3', 
		'\x2', '\x2', '\x2', '\x706', '\x6F7', '\x3', '\x2', '\x2', '\x2', '\x706', 
		'\x6F8', '\x3', '\x2', '\x2', '\x2', '\x706', '\x6F9', '\x3', '\x2', '\x2', 
		'\x2', '\x706', '\x6FA', '\x3', '\x2', '\x2', '\x2', '\x706', '\x6FB', 
		'\x3', '\x2', '\x2', '\x2', '\x706', '\x6FC', '\x3', '\x2', '\x2', '\x2', 
		'\x706', '\x6FD', '\x3', '\x2', '\x2', '\x2', '\x706', '\x6FE', '\x3', 
		'\x2', '\x2', '\x2', '\x706', '\x6FF', '\x3', '\x2', '\x2', '\x2', '\x706', 
		'\x700', '\x3', '\x2', '\x2', '\x2', '\x706', '\x701', '\x3', '\x2', '\x2', 
		'\x2', '\x706', '\x702', '\x3', '\x2', '\x2', '\x2', '\x706', '\x703', 
		'\x3', '\x2', '\x2', '\x2', '\x706', '\x704', '\x3', '\x2', '\x2', '\x2', 
		'\x706', '\x705', '\x3', '\x2', '\x2', '\x2', '\x707', '\xE1', '\x3', 
		'\x2', '\x2', '\x2', '\x708', '\x712', '\x5', '\x11C', '\x8F', '\x2', 
		'\x709', '\x712', '\x5', '\x2E2', '\x172', '\x2', '\x70A', '\x712', '\x5', 
		'\x2EC', '\x177', '\x2', '\x70B', '\x712', '\a', '\x135', '\x2', '\x2', 
		'\x70C', '\x712', '\a', 'r', '\x2', '\x2', '\x70D', '\x712', '\a', '\x91', 
		'\x2', '\x2', '\x70E', '\x712', '\a', '\x92', '\x2', '\x2', '\x70F', '\x712', 
		'\a', '\xBE', '\x2', '\x2', '\x710', '\x712', '\a', '\xCE', '\x2', '\x2', 
		'\x711', '\x708', '\x3', '\x2', '\x2', '\x2', '\x711', '\x709', '\x3', 
		'\x2', '\x2', '\x2', '\x711', '\x70A', '\x3', '\x2', '\x2', '\x2', '\x711', 
		'\x70B', '\x3', '\x2', '\x2', '\x2', '\x711', '\x70C', '\x3', '\x2', '\x2', 
		'\x2', '\x711', '\x70D', '\x3', '\x2', '\x2', '\x2', '\x711', '\x70E', 
		'\x3', '\x2', '\x2', '\x2', '\x711', '\x70F', '\x3', '\x2', '\x2', '\x2', 
		'\x711', '\x710', '\x3', '\x2', '\x2', '\x2', '\x712', '\xE3', '\x3', 
		'\x2', '\x2', '\x2', '\x713', '\x715', '\a', ',', '\x2', '\x2', '\x714', 
		'\x716', '\x5', '\xE6', 't', '\x2', '\x715', '\x714', '\x3', '\x2', '\x2', 
		'\x2', '\x716', '\x717', '\x3', '\x2', '\x2', '\x2', '\x717', '\x715', 
		'\x3', '\x2', '\x2', '\x2', '\x717', '\x718', '\x3', '\x2', '\x2', '\x2', 
		'\x718', '\x71B', '\x3', '\x2', '\x2', '\x2', '\x719', '\x71A', '\a', 
		'\x64', '\x2', '\x2', '\x71A', '\x71C', '\x5', '\xBC', '_', '\x2', '\x71B', 
		'\x719', '\x3', '\x2', '\x2', '\x2', '\x71B', '\x71C', '\x3', '\x2', '\x2', 
		'\x2', '\x71C', '\x71D', '\x3', '\x2', '\x2', '\x2', '\x71D', '\x71E', 
		'\a', 'h', '\x2', '\x2', '\x71E', '\xE5', '\x3', '\x2', '\x2', '\x2', 
		'\x71F', '\x720', '\a', '\x149', '\x2', '\x2', '\x720', '\x721', '\x5', 
		'\xBC', '_', '\x2', '\x721', '\x722', '\a', '\x129', '\x2', '\x2', '\x722', 
		'\x723', '\x5', '\xBC', '_', '\x2', '\x723', '\xE7', '\x3', '\x2', '\x2', 
		'\x2', '\x724', '\x725', '\a', ',', '\x2', '\x2', '\x725', '\x727', '\x5', 
		'\xBC', '_', '\x2', '\x726', '\x728', '\x5', '\xEA', 'v', '\x2', '\x727', 
		'\x726', '\x3', '\x2', '\x2', '\x2', '\x728', '\x729', '\x3', '\x2', '\x2', 
		'\x2', '\x729', '\x727', '\x3', '\x2', '\x2', '\x2', '\x729', '\x72A', 
		'\x3', '\x2', '\x2', '\x2', '\x72A', '\x72D', '\x3', '\x2', '\x2', '\x2', 
		'\x72B', '\x72C', '\a', '\x64', '\x2', '\x2', '\x72C', '\x72E', '\x5', 
		'\xBC', '_', '\x2', '\x72D', '\x72B', '\x3', '\x2', '\x2', '\x2', '\x72D', 
		'\x72E', '\x3', '\x2', '\x2', '\x2', '\x72E', '\x72F', '\x3', '\x2', '\x2', 
		'\x2', '\x72F', '\x730', '\a', 'h', '\x2', '\x2', '\x730', '\xE9', '\x3', 
		'\x2', '\x2', '\x2', '\x731', '\x732', '\a', '\x149', '\x2', '\x2', '\x732', 
		'\x737', '\x5', '\xEC', 'w', '\x2', '\x733', '\x734', '\a', '\x32', '\x2', 
		'\x2', '\x734', '\x736', '\x5', '\xEC', 'w', '\x2', '\x735', '\x733', 
		'\x3', '\x2', '\x2', '\x2', '\x736', '\x739', '\x3', '\x2', '\x2', '\x2', 
		'\x737', '\x735', '\x3', '\x2', '\x2', '\x2', '\x737', '\x738', '\x3', 
		'\x2', '\x2', '\x2', '\x738', '\x73A', '\x3', '\x2', '\x2', '\x2', '\x739', 
		'\x737', '\x3', '\x2', '\x2', '\x2', '\x73A', '\x73B', '\a', '\x129', 
		'\x2', '\x2', '\x73B', '\x73C', '\x5', '\xBC', '_', '\x2', '\x73C', '\xEB', 
		'\x3', '\x2', '\x2', '\x2', '\x73D', '\x73E', '\t', '\x13', '\x2', '\x2', 
		'\x73E', '\x742', '\x5', '\xC6', '\x64', '\x2', '\x73F', '\x742', '\x5', 
		'\xC8', '\x65', '\x2', '\x740', '\x742', '\x5', '\xBC', '_', '\x2', '\x741', 
		'\x73D', '\x3', '\x2', '\x2', '\x2', '\x741', '\x73F', '\x3', '\x2', '\x2', 
		'\x2', '\x741', '\x740', '\x3', '\x2', '\x2', '\x2', '\x742', '\xED', 
		'\x3', '\x2', '\x2', '\x2', '\x743', '\x744', '\a', '\xA6', '\x2', '\x2', 
		'\x744', '\x745', '\x5', '\x130', '\x99', '\x2', '\x745', '\x746', '\a', 
		'\x8E', '\x2', '\x2', '\x746', '\x751', '\x5', '\xBC', '_', '\x2', '\x747', 
		'\x748', '\a', '\x14A', '\x2', '\x2', '\x748', '\x74A', '\x5', '\xBC', 
		'_', '\x2', '\x749', '\x747', '\x3', '\x2', '\x2', '\x2', '\x749', '\x74A', 
		'\x3', '\x2', '\x2', '\x2', '\x74A', '\x74B', '\x3', '\x2', '\x2', '\x2', 
		'\x74B', '\x74C', '\a', '!', '\x2', '\x2', '\x74C', '\x752', '\x5', '\xBC', 
		'_', '\x2', '\x74D', '\x74E', '\a', '\x14A', '\x2', '\x2', '\x74E', '\x750', 
		'\x5', '\xBC', '_', '\x2', '\x74F', '\x74D', '\x3', '\x2', '\x2', '\x2', 
		'\x74F', '\x750', '\x3', '\x2', '\x2', '\x2', '\x750', '\x752', '\x3', 
		'\x2', '\x2', '\x2', '\x751', '\x749', '\x3', '\x2', '\x2', '\x2', '\x751', 
		'\x74F', '\x3', '\x2', '\x2', '\x2', '\x752', '\x753', '\x3', '\x2', '\x2', 
		'\x2', '\x753', '\x754', '\a', '\xEF', '\x2', '\x2', '\x754', '\xEF', 
		'\x3', '\x2', '\x2', '\x2', '\x755', '\x759', '\a', '\xA6', '\x2', '\x2', 
		'\x756', '\x757', '\x5', '\x130', '\x99', '\x2', '\x757', '\x758', '\a', 
		'j', '\x2', '\x2', '\x758', '\x75A', '\x3', '\x2', '\x2', '\x2', '\x759', 
		'\x756', '\x3', '\x2', '\x2', '\x2', '\x759', '\x75A', '\x3', '\x2', '\x2', 
		'\x2', '\x75A', '\x75B', '\x3', '\x2', '\x2', '\x2', '\x75B', '\x75E', 
		'\x5', '\x88', '\x45', '\x2', '\x75C', '\x75D', '\a', '\x14A', '\x2', 
		'\x2', '\x75D', '\x75F', '\x5', '\xBC', '_', '\x2', '\x75E', '\x75C', 
		'\x3', '\x2', '\x2', '\x2', '\x75E', '\x75F', '\x3', '\x2', '\x2', '\x2', 
		'\x75F', '\x760', '\x3', '\x2', '\x2', '\x2', '\x760', '\x761', '\a', 
		'!', '\x2', '\x2', '\x761', '\x762', '\x5', '\xBC', '_', '\x2', '\x762', 
		'\x763', '\a', '\xEF', '\x2', '\x2', '\x763', '\xF1', '\x3', '\x2', '\x2', 
		'\x2', '\x764', '\x765', '\a', '\xF3', '\x2', '\x2', '\x765', '\x766', 
		'\a', '\xB0', '\x2', '\x2', '\x766', '\x767', '\x5', '\x130', '\x99', 
		'\x2', '\x767', '\x768', '\a', 'j', '\x2', '\x2', '\x768', '\x769', '\x5', 
		'\xBC', '_', '\x2', '\x769', '\x76A', '\a', '\x32', '\x2', '\x2', '\x76A', 
		'\x76B', '\x5', '\x130', '\x99', '\x2', '\x76B', '\x76C', '\a', '\x8E', 
		'\x2', '\x2', '\x76C', '\x76D', '\x5', '\xBC', '_', '\x2', '\x76D', '\x76E', 
		'\a', '!', '\x2', '\x2', '\x76E', '\x76F', '\x5', '\xBC', '_', '\x2', 
		'\x76F', '\x770', '\a', '\x109', '\x2', '\x2', '\x770', '\xF3', '\x3', 
		'\x2', '\x2', '\x2', '\x771', '\x774', '\x5', '\xF6', '|', '\x2', '\x772', 
		'\x774', '\x5', '\xF8', '}', '\x2', '\x773', '\x771', '\x3', '\x2', '\x2', 
		'\x2', '\x773', '\x772', '\x3', '\x2', '\x2', '\x2', '\x774', '\xF5', 
		'\x3', '\x2', '\x2', '\x2', '\x775', '\x776', '\a', '\x16', '\x2', '\x2', 
		'\x776', '\x777', '\a', '\xB0', '\x2', '\x2', '\x777', '\x778', '\x5', 
		'\x130', '\x99', '\x2', '\x778', '\x779', '\a', 'j', '\x2', '\x2', '\x779', 
		'\x77A', '\x5', '\xBC', '_', '\x2', '\x77A', '\x77B', '\a', '\x32', '\x2', 
		'\x2', '\x77B', '\x77C', '\x5', '\x130', '\x99', '\x2', '\x77C', '\x77D', 
		'\a', '\x8E', '\x2', '\x2', '\x77D', '\x77E', '\x5', '\xBC', '_', '\x2', 
		'\x77E', '\x77F', '\a', '!', '\x2', '\x2', '\x77F', '\x780', '\x5', '\xBC', 
		'_', '\x2', '\x780', '\x781', '\a', '\x32', '\x2', '\x2', '\x781', '\x782', 
		'\x5', '\xBC', '_', '\x2', '\x782', '\x783', '\a', '\x109', '\x2', '\x2', 
		'\x783', '\xF7', '\x3', '\x2', '\x2', '\x2', '\x784', '\x785', '\a', '\x16', 
		'\x2', '\x2', '\x785', '\x786', '\a', '\xB0', '\x2', '\x2', '\x786', '\x78B', 
		'\x5', '\xBC', '_', '\x2', '\x787', '\x788', '\t', '\x19', '\x2', '\x2', 
		'\x788', '\x78A', '\x5', '\xBC', '_', '\x2', '\x789', '\x787', '\x3', 
		'\x2', '\x2', '\x2', '\x78A', '\x78D', '\x3', '\x2', '\x2', '\x2', '\x78B', 
		'\x789', '\x3', '\x2', '\x2', '\x2', '\x78B', '\x78C', '\x3', '\x2', '\x2', 
		'\x2', '\x78C', '\x78E', '\x3', '\x2', '\x2', '\x2', '\x78D', '\x78B', 
		'\x3', '\x2', '\x2', '\x2', '\x78E', '\x78F', '\a', '\x109', '\x2', '\x2', 
		'\x78F', '\xF9', '\x3', '\x2', '\x2', '\x2', '\x790', '\x791', '\t', '\x1A', 
		'\x2', '\x2', '\x791', '\x792', '\a', '\xB0', '\x2', '\x2', '\x792', '\x793', 
		'\x5', '\x130', '\x99', '\x2', '\x793', '\x794', '\a', '\x8E', '\x2', 
		'\x2', '\x794', '\x797', '\x5', '\xBC', '_', '\x2', '\x795', '\x796', 
		'\a', '\x14A', '\x2', '\x2', '\x796', '\x798', '\x5', '\xBC', '_', '\x2', 
		'\x797', '\x795', '\x3', '\x2', '\x2', '\x2', '\x797', '\x798', '\x3', 
		'\x2', '\x2', '\x2', '\x798', '\x799', '\x3', '\x2', '\x2', '\x2', '\x799', 
		'\x79A', '\a', '\x109', '\x2', '\x2', '\x79A', '\xFB', '\x3', '\x2', '\x2', 
		'\x2', '\x79B', '\x79C', '\a', '\xC9', '\x2', '\x2', '\x79C', '\x79D', 
		'\a', '\xB0', '\x2', '\x2', '\x79D', '\x7A0', '\x5', '\xBC', '_', '\x2', 
		'\x79E', '\x79F', '\a', '\x32', '\x2', '\x2', '\x79F', '\x7A1', '\x5', 
		'\xCA', '\x66', '\x2', '\x7A0', '\x79E', '\x3', '\x2', '\x2', '\x2', '\x7A0', 
		'\x7A1', '\x3', '\x2', '\x2', '\x2', '\x7A1', '\x7A2', '\x3', '\x2', '\x2', 
		'\x2', '\x7A2', '\x7A3', '\a', '\x109', '\x2', '\x2', '\x7A3', '\xFD', 
		'\x3', '\x2', '\x2', '\x2', '\x7A4', '\x7A5', '\a', '\x144', '\x2', '\x2', 
		'\x7A5', '\x7A6', '\a', '\xB0', '\x2', '\x2', '\x7A6', '\x7A7', '\x5', 
		'\xBC', '_', '\x2', '\x7A7', '\x7A8', '\a', '\x32', '\x2', '\x2', '\x7A8', 
		'\x7A9', '\x5', '\xBC', '_', '\x2', '\x7A9', '\x7AA', '\a', '\x32', '\x2', 
		'\x2', '\x7AA', '\x7AB', '\x5', '\x13E', '\xA0', '\x2', '\x7AB', '\x7AC', 
		'\a', '\x109', '\x2', '\x2', '\x7AC', '\xFF', '\x3', '\x2', '\x2', '\x2', 
		'\x7AD', '\x7AE', '\a', '\x145', '\x2', '\x2', '\x7AE', '\x7AF', '\a', 
		'\xB0', '\x2', '\x2', '\x7AF', '\x7B0', '\x5', '\xBC', '_', '\x2', '\x7B0', 
		'\x7B1', '\a', '\x32', '\x2', '\x2', '\x7B1', '\x7B2', '\x5', '\xBC', 
		'_', '\x2', '\x7B2', '\x7B3', '\a', '\x32', '\x2', '\x2', '\x7B3', '\x7B4', 
		'\x5', '\x104', '\x83', '\x2', '\x7B4', '\x7B5', '\a', '\x109', '\x2', 
		'\x2', '\x7B5', '\x101', '\x3', '\x2', '\x2', '\x2', '\x7B6', '\x7B7', 
		'\a', '\x146', '\x2', '\x2', '\x7B7', '\x7B8', '\a', '\xB0', '\x2', '\x2', 
		'\x7B8', '\x7B9', '\x5', '\xBC', '_', '\x2', '\x7B9', '\x7BA', '\a', '\x32', 
		'\x2', '\x2', '\x7BA', '\x7BB', '\x5', '\x106', '\x84', '\x2', '\x7BB', 
		'\x7BC', '\a', '\x109', '\x2', '\x2', '\x7BC', '\x103', '\x3', '\x2', 
		'\x2', '\x2', '\x7BD', '\x7BE', '\t', '\x1B', '\x2', '\x2', '\x7BE', '\x105', 
		'\x3', '\x2', '\x2', '\x2', '\x7BF', '\x7C0', '\t', '\x1C', '\x2', '\x2', 
		'\x7C0', '\x107', '\x3', '\x2', '\x2', '\x2', '\x7C1', '\x7C2', '\a', 
		'\x134', '\x2', '\x2', '\x7C2', '\x7CA', '\a', '\xB0', '\x2', '\x2', '\x7C3', 
		'\x7C5', '\t', '\x1D', '\x2', '\x2', '\x7C4', '\x7C3', '\x3', '\x2', '\x2', 
		'\x2', '\x7C4', '\x7C5', '\x3', '\x2', '\x2', '\x2', '\x7C5', '\x7C7', 
		'\x3', '\x2', '\x2', '\x2', '\x7C6', '\x7C8', '\x5', '\xBC', '_', '\x2', 
		'\x7C7', '\x7C6', '\x3', '\x2', '\x2', '\x2', '\x7C7', '\x7C8', '\x3', 
		'\x2', '\x2', '\x2', '\x7C8', '\x7C9', '\x3', '\x2', '\x2', '\x2', '\x7C9', 
		'\x7CB', '\a', '|', '\x2', '\x2', '\x7CA', '\x7C4', '\x3', '\x2', '\x2', 
		'\x2', '\x7CA', '\x7CB', '\x3', '\x2', '\x2', '\x2', '\x7CB', '\x7CC', 
		'\x3', '\x2', '\x2', '\x2', '\x7CC', '\x7CD', '\x5', '\xBC', '_', '\x2', 
		'\x7CD', '\x7CE', '\a', '\x109', '\x2', '\x2', '\x7CE', '\x109', '\x3', 
		'\x2', '\x2', '\x2', '\x7CF', '\x7D0', '\x5', '\x88', '\x45', '\x2', '\x7D0', 
		'\x10B', '\x3', '\x2', '\x2', '\x2', '\x7D1', '\x7D2', '\x5', '|', '?', 
		'\x2', '\x7D2', '\x10D', '\x3', '\x2', '\x2', '\x2', '\x7D3', '\x7D4', 
		'\a', '\xB0', '\x2', '\x2', '\x7D4', '\x7D5', '\x5', '\xBC', '_', '\x2', 
		'\x7D5', '\x7D6', '\a', '\x109', '\x2', '\x2', '\x7D6', '\x10F', '\x3', 
		'\x2', '\x2', '\x2', '\x7D7', '\x7D8', '\x5', '\x130', '\x99', '\x2', 
		'\x7D8', '\x7E1', '\a', '\xA7', '\x2', '\x2', '\x7D9', '\x7DE', '\x5', 
		'\x112', '\x8A', '\x2', '\x7DA', '\x7DB', '\a', '\x32', '\x2', '\x2', 
		'\x7DB', '\x7DD', '\x5', '\x112', '\x8A', '\x2', '\x7DC', '\x7DA', '\x3', 
		'\x2', '\x2', '\x2', '\x7DD', '\x7E0', '\x3', '\x2', '\x2', '\x2', '\x7DE', 
		'\x7DC', '\x3', '\x2', '\x2', '\x2', '\x7DE', '\x7DF', '\x3', '\x2', '\x2', 
		'\x2', '\x7DF', '\x7E2', '\x3', '\x2', '\x2', '\x2', '\x7E0', '\x7DE', 
		'\x3', '\x2', '\x2', '\x2', '\x7E1', '\x7D9', '\x3', '\x2', '\x2', '\x2', 
		'\x7E1', '\x7E2', '\x3', '\x2', '\x2', '\x2', '\x7E2', '\x7E3', '\x3', 
		'\x2', '\x2', '\x2', '\x7E3', '\x7E4', '\a', '\xF0', '\x2', '\x2', '\x7E4', 
		'\x111', '\x3', '\x2', '\x2', '\x2', '\x7E5', '\x7E6', '\x5', '\x122', 
		'\x92', '\x2', '\x7E6', '\x7E7', '\a', '\x30', '\x2', '\x2', '\x7E7', 
		'\x7E8', '\x5', '\xBC', '_', '\x2', '\x7E8', '\x7EE', '\x3', '\x2', '\x2', 
		'\x2', '\x7E9', '\x7EE', '\x5', '\xD8', 'm', '\x2', '\x7EA', '\x7EE', 
		'\x5', '\x130', '\x99', '\x2', '\x7EB', '\x7EC', '\a', 'V', '\x2', '\x2', 
		'\x7EC', '\x7EE', '\a', '\x12B', '\x2', '\x2', '\x7ED', '\x7E5', '\x3', 
		'\x2', '\x2', '\x2', '\x7ED', '\x7E9', '\x3', '\x2', '\x2', '\x2', '\x7ED', 
		'\x7EA', '\x3', '\x2', '\x2', '\x2', '\x7ED', '\x7EB', '\x3', '\x2', '\x2', 
		'\x2', '\x7EE', '\x113', '\x3', '\x2', '\x2', '\x2', '\x7EF', '\x7F0', 
		'\a', '=', '\x2', '\x2', '\x7F0', '\x7F1', '\a', '\xB0', '\x2', '\x2', 
		'\x7F1', '\x7F2', '\a', '\x12B', '\x2', '\x2', '\x7F2', '\x7F3', '\a', 
		'\x109', '\x2', '\x2', '\x7F3', '\x115', '\x3', '\x2', '\x2', '\x2', '\x7F4', 
		'\x7F5', '\a', 'o', '\x2', '\x2', '\x7F5', '\x7FE', '\a', '\xA7', '\x2', 
		'\x2', '\x7F6', '\x7FF', '\x5', '\x6', '\x4', '\x2', '\x7F7', '\x7F9', 
		'\x5', '\x44', '#', '\x2', '\x7F8', '\x7F7', '\x3', '\x2', '\x2', '\x2', 
		'\x7F8', '\x7F9', '\x3', '\x2', '\x2', '\x2', '\x7F9', '\x7FA', '\x3', 
		'\x2', '\x2', '\x2', '\x7FA', '\x7FC', '\x5', 'p', '\x39', '\x2', '\x7FB', 
		'\x7FD', '\x5', '\x30', '\x19', '\x2', '\x7FC', '\x7FB', '\x3', '\x2', 
		'\x2', '\x2', '\x7FC', '\x7FD', '\x3', '\x2', '\x2', '\x2', '\x7FD', '\x7FF', 
		'\x3', '\x2', '\x2', '\x2', '\x7FE', '\x7F6', '\x3', '\x2', '\x2', '\x2', 
		'\x7FE', '\x7F8', '\x3', '\x2', '\x2', '\x2', '\x7FF', '\x800', '\x3', 
		'\x2', '\x2', '\x2', '\x800', '\x801', '\a', '\xF0', '\x2', '\x2', '\x801', 
		'\x117', '\x3', '\x2', '\x2', '\x2', '\x802', '\x803', '\a', '=', '\x2', 
		'\x2', '\x803', '\x80C', '\a', '\xA7', '\x2', '\x2', '\x804', '\x80D', 
		'\x5', '\x6', '\x4', '\x2', '\x805', '\x807', '\x5', '\x44', '#', '\x2', 
		'\x806', '\x805', '\x3', '\x2', '\x2', '\x2', '\x806', '\x807', '\x3', 
		'\x2', '\x2', '\x2', '\x807', '\x808', '\x3', '\x2', '\x2', '\x2', '\x808', 
		'\x80A', '\x5', 'p', '\x39', '\x2', '\x809', '\x80B', '\x5', '\x30', '\x19', 
		'\x2', '\x80A', '\x809', '\x3', '\x2', '\x2', '\x2', '\x80A', '\x80B', 
		'\x3', '\x2', '\x2', '\x2', '\x80B', '\x80D', '\x3', '\x2', '\x2', '\x2', 
		'\x80C', '\x804', '\x3', '\x2', '\x2', '\x2', '\x80C', '\x806', '\x3', 
		'\x2', '\x2', '\x2', '\x80D', '\x80E', '\x3', '\x2', '\x2', '\x2', '\x80E', 
		'\x80F', '\a', '\xF0', '\x2', '\x2', '\x80F', '\x119', '\x3', '\x2', '\x2', 
		'\x2', '\x810', '\x811', '\a', '/', '\x2', '\x2', '\x811', '\x812', '\a', 
		'\xA7', '\x2', '\x2', '\x812', '\x813', '\x5', '\x6', '\x4', '\x2', '\x813', 
		'\x814', '\a', '\xF0', '\x2', '\x2', '\x814', '\x11B', '\x3', '\x2', '\x2', 
		'\x2', '\x815', '\x817', '\a', '\xB7', '\x2', '\x2', '\x816', '\x815', 
		'\x3', '\x2', '\x2', '\x2', '\x816', '\x817', '\x3', '\x2', '\x2', '\x2', 
		'\x817', '\x818', '\x3', '\x2', '\x2', '\x2', '\x818', '\x819', '\t', 
		'\x1E', '\x2', '\x2', '\x819', '\x11D', '\x3', '\x2', '\x2', '\x2', '\x81A', 
		'\x81C', '\a', '\xB7', '\x2', '\x2', '\x81B', '\x81A', '\x3', '\x2', '\x2', 
		'\x2', '\x81B', '\x81C', '\x3', '\x2', '\x2', '\x2', '\x81C', '\x81D', 
		'\x3', '\x2', '\x2', '\x2', '\x81D', '\x81E', '\a', '\a', '\x2', '\x2', 
		'\x81E', '\x11F', '\x3', '\x2', '\x2', '\x2', '\x81F', '\x828', '\a', 
		'\xA6', '\x2', '\x2', '\x820', '\x825', '\x5', '\xBC', '_', '\x2', '\x821', 
		'\x822', '\a', '\x32', '\x2', '\x2', '\x822', '\x824', '\x5', '\xBC', 
		'_', '\x2', '\x823', '\x821', '\x3', '\x2', '\x2', '\x2', '\x824', '\x827', 
		'\x3', '\x2', '\x2', '\x2', '\x825', '\x823', '\x3', '\x2', '\x2', '\x2', 
		'\x825', '\x826', '\x3', '\x2', '\x2', '\x2', '\x826', '\x829', '\x3', 
		'\x2', '\x2', '\x2', '\x827', '\x825', '\x3', '\x2', '\x2', '\x2', '\x828', 
		'\x820', '\x3', '\x2', '\x2', '\x2', '\x828', '\x829', '\x3', '\x2', '\x2', 
		'\x2', '\x829', '\x82A', '\x3', '\x2', '\x2', '\x2', '\x82A', '\x82B', 
		'\a', '\xEF', '\x2', '\x2', '\x82B', '\x121', '\x3', '\x2', '\x2', '\x2', 
		'\x82C', '\x82D', '\x5', '\x2F4', '\x17B', '\x2', '\x82D', '\x123', '\x3', 
		'\x2', '\x2', '\x2', '\x82E', '\x82F', '\a', 'S', '\x2', '\x2', '\x82F', 
		'\x830', '\x5', '\x126', '\x94', '\x2', '\x830', '\x125', '\x3', '\x2', 
		'\x2', '\x2', '\x831', '\x836', '\x5', '\x2F4', '\x17B', '\x2', '\x832', 
		'\x836', '\a', '\a', '\x2', '\x2', '\x833', '\x836', '\a', '\t', '\x2', 
		'\x2', '\x834', '\x836', '\a', '\x153', '\x2', '\x2', '\x835', '\x831', 
		'\x3', '\x2', '\x2', '\x2', '\x835', '\x832', '\x3', '\x2', '\x2', '\x2', 
		'\x835', '\x833', '\x3', '\x2', '\x2', '\x2', '\x835', '\x834', '\x3', 
		'\x2', '\x2', '\x2', '\x836', '\x127', '\x3', '\x2', '\x2', '\x2', '\x837', 
		'\x838', '\x5', '\x12C', '\x97', '\x2', '\x838', '\x83A', '\a', '\xB0', 
		'\x2', '\x2', '\x839', '\x83B', '\t', '\x2', '\x2', '\x2', '\x83A', '\x839', 
		'\x3', '\x2', '\x2', '\x2', '\x83A', '\x83B', '\x3', '\x2', '\x2', '\x2', 
		'\x83B', '\x844', '\x3', '\x2', '\x2', '\x2', '\x83C', '\x841', '\x5', 
		'\x12A', '\x96', '\x2', '\x83D', '\x83E', '\a', '\x32', '\x2', '\x2', 
		'\x83E', '\x840', '\x5', '\x12A', '\x96', '\x2', '\x83F', '\x83D', '\x3', 
		'\x2', '\x2', '\x2', '\x840', '\x843', '\x3', '\x2', '\x2', '\x2', '\x841', 
		'\x83F', '\x3', '\x2', '\x2', '\x2', '\x841', '\x842', '\x3', '\x2', '\x2', 
		'\x2', '\x842', '\x845', '\x3', '\x2', '\x2', '\x2', '\x843', '\x841', 
		'\x3', '\x2', '\x2', '\x2', '\x844', '\x83C', '\x3', '\x2', '\x2', '\x2', 
		'\x844', '\x845', '\x3', '\x2', '\x2', '\x2', '\x845', '\x846', '\x3', 
		'\x2', '\x2', '\x2', '\x846', '\x847', '\a', '\x109', '\x2', '\x2', '\x847', 
		'\x129', '\x3', '\x2', '\x2', '\x2', '\x848', '\x849', '\x5', '\xBC', 
		'_', '\x2', '\x849', '\x12B', '\x3', '\x2', '\x2', '\x2', '\x84A', '\x84B', 
		'\x5', '\x12E', '\x98', '\x2', '\x84B', '\x84C', '\x5', '\x2F4', '\x17B', 
		'\x2', '\x84C', '\x12D', '\x3', '\x2', '\x2', '\x2', '\x84D', '\x84E', 
		'\x5', '\x2F4', '\x17B', '\x2', '\x84E', '\x84F', '\a', 'V', '\x2', '\x2', 
		'\x84F', '\x851', '\x3', '\x2', '\x2', '\x2', '\x850', '\x84D', '\x3', 
		'\x2', '\x2', '\x2', '\x851', '\x854', '\x3', '\x2', '\x2', '\x2', '\x852', 
		'\x850', '\x3', '\x2', '\x2', '\x2', '\x852', '\x853', '\x3', '\x2', '\x2', 
		'\x2', '\x853', '\x12F', '\x3', '\x2', '\x2', '\x2', '\x854', '\x852', 
		'\x3', '\x2', '\x2', '\x2', '\x855', '\x856', '\x5', '\x2EE', '\x178', 
		'\x2', '\x856', '\x131', '\x3', '\x2', '\x2', '\x2', '\x857', '\x85C', 
		'\x5', '\x2F4', '\x17B', '\x2', '\x858', '\x859', '\a', '\x32', '\x2', 
		'\x2', '\x859', '\x85B', '\x5', '\x2F4', '\x17B', '\x2', '\x85A', '\x858', 
		'\x3', '\x2', '\x2', '\x2', '\x85B', '\x85E', '\x3', '\x2', '\x2', '\x2', 
		'\x85C', '\x85A', '\x3', '\x2', '\x2', '\x2', '\x85C', '\x85D', '\x3', 
		'\x2', '\x2', '\x2', '\x85D', '\x133', '\x3', '\x2', '\x2', '\x2', '\x85E', 
		'\x85C', '\x3', '\x2', '\x2', '\x2', '\x85F', '\x864', '\x5', '\x136', 
		'\x9C', '\x2', '\x860', '\x861', '\a', '!', '\x2', '\x2', '\x861', '\x863', 
		'\x5', '\x136', '\x9C', '\x2', '\x862', '\x860', '\x3', '\x2', '\x2', 
		'\x2', '\x863', '\x866', '\x3', '\x2', '\x2', '\x2', '\x864', '\x862', 
		'\x3', '\x2', '\x2', '\x2', '\x864', '\x865', '\x3', '\x2', '\x2', '\x2', 
		'\x865', '\x135', '\x3', '\x2', '\x2', '\x2', '\x866', '\x864', '\x3', 
		'\x2', '\x2', '\x2', '\x867', '\x869', '\x5', '\x138', '\x9D', '\x2', 
		'\x868', '\x86A', '\x5', '\x13A', '\x9E', '\x2', '\x869', '\x868', '\x3', 
		'\x2', '\x2', '\x2', '\x869', '\x86A', '\x3', '\x2', '\x2', '\x2', '\x86A', 
		'\x86E', '\x3', '\x2', '\x2', '\x2', '\x86B', '\x86D', '\x5', '\x13C', 
		'\x9F', '\x2', '\x86C', '\x86B', '\x3', '\x2', '\x2', '\x2', '\x86D', 
		'\x870', '\x3', '\x2', '\x2', '\x2', '\x86E', '\x86C', '\x3', '\x2', '\x2', 
		'\x2', '\x86E', '\x86F', '\x3', '\x2', '\x2', '\x2', '\x86F', '\x137', 
		'\x3', '\x2', '\x2', '\x2', '\x870', '\x86E', '\x3', '\x2', '\x2', '\x2', 
		'\x871', '\x8CA', '\a', '\xCC', '\x2', '\x2', '\x872', '\x8CA', '\a', 
		'\xCE', '\x2', '\x2', '\x873', '\x8CA', '\a', '#', '\x2', '\x2', '\x874', 
		'\x8CA', '\a', '$', '\x2', '\x2', '\x875', '\x8CA', '\a', '\x143', '\x2', 
		'\x2', '\x876', '\x8CA', '\a', '\x123', '\x2', '\x2', '\x877', '\x8CA', 
		'\a', '\x94', '\x2', '\x2', '\x878', '\x87A', '\a', '\x11C', '\x2', '\x2', 
		'\x879', '\x878', '\x3', '\x2', '\x2', '\x2', '\x879', '\x87A', '\x3', 
		'\x2', '\x2', '\x2', '\x87A', '\x87B', '\x3', '\x2', '\x2', '\x2', '\x87B', 
		'\x8CA', '\a', '\x99', '\x2', '\x2', '\x87C', '\x8CA', '\a', '\x9A', '\x2', 
		'\x2', '\x87D', '\x8CA', '\a', '\x95', '\x2', '\x2', '\x87E', '\x8CA', 
		'\a', 'v', '\x2', '\x2', '\x87F', '\x8CA', '\a', 'w', '\x2', '\x2', '\x880', 
		'\x8CA', '\a', '\x46', '\x2', '\x2', '\x881', '\x882', '\a', '\xAE', '\x2', 
		'\x2', '\x882', '\x8CA', '\t', '\x1F', '\x2', '\x2', '\x883', '\x884', 
		'\a', '\x151', '\x2', '\x2', '\x884', '\x8CA', '\t', '\x1F', '\x2', '\x2', 
		'\x885', '\x886', '\a', '\x12A', '\x2', '\x2', '\x886', '\x88A', '\t', 
		' ', '\x2', '\x2', '\x887', '\x88B', '\a', '\x12D', '\x2', '\x2', '\x888', 
		'\x889', '\a', '\x12A', '\x2', '\x2', '\x889', '\x88B', '\a', '\x150', 
		'\x2', '\x2', '\x88A', '\x887', '\x3', '\x2', '\x2', '\x2', '\x88A', '\x888', 
		'\x3', '\x2', '\x2', '\x2', '\x88B', '\x8CA', '\x3', '\x2', '\x2', '\x2', 
		'\x88C', '\x88D', '\a', '\x12C', '\x2', '\x2', '\x88D', '\x891', '\t', 
		' ', '\x2', '\x2', '\x88E', '\x892', '\a', '\x12D', '\x2', '\x2', '\x88F', 
		'\x890', '\a', '\x12A', '\x2', '\x2', '\x890', '\x892', '\a', '\x150', 
		'\x2', '\x2', '\x891', '\x88E', '\x3', '\x2', '\x2', '\x2', '\x891', '\x88F', 
		'\x3', '\x2', '\x2', '\x2', '\x892', '\x8CA', '\x3', '\x2', '\x2', '\x2', 
		'\x893', '\x8CA', '\a', '^', '\x2', '\x2', '\x894', '\x8CA', '\a', '\xE0', 
		'\x2', '\x2', '\x895', '\x8CA', '\a', '\xC5', '\x2', '\x2', '\x896', '\x897', 
		'\a', '\x144', '\x2', '\x2', '\x897', '\x898', '\a', '\xB0', '\x2', '\x2', 
		'\x898', '\x899', '\x5', '\x11E', '\x90', '\x2', '\x899', '\x89A', '\a', 
		'\x32', '\x2', '\x2', '\x89A', '\x89B', '\x5', '\x13E', '\xA0', '\x2', 
		'\x89B', '\x89C', '\a', '\x109', '\x2', '\x2', '\x89C', '\x8CA', '\x3', 
		'\x2', '\x2', '\x2', '\x89D', '\x8A2', '\a', '\x144', '\x2', '\x2', '\x89E', 
		'\x89F', '\a', '\xB1', '\x2', '\x2', '\x89F', '\x8A0', '\x5', '\x13E', 
		'\xA0', '\x2', '\x8A0', '\x8A1', '\a', '\x86', '\x2', '\x2', '\x8A1', 
		'\x8A3', '\x3', '\x2', '\x2', '\x2', '\x8A2', '\x89E', '\x3', '\x2', '\x2', 
		'\x2', '\x8A2', '\x8A3', '\x3', '\x2', '\x2', '\x2', '\x8A3', '\x8A8', 
		'\x3', '\x2', '\x2', '\x2', '\x8A4', '\x8A5', '\a', '\xB0', '\x2', '\x2', 
		'\x8A5', '\x8A6', '\x5', '\x11E', '\x90', '\x2', '\x8A6', '\x8A7', '\a', 
		'\x109', '\x2', '\x2', '\x8A7', '\x8A9', '\x3', '\x2', '\x2', '\x2', '\x8A8', 
		'\x8A4', '\x3', '\x2', '\x2', '\x2', '\x8A8', '\x8A9', '\x3', '\x2', '\x2', 
		'\x2', '\x8A9', '\x8CA', '\x3', '\x2', '\x2', '\x2', '\x8AA', '\x8CA', 
		'\a', '\x147', '\x2', '\x2', '\x8AB', '\x8CA', '\a', '\xF7', '\x2', '\x2', 
		'\x8AC', '\x8CA', '\a', '`', '\x2', '\x2', '\x8AD', '\x8CA', '\a', '\xB4', 
		'\x2', '\x2', '\x8AE', '\x8AF', '\t', '!', '\x2', '\x2', '\x8AF', '\x8B0', 
		'\a', '\xB1', '\x2', '\x2', '\x8B0', '\x8B1', '\x5', '\x134', '\x9B', 
		'\x2', '\x8B1', '\x8B2', '\a', '\x86', '\x2', '\x2', '\x8B2', '\x8CA', 
		'\x3', '\x2', '\x2', '\x2', '\x8B3', '\x8CA', '\a', '\xDB', '\x2', '\x2', 
		'\x8B4', '\x8CA', '\a', '\xDC', '\x2', '\x2', '\x8B5', '\x8B6', '\a', 
		'\xEA', '\x2', '\x2', '\x8B6', '\x8CA', '\a', '\x142', '\x2', '\x2', '\x8B7', 
		'\x8C7', '\a', '\x19', '\x2', '\x2', '\x8B8', '\x8C8', '\a', '\xC5', '\x2', 
		'\x2', '\x8B9', '\x8C8', '\a', '\x147', '\x2', '\x2', '\x8BA', '\x8C8', 
		'\a', '\xF7', '\x2', '\x2', '\x8BB', '\x8C8', '\a', '`', '\x2', '\x2', 
		'\x8BC', '\x8C8', '\a', '\xB4', '\x2', '\x2', '\x8BD', '\x8BE', '\a', 
		'\xEA', '\x2', '\x2', '\x8BE', '\x8C8', '\a', '\x142', '\x2', '\x2', '\x8BF', 
		'\x8C1', '\a', '\x142', '\x2', '\x2', '\x8C0', '\x8BF', '\x3', '\x2', 
		'\x2', '\x2', '\x8C0', '\x8C1', '\x3', '\x2', '\x2', '\x2', '\x8C1', '\x8C2', 
		'\x3', '\x2', '\x2', '\x2', '\x8C2', '\x8C3', '\a', '\xB1', '\x2', '\x2', 
		'\x8C3', '\x8C4', '\x5', '\x134', '\x9B', '\x2', '\x8C4', '\x8C5', '\a', 
		'\x86', '\x2', '\x2', '\x8C5', '\x8C8', '\x3', '\x2', '\x2', '\x2', '\x8C6', 
		'\x8C8', '\a', '\x142', '\x2', '\x2', '\x8C7', '\x8B8', '\x3', '\x2', 
		'\x2', '\x2', '\x8C7', '\x8B9', '\x3', '\x2', '\x2', '\x2', '\x8C7', '\x8BA', 
		'\x3', '\x2', '\x2', '\x2', '\x8C7', '\x8BB', '\x3', '\x2', '\x2', '\x2', 
		'\x8C7', '\x8BC', '\x3', '\x2', '\x2', '\x2', '\x8C7', '\x8BD', '\x3', 
		'\x2', '\x2', '\x2', '\x8C7', '\x8C0', '\x3', '\x2', '\x2', '\x2', '\x8C7', 
		'\x8C6', '\x3', '\x2', '\x2', '\x2', '\x8C7', '\x8C8', '\x3', '\x2', '\x2', 
		'\x2', '\x8C8', '\x8CA', '\x3', '\x2', '\x2', '\x2', '\x8C9', '\x871', 
		'\x3', '\x2', '\x2', '\x2', '\x8C9', '\x872', '\x3', '\x2', '\x2', '\x2', 
		'\x8C9', '\x873', '\x3', '\x2', '\x2', '\x2', '\x8C9', '\x874', '\x3', 
		'\x2', '\x2', '\x2', '\x8C9', '\x875', '\x3', '\x2', '\x2', '\x2', '\x8C9', 
		'\x876', '\x3', '\x2', '\x2', '\x2', '\x8C9', '\x877', '\x3', '\x2', '\x2', 
		'\x2', '\x8C9', '\x879', '\x3', '\x2', '\x2', '\x2', '\x8C9', '\x87C', 
		'\x3', '\x2', '\x2', '\x2', '\x8C9', '\x87D', '\x3', '\x2', '\x2', '\x2', 
		'\x8C9', '\x87E', '\x3', '\x2', '\x2', '\x2', '\x8C9', '\x87F', '\x3', 
		'\x2', '\x2', '\x2', '\x8C9', '\x880', '\x3', '\x2', '\x2', '\x2', '\x8C9', 
		'\x881', '\x3', '\x2', '\x2', '\x2', '\x8C9', '\x883', '\x3', '\x2', '\x2', 
		'\x2', '\x8C9', '\x885', '\x3', '\x2', '\x2', '\x2', '\x8C9', '\x88C', 
		'\x3', '\x2', '\x2', '\x2', '\x8C9', '\x893', '\x3', '\x2', '\x2', '\x2', 
		'\x8C9', '\x894', '\x3', '\x2', '\x2', '\x2', '\x8C9', '\x895', '\x3', 
		'\x2', '\x2', '\x2', '\x8C9', '\x896', '\x3', '\x2', '\x2', '\x2', '\x8C9', 
		'\x89D', '\x3', '\x2', '\x2', '\x2', '\x8C9', '\x8AA', '\x3', '\x2', '\x2', 
		'\x2', '\x8C9', '\x8AB', '\x3', '\x2', '\x2', '\x2', '\x8C9', '\x8AC', 
		'\x3', '\x2', '\x2', '\x2', '\x8C9', '\x8AD', '\x3', '\x2', '\x2', '\x2', 
		'\x8C9', '\x8AE', '\x3', '\x2', '\x2', '\x2', '\x8C9', '\x8B3', '\x3', 
		'\x2', '\x2', '\x2', '\x8C9', '\x8B4', '\x3', '\x2', '\x2', '\x2', '\x8C9', 
		'\x8B5', '\x3', '\x2', '\x2', '\x2', '\x8C9', '\x8B7', '\x3', '\x2', '\x2', 
		'\x2', '\x8CA', '\x139', '\x3', '\x2', '\x2', '\x2', '\x8CB', '\x8CC', 
		'\a', '\xCB', '\x2', '\x2', '\x8CC', '\x8CF', '\a', '\xCE', '\x2', '\x2', 
		'\x8CD', '\x8CF', '\a', '\xA4', '\x2', '\x2', '\x8CE', '\x8CB', '\x3', 
		'\x2', '\x2', '\x2', '\x8CE', '\x8CD', '\x3', '\x2', '\x2', '\x2', '\x8CF', 
		'\x13B', '\x3', '\x2', '\x2', '\x2', '\x8D0', '\x8D2', '\t', '!', '\x2', 
		'\x2', '\x8D1', '\x8D3', '\x5', '\x13A', '\x9E', '\x2', '\x8D2', '\x8D1', 
		'\x3', '\x2', '\x2', '\x2', '\x8D2', '\x8D3', '\x3', '\x2', '\x2', '\x2', 
		'\x8D3', '\x13D', '\x3', '\x2', '\x2', '\x2', '\x8D4', '\x8E5', '\a', 
		'\x94', '\x2', '\x2', '\x8D5', '\x8D7', '\a', '\x11C', '\x2', '\x2', '\x8D6', 
		'\x8D5', '\x3', '\x2', '\x2', '\x2', '\x8D6', '\x8D7', '\x3', '\x2', '\x2', 
		'\x2', '\x8D7', '\x8D8', '\x3', '\x2', '\x2', '\x2', '\x8D8', '\x8E5', 
		'\a', '\x99', '\x2', '\x2', '\x8D9', '\x8E5', '\a', '\x9A', '\x2', '\x2', 
		'\x8DA', '\x8E5', '\a', '\x9B', '\x2', '\x2', '\x8DB', '\x8E5', '\a', 
		'\x9C', '\x2', '\x2', '\x8DC', '\x8E5', '\a', '\x9D', '\x2', '\x2', '\x8DD', 
		'\x8E5', '\a', '\x95', '\x2', '\x2', '\x8DE', '\x8E5', '\a', '\x96', '\x2', 
		'\x2', '\x8DF', '\x8E5', '\a', '\x97', '\x2', '\x2', '\x8E0', '\x8E5', 
		'\a', '\x98', '\x2', '\x2', '\x8E1', '\x8E5', '\a', 'v', '\x2', '\x2', 
		'\x8E2', '\x8E5', '\a', 'w', '\x2', '\x2', '\x8E3', '\x8E5', '\a', 'x', 
		'\x2', '\x2', '\x8E4', '\x8D4', '\x3', '\x2', '\x2', '\x2', '\x8E4', '\x8D6', 
		'\x3', '\x2', '\x2', '\x2', '\x8E4', '\x8D9', '\x3', '\x2', '\x2', '\x2', 
		'\x8E4', '\x8DA', '\x3', '\x2', '\x2', '\x2', '\x8E4', '\x8DB', '\x3', 
		'\x2', '\x2', '\x2', '\x8E4', '\x8DC', '\x3', '\x2', '\x2', '\x2', '\x8E4', 
		'\x8DD', '\x3', '\x2', '\x2', '\x2', '\x8E4', '\x8DE', '\x3', '\x2', '\x2', 
		'\x2', '\x8E4', '\x8DF', '\x3', '\x2', '\x2', '\x2', '\x8E4', '\x8E0', 
		'\x3', '\x2', '\x2', '\x2', '\x8E4', '\x8E1', '\x3', '\x2', '\x2', '\x2', 
		'\x8E4', '\x8E2', '\x3', '\x2', '\x2', '\x2', '\x8E4', '\x8E3', '\x3', 
		'\x2', '\x2', '\x2', '\x8E5', '\x8E7', '\x3', '\x2', '\x2', '\x2', '\x8E6', 
		'\x8E8', '\x5', '\x13A', '\x9E', '\x2', '\x8E7', '\x8E6', '\x3', '\x2', 
		'\x2', '\x2', '\x8E7', '\x8E8', '\x3', '\x2', '\x2', '\x2', '\x8E8', '\x13F', 
		'\x3', '\x2', '\x2', '\x2', '\x8E9', '\x8EB', '\x5', '\x16', '\f', '\x2', 
		'\x8EA', '\x8E9', '\x3', '\x2', '\x2', '\x2', '\x8EA', '\x8EB', '\x3', 
		'\x2', '\x2', '\x2', '\x8EB', '\x8F9', '\x3', '\x2', '\x2', '\x2', '\x8EC', 
		'\x8FA', '\x5', '\x142', '\xA2', '\x2', '\x8ED', '\x8FA', '\x5', '\x146', 
		'\xA4', '\x2', '\x8EE', '\x8FA', '\x5', '\x144', '\xA3', '\x2', '\x8EF', 
		'\x8FA', '\x5', '\x1D8', '\xED', '\x2', '\x8F0', '\x8FA', '\x5', '\x1DC', 
		'\xEF', '\x2', '\x8F1', '\x8FA', '\x5', '\x1DE', '\xF0', '\x2', '\x8F2', 
		'\x8FA', '\x5', '\x1DA', '\xEE', '\x2', '\x8F3', '\x8FA', '\x5', '\x2B0', 
		'\x159', '\x2', '\x8F4', '\x8FA', '\x5', '\x2B2', '\x15A', '\x2', '\x8F5', 
		'\x8FA', '\x5', '\x1E6', '\xF4', '\x2', '\x8F6', '\x8FA', '\x5', '\x1F0', 
		'\xF9', '\x2', '\x8F7', '\x8FA', '\x5', '\x148', '\xA5', '\x2', '\x8F8', 
		'\x8FA', '\x5', '\x156', '\xAC', '\x2', '\x8F9', '\x8EC', '\x3', '\x2', 
		'\x2', '\x2', '\x8F9', '\x8ED', '\x3', '\x2', '\x2', '\x2', '\x8F9', '\x8EE', 
		'\x3', '\x2', '\x2', '\x2', '\x8F9', '\x8EF', '\x3', '\x2', '\x2', '\x2', 
		'\x8F9', '\x8F0', '\x3', '\x2', '\x2', '\x2', '\x8F9', '\x8F1', '\x3', 
		'\x2', '\x2', '\x2', '\x8F9', '\x8F2', '\x3', '\x2', '\x2', '\x2', '\x8F9', 
		'\x8F3', '\x3', '\x2', '\x2', '\x2', '\x8F9', '\x8F4', '\x3', '\x2', '\x2', 
		'\x2', '\x8F9', '\x8F5', '\x3', '\x2', '\x2', '\x2', '\x8F9', '\x8F6', 
		'\x3', '\x2', '\x2', '\x2', '\x8F9', '\x8F7', '\x3', '\x2', '\x2', '\x2', 
		'\x8F9', '\x8F8', '\x3', '\x2', '\x2', '\x2', '\x8FA', '\x141', '\x3', 
		'\x2', '\x2', '\x2', '\x8FB', '\x8FE', '\a', '>', '\x2', '\x2', '\x8FC', 
		'\x8FD', '\a', '\xD7', '\x2', '\x2', '\x8FD', '\x8FF', '\a', '\xFB', '\x2', 
		'\x2', '\x8FE', '\x8FC', '\x3', '\x2', '\x2', '\x2', '\x8FE', '\x8FF', 
		'\x3', '\x2', '\x2', '\x2', '\x8FF', '\x907', '\x3', '\x2', '\x2', '\x2', 
		'\x900', '\x908', '\x5', '\x2BE', '\x160', '\x2', '\x901', '\x908', '\x5', 
		'\x286', '\x144', '\x2', '\x902', '\x908', '\x5', '\x186', '\xC4', '\x2', 
		'\x903', '\x908', '\x5', '\x288', '\x145', '\x2', '\x904', '\x908', '\x5', 
		'\x18C', '\xC7', '\x2', '\x905', '\x908', '\x5', '\x1F6', '\xFC', '\x2', 
		'\x906', '\x908', '\x5', '\x202', '\x102', '\x2', '\x907', '\x900', '\x3', 
		'\x2', '\x2', '\x2', '\x907', '\x901', '\x3', '\x2', '\x2', '\x2', '\x907', 
		'\x902', '\x3', '\x2', '\x2', '\x2', '\x907', '\x903', '\x3', '\x2', '\x2', 
		'\x2', '\x907', '\x904', '\x3', '\x2', '\x2', '\x2', '\x907', '\x905', 
		'\x3', '\x2', '\x2', '\x2', '\x907', '\x906', '\x3', '\x2', '\x2', '\x2', 
		'\x908', '\x143', '\x3', '\x2', '\x2', '\x2', '\x909', '\x910', '\a', 
		'\x17', '\x2', '\x2', '\x90A', '\x911', '\x5', '\x2C4', '\x163', '\x2', 
		'\x90B', '\x911', '\x5', '\x208', '\x105', '\x2', '\x90C', '\x911', '\x5', 
		'\x1A2', '\xD2', '\x2', '\x90D', '\x911', '\x5', '\x2A2', '\x152', '\x2', 
		'\x90E', '\x911', '\x5', '\x20A', '\x106', '\x2', '\x90F', '\x911', '\x5', 
		'\x1E8', '\xF5', '\x2', '\x910', '\x90A', '\x3', '\x2', '\x2', '\x2', 
		'\x910', '\x90B', '\x3', '\x2', '\x2', '\x2', '\x910', '\x90C', '\x3', 
		'\x2', '\x2', '\x2', '\x910', '\x90D', '\x3', '\x2', '\x2', '\x2', '\x910', 
		'\x90E', '\x3', '\x2', '\x2', '\x2', '\x910', '\x90F', '\x3', '\x2', '\x2', 
		'\x2', '\x911', '\x145', '\x3', '\x2', '\x2', '\x2', '\x912', '\x91A', 
		'\a', '[', '\x2', '\x2', '\x913', '\x91B', '\x5', '\x2C2', '\x162', '\x2', 
		'\x914', '\x91B', '\x5', '\x18A', '\xC6', '\x2', '\x915', '\x91B', '\x5', 
		'\x29E', '\x150', '\x2', '\x916', '\x91B', '\x5', '\x19C', '\xCF', '\x2', 
		'\x917', '\x91B', '\x5', '\x1F8', '\xFD', '\x2', '\x918', '\x91B', '\x5', 
		'\x1EC', '\xF7', '\x2', '\x919', '\x91B', '\x5', '\x204', '\x103', '\x2', 
		'\x91A', '\x913', '\x3', '\x2', '\x2', '\x2', '\x91A', '\x914', '\x3', 
		'\x2', '\x2', '\x2', '\x91A', '\x915', '\x3', '\x2', '\x2', '\x2', '\x91A', 
		'\x916', '\x3', '\x2', '\x2', '\x2', '\x91A', '\x917', '\x3', '\x2', '\x2', 
		'\x2', '\x91A', '\x918', '\x3', '\x2', '\x2', '\x2', '\x91A', '\x919', 
		'\x3', '\x2', '\x2', '\x2', '\x91B', '\x147', '\x3', '\x2', '\x2', '\x2', 
		'\x91C', '\x92E', '\a', '\x11B', '\x2', '\x2', '\x91D', '\x92F', '\x5', 
		'\x2D0', '\x169', '\x2', '\x91E', '\x92F', '\x5', '\x162', '\xB2', '\x2', 
		'\x91F', '\x92F', '\x5', '\x16A', '\xB6', '\x2', '\x920', '\x92F', '\x5', 
		'\x220', '\x111', '\x2', '\x921', '\x92F', '\x5', '\x2B8', '\x15D', '\x2', 
		'\x922', '\x92F', '\x5', '\x16E', '\xB8', '\x2', '\x923', '\x92F', '\x5', 
		'\x15C', '\xAF', '\x2', '\x924', '\x92F', '\x5', '\x224', '\x113', '\x2', 
		'\x925', '\x92F', '\x5', '\x16C', '\xB7', '\x2', '\x926', '\x92F', '\x5', 
		'\x226', '\x114', '\x2', '\x927', '\x92F', '\x5', '\x1FC', '\xFF', '\x2', 
		'\x928', '\x92F', '\x5', '\x1EE', '\xF8', '\x2', '\x929', '\x92F', '\x5', 
		'\x17A', '\xBE', '\x2', '\x92A', '\x92F', '\x5', '\x222', '\x112', '\x2', 
		'\x92B', '\x92F', '\x5', '\x176', '\xBC', '\x2', '\x92C', '\x92F', '\x5', 
		'\x228', '\x115', '\x2', '\x92D', '\x92F', '\x5', '\x21E', '\x110', '\x2', 
		'\x92E', '\x91D', '\x3', '\x2', '\x2', '\x2', '\x92E', '\x91E', '\x3', 
		'\x2', '\x2', '\x2', '\x92E', '\x91F', '\x3', '\x2', '\x2', '\x2', '\x92E', 
		'\x920', '\x3', '\x2', '\x2', '\x2', '\x92E', '\x921', '\x3', '\x2', '\x2', 
		'\x2', '\x92E', '\x922', '\x3', '\x2', '\x2', '\x2', '\x92E', '\x923', 
		'\x3', '\x2', '\x2', '\x2', '\x92E', '\x924', '\x3', '\x2', '\x2', '\x2', 
		'\x92E', '\x925', '\x3', '\x2', '\x2', '\x2', '\x92E', '\x926', '\x3', 
		'\x2', '\x2', '\x2', '\x92E', '\x927', '\x3', '\x2', '\x2', '\x2', '\x92E', 
		'\x928', '\x3', '\x2', '\x2', '\x2', '\x92E', '\x929', '\x3', '\x2', '\x2', 
		'\x2', '\x92E', '\x92A', '\x3', '\x2', '\x2', '\x2', '\x92E', '\x92B', 
		'\x3', '\x2', '\x2', '\x2', '\x92E', '\x92C', '\x3', '\x2', '\x2', '\x2', 
		'\x92E', '\x92D', '\x3', '\x2', '\x2', '\x2', '\x92F', '\x149', '\x3', 
		'\x2', '\x2', '\x2', '\x930', '\x932', '\x5', '\x152', '\xAA', '\x2', 
		'\x931', '\x933', '\x5', '\x1C', '\xF', '\x2', '\x932', '\x931', '\x3', 
		'\x2', '\x2', '\x2', '\x932', '\x933', '\x3', '\x2', '\x2', '\x2', '\x933', 
		'\x936', '\x3', '\x2', '\x2', '\x2', '\x934', '\x936', '\x5', '\x30', 
		'\x19', '\x2', '\x935', '\x930', '\x3', '\x2', '\x2', '\x2', '\x935', 
		'\x934', '\x3', '\x2', '\x2', '\x2', '\x936', '\x14B', '\x3', '\x2', '\x2', 
		'\x2', '\x937', '\x93A', '\x5', '\x130', '\x99', '\x2', '\x938', '\x939', 
		'\a', '\x1B', '\x2', '\x2', '\x939', '\x93B', '\x5', '\x130', '\x99', 
		'\x2', '\x93A', '\x938', '\x3', '\x2', '\x2', '\x2', '\x93A', '\x93B', 
		'\x3', '\x2', '\x2', '\x2', '\x93B', '\x14D', '\x3', '\x2', '\x2', '\x2', 
		'\x93C', '\x93D', '\t', '\x5', '\x2', '\x2', '\x93D', '\x93E', '\x5', 
		'\x11E', '\x90', '\x2', '\x93E', '\x14F', '\x3', '\x2', '\x2', '\x2', 
		'\x93F', '\x940', '\a', '\xAB', '\x2', '\x2', '\x940', '\x941', '\x5', 
		'\x11E', '\x90', '\x2', '\x941', '\x151', '\x3', '\x2', '\x2', '\x2', 
		'\x942', '\x94C', '\a', '\x14F', '\x2', '\x2', '\x943', '\x94D', '\a', 
		'\x12B', '\x2', '\x2', '\x944', '\x949', '\x5', '\x14C', '\xA7', '\x2', 
		'\x945', '\x946', '\a', '\x32', '\x2', '\x2', '\x946', '\x948', '\x5', 
		'\x14C', '\xA7', '\x2', '\x947', '\x945', '\x3', '\x2', '\x2', '\x2', 
		'\x948', '\x94B', '\x3', '\x2', '\x2', '\x2', '\x949', '\x947', '\x3', 
		'\x2', '\x2', '\x2', '\x949', '\x94A', '\x3', '\x2', '\x2', '\x2', '\x94A', 
		'\x94D', '\x3', '\x2', '\x2', '\x2', '\x94B', '\x949', '\x3', '\x2', '\x2', 
		'\x2', '\x94C', '\x943', '\x3', '\x2', '\x2', '\x2', '\x94C', '\x944', 
		'\x3', '\x2', '\x2', '\x2', '\x94D', '\x94F', '\x3', '\x2', '\x2', '\x2', 
		'\x94E', '\x950', '\x5', '*', '\x16', '\x2', '\x94F', '\x94E', '\x3', 
		'\x2', '\x2', '\x2', '\x94F', '\x950', '\x3', '\x2', '\x2', '\x2', '\x950', 
		'\x952', '\x3', '\x2', '\x2', '\x2', '\x951', '\x953', '\x5', '\x14E', 
		'\xA8', '\x2', '\x952', '\x951', '\x3', '\x2', '\x2', '\x2', '\x952', 
		'\x953', '\x3', '\x2', '\x2', '\x2', '\x953', '\x955', '\x3', '\x2', '\x2', 
		'\x2', '\x954', '\x956', '\x5', '\x150', '\xA9', '\x2', '\x955', '\x954', 
		'\x3', '\x2', '\x2', '\x2', '\x955', '\x956', '\x3', '\x2', '\x2', '\x2', 
		'\x956', '\x958', '\x3', '\x2', '\x2', '\x2', '\x957', '\x959', '\x5', 
		'\x30', '\x19', '\x2', '\x958', '\x957', '\x3', '\x2', '\x2', '\x2', '\x958', 
		'\x959', '\x3', '\x2', '\x2', '\x2', '\x959', '\x153', '\x3', '\x2', '\x2', 
		'\x2', '\x95A', '\x95B', '\a', '\xD5', '\x2', '\x2', '\x95B', '\x95C', 
		'\x5', '\x2EA', '\x176', '\x2', '\x95C', '\x155', '\x3', '\x2', '\x2', 
		'\x2', '\x95D', '\x95E', '\a', '\x127', '\x2', '\x2', '\x95E', '\x95F', 
		'\x5', '\x178', '\xBD', '\x2', '\x95F', '\x157', '\x3', '\x2', '\x2', 
		'\x2', '\x960', '\x963', '\x5', '\x156', '\xAC', '\x2', '\x961', '\x963', 
		'\x5', '\x15A', '\xAE', '\x2', '\x962', '\x960', '\x3', '\x2', '\x2', 
		'\x2', '\x962', '\x961', '\x3', '\x2', '\x2', '\x2', '\x963', '\x159', 
		'\x3', '\x2', '\x2', '\x2', '\x964', '\x96C', '\a', '\x11B', '\x2', '\x2', 
		'\x965', '\x96D', '\x5', '\x15C', '\xAF', '\x2', '\x966', '\x96D', '\x5', 
		'\x162', '\xB2', '\x2', '\x967', '\x96D', '\x5', '\x16A', '\xB6', '\x2', 
		'\x968', '\x96D', '\x5', '\x16E', '\xB8', '\x2', '\x969', '\x96D', '\x5', 
		'\x16C', '\xB7', '\x2', '\x96A', '\x96D', '\x5', '\x17A', '\xBE', '\x2', 
		'\x96B', '\x96D', '\x5', '\x176', '\xBC', '\x2', '\x96C', '\x965', '\x3', 
		'\x2', '\x2', '\x2', '\x96C', '\x966', '\x3', '\x2', '\x2', '\x2', '\x96C', 
		'\x967', '\x3', '\x2', '\x2', '\x2', '\x96C', '\x968', '\x3', '\x2', '\x2', 
		'\x2', '\x96C', '\x969', '\x3', '\x2', '\x2', '\x2', '\x96C', '\x96A', 
		'\x3', '\x2', '\x2', '\x2', '\x96C', '\x96B', '\x3', '\x2', '\x2', '\x2', 
		'\x96D', '\x15B', '\x3', '\x2', '\x2', '\x2', '\x96E', '\x970', '\x5', 
		'\x15E', '\xB0', '\x2', '\x96F', '\x96E', '\x3', '\x2', '\x2', '\x2', 
		'\x96F', '\x970', '\x3', '\x2', '\x2', '\x2', '\x970', '\x971', '\x3', 
		'\x2', '\x2', '\x2', '\x971', '\x972', '\x5', '\x160', '\xB1', '\x2', 
		'\x972', '\x15D', '\x3', '\x2', '\x2', '\x2', '\x973', '\x974', '\t', 
		'\"', '\x2', '\x2', '\x974', '\x15F', '\x3', '\x2', '\x2', '\x2', '\x975', 
		'\x977', '\x5', '\x25A', '\x12E', '\x2', '\x976', '\x978', '\x5', '\x14A', 
		'\xA6', '\x2', '\x977', '\x976', '\x3', '\x2', '\x2', '\x2', '\x977', 
		'\x978', '\x3', '\x2', '\x2', '\x2', '\x978', '\x97A', '\x3', '\x2', '\x2', 
		'\x2', '\x979', '\x97B', '\x5', '\x158', '\xAD', '\x2', '\x97A', '\x979', 
		'\x3', '\x2', '\x2', '\x2', '\x97A', '\x97B', '\x3', '\x2', '\x2', '\x2', 
		'\x97B', '\x161', '\x3', '\x2', '\x2', '\x2', '\x97C', '\x97E', '\a', 
		'\x15', '\x2', '\x2', '\x97D', '\x97C', '\x3', '\x2', '\x2', '\x2', '\x97D', 
		'\x97E', '\x3', '\x2', '\x2', '\x2', '\x97E', '\x97F', '\x3', '\x2', '\x2', 
		'\x2', '\x97F', '\x99A', '\x5', '\x168', '\xB5', '\x2', '\x980', '\x982', 
		'\x5', '\x164', '\xB3', '\x2', '\x981', '\x980', '\x3', '\x2', '\x2', 
		'\x2', '\x981', '\x982', '\x3', '\x2', '\x2', '\x2', '\x982', '\x983', 
		'\x3', '\x2', '\x2', '\x2', '\x983', '\x984', '\x5', '\x166', '\xB4', 
		'\x2', '\x984', '\x985', '\x5', '\x168', '\xB5', '\x2', '\x985', '\x99A', 
		'\x3', '\x2', '\x2', '\x2', '\x986', '\x988', '\x5', '\x164', '\xB3', 
		'\x2', '\x987', '\x986', '\x3', '\x2', '\x2', '\x2', '\x987', '\x988', 
		'\x3', '\x2', '\x2', '\x2', '\x988', '\x989', '\x3', '\x2', '\x2', '\x2', 
		'\x989', '\x98A', '\a', '\xA0', '\x2', '\x2', '\x98A', '\x99A', '\x5', 
		'\x168', '\xB5', '\x2', '\x98B', '\x98D', '\x5', '\x164', '\xB3', '\x2', 
		'\x98C', '\x98B', '\x3', '\x2', '\x2', '\x2', '\x98C', '\x98D', '\x3', 
		'\x2', '\x2', '\x2', '\x98D', '\x98E', '\x3', '\x2', '\x2', '\x2', '\x98E', 
		'\x98F', '\a', '\xEA', '\x2', '\x2', '\x98F', '\x990', '\a', '\x136', 
		'\x2', '\x2', '\x990', '\x99A', '\x5', '\x168', '\xB5', '\x2', '\x991', 
		'\x993', '\x5', '\x164', '\xB3', '\x2', '\x992', '\x991', '\x3', '\x2', 
		'\x2', '\x2', '\x992', '\x993', '\x3', '\x2', '\x2', '\x2', '\x993', '\x995', 
		'\x3', '\x2', '\x2', '\x2', '\x994', '\x996', '\a', '\xEA', '\x2', '\x2', 
		'\x995', '\x994', '\x3', '\x2', '\x2', '\x2', '\x995', '\x996', '\x3', 
		'\x2', '\x2', '\x2', '\x996', '\x997', '\x3', '\x2', '\x2', '\x2', '\x997', 
		'\x998', '\t', '#', '\x2', '\x2', '\x998', '\x99A', '\x5', '\x168', '\xB5', 
		'\x2', '\x999', '\x97D', '\x3', '\x2', '\x2', '\x2', '\x999', '\x981', 
		'\x3', '\x2', '\x2', '\x2', '\x999', '\x987', '\x3', '\x2', '\x2', '\x2', 
		'\x999', '\x98C', '\x3', '\x2', '\x2', '\x2', '\x999', '\x992', '\x3', 
		'\x2', '\x2', '\x2', '\x99A', '\x163', '\x3', '\x2', '\x2', '\x2', '\x99B', 
		'\x99E', '\a', '\xC5', '\x2', '\x2', '\x99C', '\x99E', '\t', '$', '\x2', 
		'\x2', '\x99D', '\x99B', '\x3', '\x2', '\x2', '\x2', '\x99D', '\x99C', 
		'\x3', '\x2', '\x2', '\x2', '\x99E', '\x165', '\x3', '\x2', '\x2', '\x2', 
		'\x99F', '\x9A6', '\a', 'n', '\x2', '\x2', '\x9A0', '\x9A6', '\a', 'm', 
		'\x2', '\x2', '\x9A1', '\x9A2', '\a', '\xEA', '\x2', '\x2', '\x9A2', '\x9A6', 
		'\a', 'n', '\x2', '\x2', '\x9A3', '\x9A4', '\a', '\xEA', '\x2', '\x2', 
		'\x9A4', '\x9A6', '\a', 'm', '\x2', '\x2', '\x9A5', '\x99F', '\x3', '\x2', 
		'\x2', '\x2', '\x9A5', '\x9A0', '\x3', '\x2', '\x2', '\x2', '\x9A5', '\x9A1', 
		'\x3', '\x2', '\x2', '\x2', '\x9A5', '\x9A3', '\x3', '\x2', '\x2', '\x2', 
		'\x9A6', '\x167', '\x3', '\x2', '\x2', '\x2', '\x9A7', '\x9A9', '\x5', 
		'\x25C', '\x12F', '\x2', '\x9A8', '\x9AA', '\x5', '\x14A', '\xA6', '\x2', 
		'\x9A9', '\x9A8', '\x3', '\x2', '\x2', '\x2', '\x9A9', '\x9AA', '\x3', 
		'\x2', '\x2', '\x2', '\x9AA', '\x9AC', '\x3', '\x2', '\x2', '\x2', '\x9AB', 
		'\x9AD', '\x5', '\x158', '\xAD', '\x2', '\x9AC', '\x9AB', '\x3', '\x2', 
		'\x2', '\x2', '\x9AC', '\x9AD', '\x3', '\x2', '\x2', '\x2', '\x9AD', '\x169', 
		'\x3', '\x2', '\x2', '\x2', '\x9AE', '\x9AF', '\a', '\x41', '\x2', '\x2', 
		'\x9AF', '\x9B0', '\a', '\x82', '\x2', '\x2', '\x9B0', '\x9B2', '\a', 
		'\x136', '\x2', '\x2', '\x9B1', '\x9B3', '\x5', '\x14A', '\xA6', '\x2', 
		'\x9B2', '\x9B1', '\x3', '\x2', '\x2', '\x2', '\x9B2', '\x9B3', '\x3', 
		'\x2', '\x2', '\x2', '\x9B3', '\x9B5', '\x3', '\x2', '\x2', '\x2', '\x9B4', 
		'\x9B6', '\x5', '\x158', '\xAD', '\x2', '\x9B5', '\x9B4', '\x3', '\x2', 
		'\x2', '\x2', '\x9B5', '\x9B6', '\x3', '\x2', '\x2', '\x2', '\x9B6', '\x16B', 
		'\x3', '\x2', '\x2', '\x2', '\x9B7', '\x9B9', '\t', '%', '\x2', '\x2', 
		'\x9B8', '\x9BA', '\x5', '\x172', '\xBA', '\x2', '\x9B9', '\x9B8', '\x3', 
		'\x2', '\x2', '\x2', '\x9B9', '\x9BA', '\x3', '\x2', '\x2', '\x2', '\x9BA', 
		'\x9BC', '\x3', '\x2', '\x2', '\x2', '\x9BB', '\x9BD', '\x5', '\x14A', 
		'\xA6', '\x2', '\x9BC', '\x9BB', '\x3', '\x2', '\x2', '\x2', '\x9BC', 
		'\x9BD', '\x3', '\x2', '\x2', '\x2', '\x9BD', '\x9BF', '\x3', '\x2', '\x2', 
		'\x2', '\x9BE', '\x9C0', '\x5', '\x158', '\xAD', '\x2', '\x9BF', '\x9BE', 
		'\x3', '\x2', '\x2', '\x2', '\x9BF', '\x9C0', '\x3', '\x2', '\x2', '\x2', 
		'\x9C0', '\x16D', '\x3', '\x2', '\x2', '\x2', '\x9C1', '\x9C3', '\x5', 
		'\x174', '\xBB', '\x2', '\x9C2', '\x9C1', '\x3', '\x2', '\x2', '\x2', 
		'\x9C2', '\x9C3', '\x3', '\x2', '\x2', '\x2', '\x9C3', '\x9C4', '\x3', 
		'\x2', '\x2', '\x2', '\x9C4', '\x9C6', '\x5', '\x170', '\xB9', '\x2', 
		'\x9C5', '\x9C7', '\x5', '\x172', '\xBA', '\x2', '\x9C6', '\x9C5', '\x3', 
		'\x2', '\x2', '\x2', '\x9C6', '\x9C7', '\x3', '\x2', '\x2', '\x2', '\x9C7', 
		'\x9C9', '\x3', '\x2', '\x2', '\x2', '\x9C8', '\x9CA', '\x5', '\x14A', 
		'\xA6', '\x2', '\x9C9', '\x9C8', '\x3', '\x2', '\x2', '\x2', '\x9C9', 
		'\x9CA', '\x3', '\x2', '\x2', '\x2', '\x9CA', '\x9CC', '\x3', '\x2', '\x2', 
		'\x2', '\x9CB', '\x9CD', '\x5', '\x158', '\xAD', '\x2', '\x9CC', '\x9CB', 
		'\x3', '\x2', '\x2', '\x2', '\x9CC', '\x9CD', '\x3', '\x2', '\x2', '\x2', 
		'\x9CD', '\x16F', '\x3', '\x2', '\x2', '\x2', '\x9CE', '\x9CF', '\t', 
		'&', '\x2', '\x2', '\x9CF', '\x171', '\x3', '\x2', '\x2', '\x2', '\x9D0', 
		'\x9D7', '\a', 'k', '\x2', '\x2', '\x9D1', '\x9D5', '\a', ')', '\x2', 
		'\x2', '\x9D2', '\x9D3', '\a', '\x41', '\x2', '\x2', '\x9D3', '\x9D6', 
		'\a', '\x13F', '\x2', '\x2', '\x9D4', '\x9D6', '\x5', '\x2F4', '\x17B', 
		'\x2', '\x9D5', '\x9D2', '\x3', '\x2', '\x2', '\x2', '\x9D5', '\x9D4', 
		'\x3', '\x2', '\x2', '\x2', '\x9D6', '\x9D8', '\x3', '\x2', '\x2', '\x2', 
		'\x9D7', '\x9D1', '\x3', '\x2', '\x2', '\x2', '\x9D7', '\x9D8', '\x3', 
		'\x2', '\x2', '\x2', '\x9D8', '\x173', '\x3', '\x2', '\x2', '\x2', '\x9D9', 
		'\x9DF', '\a', '\x15', '\x2', '\x2', '\x9DA', '\x9DB', '\a', '(', '\x2', 
		'\x2', '\x9DB', '\x9DF', '\a', '\x8E', '\x2', '\x2', '\x9DC', '\x9DD', 
		'\a', '\x13F', '\x2', '\x2', '\x9DD', '\x9DF', '\a', 'K', '\x2', '\x2', 
		'\x9DE', '\x9D9', '\x3', '\x2', '\x2', '\x2', '\x9DE', '\x9DA', '\x3', 
		'\x2', '\x2', '\x2', '\x9DE', '\x9DC', '\x3', '\x2', '\x2', '\x2', '\x9DF', 
		'\x175', '\x3', '\x2', '\x2', '\x2', '\x9E0', '\x9E1', '\x5', '\x25E', 
		'\x130', '\x2', '\x9E1', '\x9E2', '\x5', '\x17E', '\xC0', '\x2', '\x9E2', 
		'\x177', '\x3', '\x2', '\x2', '\x2', '\x9E3', '\x9E4', '\x5', '\x25E', 
		'\x130', '\x2', '\x9E4', '\x9E6', '\x5', '\x180', '\xC1', '\x2', '\x9E5', 
		'\x9E7', '\x5', '\x14A', '\xA6', '\x2', '\x9E6', '\x9E5', '\x3', '\x2', 
		'\x2', '\x2', '\x9E6', '\x9E7', '\x3', '\x2', '\x2', '\x2', '\x9E7', '\x9E9', 
		'\x3', '\x2', '\x2', '\x2', '\x9E8', '\x9EA', '\x5', '\x158', '\xAD', 
		'\x2', '\x9E9', '\x9E8', '\x3', '\x2', '\x2', '\x2', '\x9E9', '\x9EA', 
		'\x3', '\x2', '\x2', '\x2', '\x9EA', '\x179', '\x3', '\x2', '\x2', '\x2', 
		'\x9EB', '\x9EC', '\x5', '\x17C', '\xBF', '\x2', '\x9EC', '\x9ED', '\x5', 
		'\x17E', '\xC0', '\x2', '\x9ED', '\x17B', '\x3', '\x2', '\x2', '\x2', 
		'\x9EE', '\x9EF', '\t', '\'', '\x2', '\x2', '\x9EF', '\x17D', '\x3', '\x2', 
		'\x2', '\x2', '\x9F0', '\x9F2', '\x5', '\x14A', '\xA6', '\x2', '\x9F1', 
		'\x9F0', '\x3', '\x2', '\x2', '\x2', '\x9F1', '\x9F2', '\x3', '\x2', '\x2', 
		'\x2', '\x9F2', '\x9F8', '\x3', '\x2', '\x2', '\x2', '\x9F3', '\x9F5', 
		'\x5', '\x180', '\xC1', '\x2', '\x9F4', '\x9F6', '\x5', '\x14A', '\xA6', 
		'\x2', '\x9F5', '\x9F4', '\x3', '\x2', '\x2', '\x2', '\x9F5', '\x9F6', 
		'\x3', '\x2', '\x2', '\x2', '\x9F6', '\x9F8', '\x3', '\x2', '\x2', '\x2', 
		'\x9F7', '\x9F1', '\x3', '\x2', '\x2', '\x2', '\x9F7', '\x9F3', '\x3', 
		'\x2', '\x2', '\x2', '\x9F8', '\x9FA', '\x3', '\x2', '\x2', '\x2', '\x9F9', 
		'\x9FB', '\x5', '\x158', '\xAD', '\x2', '\x9FA', '\x9F9', '\x3', '\x2', 
		'\x2', '\x2', '\x9FA', '\x9FB', '\x3', '\x2', '\x2', '\x2', '\x9FB', '\x17F', 
		'\x3', '\x2', '\x2', '\x2', '\x9FC', '\x9FF', '\x5', '\x2E0', '\x171', 
		'\x2', '\x9FD', '\x9FF', '\x5', '\xBC', '_', '\x2', '\x9FE', '\x9FC', 
		'\x3', '\x2', '\x2', '\x2', '\x9FE', '\x9FD', '\x3', '\x2', '\x2', '\x2', 
		'\x9FF', '\x181', '\x3', '\x2', '\x2', '\x2', '\xA00', '\xA01', '\a', 
		'\xB0', '\x2', '\x2', '\xA01', '\xA02', '\x5', '\x130', '\x99', '\x2', 
		'\xA02', '\xA03', '\x5', '\x9A', 'N', '\x2', '\xA03', '\xA04', '\a', '\x109', 
		'\x2', '\x2', '\xA04', '\x183', '\x3', '\x2', '\x2', '\x2', '\xA05', '\xA06', 
		'\a', '\xB0', '\x2', '\x2', '\xA06', '\xA08', '\a', '\x109', '\x2', '\x2', 
		'\xA07', '\xA09', '\x5', '\xA6', 'T', '\x2', '\xA08', '\xA07', '\x3', 
		'\x2', '\x2', '\x2', '\xA08', '\xA09', '\x3', '\x2', '\x2', '\x2', '\xA09', 
		'\xA0A', '\x3', '\x2', '\x2', '\x2', '\xA0A', '\xA0B', '\x5', '\xA8', 
		'U', '\x2', '\xA0B', '\xA0C', '\a', '\xA6', '\x2', '\x2', '\xA0C', '\xA0D', 
		'\x5', '\x130', '\x99', '\x2', '\xA0D', '\xA0E', '\x5', '\x9C', 'O', '\x2', 
		'\xA0E', '\xA0F', '\a', '\xEF', '\x2', '\x2', '\xA0F', '\xA11', '\x5', 
		'\xA8', 'U', '\x2', '\xA10', '\xA12', '\x5', '\xAA', 'V', '\x2', '\xA11', 
		'\xA10', '\x3', '\x2', '\x2', '\x2', '\xA11', '\xA12', '\x3', '\x2', '\x2', 
		'\x2', '\xA12', '\xA13', '\x3', '\x2', '\x2', '\x2', '\xA13', '\xA14', 
		'\a', '\xB0', '\x2', '\x2', '\xA14', '\xA15', '\a', '\x109', '\x2', '\x2', 
		'\xA15', '\x185', '\x3', '\x2', '\x2', '\x2', '\xA16', '\xA18', '\a', 
		'\x37', '\x2', '\x2', '\xA17', '\xA19', '\x5', '\x2D2', '\x16A', '\x2', 
		'\xA18', '\xA17', '\x3', '\x2', '\x2', '\x2', '\xA18', '\xA19', '\x3', 
		'\x2', '\x2', '\x2', '\xA19', '\xA1D', '\x3', '\x2', '\x2', '\x2', '\xA1A', 
		'\xA1B', '\a', '\x8B', '\x2', '\x2', '\xA1B', '\xA1C', '\a', '\xCB', '\x2', 
		'\x2', '\xA1C', '\xA1E', '\a', 'o', '\x2', '\x2', '\xA1D', '\xA1A', '\x3', 
		'\x2', '\x2', '\x2', '\xA1D', '\xA1E', '\x3', '\x2', '\x2', '\x2', '\xA1E', 
		'\xA1F', '\x3', '\x2', '\x2', '\x2', '\xA1F', '\xA22', '\a', 'y', '\x2', 
		'\x2', '\xA20', '\xA23', '\x5', '\x182', '\xC2', '\x2', '\xA21', '\xA23', 
		'\x5', '\x184', '\xC3', '\x2', '\xA22', '\xA20', '\x3', '\x2', '\x2', 
		'\x2', '\xA22', '\xA21', '\x3', '\x2', '\x2', '\x2', '\xA23', '\xA24', 
		'\x3', '\x2', '\x2', '\x2', '\xA24', '\xA26', '\x5', '\x188', '\xC5', 
		'\x2', '\xA25', '\xA27', '\x5', '\x154', '\xAB', '\x2', '\xA26', '\xA25', 
		'\x3', '\x2', '\x2', '\x2', '\xA26', '\xA27', '\x3', '\x2', '\x2', '\x2', 
		'\xA27', '\x187', '\x3', '\x2', '\x2', '\x2', '\xA28', '\xA29', '\a', 
		'\xFF', '\x2', '\x2', '\xA29', '\xA2D', '\x5', '\x19E', '\xD0', '\x2', 
		'\xA2A', '\xA2E', '\a', '\x31', '\x2', '\x2', '\xA2B', '\xA2C', '\a', 
		'\x9E', '\x2', '\x2', '\xA2C', '\xA2E', '\t', '\x14', '\x2', '\x2', '\xA2D', 
		'\xA2A', '\x3', '\x2', '\x2', '\x2', '\xA2D', '\xA2B', '\x3', '\x2', '\x2', 
		'\x2', '\xA2E', '\xA2F', '\x3', '\x2', '\x2', '\x2', '\xA2F', '\xA30', 
		'\x5', '\x134', '\x9B', '\x2', '\xA30', '\xA48', '\x3', '\x2', '\x2', 
		'\x2', '\xA31', '\xA32', '\a', '\xFF', '\x2', '\x2', '\xA32', '\xA33', 
		'\x5', '\x19E', '\xD0', '\x2', '\xA33', '\xA35', '\a', '\x9E', '\x2', 
		'\x2', '\xA34', '\xA36', '\t', '(', '\x2', '\x2', '\xA35', '\xA34', '\x3', 
		'\x2', '\x2', '\x2', '\xA35', '\xA36', '\x3', '\x2', '\x2', '\x2', '\xA36', 
		'\xA37', '\x3', '\x2', '\x2', '\x2', '\xA37', '\xA38', '\a', '\x13A', 
		'\x2', '\x2', '\xA38', '\xA48', '\x3', '\x2', '\x2', '\x2', '\xA39', '\xA3A', 
		'\a', '\xFF', '\x2', '\x2', '\xA3A', '\xA3B', '\x5', '\x19E', '\xD0', 
		'\x2', '\xA3B', '\xA3D', '\a', '\x9E', '\x2', '\x2', '\xA3C', '\xA3E', 
		'\t', '(', '\x2', '\x2', '\xA3D', '\xA3C', '\x3', '\x2', '\x2', '\x2', 
		'\xA3D', '\xA3E', '\x3', '\x2', '\x2', '\x2', '\xA3E', '\xA3F', '\x3', 
		'\x2', '\x2', '\x2', '\xA3F', '\xA40', '\a', '\xA0', '\x2', '\x2', '\xA40', 
		'\xA48', '\x3', '\x2', '\x2', '\x2', '\xA41', '\xA42', '\a', '\xFF', '\x2', 
		'\x2', '\xA42', '\xA43', '\x5', '\x19E', '\xD0', '\x2', '\xA43', '\xA44', 
		'\a', '\x9E', '\x2', '\x2', '\xA44', '\xA45', '\a', '\xCB', '\x2', '\x2', 
		'\xA45', '\xA46', '\a', '\xCE', '\x2', '\x2', '\xA46', '\xA48', '\x3', 
		'\x2', '\x2', '\x2', '\xA47', '\xA28', '\x3', '\x2', '\x2', '\x2', '\xA47', 
		'\xA31', '\x3', '\x2', '\x2', '\x2', '\xA47', '\xA39', '\x3', '\x2', '\x2', 
		'\x2', '\xA47', '\xA41', '\x3', '\x2', '\x2', '\x2', '\xA48', '\x189', 
		'\x3', '\x2', '\x2', '\x2', '\xA49', '\xA4A', '\a', '\x37', '\x2', '\x2', 
		'\xA4A', '\xA4D', '\x5', '\x2D2', '\x16A', '\x2', '\xA4B', '\xA4C', '\a', 
		'\x8B', '\x2', '\x2', '\xA4C', '\xA4E', '\a', 'o', '\x2', '\x2', '\xA4D', 
		'\xA4B', '\x3', '\x2', '\x2', '\x2', '\xA4D', '\xA4E', '\x3', '\x2', '\x2', 
		'\x2', '\xA4E', '\x18B', '\x3', '\x2', '\x2', '\x2', '\xA4F', '\xA50', 
		'\a', '\xEE', '\x2', '\x2', '\xA50', '\xA51', '\a', '\x8F', '\x2', '\x2', 
		'\xA51', '\xA64', '\x5', '\x18E', '\xC8', '\x2', '\xA52', '\xA53', '\a', 
		'\x128', '\x2', '\x2', '\xA53', '\xA54', '\a', '\x8F', '\x2', '\x2', '\xA54', 
		'\xA64', '\x5', '\x18E', '\xC8', '\x2', '\xA55', '\xA56', '\a', '\xE0', 
		'\x2', '\x2', '\xA56', '\xA57', '\a', '\x8F', '\x2', '\x2', '\xA57', '\xA64', 
		'\x5', '\x18E', '\xC8', '\x2', '\xA58', '\xA59', '\a', '\x144', '\x2', 
		'\x2', '\xA59', '\xA5A', '\a', '\x8F', '\x2', '\x2', '\xA5A', '\xA64', 
		'\x5', '\x18E', '\xC8', '\x2', '\xA5B', '\xA5C', '\a', '\xAF', '\x2', 
		'\x2', '\xA5C', '\xA5D', '\a', '\x8F', '\x2', '\x2', '\xA5D', '\xA64', 
		'\x5', '\x196', '\xCC', '\x2', '\xA5E', '\xA5F', '\a', '}', '\x2', '\x2', 
		'\xA5F', '\xA60', '\a', '\x8F', '\x2', '\x2', '\xA60', '\xA64', '\x5', 
		'\x190', '\xC9', '\x2', '\xA61', '\xA62', '\a', '\x8F', '\x2', '\x2', 
		'\xA62', '\xA64', '\x5', '\x18E', '\xC8', '\x2', '\xA63', '\xA4F', '\x3', 
		'\x2', '\x2', '\x2', '\xA63', '\xA52', '\x3', '\x2', '\x2', '\x2', '\xA63', 
		'\xA55', '\x3', '\x2', '\x2', '\x2', '\xA63', '\xA58', '\x3', '\x2', '\x2', 
		'\x2', '\xA63', '\xA5B', '\x3', '\x2', '\x2', '\x2', '\xA63', '\xA5E', 
		'\x3', '\x2', '\x2', '\x2', '\xA63', '\xA61', '\x3', '\x2', '\x2', '\x2', 
		'\xA64', '\x18D', '\x3', '\x2', '\x2', '\x2', '\xA65', '\xA67', '\x5', 
		'\x2D2', '\x16A', '\x2', '\xA66', '\xA65', '\x3', '\x2', '\x2', '\x2', 
		'\xA66', '\xA67', '\x3', '\x2', '\x2', '\x2', '\xA67', '\xA6B', '\x3', 
		'\x2', '\x2', '\x2', '\xA68', '\xA69', '\a', '\x8B', '\x2', '\x2', '\xA69', 
		'\xA6A', '\a', '\xCB', '\x2', '\x2', '\xA6A', '\xA6C', '\a', 'o', '\x2', 
		'\x2', '\xA6B', '\xA68', '\x3', '\x2', '\x2', '\x2', '\xA6B', '\xA6C', 
		'\x3', '\x2', '\x2', '\x2', '\xA6C', '\xA6D', '\x3', '\x2', '\x2', '\x2', 
		'\xA6D', '\xA70', '\a', 'y', '\x2', '\x2', '\xA6E', '\xA71', '\x5', '\x182', 
		'\xC2', '\x2', '\xA6F', '\xA71', '\x5', '\x184', '\xC3', '\x2', '\xA70', 
		'\xA6E', '\x3', '\x2', '\x2', '\x2', '\xA70', '\xA6F', '\x3', '\x2', '\x2', 
		'\x2', '\xA71', '\xA72', '\x3', '\x2', '\x2', '\x2', '\xA72', '\xA73', 
		'\a', '\xD2', '\x2', '\x2', '\xA73', '\xA75', '\x5', '\x19E', '\xD0', 
		'\x2', '\xA74', '\xA76', '\x5', '\x154', '\xAB', '\x2', '\xA75', '\xA74', 
		'\x3', '\x2', '\x2', '\x2', '\xA75', '\xA76', '\x3', '\x2', '\x2', '\x2', 
		'\xA76', '\x18F', '\x3', '\x2', '\x2', '\x2', '\xA77', '\xA79', '\x5', 
		'\x2D2', '\x16A', '\x2', '\xA78', '\xA77', '\x3', '\x2', '\x2', '\x2', 
		'\xA78', '\xA79', '\x3', '\x2', '\x2', '\x2', '\xA79', '\xA7D', '\x3', 
		'\x2', '\x2', '\x2', '\xA7A', '\xA7B', '\a', '\x8B', '\x2', '\x2', '\xA7B', 
		'\xA7C', '\a', '\xCB', '\x2', '\x2', '\xA7C', '\xA7E', '\a', 'o', '\x2', 
		'\x2', '\xA7D', '\xA7A', '\x3', '\x2', '\x2', '\x2', '\xA7D', '\xA7E', 
		'\x3', '\x2', '\x2', '\x2', '\xA7E', '\xA7F', '\x3', '\x2', '\x2', '\x2', 
		'\xA7F', '\xA82', '\a', 'y', '\x2', '\x2', '\xA80', '\xA83', '\x5', '\x192', 
		'\xCA', '\x2', '\xA81', '\xA83', '\x5', '\x194', '\xCB', '\x2', '\xA82', 
		'\xA80', '\x3', '\x2', '\x2', '\x2', '\xA82', '\xA81', '\x3', '\x2', '\x2', 
		'\x2', '\xA83', '\xA84', '\x3', '\x2', '\x2', '\x2', '\xA84', '\xA85', 
		'\a', '\xD2', '\x2', '\x2', '\xA85', '\xA86', '\a', '_', '\x2', '\x2', 
		'\xA86', '\xA87', '\a', '\xA6', '\x2', '\x2', '\xA87', '\xA88', '\x5', 
		'\x1A0', '\xD1', '\x2', '\xA88', '\xA8A', '\a', '\xEF', '\x2', '\x2', 
		'\xA89', '\xA8B', '\x5', '\x154', '\xAB', '\x2', '\xA8A', '\xA89', '\x3', 
		'\x2', '\x2', '\x2', '\xA8A', '\xA8B', '\x3', '\x2', '\x2', '\x2', '\xA8B', 
		'\x191', '\x3', '\x2', '\x2', '\x2', '\xA8C', '\xA8D', '\a', '\xB0', '\x2', 
		'\x2', '\xA8D', '\xA8E', '\x5', '\x130', '\x99', '\x2', '\xA8E', '\xA8F', 
		'\a', '\x30', '\x2', '\x2', '\xA8F', '\xA94', '\x5', '\x2F4', '\x17B', 
		'\x2', '\xA90', '\xA91', '\a', '!', '\x2', '\x2', '\xA91', '\xA93', '\x5', 
		'\x2F4', '\x17B', '\x2', '\xA92', '\xA90', '\x3', '\x2', '\x2', '\x2', 
		'\xA93', '\xA96', '\x3', '\x2', '\x2', '\x2', '\xA94', '\xA92', '\x3', 
		'\x2', '\x2', '\x2', '\xA94', '\xA95', '\x3', '\x2', '\x2', '\x2', '\xA95', 
		'\xA97', '\x3', '\x2', '\x2', '\x2', '\xA96', '\xA94', '\x3', '\x2', '\x2', 
		'\x2', '\xA97', '\xA98', '\a', '\x109', '\x2', '\x2', '\xA98', '\x193', 
		'\x3', '\x2', '\x2', '\x2', '\xA99', '\xA9A', '\a', '\xB0', '\x2', '\x2', 
		'\xA9A', '\xA9C', '\a', '\x109', '\x2', '\x2', '\xA9B', '\xA9D', '\x5', 
		'\xA6', 'T', '\x2', '\xA9C', '\xA9B', '\x3', '\x2', '\x2', '\x2', '\xA9C', 
		'\xA9D', '\x3', '\x2', '\x2', '\x2', '\xA9D', '\xA9E', '\x3', '\x2', '\x2', 
		'\x2', '\xA9E', '\xA9F', '\x5', '\xA8', 'U', '\x2', '\xA9F', '\xAA0', 
		'\a', '\xA6', '\x2', '\x2', '\xAA0', '\xAA1', '\x5', '\x130', '\x99', 
		'\x2', '\xAA1', '\xAA2', '\a', '\x30', '\x2', '\x2', '\xAA2', '\xAA7', 
		'\x5', '\x2F4', '\x17B', '\x2', '\xAA3', '\xAA4', '\a', '!', '\x2', '\x2', 
		'\xAA4', '\xAA6', '\x5', '\x2F4', '\x17B', '\x2', '\xAA5', '\xAA3', '\x3', 
		'\x2', '\x2', '\x2', '\xAA6', '\xAA9', '\x3', '\x2', '\x2', '\x2', '\xAA7', 
		'\xAA5', '\x3', '\x2', '\x2', '\x2', '\xAA7', '\xAA8', '\x3', '\x2', '\x2', 
		'\x2', '\xAA8', '\xAAA', '\x3', '\x2', '\x2', '\x2', '\xAA9', '\xAA7', 
		'\x3', '\x2', '\x2', '\x2', '\xAAA', '\xAAB', '\a', '\xEF', '\x2', '\x2', 
		'\xAAB', '\xAAD', '\x5', '\xA8', 'U', '\x2', '\xAAC', '\xAAE', '\x5', 
		'\xAA', 'V', '\x2', '\xAAD', '\xAAC', '\x3', '\x2', '\x2', '\x2', '\xAAD', 
		'\xAAE', '\x3', '\x2', '\x2', '\x2', '\xAAE', '\xAAF', '\x3', '\x2', '\x2', 
		'\x2', '\xAAF', '\xAB0', '\a', '\xB0', '\x2', '\x2', '\xAB0', '\xAB1', 
		'\a', '\x109', '\x2', '\x2', '\xAB1', '\x195', '\x3', '\x2', '\x2', '\x2', 
		'\xAB2', '\xAB4', '\x5', '\x2D2', '\x16A', '\x2', '\xAB3', '\xAB2', '\x3', 
		'\x2', '\x2', '\x2', '\xAB3', '\xAB4', '\x3', '\x2', '\x2', '\x2', '\xAB4', 
		'\xAB8', '\x3', '\x2', '\x2', '\x2', '\xAB5', '\xAB6', '\a', '\x8B', '\x2', 
		'\x2', '\xAB6', '\xAB7', '\a', '\xCB', '\x2', '\x2', '\xAB7', '\xAB9', 
		'\a', 'o', '\x2', '\x2', '\xAB8', '\xAB5', '\x3', '\x2', '\x2', '\x2', 
		'\xAB8', '\xAB9', '\x3', '\x2', '\x2', '\x2', '\xAB9', '\xABA', '\x3', 
		'\x2', '\x2', '\x2', '\xABA', '\xABD', '\a', 'y', '\x2', '\x2', '\xABB', 
		'\xABE', '\x5', '\x198', '\xCD', '\x2', '\xABC', '\xABE', '\x5', '\x19A', 
		'\xCE', '\x2', '\xABD', '\xABB', '\x3', '\x2', '\x2', '\x2', '\xABD', 
		'\xABC', '\x3', '\x2', '\x2', '\x2', '\xABE', '\xABF', '\x3', '\x2', '\x2', 
		'\x2', '\xABF', '\xAC0', '\x5', '\x2F4', '\x17B', '\x2', '\xAC0', '\xAC1', 
		'\a', '\xB0', '\x2', '\x2', '\xAC1', '\xAC2', '\x5', '\x130', '\x99', 
		'\x2', '\xAC2', '\xAC4', '\a', '\x109', '\x2', '\x2', '\xAC3', '\xAC5', 
		'\x5', '\x154', '\xAB', '\x2', '\xAC4', '\xAC3', '\x3', '\x2', '\x2', 
		'\x2', '\xAC4', '\xAC5', '\x3', '\x2', '\x2', '\x2', '\xAC5', '\x197', 
		'\x3', '\x2', '\x2', '\x2', '\xAC6', '\xAC7', '\a', '\xB0', '\x2', '\x2', 
		'\xAC7', '\xAC8', '\x5', '\x130', '\x99', '\x2', '\xAC8', '\xAC9', '\a', 
		'\x109', '\x2', '\x2', '\xAC9', '\xACA', '\a', '\xD2', '\x2', '\x2', '\xACA', 
		'\xACB', '\a', '_', '\x2', '\x2', '\xACB', '\x199', '\x3', '\x2', '\x2', 
		'\x2', '\xACC', '\xACD', '\a', '\xB0', '\x2', '\x2', '\xACD', '\xACF', 
		'\a', '\x109', '\x2', '\x2', '\xACE', '\xAD0', '\x5', '\xA6', 'T', '\x2', 
		'\xACF', '\xACE', '\x3', '\x2', '\x2', '\x2', '\xACF', '\xAD0', '\x3', 
		'\x2', '\x2', '\x2', '\xAD0', '\xAD1', '\x3', '\x2', '\x2', '\x2', '\xAD1', 
		'\xAD2', '\x5', '\xA8', 'U', '\x2', '\xAD2', '\xAD3', '\a', '\xA6', '\x2', 
		'\x2', '\xAD3', '\xAD4', '\x5', '\x130', '\x99', '\x2', '\xAD4', '\xAD5', 
		'\a', '\xEF', '\x2', '\x2', '\xAD5', '\xAD7', '\x5', '\xA8', 'U', '\x2', 
		'\xAD6', '\xAD8', '\x5', '\xAA', 'V', '\x2', '\xAD7', '\xAD6', '\x3', 
		'\x2', '\x2', '\x2', '\xAD7', '\xAD8', '\x3', '\x2', '\x2', '\x2', '\xAD8', 
		'\xAD9', '\x3', '\x2', '\x2', '\x2', '\xAD9', '\xADA', '\a', '\xB0', '\x2', 
		'\x2', '\xADA', '\xADB', '\a', '\x109', '\x2', '\x2', '\xADB', '\xADD', 
		'\a', '\xD2', '\x2', '\x2', '\xADC', '\xADE', '\a', '_', '\x2', '\x2', 
		'\xADD', '\xADC', '\x3', '\x2', '\x2', '\x2', '\xADD', '\xADE', '\x3', 
		'\x2', '\x2', '\x2', '\xADE', '\x19B', '\x3', '\x2', '\x2', '\x2', '\xADF', 
		'\xAE0', '\a', '\x8F', '\x2', '\x2', '\xAE0', '\xAE3', '\x5', '\x2D2', 
		'\x16A', '\x2', '\xAE1', '\xAE2', '\a', '\x8B', '\x2', '\x2', '\xAE2', 
		'\xAE4', '\a', 'o', '\x2', '\x2', '\xAE3', '\xAE1', '\x3', '\x2', '\x2', 
		'\x2', '\xAE3', '\xAE4', '\x3', '\x2', '\x2', '\x2', '\xAE4', '\x19D', 
		'\x3', '\x2', '\x2', '\x2', '\xAE5', '\xAE6', '\x5', '\x130', '\x99', 
		'\x2', '\xAE6', '\xAE7', '\x5', '\xD8', 'm', '\x2', '\xAE7', '\xAED', 
		'\x3', '\x2', '\x2', '\x2', '\xAE8', '\xAE9', '\a', '\xB0', '\x2', '\x2', 
		'\xAE9', '\xAEA', '\x5', '\x1A0', '\xD1', '\x2', '\xAEA', '\xAEB', '\a', 
		'\x109', '\x2', '\x2', '\xAEB', '\xAED', '\x3', '\x2', '\x2', '\x2', '\xAEC', 
		'\xAE5', '\x3', '\x2', '\x2', '\x2', '\xAEC', '\xAE8', '\x3', '\x2', '\x2', 
		'\x2', '\xAED', '\x19F', '\x3', '\x2', '\x2', '\x2', '\xAEE', '\xAEF', 
		'\x5', '\x130', '\x99', '\x2', '\xAEF', '\xAF6', '\x5', '\xD8', 'm', '\x2', 
		'\xAF0', '\xAF1', '\a', '\x32', '\x2', '\x2', '\xAF1', '\xAF2', '\x5', 
		'\x130', '\x99', '\x2', '\xAF2', '\xAF3', '\x5', '\xD8', 'm', '\x2', '\xAF3', 
		'\xAF5', '\x3', '\x2', '\x2', '\x2', '\xAF4', '\xAF0', '\x3', '\x2', '\x2', 
		'\x2', '\xAF5', '\xAF8', '\x3', '\x2', '\x2', '\x2', '\xAF6', '\xAF4', 
		'\x3', '\x2', '\x2', '\x2', '\xAF6', '\xAF7', '\x3', '\x2', '\x2', '\x2', 
		'\xAF7', '\x1A1', '\x3', '\x2', '\x2', '\x2', '\xAF8', '\xAF6', '\x3', 
		'\x2', '\x2', '\x2', '\xAF9', '\xAFA', '\a', '\x41', '\x2', '\x2', '\xAFA', 
		'\xAFB', '\a', '\x82', '\x2', '\x2', '\xAFB', '\xB00', '\a', '\x136', 
		'\x2', '\x2', '\xAFC', '\xAFD', '\t', ')', '\x2', '\x2', '\xAFD', '\xB01', 
		'\x5', '\x1A4', '\xD3', '\x2', '\xAFE', '\xAFF', '\a', '[', '\x2', '\x2', 
		'\xAFF', '\xB01', '\x5', '\x1A6', '\xD4', '\x2', '\xB00', '\xAFC', '\x3', 
		'\x2', '\x2', '\x2', '\xB00', '\xAFE', '\x3', '\x2', '\x2', '\x2', '\xB01', 
		'\x1A3', '\x3', '\x2', '\x2', '\x2', '\xB02', '\xB04', '\a', '\xA7', '\x2', 
		'\x2', '\xB03', '\xB05', '\x5', '\x1A8', '\xD5', '\x2', '\xB04', '\xB03', 
		'\x3', '\x2', '\x2', '\x2', '\xB04', '\xB05', '\x3', '\x2', '\x2', '\x2', 
		'\xB05', '\xB06', '\x3', '\x2', '\x2', '\x2', '\xB06', '\xB07', '\a', 
		'\xF0', '\x2', '\x2', '\xB07', '\x1A5', '\x3', '\x2', '\x2', '\x2', '\xB08', 
		'\xB0A', '\a', '\xA7', '\x2', '\x2', '\xB09', '\xB0B', '\x5', '\x1AA', 
		'\xD6', '\x2', '\xB0A', '\xB09', '\x3', '\x2', '\x2', '\x2', '\xB0A', 
		'\xB0B', '\x3', '\x2', '\x2', '\x2', '\xB0B', '\xB0C', '\x3', '\x2', '\x2', 
		'\x2', '\xB0C', '\xB0D', '\a', '\xF0', '\x2', '\x2', '\xB0D', '\x1A7', 
		'\x3', '\x2', '\x2', '\x2', '\xB0E', '\xB13', '\x5', '\x1AC', '\xD7', 
		'\x2', '\xB0F', '\xB10', '\a', '\x32', '\x2', '\x2', '\xB10', '\xB12', 
		'\x5', '\x1AC', '\xD7', '\x2', '\xB11', '\xB0F', '\x3', '\x2', '\x2', 
		'\x2', '\xB12', '\xB15', '\x3', '\x2', '\x2', '\x2', '\xB13', '\xB11', 
		'\x3', '\x2', '\x2', '\x2', '\xB13', '\xB14', '\x3', '\x2', '\x2', '\x2', 
		'\xB14', '\x1A9', '\x3', '\x2', '\x2', '\x2', '\xB15', '\xB13', '\x3', 
		'\x2', '\x2', '\x2', '\xB16', '\xB1B', '\x5', '\x1AE', '\xD8', '\x2', 
		'\xB17', '\xB18', '\a', '\x32', '\x2', '\x2', '\xB18', '\xB1A', '\x5', 
		'\x1AE', '\xD8', '\x2', '\xB19', '\xB17', '\x3', '\x2', '\x2', '\x2', 
		'\xB1A', '\xB1D', '\x3', '\x2', '\x2', '\x2', '\xB1B', '\xB19', '\x3', 
		'\x2', '\x2', '\x2', '\xB1B', '\xB1C', '\x3', '\x2', '\x2', '\x2', '\xB1C', 
		'\x1AB', '\x3', '\x2', '\x2', '\x2', '\xB1D', '\xB1B', '\x3', '\x2', '\x2', 
		'\x2', '\xB1E', '\xB22', '\x5', '\x1C2', '\xE2', '\x2', '\xB1F', '\xB22', 
		'\x5', '\x1B6', '\xDC', '\x2', '\xB20', '\xB22', '\x5', '\x1D6', '\xEC', 
		'\x2', '\xB21', '\xB1E', '\x3', '\x2', '\x2', '\x2', '\xB21', '\xB1F', 
		'\x3', '\x2', '\x2', '\x2', '\xB21', '\xB20', '\x3', '\x2', '\x2', '\x2', 
		'\xB22', '\x1AD', '\x3', '\x2', '\x2', '\x2', '\xB23', '\xB28', '\x5', 
		'\x1C2', '\xE2', '\x2', '\xB24', '\xB28', '\x5', '\x1B6', '\xDC', '\x2', 
		'\xB25', '\xB26', '\a', '\x37', '\x2', '\x2', '\xB26', '\xB28', '\x5', 
		'\x2F4', '\x17B', '\x2', '\xB27', '\xB23', '\x3', '\x2', '\x2', '\x2', 
		'\xB27', '\xB24', '\x3', '\x2', '\x2', '\x2', '\xB27', '\xB25', '\x3', 
		'\x2', '\x2', '\x2', '\xB28', '\x1AF', '\x3', '\x2', '\x2', '\x2', '\xB29', 
		'\xB2B', '\x5', '\x188', '\xC5', '\x2', '\xB2A', '\xB2C', '\x5', '\x154', 
		'\xAB', '\x2', '\xB2B', '\xB2A', '\x3', '\x2', '\x2', '\x2', '\xB2B', 
		'\xB2C', '\x3', '\x2', '\x2', '\x2', '\xB2C', '\xB2E', '\x3', '\x2', '\x2', 
		'\x2', '\xB2D', '\xB29', '\x3', '\x2', '\x2', '\x2', '\xB2E', '\xB2F', 
		'\x3', '\x2', '\x2', '\x2', '\xB2F', '\xB2D', '\x3', '\x2', '\x2', '\x2', 
		'\xB2F', '\xB30', '\x3', '\x2', '\x2', '\x2', '\xB30', '\x1B1', '\x3', 
		'\x2', '\x2', '\x2', '\xB31', '\xB33', '\x5', '\x188', '\xC5', '\x2', 
		'\xB32', '\xB34', '\x5', '\x154', '\xAB', '\x2', '\xB33', '\xB32', '\x3', 
		'\x2', '\x2', '\x2', '\xB33', '\xB34', '\x3', '\x2', '\x2', '\x2', '\xB34', 
		'\xB36', '\x3', '\x2', '\x2', '\x2', '\xB35', '\xB31', '\x3', '\x2', '\x2', 
		'\x2', '\xB36', '\xB37', '\x3', '\x2', '\x2', '\x2', '\xB37', '\xB35', 
		'\x3', '\x2', '\x2', '\x2', '\xB37', '\xB38', '\x3', '\x2', '\x2', '\x2', 
		'\xB38', '\x1B3', '\x3', '\x2', '\x2', '\x2', '\xB39', '\xB3A', '\a', 
		'j', '\x2', '\x2', '\xB3A', '\xB3D', '\x5', '\xAA', 'V', '\x2', '\xB3B', 
		'\xB3D', '\a', '\xB9', '\x2', '\x2', '\xB3C', '\xB39', '\x3', '\x2', '\x2', 
		'\x2', '\xB3C', '\xB3B', '\x3', '\x2', '\x2', '\x2', '\xB3D', '\x1B5', 
		'\x3', '\x2', '\x2', '\x2', '\xB3E', '\xB40', '\a', '\xB0', '\x2', '\x2', 
		'\xB3F', '\xB41', '\x5', '\x130', '\x99', '\x2', '\xB40', '\xB3F', '\x3', 
		'\x2', '\x2', '\x2', '\xB40', '\xB41', '\x3', '\x2', '\x2', '\x2', '\xB41', 
		'\xB42', '\x3', '\x2', '\x2', '\x2', '\xB42', '\xB44', '\x5', '\x1BA', 
		'\xDE', '\x2', '\xB43', '\xB45', '\x5', '\x1B8', '\xDD', '\x2', '\xB44', 
		'\xB43', '\x3', '\x2', '\x2', '\x2', '\xB44', '\xB45', '\x3', '\x2', '\x2', 
		'\x2', '\xB45', '\xB47', '\x3', '\x2', '\x2', '\x2', '\xB46', '\xB48', 
		'\x5', '\x1CE', '\xE8', '\x2', '\xB47', '\xB46', '\x3', '\x2', '\x2', 
		'\x2', '\xB47', '\xB48', '\x3', '\x2', '\x2', '\x2', '\xB48', '\xB49', 
		'\x3', '\x2', '\x2', '\x2', '\xB49', '\xB4B', '\a', '\x109', '\x2', '\x2', 
		'\xB4A', '\xB4C', '\x5', '\x1B0', '\xD9', '\x2', '\xB4B', '\xB4A', '\x3', 
		'\x2', '\x2', '\x2', '\xB4B', '\xB4C', '\x3', '\x2', '\x2', '\x2', '\xB4C', 
		'\x1B7', '\x3', '\x2', '\x2', '\x2', '\xB4D', '\xB52', '\x5', '\x9A', 
		'N', '\x2', '\xB4E', '\xB4F', '\a', '\xA3', '\x2', '\x2', '\xB4F', '\xB51', 
		'\x5', '\x2F4', '\x17B', '\x2', '\xB50', '\xB4E', '\x3', '\x2', '\x2', 
		'\x2', '\xB51', '\xB54', '\x3', '\x2', '\x2', '\x2', '\xB52', '\xB50', 
		'\x3', '\x2', '\x2', '\x2', '\xB52', '\xB53', '\x3', '\x2', '\x2', '\x2', 
		'\xB53', '\x1B9', '\x3', '\x2', '\x2', '\x2', '\xB54', '\xB52', '\x3', 
		'\x2', '\x2', '\x2', '\xB55', '\xB56', '\x5', '\x9A', 'N', '\x2', '\xB56', 
		'\xB57', '\x5', '\x1B4', '\xDB', '\x2', '\xB57', '\x1BB', '\x3', '\x2', 
		'\x2', '\x2', '\xB58', '\xB5B', '\x5', '\x1BE', '\xE0', '\x2', '\xB59', 
		'\xB5B', '\x5', '\x1C0', '\xE1', '\x2', '\xB5A', '\xB58', '\x3', '\x2', 
		'\x2', '\x2', '\xB5A', '\xB59', '\x3', '\x2', '\x2', '\x2', '\xB5B', '\x1BD', 
		'\x3', '\x2', '\x2', '\x2', '\xB5C', '\xB5D', '\a', '\xB0', '\x2', '\x2', 
		'\xB5D', '\xB5E', '\x5', '\x130', '\x99', '\x2', '\xB5E', '\xB5F', '\a', 
		'\x109', '\x2', '\x2', '\xB5F', '\x1BF', '\x3', '\x2', '\x2', '\x2', '\xB60', 
		'\xB68', '\a', '\xB0', '\x2', '\x2', '\xB61', '\xB63', '\x5', '\x130', 
		'\x99', '\x2', '\xB62', '\xB61', '\x3', '\x2', '\x2', '\x2', '\xB62', 
		'\xB63', '\x3', '\x2', '\x2', '\x2', '\xB63', '\xB64', '\x3', '\x2', '\x2', 
		'\x2', '\xB64', '\xB66', '\x5', '\x9A', 'N', '\x2', '\xB65', '\xB67', 
		'\x5', '\x1B4', '\xDB', '\x2', '\xB66', '\xB65', '\x3', '\x2', '\x2', 
		'\x2', '\xB66', '\xB67', '\x3', '\x2', '\x2', '\x2', '\xB67', '\xB69', 
		'\x3', '\x2', '\x2', '\x2', '\xB68', '\xB62', '\x3', '\x2', '\x2', '\x2', 
		'\xB68', '\xB69', '\x3', '\x2', '\x2', '\x2', '\xB69', '\xB6A', '\x3', 
		'\x2', '\x2', '\x2', '\xB6A', '\xB6B', '\a', '\x109', '\x2', '\x2', '\xB6B', 
		'\x1C1', '\x3', '\x2', '\x2', '\x2', '\xB6C', '\xB6D', '\x5', '\x1BC', 
		'\xDF', '\x2', '\xB6D', '\xB6E', '\x5', '\x1C4', '\xE3', '\x2', '\xB6E', 
		'\xB70', '\x5', '\x1BC', '\xDF', '\x2', '\xB6F', '\xB71', '\x5', '\x1B2', 
		'\xDA', '\x2', '\xB70', '\xB6F', '\x3', '\x2', '\x2', '\x2', '\xB70', 
		'\xB71', '\x3', '\x2', '\x2', '\x2', '\xB71', '\x1C3', '\x3', '\x2', '\x2', 
		'\x2', '\xB72', '\xB73', '\x5', '\xA8', 'U', '\x2', '\xB73', '\xB75', 
		'\a', '\xA6', '\x2', '\x2', '\xB74', '\xB76', '\x5', '\x130', '\x99', 
		'\x2', '\xB75', '\xB74', '\x3', '\x2', '\x2', '\x2', '\xB75', '\xB76', 
		'\x3', '\x2', '\x2', '\x2', '\xB76', '\xB77', '\x3', '\x2', '\x2', '\x2', 
		'\xB77', '\xB79', '\x5', '\x1C6', '\xE4', '\x2', '\xB78', '\xB7A', '\x5', 
		'\x1CE', '\xE8', '\x2', '\xB79', '\xB78', '\x3', '\x2', '\x2', '\x2', 
		'\xB79', '\xB7A', '\x3', '\x2', '\x2', '\x2', '\xB7A', '\xB7B', '\x3', 
		'\x2', '\x2', '\x2', '\xB7B', '\xB7C', '\a', '\xEF', '\x2', '\x2', '\xB7C', 
		'\xB7D', '\x5', '\xA8', 'U', '\x2', '\xB7D', '\xB7E', '\x5', '\xAA', 'V', 
		'\x2', '\xB7E', '\x1C5', '\x3', '\x2', '\x2', '\x2', '\xB7F', '\xB80', 
		'\x5', '\x9C', 'O', '\x2', '\xB80', '\xB81', '\x5', '\x1B4', '\xDB', '\x2', 
		'\xB81', '\x1C7', '\x3', '\x2', '\x2', '\x2', '\xB82', '\xB85', '\x5', 
		'\x1CA', '\xE6', '\x2', '\xB83', '\xB85', '\x5', '\x1CC', '\xE7', '\x2', 
		'\xB84', '\xB82', '\x3', '\x2', '\x2', '\x2', '\xB84', '\xB83', '\x3', 
		'\x2', '\x2', '\x2', '\xB85', '\x1C9', '\x3', '\x2', '\x2', '\x2', '\xB86', 
		'\xB87', '\a', '\xB0', '\x2', '\x2', '\xB87', '\xB88', '\a', '\x109', 
		'\x2', '\x2', '\xB88', '\xB89', '\x5', '\xA8', 'U', '\x2', '\xB89', '\xB8A', 
		'\a', '\xA6', '\x2', '\x2', '\xB8A', '\xB8B', '\x5', '\x130', '\x99', 
		'\x2', '\xB8B', '\xB8C', '\a', '\xEF', '\x2', '\x2', '\xB8C', '\xB8D', 
		'\x5', '\xA8', 'U', '\x2', '\xB8D', '\xB8E', '\x5', '\xAA', 'V', '\x2', 
		'\xB8E', '\xB8F', '\a', '\xB0', '\x2', '\x2', '\xB8F', '\xB90', '\a', 
		'\x109', '\x2', '\x2', '\xB90', '\x1CB', '\x3', '\x2', '\x2', '\x2', '\xB91', 
		'\xB92', '\a', '\xB0', '\x2', '\x2', '\xB92', '\xB93', '\a', '\x109', 
		'\x2', '\x2', '\xB93', '\xB94', '\x5', '\xA8', 'U', '\x2', '\xB94', '\xB96', 
		'\a', '\xA6', '\x2', '\x2', '\xB95', '\xB97', '\x5', '\x130', '\x99', 
		'\x2', '\xB96', '\xB95', '\x3', '\x2', '\x2', '\x2', '\xB96', '\xB97', 
		'\x3', '\x2', '\x2', '\x2', '\xB97', '\xB98', '\x3', '\x2', '\x2', '\x2', 
		'\xB98', '\xB9A', '\x5', '\x9C', 'O', '\x2', '\xB99', '\xB9B', '\x5', 
		'\x1B4', '\xDB', '\x2', '\xB9A', '\xB99', '\x3', '\x2', '\x2', '\x2', 
		'\xB9A', '\xB9B', '\x3', '\x2', '\x2', '\x2', '\xB9B', '\xB9C', '\x3', 
		'\x2', '\x2', '\x2', '\xB9C', '\xB9D', '\a', '\xEF', '\x2', '\x2', '\xB9D', 
		'\xB9E', '\x5', '\xA8', 'U', '\x2', '\xB9E', '\xB9F', '\x5', '\xAA', 'V', 
		'\x2', '\xB9F', '\xBA0', '\a', '\xB0', '\x2', '\x2', '\xBA0', '\xBA1', 
		'\a', '\x109', '\x2', '\x2', '\xBA1', '\x1CD', '\x3', '\x2', '\x2', '\x2', 
		'\xBA2', '\xBAB', '\a', '\xA7', '\x2', '\x2', '\xBA3', '\xBA8', '\x5', 
		'\x1D0', '\xE9', '\x2', '\xBA4', '\xBA5', '\a', '\x32', '\x2', '\x2', 
		'\xBA5', '\xBA7', '\x5', '\x1D0', '\xE9', '\x2', '\xBA6', '\xBA4', '\x3', 
		'\x2', '\x2', '\x2', '\xBA7', '\xBAA', '\x3', '\x2', '\x2', '\x2', '\xBA8', 
		'\xBA6', '\x3', '\x2', '\x2', '\x2', '\xBA8', '\xBA9', '\x3', '\x2', '\x2', 
		'\x2', '\xBA9', '\xBAC', '\x3', '\x2', '\x2', '\x2', '\xBAA', '\xBA8', 
		'\x3', '\x2', '\x2', '\x2', '\xBAB', '\xBA3', '\x3', '\x2', '\x2', '\x2', 
		'\xBAB', '\xBAC', '\x3', '\x2', '\x2', '\x2', '\xBAC', '\xBAD', '\x3', 
		'\x2', '\x2', '\x2', '\xBAD', '\xBAE', '\a', '\xF0', '\x2', '\x2', '\xBAE', 
		'\x1CF', '\x3', '\x2', '\x2', '\x2', '\xBAF', '\xBB1', '\x5', '\x122', 
		'\x92', '\x2', '\xBB0', '\xBB2', '\x5', '\x1D4', '\xEB', '\x2', '\xBB1', 
		'\xBB0', '\x3', '\x2', '\x2', '\x2', '\xBB1', '\xBB2', '\x3', '\x2', '\x2', 
		'\x2', '\xBB2', '\xBB3', '\x3', '\x2', '\x2', '\x2', '\xBB3', '\xBB5', 
		'\x5', '\x134', '\x9B', '\x2', '\xBB4', '\xBB6', '\x5', '\x1D2', '\xEA', 
		'\x2', '\xBB5', '\xBB4', '\x3', '\x2', '\x2', '\x2', '\xBB5', '\xBB6', 
		'\x3', '\x2', '\x2', '\x2', '\xBB6', '\x1D1', '\x3', '\x2', '\x2', '\x2', 
		'\xBB7', '\xBB9', '\a', '\x9E', '\x2', '\x2', '\xBB8', '\xBBA', '\t', 
		'(', '\x2', '\x2', '\xBB9', '\xBB8', '\x3', '\x2', '\x2', '\x2', '\xBB9', 
		'\xBBA', '\x3', '\x2', '\x2', '\x2', '\xBBA', '\xBBB', '\x3', '\x2', '\x2', 
		'\x2', '\xBBB', '\xBBC', '\t', '*', '\x2', '\x2', '\xBBC', '\x1D3', '\x3', 
		'\x2', '\x2', '\x2', '\xBBD', '\xBBE', '\t', '\x14', '\x2', '\x2', '\xBBE', 
		'\x1D5', '\x3', '\x2', '\x2', '\x2', '\xBBF', '\xBC1', '\a', '\x37', '\x2', 
		'\x2', '\xBC0', '\xBC2', '\x5', '\x2F4', '\x17B', '\x2', '\xBC1', '\xBC0', 
		'\x3', '\x2', '\x2', '\x2', '\xBC1', '\xBC2', '\x3', '\x2', '\x2', '\x2', 
		'\xBC2', '\xBC3', '\x3', '\x2', '\x2', '\x2', '\xBC3', '\xBC6', '\a', 
		'y', '\x2', '\x2', '\xBC4', '\xBC7', '\x5', '\x1BC', '\xDF', '\x2', '\xBC5', 
		'\xBC7', '\x5', '\x1C8', '\xE5', '\x2', '\xBC6', '\xBC4', '\x3', '\x2', 
		'\x2', '\x2', '\xBC6', '\xBC5', '\x3', '\x2', '\x2', '\x2', '\xBC7', '\xBC8', 
		'\x3', '\x2', '\x2', '\x2', '\xBC8', '\xBCA', '\x5', '\x188', '\xC5', 
		'\x2', '\xBC9', '\xBCB', '\x5', '\x154', '\xAB', '\x2', '\xBCA', '\xBC9', 
		'\x3', '\x2', '\x2', '\x2', '\xBCA', '\xBCB', '\x3', '\x2', '\x2', '\x2', 
		'\xBCB', '\x1D7', '\x3', '\x2', '\x2', '\x2', '\xBCC', '\xBD0', '\a', 
		'\xF4', '\x2', '\x2', '\xBCD', '\xBD1', '\x5', '\x1FA', '\xFE', '\x2', 
		'\xBCE', '\xBD1', '\x5', '\x1EA', '\xF6', '\x2', '\xBCF', '\xBD1', '\x5', 
		'\x206', '\x104', '\x2', '\xBD0', '\xBCD', '\x3', '\x2', '\x2', '\x2', 
		'\xBD0', '\xBCE', '\x3', '\x2', '\x2', '\x2', '\xBD0', '\xBCF', '\x3', 
		'\x2', '\x2', '\x2', '\xBD1', '\x1D9', '\x3', '\x2', '\x2', '\x2', '\xBD2', 
		'\xBDD', '\a', '\x81', '\x2', '\x2', '\xBD3', '\xBD5', '\a', '\x8D', '\x2', 
		'\x2', '\xBD4', '\xBD3', '\x3', '\x2', '\x2', '\x2', '\xBD4', '\xBD5', 
		'\x3', '\x2', '\x2', '\x2', '\xBD5', '\xBD6', '\x3', '\x2', '\x2', '\x2', 
		'\xBD6', '\xBD7', '\x5', '\x22E', '\x118', '\x2', '\xBD7', '\xBD8', '\a', 
		'\x12E', '\x2', '\x2', '\xBD8', '\xBD9', '\x5', '\x1E2', '\xF2', '\x2', 
		'\xBD9', '\xBDE', '\x3', '\x2', '\x2', '\x2', '\xBDA', '\xBDB', '\x5', 
		'\x1E4', '\xF3', '\x2', '\xBDB', '\xBDC', '\x5', '\x1FE', '\x100', '\x2', 
		'\xBDC', '\xBDE', '\x3', '\x2', '\x2', '\x2', '\xBDD', '\xBD4', '\x3', 
		'\x2', '\x2', '\x2', '\xBDD', '\xBDA', '\x3', '\x2', '\x2', '\x2', '\xBDE', 
		'\x1DB', '\x3', '\x2', '\x2', '\x2', '\xBDF', '\xBE1', '\a', 'M', '\x2', 
		'\x2', '\xBE0', '\xBE2', '\a', '\x8D', '\x2', '\x2', '\xBE1', '\xBE0', 
		'\x3', '\x2', '\x2', '\x2', '\xBE1', '\xBE2', '\x3', '\x2', '\x2', '\x2', 
		'\xBE2', '\xBE3', '\x3', '\x2', '\x2', '\x2', '\xBE3', '\xBE4', '\x5', 
		'\x22E', '\x118', '\x2', '\xBE4', '\xBE5', '\a', '\x12E', '\x2', '\x2', 
		'\xBE5', '\xBE6', '\x5', '\x1E2', '\xF2', '\x2', '\xBE6', '\x1DD', '\x3', 
		'\x2', '\x2', '\x2', '\xBE7', '\xBF5', '\a', '\x104', '\x2', '\x2', '\xBE8', 
		'\xBEA', '\t', '+', '\x2', '\x2', '\xBE9', '\xBE8', '\x3', '\x2', '\x2', 
		'\x2', '\xBE9', '\xBEA', '\x3', '\x2', '\x2', '\x2', '\xBEA', '\xBEC', 
		'\x3', '\x2', '\x2', '\x2', '\xBEB', '\xBED', '\a', '\x8D', '\x2', '\x2', 
		'\xBEC', '\xBEB', '\x3', '\x2', '\x2', '\x2', '\xBEC', '\xBED', '\x3', 
		'\x2', '\x2', '\x2', '\xBED', '\xBEE', '\x3', '\x2', '\x2', '\x2', '\xBEE', 
		'\xBEF', '\x5', '\x22E', '\x118', '\x2', '\xBEF', '\xBF0', '\a', '|', 
		'\x2', '\x2', '\xBF0', '\xBF1', '\x5', '\x1E2', '\xF2', '\x2', '\xBF1', 
		'\xBF6', '\x3', '\x2', '\x2', '\x2', '\xBF2', '\xBF3', '\x5', '\x1E4', 
		'\xF3', '\x2', '\xBF3', '\xBF4', '\x5', '\x200', '\x101', '\x2', '\xBF4', 
		'\xBF6', '\x3', '\x2', '\x2', '\x2', '\xBF5', '\xBE9', '\x3', '\x2', '\x2', 
		'\x2', '\xBF5', '\xBF2', '\x3', '\x2', '\x2', '\x2', '\xBF6', '\x1DF', 
		'\x3', '\x2', '\x2', '\x2', '\xBF7', '\xBF8', '\x5', '\x2D6', '\x16C', 
		'\x2', '\xBF8', '\x1E1', '\x3', '\x2', '\x2', '\x2', '\xBF9', '\xBFA', 
		'\x5', '\x2D6', '\x16C', '\x2', '\xBFA', '\x1E3', '\x3', '\x2', '\x2', 
		'\x2', '\xBFB', '\xBFC', '\t', ',', '\x2', '\x2', '\xBFC', '\x1E5', '\x3', 
		'\x2', '\x2', '\x2', '\xBFD', '\xBFE', '\a', '\x61', '\x2', '\x2', '\xBFE', 
		'\xBFF', '\a', '\x112', '\x2', '\x2', '\xBFF', '\xC01', '\x5', '\x2E6', 
		'\x174', '\x2', '\xC00', '\xC02', '\x5', '\x154', '\xAB', '\x2', '\xC01', 
		'\xC00', '\x3', '\x2', '\x2', '\x2', '\xC01', '\xC02', '\x3', '\x2', '\x2', 
		'\x2', '\xC02', '\x1E7', '\x3', '\x2', '\x2', '\x2', '\xC03', '\xC04', 
		'\a', '\x112', '\x2', '\x2', '\xC04', '\xC05', '\x5', '\x2E6', '\x174', 
		'\x2', '\xC05', '\xC06', '\a', '\x114', '\x2', '\x2', '\xC06', '\xC07', 
		'\x5', '\x154', '\xAB', '\x2', '\xC07', '\x1E9', '\x3', '\x2', '\x2', 
		'\x2', '\xC08', '\xC09', '\a', '\x112', '\x2', '\x2', '\xC09', '\xC0A', 
		'\x5', '\x2E6', '\x174', '\x2', '\xC0A', '\xC0B', '\a', '\x12E', '\x2', 
		'\x2', '\xC0B', '\xC0C', '\x5', '\x2E6', '\x174', '\x2', '\xC0C', '\x1EB', 
		'\x3', '\x2', '\x2', '\x2', '\xC0D', '\xC0E', '\a', '\x112', '\x2', '\x2', 
		'\xC0E', '\xC0F', '\x5', '\x2E6', '\x174', '\x2', '\xC0F', '\x1ED', '\x3', 
		'\x2', '\x2', '\x2', '\xC10', '\xC12', '\t', '-', '\x2', '\x2', '\xC11', 
		'\xC13', '\x5', '\x14A', '\xA6', '\x2', '\xC12', '\xC11', '\x3', '\x2', 
		'\x2', '\x2', '\xC12', '\xC13', '\x3', '\x2', '\x2', '\x2', '\xC13', '\x1EF', 
		'\x3', '\x2', '\x2', '\x2', '\xC14', '\xC16', '\a', '\\', '\x2', '\x2', 
		'\xC15', '\xC14', '\x3', '\x2', '\x2', '\x2', '\xC15', '\xC16', '\x3', 
		'\x2', '\x2', '\x2', '\xC16', '\xC19', '\x3', '\x2', '\x2', '\x2', '\xC17', 
		'\xC1A', '\x5', '\x1F2', '\xFA', '\x2', '\xC18', '\xC1A', '\x5', '\x1F4', 
		'\xFB', '\x2', '\xC19', '\xC17', '\x3', '\x2', '\x2', '\x2', '\xC19', 
		'\xC18', '\x3', '\x2', '\x2', '\x2', '\xC1A', '\x1F1', '\x3', '\x2', '\x2', 
		'\x2', '\xC1B', '\xC1C', '\a', 'I', '\x2', '\x2', '\xC1C', '\xC1D', '\t', 
		'.', '\x2', '\x2', '\xC1D', '\xC1E', '\a', '|', '\x2', '\x2', '\xC1E', 
		'\xC1F', '\t', '-', '\x2', '\x2', '\xC1F', '\xC24', '\x5', '\x2E6', '\x174', 
		'\x2', '\xC20', '\xC21', '\a', '\x32', '\x2', '\x2', '\xC21', '\xC23', 
		'\x5', '\x2E6', '\x174', '\x2', '\xC22', '\xC20', '\x3', '\x2', '\x2', 
		'\x2', '\xC23', '\xC26', '\x3', '\x2', '\x2', '\x2', '\xC24', '\xC22', 
		'\x3', '\x2', '\x2', '\x2', '\xC24', '\xC25', '\x3', '\x2', '\x2', '\x2', 
		'\xC25', '\x1F3', '\x3', '\x2', '\x2', '\x2', '\xC26', '\xC24', '\x3', 
		'\x2', '\x2', '\x2', '\xC27', '\xC28', '\a', '\xF2', '\x2', '\x2', '\xC28', 
		'\xC29', '\t', '.', '\x2', '\x2', '\xC29', '\x1F5', '\x3', '\x2', '\x2', 
		'\x2', '\xC2A', '\xC2C', '\a', '\x8D', '\x2', '\x2', '\xC2B', '\xC2A', 
		'\x3', '\x2', '\x2', '\x2', '\xC2B', '\xC2C', '\x3', '\x2', '\x2', '\x2', 
		'\xC2C', '\xC2D', '\x3', '\x2', '\x2', '\x2', '\xC2D', '\xC2E', '\a', 
		'\x105', '\x2', '\x2', '\xC2E', '\xC32', '\x5', '\x2D4', '\x16B', '\x2', 
		'\xC2F', '\xC30', '\a', '\x8B', '\x2', '\x2', '\xC30', '\xC31', '\a', 
		'\xCB', '\x2', '\x2', '\xC31', '\xC33', '\a', 'o', '\x2', '\x2', '\xC32', 
		'\xC2F', '\x3', '\x2', '\x2', '\x2', '\xC32', '\xC33', '\x3', '\x2', '\x2', 
		'\x2', '\xC33', '\xC38', '\x3', '\x2', '\x2', '\x2', '\xC34', '\xC35', 
		'\a', '\x1B', '\x2', '\x2', '\xC35', '\xC36', '\a', ':', '\x2', '\x2', 
		'\xC36', '\xC37', '\a', '\xCF', '\x2', '\x2', '\xC37', '\xC39', '\x5', 
		'\x2D4', '\x16B', '\x2', '\xC38', '\xC34', '\x3', '\x2', '\x2', '\x2', 
		'\xC38', '\xC39', '\x3', '\x2', '\x2', '\x2', '\xC39', '\x1F7', '\x3', 
		'\x2', '\x2', '\x2', '\xC3A', '\xC3B', '\a', '\x105', '\x2', '\x2', '\xC3B', 
		'\xC3E', '\x5', '\x2D4', '\x16B', '\x2', '\xC3C', '\xC3D', '\a', '\x8B', 
		'\x2', '\x2', '\xC3D', '\xC3F', '\a', 'o', '\x2', '\x2', '\xC3E', '\xC3C', 
		'\x3', '\x2', '\x2', '\x2', '\xC3E', '\xC3F', '\x3', '\x2', '\x2', '\x2', 
		'\xC3F', '\x1F9', '\x3', '\x2', '\x2', '\x2', '\xC40', '\xC41', '\a', 
		'\x105', '\x2', '\x2', '\xC41', '\xC44', '\x5', '\x2D4', '\x16B', '\x2', 
		'\xC42', '\xC43', '\a', '\x8B', '\x2', '\x2', '\xC43', '\xC45', '\a', 
		'o', '\x2', '\x2', '\xC44', '\xC42', '\x3', '\x2', '\x2', '\x2', '\xC44', 
		'\xC45', '\x3', '\x2', '\x2', '\x2', '\xC45', '\xC46', '\x3', '\x2', '\x2', 
		'\x2', '\xC46', '\xC47', '\a', '\x12E', '\x2', '\x2', '\xC47', '\xC48', 
		'\x5', '\x2D4', '\x16B', '\x2', '\xC48', '\x1FB', '\x3', '\x2', '\x2', 
		'\x2', '\xC49', '\xC4B', '\t', '/', '\x2', '\x2', '\xC4A', '\xC49', '\x3', 
		'\x2', '\x2', '\x2', '\xC4A', '\xC4B', '\x3', '\x2', '\x2', '\x2', '\xC4B', 
		'\xC4C', '\x3', '\x2', '\x2', '\x2', '\xC4C', '\xC4F', '\x5', '\x1E4', 
		'\xF3', '\x2', '\xC4D', '\xC4E', '\a', '\x14B', '\x2', '\x2', '\xC4E', 
		'\xC50', '\t', '\x30', '\x2', '\x2', '\xC4F', '\xC4D', '\x3', '\x2', '\x2', 
		'\x2', '\xC4F', '\xC50', '\x3', '\x2', '\x2', '\x2', '\xC50', '\xC52', 
		'\x3', '\x2', '\x2', '\x2', '\xC51', '\xC53', '\x5', '\x14A', '\xA6', 
		'\x2', '\xC52', '\xC51', '\x3', '\x2', '\x2', '\x2', '\xC52', '\xC53', 
		'\x3', '\x2', '\x2', '\x2', '\xC53', '\x1FD', '\x3', '\x2', '\x2', '\x2', 
		'\xC54', '\xC55', '\x5', '\x1E2', '\xF2', '\x2', '\xC55', '\xC56', '\a', 
		'\x12E', '\x2', '\x2', '\xC56', '\xC57', '\x5', '\x1E0', '\xF1', '\x2', 
		'\xC57', '\x1FF', '\x3', '\x2', '\x2', '\x2', '\xC58', '\xC59', '\x5', 
		'\x1E2', '\xF2', '\x2', '\xC59', '\xC5A', '\a', '|', '\x2', '\x2', '\xC5A', 
		'\xC5B', '\x5', '\x1E0', '\xF1', '\x2', '\xC5B', '\x201', '\x3', '\x2', 
		'\x2', '\x2', '\xC5C', '\xC5D', '\a', '\x13F', '\x2', '\x2', '\xC5D', 
		'\xC61', '\x5', '\x2D4', '\x16B', '\x2', '\xC5E', '\xC5F', '\a', '\x8B', 
		'\x2', '\x2', '\xC5F', '\xC60', '\a', '\xCB', '\x2', '\x2', '\xC60', '\xC62', 
		'\a', 'o', '\x2', '\x2', '\xC61', '\xC5E', '\x3', '\x2', '\x2', '\x2', 
		'\xC61', '\xC62', '\x3', '\x2', '\x2', '\x2', '\xC62', '\xC6C', '\x3', 
		'\x2', '\x2', '\x2', '\xC63', '\xC6A', '\a', '\x114', '\x2', '\x2', '\xC64', 
		'\xC6B', '\x5', '\x20E', '\x108', '\x2', '\xC65', '\xC66', '\a', '\xD9', 
		'\x2', '\x2', '\xC66', '\xC6B', '\x5', '\x214', '\x10B', '\x2', '\xC67', 
		'\xC6B', '\x5', '\x216', '\x10C', '\x2', '\xC68', '\xC6B', '\x5', '\x218', 
		'\x10D', '\x2', '\xC69', '\xC6B', '\x5', '\x21A', '\x10E', '\x2', '\xC6A', 
		'\xC64', '\x3', '\x2', '\x2', '\x2', '\xC6A', '\xC65', '\x3', '\x2', '\x2', 
		'\x2', '\xC6A', '\xC67', '\x3', '\x2', '\x2', '\x2', '\xC6A', '\xC68', 
		'\x3', '\x2', '\x2', '\x2', '\xC6A', '\xC69', '\x3', '\x2', '\x2', '\x2', 
		'\xC6B', '\xC6D', '\x3', '\x2', '\x2', '\x2', '\xC6C', '\xC63', '\x3', 
		'\x2', '\x2', '\x2', '\xC6D', '\xC6E', '\x3', '\x2', '\x2', '\x2', '\xC6E', 
		'\xC6C', '\x3', '\x2', '\x2', '\x2', '\xC6E', '\xC6F', '\x3', '\x2', '\x2', 
		'\x2', '\xC6F', '\x203', '\x3', '\x2', '\x2', '\x2', '\xC70', '\xC71', 
		'\a', '\x13F', '\x2', '\x2', '\xC71', '\xC74', '\x5', '\x2D4', '\x16B', 
		'\x2', '\xC72', '\xC73', '\a', '\x8B', '\x2', '\x2', '\xC73', '\xC75', 
		'\a', 'o', '\x2', '\x2', '\xC74', '\xC72', '\x3', '\x2', '\x2', '\x2', 
		'\xC74', '\xC75', '\x3', '\x2', '\x2', '\x2', '\xC75', '\x205', '\x3', 
		'\x2', '\x2', '\x2', '\xC76', '\xC77', '\a', '\x13F', '\x2', '\x2', '\xC77', 
		'\xC7A', '\x5', '\x2D4', '\x16B', '\x2', '\xC78', '\xC79', '\a', '\x8B', 
		'\x2', '\x2', '\xC79', '\xC7B', '\a', 'o', '\x2', '\x2', '\xC7A', '\xC78', 
		'\x3', '\x2', '\x2', '\x2', '\xC7A', '\xC7B', '\x3', '\x2', '\x2', '\x2', 
		'\xC7B', '\xC7C', '\x3', '\x2', '\x2', '\x2', '\xC7C', '\xC7D', '\a', 
		'\x12E', '\x2', '\x2', '\xC7D', '\xC7E', '\x5', '\x2D4', '\x16B', '\x2', 
		'\xC7E', '\x207', '\x3', '\x2', '\x2', '\x2', '\xC7F', '\xC80', '\a', 
		'\x41', '\x2', '\x2', '\xC80', '\xC81', '\a', '\x13F', '\x2', '\x2', '\xC81', 
		'\xC82', '\a', '\x114', '\x2', '\x2', '\xC82', '\xC83', '\a', '\xD9', 
		'\x2', '\x2', '\xC83', '\xC84', '\a', '|', '\x2', '\x2', '\xC84', '\xC85', 
		'\x5', '\x212', '\x10A', '\x2', '\xC85', '\xC86', '\a', '\x12E', '\x2', 
		'\x2', '\xC86', '\xC87', '\x5', '\x212', '\x10A', '\x2', '\xC87', '\x209', 
		'\x3', '\x2', '\x2', '\x2', '\xC88', '\xC89', '\a', '\x13F', '\x2', '\x2', 
		'\xC89', '\xC8C', '\x5', '\x2D4', '\x16B', '\x2', '\xC8A', '\xC8B', '\a', 
		'\x8B', '\x2', '\x2', '\xC8B', '\xC8D', '\a', 'o', '\x2', '\x2', '\xC8C', 
		'\xC8A', '\x3', '\x2', '\x2', '\x2', '\xC8C', '\xC8D', '\x3', '\x2', '\x2', 
		'\x2', '\xC8D', '\xC9B', '\x3', '\x2', '\x2', '\x2', '\xC8E', '\xC97', 
		'\a', '\xF9', '\x2', '\x2', '\xC8F', '\xC90', '\a', '\x89', '\x2', '\x2', 
		'\xC90', '\xC98', '\a', '\x44', '\x2', '\x2', '\xC91', '\xC92', '\a', 
		'\x15', '\x2', '\x2', '\xC92', '\xC94', '\a', ' ', '\x2', '\x2', '\xC93', 
		'\xC95', '\t', '\x31', '\x2', '\x2', '\xC94', '\xC93', '\x3', '\x2', '\x2', 
		'\x2', '\xC94', '\xC95', '\x3', '\x2', '\x2', '\x2', '\xC95', '\xC98', 
		'\x3', '\x2', '\x2', '\x2', '\xC96', '\xC98', '\x5', '\x20C', '\x107', 
		'\x2', '\xC97', '\xC8F', '\x3', '\x2', '\x2', '\x2', '\xC97', '\xC91', 
		'\x3', '\x2', '\x2', '\x2', '\xC97', '\xC96', '\x3', '\x2', '\x2', '\x2', 
		'\xC98', '\xC9A', '\x3', '\x2', '\x2', '\x2', '\xC99', '\xC8E', '\x3', 
		'\x2', '\x2', '\x2', '\xC9A', '\xC9D', '\x3', '\x2', '\x2', '\x2', '\xC9B', 
		'\xC99', '\x3', '\x2', '\x2', '\x2', '\xC9B', '\xC9C', '\x3', '\x2', '\x2', 
		'\x2', '\xC9C', '\xCA9', '\x3', '\x2', '\x2', '\x2', '\xC9D', '\xC9B', 
		'\x3', '\x2', '\x2', '\x2', '\xC9E', '\xCA5', '\a', '\x114', '\x2', '\x2', 
		'\xC9F', '\xCA6', '\x5', '\x20E', '\x108', '\x2', '\xCA0', '\xCA1', '\a', 
		'\xD9', '\x2', '\x2', '\xCA1', '\xCA6', '\x5', '\x214', '\x10B', '\x2', 
		'\xCA2', '\xCA6', '\x5', '\x216', '\x10C', '\x2', '\xCA3', '\xCA6', '\x5', 
		'\x218', '\x10D', '\x2', '\xCA4', '\xCA6', '\x5', '\x21A', '\x10E', '\x2', 
		'\xCA5', '\xC9F', '\x3', '\x2', '\x2', '\x2', '\xCA5', '\xCA0', '\x3', 
		'\x2', '\x2', '\x2', '\xCA5', '\xCA2', '\x3', '\x2', '\x2', '\x2', '\xCA5', 
		'\xCA3', '\x3', '\x2', '\x2', '\x2', '\xCA5', '\xCA4', '\x3', '\x2', '\x2', 
		'\x2', '\xCA6', '\xCA8', '\x3', '\x2', '\x2', '\x2', '\xCA7', '\xC9E', 
		'\x3', '\x2', '\x2', '\x2', '\xCA8', '\xCAB', '\x3', '\x2', '\x2', '\x2', 
		'\xCA9', '\xCA7', '\x3', '\x2', '\x2', '\x2', '\xCA9', '\xCAA', '\x3', 
		'\x2', '\x2', '\x2', '\xCAA', '\x20B', '\x3', '\x2', '\x2', '\x2', '\xCAB', 
		'\xCA9', '\x3', '\x2', '\x2', '\x2', '\xCAC', '\xCAE', '\a', ' ', '\x2', 
		'\x2', '\xCAD', '\xCAF', '\t', '\x31', '\x2', '\x2', '\xCAE', '\xCAD', 
		'\x3', '\x2', '\x2', '\x2', '\xCAE', '\xCAF', '\x3', '\x2', '\x2', '\x2', 
		'\xCAF', '\xCB3', '\x3', '\x2', '\x2', '\x2', '\xCB0', '\xCB4', '\x5', 
		'\x2E2', '\x172', '\x2', '\xCB1', '\xCB4', '\x5', '\x2DE', '\x170', '\x2', 
		'\xCB2', '\xCB4', '\x5', '\x124', '\x93', '\x2', '\xCB3', '\xCB0', '\x3', 
		'\x2', '\x2', '\x2', '\xCB3', '\xCB1', '\x3', '\x2', '\x2', '\x2', '\xCB3', 
		'\xCB2', '\x3', '\x2', '\x2', '\x2', '\xCB4', '\x20D', '\x3', '\x2', '\x2', 
		'\x2', '\xCB5', '\xCB7', '\t', '\x32', '\x2', '\x2', '\xCB6', '\xCB5', 
		'\x3', '\x2', '\x2', '\x2', '\xCB6', '\xCB7', '\x3', '\x2', '\x2', '\x2', 
		'\xCB7', '\xCB8', '\x3', '\x2', '\x2', '\x2', '\xCB8', '\xCB9', '\a', 
		'\xD9', '\x2', '\x2', '\xCB9', '\xCBB', '\x5', '\x212', '\x10A', '\x2', 
		'\xCBA', '\xCBC', '\x5', '\x214', '\x10B', '\x2', '\xCBB', '\xCBA', '\x3', 
		'\x2', '\x2', '\x2', '\xCBB', '\xCBC', '\x3', '\x2', '\x2', '\x2', '\xCBC', 
		'\x20F', '\x3', '\x2', '\x2', '\x2', '\xCBD', '\xCBF', '\t', '\x32', '\x2', 
		'\x2', '\xCBE', '\xCBD', '\x3', '\x2', '\x2', '\x2', '\xCBE', '\xCBF', 
		'\x3', '\x2', '\x2', '\x2', '\xCBF', '\xCC0', '\x3', '\x2', '\x2', '\x2', 
		'\xCC0', '\xCC1', '\a', '\xD9', '\x2', '\x2', '\xCC1', '\xCC2', '\x5', 
		'\x212', '\x10A', '\x2', '\xCC2', '\x211', '\x3', '\x2', '\x2', '\x2', 
		'\xCC3', '\xCC6', '\x5', '\x2E2', '\x172', '\x2', '\xCC4', '\xCC6', '\x5', 
		'\x124', '\x93', '\x2', '\xCC5', '\xCC3', '\x3', '\x2', '\x2', '\x2', 
		'\xCC5', '\xCC4', '\x3', '\x2', '\x2', '\x2', '\xCC6', '\x213', '\x3', 
		'\x2', '\x2', '\x2', '\xCC7', '\xCC9', '\a', '-', '\x2', '\x2', '\xCC8', 
		'\xCCA', '\a', '\xCB', '\x2', '\x2', '\xCC9', '\xCC8', '\x3', '\x2', '\x2', 
		'\x2', '\xCC9', '\xCCA', '\x3', '\x2', '\x2', '\x2', '\xCCA', '\xCCB', 
		'\x3', '\x2', '\x2', '\x2', '\xCCB', '\xCCC', '\a', '\x100', '\x2', '\x2', 
		'\xCCC', '\x215', '\x3', '\x2', '\x2', '\x2', '\xCCD', '\xCCE', '\a', 
		'\x121', '\x2', '\x2', '\xCCE', '\xCCF', '\t', '\x33', '\x2', '\x2', '\xCCF', 
		'\x217', '\x3', '\x2', '\x2', '\x2', '\xCD0', '\xCD1', '\a', '\x89', '\x2', 
		'\x2', '\xCD1', '\xCD2', '\a', '\x44', '\x2', '\x2', '\xCD2', '\xCD3', 
		'\x5', '\x2DA', '\x16E', '\x2', '\xCD3', '\x219', '\x3', '\x2', '\x2', 
		'\x2', '\xCD4', '\xCD6', '\a', ' ', '\x2', '\x2', '\xCD5', '\xCD7', '\a', 
		'\xEB', '\x2', '\x2', '\xCD6', '\xCD5', '\x3', '\x2', '\x2', '\x2', '\xCD6', 
		'\xCD7', '\x3', '\x2', '\x2', '\x2', '\xCD7', '\xCD8', '\x3', '\x2', '\x2', 
		'\x2', '\xCD8', '\xCD9', '\x5', '\x2E2', '\x172', '\x2', '\xCD9', '\xCDC', 
		'\a', '\xA7', '\x2', '\x2', '\xCDA', '\xCDB', '\a', '\x114', '\x2', '\x2', 
		'\xCDB', '\xCDD', '\x5', '\x21C', '\x10F', '\x2', '\xCDC', '\xCDA', '\x3', 
		'\x2', '\x2', '\x2', '\xCDD', '\xCDE', '\x3', '\x2', '\x2', '\x2', '\xCDE', 
		'\xCDC', '\x3', '\x2', '\x2', '\x2', '\xCDE', '\xCDF', '\x3', '\x2', '\x2', 
		'\x2', '\xCDF', '\xCE0', '\x3', '\x2', '\x2', '\x2', '\xCE0', '\xCE1', 
		'\a', '\xF0', '\x2', '\x2', '\xCE1', '\x21B', '\x3', '\x2', '\x2', '\x2', 
		'\xCE2', '\xCE3', '\a', '\x8A', '\x2', '\x2', '\xCE3', '\xCE8', '\x5', 
		'\x2E4', '\x173', '\x2', '\xCE4', '\xCE8', '\x5', '\x210', '\x109', '\x2', 
		'\xCE5', '\xCE6', '\a', '\xD9', '\x2', '\x2', '\xCE6', '\xCE8', '\x5', 
		'\x214', '\x10B', '\x2', '\xCE7', '\xCE2', '\x3', '\x2', '\x2', '\x2', 
		'\xCE7', '\xCE4', '\x3', '\x2', '\x2', '\x2', '\xCE7', '\xCE5', '\x3', 
		'\x2', '\x2', '\x2', '\xCE8', '\x21D', '\x3', '\x2', '\x2', '\x2', '\xCE9', 
		'\xCEC', '\t', '\x30', '\x2', '\x2', '\xCEA', '\xCEB', '\a', '\x14B', 
		'\x2', '\x2', '\xCEB', '\xCED', '\a', ' ', '\x2', '\x2', '\xCEC', '\xCEA', 
		'\x3', '\x2', '\x2', '\x2', '\xCEC', '\xCED', '\x3', '\x2', '\x2', '\x2', 
		'\xCED', '\xCEF', '\x3', '\x2', '\x2', '\x2', '\xCEE', '\xCF0', '\x5', 
		'\x14A', '\xA6', '\x2', '\xCEF', '\xCEE', '\x3', '\x2', '\x2', '\x2', 
		'\xCEF', '\xCF0', '\x3', '\x2', '\x2', '\x2', '\xCF0', '\x21F', '\x3', 
		'\x2', '\x2', '\x2', '\xCF1', '\xCF2', '\a', '\x41', '\x2', '\x2', '\xCF2', 
		'\xCF4', '\a', '\x13F', '\x2', '\x2', '\xCF3', '\xCF5', '\x5', '\x14A', 
		'\xA6', '\x2', '\xCF4', '\xCF3', '\x3', '\x2', '\x2', '\x2', '\xCF4', 
		'\xCF5', '\x3', '\x2', '\x2', '\x2', '\xCF5', '\x221', '\x3', '\x2', '\x2', 
		'\x2', '\xCF6', '\xCF7', '\a', '\x124', '\x2', '\x2', '\xCF7', '\xCF9', 
		'\x5', '\x22C', '\x117', '\x2', '\xCF8', '\xCFA', '\x5', '\x14A', '\xA6', 
		'\x2', '\xCF9', '\xCF8', '\x3', '\x2', '\x2', '\x2', '\xCF9', '\xCFA', 
		'\x3', '\x2', '\x2', '\x2', '\xCFA', '\x223', '\x3', '\x2', '\x2', '\x2', 
		'\xCFB', '\xCFD', '\a', '\x15', '\x2', '\x2', '\xCFC', '\xCFB', '\x3', 
		'\x2', '\x2', '\x2', '\xCFC', '\xCFD', '\x3', '\x2', '\x2', '\x2', '\xCFD', 
		'\xCFE', '\x3', '\x2', '\x2', '\x2', '\xCFE', '\xD00', '\x5', '\x22C', 
		'\x117', '\x2', '\xCFF', '\xD01', '\x5', '\x22A', '\x116', '\x2', '\xD00', 
		'\xCFF', '\x3', '\x2', '\x2', '\x2', '\xD00', '\xD01', '\x3', '\x2', '\x2', 
		'\x2', '\xD01', '\xD03', '\x3', '\x2', '\x2', '\x2', '\xD02', '\xD04', 
		'\x5', '\x14A', '\xA6', '\x2', '\xD03', '\xD02', '\x3', '\x2', '\x2', 
		'\x2', '\xD03', '\xD04', '\x3', '\x2', '\x2', '\x2', '\xD04', '\x225', 
		'\x3', '\x2', '\x2', '\x2', '\xD05', '\xD06', '\t', ',', '\x2', '\x2', 
		'\xD06', '\xD07', '\x5', '\x1E2', '\xF2', '\x2', '\xD07', '\xD09', '\x5', 
		'\x22C', '\x117', '\x2', '\xD08', '\xD0A', '\x5', '\x22A', '\x116', '\x2', 
		'\xD09', '\xD08', '\x3', '\x2', '\x2', '\x2', '\xD09', '\xD0A', '\x3', 
		'\x2', '\x2', '\x2', '\xD0A', '\xD0C', '\x3', '\x2', '\x2', '\x2', '\xD0B', 
		'\xD0D', '\x5', '\x14A', '\xA6', '\x2', '\xD0C', '\xD0B', '\x3', '\x2', 
		'\x2', '\x2', '\xD0C', '\xD0D', '\x3', '\x2', '\x2', '\x2', '\xD0D', '\x227', 
		'\x3', '\x2', '\x2', '\x2', '\xD0E', '\xD10', '\t', '\x30', '\x2', '\x2', 
		'\xD0F', '\xD11', '\x5', '\x1E0', '\xF1', '\x2', '\xD10', '\xD0F', '\x3', 
		'\x2', '\x2', '\x2', '\xD10', '\xD11', '\x3', '\x2', '\x2', '\x2', '\xD11', 
		'\xD12', '\x3', '\x2', '\x2', '\x2', '\xD12', '\xD14', '\x5', '\x22C', 
		'\x117', '\x2', '\xD13', '\xD15', '\x5', '\x22A', '\x116', '\x2', '\xD14', 
		'\xD13', '\x3', '\x2', '\x2', '\x2', '\xD14', '\xD15', '\x3', '\x2', '\x2', 
		'\x2', '\xD15', '\xD17', '\x3', '\x2', '\x2', '\x2', '\xD16', '\xD18', 
		'\x5', '\x14A', '\xA6', '\x2', '\xD17', '\xD16', '\x3', '\x2', '\x2', 
		'\x2', '\xD17', '\xD18', '\x3', '\x2', '\x2', '\x2', '\xD18', '\x229', 
		'\x3', '\x2', '\x2', '\x2', '\xD19', '\xD1B', '\a', '\x1B', '\x2', '\x2', 
		'\xD1A', '\xD1C', '\a', '\x104', '\x2', '\x2', '\xD1B', '\xD1A', '\x3', 
		'\x2', '\x2', '\x2', '\xD1B', '\xD1C', '\x3', '\x2', '\x2', '\x2', '\xD1C', 
		'\xD1D', '\x3', '\x2', '\x2', '\x2', '\xD1D', '\xD1E', '\t', '\x34', '\x2', 
		'\x2', '\xD1E', '\x22B', '\x3', '\x2', '\x2', '\x2', '\xD1F', '\xD20', 
		'\t', '\x35', '\x2', '\x2', '\xD20', '\x22D', '\x3', '\x2', '\x2', '\x2', 
		'\xD21', '\xD2D', '\x5', '\x230', '\x119', '\x2', '\xD22', '\xD2D', '\x5', 
		'\x236', '\x11C', '\x2', '\xD23', '\xD2D', '\x5', '\x250', '\x129', '\x2', 
		'\xD24', '\xD2D', '\x5', '\x252', '\x12A', '\x2', '\xD25', '\xD2D', '\x5', 
		'\x242', '\x122', '\x2', '\xD26', '\xD2D', '\x5', '\x244', '\x123', '\x2', 
		'\xD27', '\xD2D', '\x5', '\x270', '\x139', '\x2', '\xD28', '\xD2D', '\x5', 
		'\x24C', '\x127', '\x2', '\xD29', '\xD2D', '\x5', '\x248', '\x125', '\x2', 
		'\xD2A', '\xD2D', '\x5', '\x246', '\x124', '\x2', '\xD2B', '\xD2D', '\x5', 
		'\x24E', '\x128', '\x2', '\xD2C', '\xD21', '\x3', '\x2', '\x2', '\x2', 
		'\xD2C', '\xD22', '\x3', '\x2', '\x2', '\x2', '\xD2C', '\xD23', '\x3', 
		'\x2', '\x2', '\x2', '\xD2C', '\xD24', '\x3', '\x2', '\x2', '\x2', '\xD2C', 
		'\xD25', '\x3', '\x2', '\x2', '\x2', '\xD2C', '\xD26', '\x3', '\x2', '\x2', 
		'\x2', '\xD2C', '\xD27', '\x3', '\x2', '\x2', '\x2', '\xD2C', '\xD28', 
		'\x3', '\x2', '\x2', '\x2', '\xD2C', '\xD29', '\x3', '\x2', '\x2', '\x2', 
		'\xD2C', '\xD2A', '\x3', '\x2', '\x2', '\x2', '\xD2C', '\xD2B', '\x3', 
		'\x2', '\x2', '\x2', '\xD2D', '\x22F', '\x3', '\x2', '\x2', '\x2', '\xD2E', 
		'\xD30', '\a', '\x15', '\x2', '\x2', '\xD2F', '\xD31', '\x5', '\x232', 
		'\x11A', '\x2', '\xD30', '\xD2F', '\x3', '\x2', '\x2', '\x2', '\xD30', 
		'\xD31', '\x3', '\x2', '\x2', '\x2', '\xD31', '\xD32', '\x3', '\x2', '\x2', 
		'\x2', '\xD32', '\xD33', '\a', '\xD2', '\x2', '\x2', '\xD33', '\xD34', 
		'\x5', '\x234', '\x11B', '\x2', '\xD34', '\x231', '\x3', '\x2', '\x2', 
		'\x2', '\xD35', '\xD37', '\t', '\x36', '\x2', '\x2', '\xD36', '\xD35', 
		'\x3', '\x2', '\x2', '\x2', '\xD36', '\xD37', '\x3', '\x2', '\x2', '\x2', 
		'\xD37', '\xD38', '\x3', '\x2', '\x2', '\x2', '\xD38', '\xD39', '\a', 
		'\xE6', '\x2', '\x2', '\xD39', '\x233', '\x3', '\x2', '\x2', '\x2', '\xD3A', 
		'\xD3B', '\a', '\x89', '\x2', '\x2', '\xD3B', '\xD48', '\t', '\x37', '\x2', 
		'\x2', '\xD3C', '\xD3F', '\t', '.', '\x2', '\x2', '\xD3D', '\xD40', '\a', 
		'\x12B', '\x2', '\x2', '\xD3E', '\xD40', '\x5', '\x2D8', '\x16D', '\x2', 
		'\xD3F', '\xD3D', '\x3', '\x2', '\x2', '\x2', '\xD3F', '\xD3E', '\x3', 
		'\x2', '\x2', '\x2', '\xD40', '\xD48', '\x3', '\x2', '\x2', '\x2', '\xD41', 
		'\xD44', '\t', '\x38', '\x2', '\x2', '\xD42', '\xD45', '\a', '\x12B', 
		'\x2', '\x2', '\xD43', '\xD45', '\x5', '\x2D8', '\x16D', '\x2', '\xD44', 
		'\xD42', '\x3', '\x2', '\x2', '\x2', '\xD44', '\xD43', '\x3', '\x2', '\x2', 
		'\x2', '\xD45', '\xD48', '\x3', '\x2', '\x2', '\x2', '\xD46', '\xD48', 
		'\a', 'H', '\x2', '\x2', '\xD47', '\xD3A', '\x3', '\x2', '\x2', '\x2', 
		'\xD47', '\xD3C', '\x3', '\x2', '\x2', '\x2', '\xD47', '\xD41', '\x3', 
		'\x2', '\x2', '\x2', '\xD47', '\xD46', '\x3', '\x2', '\x2', '\x2', '\xD48', 
		'\x235', '\x3', '\x2', '\x2', '\x2', '\xD49', '\xD56', '\a', '>', '\x2', 
		'\x2', '\xD4A', '\xD4B', '\x5', '\x238', '\x11D', '\x2', '\xD4B', '\xD4C', 
		'\a', '\xD2', '\x2', '\x2', '\xD4C', '\xD4D', '\x5', '\x282', '\x142', 
		'\x2', '\xD4D', '\xD57', '\x3', '\x2', '\x2', '\x2', '\xD4E', '\xD4F', 
		'\x5', '\x240', '\x121', '\x2', '\xD4F', '\xD50', '\a', '\xD2', '\x2', 
		'\x2', '\xD50', '\xD51', '\a', 'H', '\x2', '\x2', '\xD51', '\xD57', '\x3', 
		'\x2', '\x2', '\x2', '\xD52', '\xD53', '\a', '\xD2', '\x2', '\x2', '\xD53', 
		'\xD54', '\x5', '\x284', '\x143', '\x2', '\xD54', '\xD55', '\x5', '\x278', 
		'\x13D', '\x2', '\xD55', '\xD57', '\x3', '\x2', '\x2', '\x2', '\xD56', 
		'\xD4A', '\x3', '\x2', '\x2', '\x2', '\xD56', '\xD4E', '\x3', '\x2', '\x2', 
		'\x2', '\xD56', '\xD52', '\x3', '\x2', '\x2', '\x2', '\xD57', '\x237', 
		'\x3', '\x2', '\x2', '\x2', '\xD58', '\xD5E', '\x5', '\x25A', '\x12E', 
		'\x2', '\xD59', '\xD5E', '\x5', '\x25C', '\x12F', '\x2', '\xD5A', '\xD5E', 
		'\x5', '\x23A', '\x11E', '\x2', '\xD5B', '\xD5E', '\x5', '\x23C', '\x11F', 
		'\x2', '\xD5C', '\xD5E', '\x5', '\x23E', '\x120', '\x2', '\xD5D', '\xD58', 
		'\x3', '\x2', '\x2', '\x2', '\xD5D', '\xD59', '\x3', '\x2', '\x2', '\x2', 
		'\xD5D', '\xD5A', '\x3', '\x2', '\x2', '\x2', '\xD5D', '\xD5B', '\x3', 
		'\x2', '\x2', '\x2', '\xD5D', '\xD5C', '\x3', '\x2', '\x2', '\x2', '\xD5E', 
		'\x239', '\x3', '\x2', '\x2', '\x2', '\xD5F', '\xD61', '\a', '\xC3', '\x2', 
		'\x2', '\xD60', '\xD62', '\a', '\xC5', '\x2', '\x2', '\xD61', '\xD60', 
		'\x3', '\x2', '\x2', '\x2', '\xD61', '\xD62', '\x3', '\x2', '\x2', '\x2', 
		'\xD62', '\xD63', '\x3', '\x2', '\x2', '\x2', '\xD63', '\xD64', '\t', 
		'\x39', '\x2', '\x2', '\xD64', '\x23B', '\x3', '\x2', '\x2', '\x2', '\xD65', 
		'\xD67', '\a', '\xC3', '\x2', '\x2', '\xD66', '\xD68', '\a', '\xF7', '\x2', 
		'\x2', '\xD67', '\xD66', '\x3', '\x2', '\x2', '\x2', '\xD67', '\xD68', 
		'\x3', '\x2', '\x2', '\x2', '\xD68', '\xD69', '\x3', '\x2', '\x2', '\x2', 
		'\xD69', '\xD6A', '\t', ':', '\x2', '\x2', '\xD6A', '\x23D', '\x3', '\x2', 
		'\x2', '\x2', '\xD6B', '\xD6D', '\a', '\xC3', '\x2', '\x2', '\xD6C', '\xD6E', 
		'\a', '\xEA', '\x2', '\x2', '\xD6D', '\xD6C', '\x3', '\x2', '\x2', '\x2', 
		'\xD6D', '\xD6E', '\x3', '\x2', '\x2', '\x2', '\xD6E', '\xD6F', '\x3', 
		'\x2', '\x2', '\x2', '\xD6F', '\xD70', '\t', ';', '\x2', '\x2', '\xD70', 
		'\x23F', '\x3', '\x2', '\x2', '\x2', '\xD71', '\xD79', '\a', '\x12', '\x2', 
		'\x2', '\xD72', '\xD74', '\a', '\x35', '\x2', '\x2', '\xD73', '\xD72', 
		'\x3', '\x2', '\x2', '\x2', '\xD73', '\xD74', '\x3', '\x2', '\x2', '\x2', 
		'\xD74', '\xD75', '\x3', '\x2', '\x2', '\x2', '\xD75', '\xD79', '\a', 
		'\x44', '\x2', '\x2', '\xD76', '\xD79', '\a', '\x105', '\x2', '\x2', '\xD77', 
		'\xD79', '\a', '\x13F', '\x2', '\x2', '\xD78', '\xD71', '\x3', '\x2', 
		'\x2', '\x2', '\xD78', '\xD73', '\x3', '\x2', '\x2', '\x2', '\xD78', '\xD76', 
		'\x3', '\x2', '\x2', '\x2', '\xD78', '\xD77', '\x3', '\x2', '\x2', '\x2', 
		'\xD79', '\x241', '\x3', '\x2', '\x2', '\x2', '\xD7A', '\xD86', '\a', 
		'[', '\x2', '\x2', '\xD7B', '\xD7E', '\x5', '\x25A', '\x12E', '\x2', '\xD7C', 
		'\xD7E', '\x5', '\x25C', '\x12F', '\x2', '\xD7D', '\xD7B', '\x3', '\x2', 
		'\x2', '\x2', '\xD7D', '\xD7C', '\x3', '\x2', '\x2', '\x2', '\xD7E', '\xD7F', 
		'\x3', '\x2', '\x2', '\x2', '\xD7F', '\xD80', '\a', '\xD2', '\x2', '\x2', 
		'\xD80', '\xD81', '\x5', '\x282', '\x142', '\x2', '\xD81', '\xD87', '\x3', 
		'\x2', '\x2', '\x2', '\xD82', '\xD83', '\x5', '\x240', '\x121', '\x2', 
		'\xD83', '\xD84', '\a', '\xD2', '\x2', '\x2', '\xD84', '\xD85', '\a', 
		'H', '\x2', '\x2', '\xD85', '\xD87', '\x3', '\x2', '\x2', '\x2', '\xD86', 
		'\xD7D', '\x3', '\x2', '\x2', '\x2', '\xD86', '\xD82', '\x3', '\x2', '\x2', 
		'\x2', '\xD87', '\x243', '\x3', '\x2', '\x2', '\x2', '\xD88', '\xD89', 
		'\a', '\xAD', '\x2', '\x2', '\xD89', '\xD8E', '\a', '\xD2', '\x2', '\x2', 
		'\xD8A', '\xD8B', '\t', '<', '\x2', '\x2', '\xD8B', '\xD8F', '\x5', '\x2E6', 
		'\x174', '\x2', '\xD8C', '\xD8D', '\a', '\x15', '\x2', '\x2', '\xD8D', 
		'\xD8F', '\a', '\x43', '\x2', '\x2', '\xD8E', '\xD8A', '\x3', '\x2', '\x2', 
		'\x2', '\xD8E', '\xD8C', '\x3', '\x2', '\x2', '\x2', '\xD8F', '\x245', 
		'\x3', '\x2', '\x2', '\x2', '\xD90', '\xDA9', '\a', '\x11B', '\x2', '\x2', 
		'\xD91', '\xD98', '\x5', '\x25A', '\x12E', '\x2', '\xD92', '\xD98', '\x5', 
		'\x25C', '\x12F', '\x2', '\xD93', '\xD95', '\x5', '\x25E', '\x130', '\x2', 
		'\xD94', '\xD96', '\x5', '\x260', '\x131', '\x2', '\xD95', '\xD94', '\x3', 
		'\x2', '\x2', '\x2', '\xD95', '\xD96', '\x3', '\x2', '\x2', '\x2', '\xD96', 
		'\xD98', '\x3', '\x2', '\x2', '\x2', '\xD97', '\xD91', '\x3', '\x2', '\x2', 
		'\x2', '\xD97', '\xD92', '\x3', '\x2', '\x2', '\x2', '\xD97', '\xD93', 
		'\x3', '\x2', '\x2', '\x2', '\xD98', '\xD99', '\x3', '\x2', '\x2', '\x2', 
		'\xD99', '\xD9A', '\a', '\xD2', '\x2', '\x2', '\xD9A', '\xD9B', '\x5', 
		'\x282', '\x142', '\x2', '\xD9B', '\xDAA', '\x3', '\x2', '\x2', '\x2', 
		'\xD9C', '\xDA6', '\a', '\x12', '\x2', '\x2', '\xD9D', '\xDA6', '\a', 
		'\xE5', '\x2', '\x2', '\xD9E', '\xDA6', '\a', '\x105', '\x2', '\x2', '\xD9F', 
		'\xDA6', '\a', '\x112', '\x2', '\x2', '\xDA0', '\xDA6', '\a', '\x113', 
		'\x2', '\x2', '\xDA1', '\xDA2', '\x5', '\x17C', '\xBF', '\x2', '\xDA2', 
		'\xDA3', '\x5', '\x266', '\x134', '\x2', '\xDA3', '\xDA6', '\x3', '\x2', 
		'\x2', '\x2', '\xDA4', '\xDA6', '\a', '\x13F', '\x2', '\x2', '\xDA5', 
		'\xD9C', '\x3', '\x2', '\x2', '\x2', '\xDA5', '\xD9D', '\x3', '\x2', '\x2', 
		'\x2', '\xDA5', '\xD9E', '\x3', '\x2', '\x2', '\x2', '\xDA5', '\xD9F', 
		'\x3', '\x2', '\x2', '\x2', '\xDA5', '\xDA0', '\x3', '\x2', '\x2', '\x2', 
		'\xDA5', '\xDA1', '\x3', '\x2', '\x2', '\x2', '\xDA5', '\xDA4', '\x3', 
		'\x2', '\x2', '\x2', '\xDA6', '\xDA7', '\x3', '\x2', '\x2', '\x2', '\xDA7', 
		'\xDA8', '\a', '\xD2', '\x2', '\x2', '\xDA8', '\xDAA', '\a', 'H', '\x2', 
		'\x2', '\xDA9', '\xD97', '\x3', '\x2', '\x2', '\x2', '\xDA9', '\xDA5', 
		'\x3', '\x2', '\x2', '\x2', '\xDAA', '\x247', '\x3', '\x2', '\x2', '\x2', 
		'\xDAB', '\xDD1', '\a', '\x114', '\x2', '\x2', '\xDAC', '\xDBB', '\x5', 
		'\x24A', '\x126', '\x2', '\xDAD', '\xDB1', '\a', '\x13F', '\x2', '\x2', 
		'\xDAE', '\xDB2', '\a', '\x121', '\x2', '\x2', '\xDAF', '\xDB0', '\a', 
		'\x89', '\x2', '\x2', '\xDB0', '\xDB2', '\a', '\x44', '\x2', '\x2', '\xDB1', 
		'\xDAE', '\x3', '\x2', '\x2', '\x2', '\xDB1', '\xDAF', '\x3', '\x2', '\x2', 
		'\x2', '\xDB2', '\xDBB', '\x3', '\x2', '\x2', '\x2', '\xDB3', '\xDB7', 
		'\a', '\x44', '\x2', '\x2', '\xDB4', '\xDB8', '\a', '\r', '\x2', '\x2', 
		'\xDB5', '\xDB6', '\a', 'J', '\x2', '\x2', '\xDB6', '\xDB8', '\a', '\xA5', 
		'\x2', '\x2', '\xDB7', '\xDB4', '\x3', '\x2', '\x2', '\x2', '\xDB7', '\xDB5', 
		'\x3', '\x2', '\x2', '\x2', '\xDB8', '\xDBB', '\x3', '\x2', '\x2', '\x2', 
		'\xDB9', '\xDBB', '\a', ' ', '\x2', '\x2', '\xDBA', '\xDAC', '\x3', '\x2', 
		'\x2', '\x2', '\xDBA', '\xDAD', '\x3', '\x2', '\x2', '\x2', '\xDBA', '\xDB3', 
		'\x3', '\x2', '\x2', '\x2', '\xDBA', '\xDB9', '\x3', '\x2', '\x2', '\x2', 
		'\xDBB', '\xDBC', '\x3', '\x2', '\x2', '\x2', '\xDBC', '\xDBD', '\a', 
		'\xD2', '\x2', '\x2', '\xDBD', '\xDD2', '\a', 'H', '\x2', '\x2', '\xDBE', 
		'\xDC2', '\a', '\x44', '\x2', '\x2', '\xDBF', '\xDC3', '\a', '\r', '\x2', 
		'\x2', '\xDC0', '\xDC1', '\a', 'J', '\x2', '\x2', '\xDC1', '\xDC3', '\a', 
		'\xA5', '\x2', '\x2', '\xDC2', '\xDBF', '\x3', '\x2', '\x2', '\x2', '\xDC2', 
		'\xDC0', '\x3', '\x2', '\x2', '\x2', '\xDC3', '\xDC4', '\x3', '\x2', '\x2', 
		'\x2', '\xDC4', '\xDC5', '\a', '\xD2', '\x2', '\x2', '\xDC5', '\xDD2', 
		'\x5', '\x282', '\x142', '\x2', '\xDC6', '\xDC7', '\a', '\xA1', '\x2', 
		'\x2', '\xDC7', '\xDC8', '\x5', '\x272', '\x13A', '\x2', '\xDC8', '\xDC9', 
		'\a', '\xD2', '\x2', '\x2', '\xDC9', '\xDCA', '\x5', '\x284', '\x143', 
		'\x2', '\xDCA', '\xDD2', '\x3', '\x2', '\x2', '\x2', '\xDCB', '\xDCC', 
		'\a', '\xEA', '\x2', '\x2', '\xDCC', '\xDCD', '\x5', '\x274', '\x13B', 
		'\x2', '\xDCD', '\xDCE', '\a', '\xD2', '\x2', '\x2', '\xDCE', '\xDCF', 
		'\x5', '\x284', '\x143', '\x2', '\xDCF', '\xDD0', '\x5', '\x278', '\x13D', 
		'\x2', '\xDD0', '\xDD2', '\x3', '\x2', '\x2', '\x2', '\xDD1', '\xDBA', 
		'\x3', '\x2', '\x2', '\x2', '\xDD1', '\xDBE', '\x3', '\x2', '\x2', '\x2', 
		'\xDD1', '\xDC6', '\x3', '\x2', '\x2', '\x2', '\xDD1', '\xDCB', '\x3', 
		'\x2', '\x2', '\x2', '\xDD2', '\x249', '\x3', '\x2', '\x2', '\x2', '\xDD3', 
		'\xDD4', '\t', '=', '\x2', '\x2', '\xDD4', '\x24B', '\x3', '\x2', '\x2', 
		'\x2', '\xDD5', '\xDDE', '\a', '\xF9', '\x2', '\x2', '\xDD6', '\xDD7', 
		'\t', '>', '\x2', '\x2', '\xDD7', '\xDD8', '\a', '\xD2', '\x2', '\x2', 
		'\xDD8', '\xDDF', '\a', 'H', '\x2', '\x2', '\xDD9', '\xDDA', '\a', '\xA1', 
		'\x2', '\x2', '\xDDA', '\xDDB', '\x5', '\x272', '\x13A', '\x2', '\xDDB', 
		'\xDDC', '\a', '\xD2', '\x2', '\x2', '\xDDC', '\xDDD', '\x5', '\x284', 
		'\x143', '\x2', '\xDDD', '\xDDF', '\x3', '\x2', '\x2', '\x2', '\xDDE', 
		'\xDD6', '\x3', '\x2', '\x2', '\x2', '\xDDE', '\xDD9', '\x3', '\x2', '\x2', 
		'\x2', '\xDDF', '\x24D', '\x3', '\x2', '\x2', '\x2', '\xDE0', '\xDE1', 
		'\a', '\x14D', '\x2', '\x2', '\xDE1', '\xDE2', '\a', '\xD2', '\x2', '\x2', 
		'\xDE2', '\xDE3', '\x5', '\x284', '\x143', '\x2', '\xDE3', '\x24F', '\x3', 
		'\x2', '\x2', '\x2', '\xDE4', '\xE00', '\a', '\r', '\x2', '\x2', '\xDE5', 
		'\xDE7', '\a', '\x17', '\x2', '\x2', '\xDE6', '\xDE8', '\a', '\x35', '\x2', 
		'\x2', '\xDE7', '\xDE6', '\x3', '\x2', '\x2', '\x2', '\xDE7', '\xDE8', 
		'\x3', '\x2', '\x2', '\x2', '\xDE8', '\xDE9', '\x3', '\x2', '\x2', '\x2', 
		'\xDE9', '\xE00', '\a', '\x44', '\x2', '\x2', '\xDEA', '\xE00', '\a', 
		'\x11F', '\x2', '\x2', '\xDEB', '\xE00', '\a', '\x122', '\x2', '\x2', 
		'\xDEC', '\xDF0', '\x5', '\x25A', '\x12E', '\x2', '\xDED', '\xDF0', '\x5', 
		'\x25C', '\x12F', '\x2', '\xDEE', '\xDF0', '\a', '\xBC', '\x2', '\x2', 
		'\xDEF', '\xDEC', '\x3', '\x2', '\x2', '\x2', '\xDEF', '\xDED', '\x3', 
		'\x2', '\x2', '\x2', '\xDEF', '\xDEE', '\x3', '\x2', '\x2', '\x2', '\xDF0', 
		'\xDF2', '\x3', '\x2', '\x2', '\x2', '\xDF1', '\xDF3', '\a', '\xB2', '\x2', 
		'\x2', '\xDF2', '\xDF1', '\x3', '\x2', '\x2', '\x2', '\xDF2', '\xDF3', 
		'\x3', '\x2', '\x2', '\x2', '\xDF3', '\xE00', '\x3', '\x2', '\x2', '\x2', 
		'\xDF4', '\xDF6', '\a', '\x131', '\x2', '\x2', '\xDF5', '\xDF7', '\a', 
		'\xB2', '\x2', '\x2', '\xDF6', '\xDF5', '\x3', '\x2', '\x2', '\x2', '\xDF6', 
		'\xDF7', '\x3', '\x2', '\x2', '\x2', '\xDF7', '\xDFB', '\x3', '\x2', '\x2', 
		'\x2', '\xDF8', '\xDF9', '\a', '\x127', '\x2', '\x2', '\xDF9', '\xDFB', 
		'\x5', '\x25E', '\x130', '\x2', '\xDFA', '\xDF4', '\x3', '\x2', '\x2', 
		'\x2', '\xDFA', '\xDF8', '\x3', '\x2', '\x2', '\x2', '\xDFB', '\xDFD', 
		'\x3', '\x2', '\x2', '\x2', '\xDFC', '\xDFE', '\x5', '\x260', '\x131', 
		'\x2', '\xDFD', '\xDFC', '\x3', '\x2', '\x2', '\x2', '\xDFD', '\xDFE', 
		'\x3', '\x2', '\x2', '\x2', '\xDFE', '\xE00', '\x3', '\x2', '\x2', '\x2', 
		'\xDFF', '\xDE4', '\x3', '\x2', '\x2', '\x2', '\xDFF', '\xDE5', '\x3', 
		'\x2', '\x2', '\x2', '\xDFF', '\xDEA', '\x3', '\x2', '\x2', '\x2', '\xDFF', 
		'\xDEB', '\x3', '\x2', '\x2', '\x2', '\xDFF', '\xDEF', '\x3', '\x2', '\x2', 
		'\x2', '\xDFF', '\xDFA', '\x3', '\x2', '\x2', '\x2', '\xE00', '\xE01', 
		'\x3', '\x2', '\x2', '\x2', '\xE01', '\xE02', '\a', '\xD2', '\x2', '\x2', 
		'\xE02', '\xE03', '\x5', '\x282', '\x142', '\x2', '\xE03', '\x251', '\x3', 
		'\x2', '\x2', '\x2', '\xE04', '\xE0B', '\a', '\x17', '\x2', '\x2', '\xE05', 
		'\xE0C', '\a', '\x12', '\x2', '\x2', '\xE06', '\xE08', '\a', '\x35', '\x2', 
		'\x2', '\xE07', '\xE06', '\x3', '\x2', '\x2', '\x2', '\xE07', '\xE08', 
		'\x3', '\x2', '\x2', '\x2', '\xE08', '\xE09', '\x3', '\x2', '\x2', '\x2', 
		'\xE09', '\xE0C', '\a', '\x44', '\x2', '\x2', '\xE0A', '\xE0C', '\a', 
		'\x13F', '\x2', '\x2', '\xE0B', '\xE05', '\x3', '\x2', '\x2', '\x2', '\xE0B', 
		'\xE07', '\x3', '\x2', '\x2', '\x2', '\xE0B', '\xE0A', '\x3', '\x2', '\x2', 
		'\x2', '\xE0C', '\xE23', '\x3', '\x2', '\x2', '\x2', '\xE0D', '\xE0E', 
		'\a', '\x1E', '\x2', '\x2', '\xE0E', '\xE23', '\t', '>', '\x2', '\x2', 
		'\xE0F', '\xE19', '\a', '\x12', '\x2', '\x2', '\xE10', '\xE12', '\a', 
		'\x35', '\x2', '\x2', '\xE11', '\xE10', '\x3', '\x2', '\x2', '\x2', '\xE11', 
		'\xE12', '\x3', '\x2', '\x2', '\x2', '\xE12', '\xE13', '\x3', '\x2', '\x2', 
		'\x2', '\xE13', '\xE19', '\a', '\x44', '\x2', '\x2', '\xE14', '\xE19', 
		'\a', '\xE5', '\x2', '\x2', '\xE15', '\xE19', '\a', '\x105', '\x2', '\x2', 
		'\xE16', '\xE19', '\a', '\x112', '\x2', '\x2', '\xE17', '\xE19', '\a', 
		'\x13F', '\x2', '\x2', '\xE18', '\xE0F', '\x3', '\x2', '\x2', '\x2', '\xE18', 
		'\xE11', '\x3', '\x2', '\x2', '\x2', '\xE18', '\xE14', '\x3', '\x2', '\x2', 
		'\x2', '\xE18', '\xE15', '\x3', '\x2', '\x2', '\x2', '\xE18', '\xE16', 
		'\x3', '\x2', '\x2', '\x2', '\xE18', '\xE17', '\x3', '\x2', '\x2', '\x2', 
		'\xE19', '\xE1A', '\x3', '\x2', '\x2', '\x2', '\xE1A', '\xE23', '\a', 
		'\xB2', '\x2', '\x2', '\xE1B', '\xE23', '\x5', '\x254', '\x12B', '\x2', 
		'\xE1C', '\xE1D', '\a', '\xF4', '\x2', '\x2', '\xE1D', '\xE23', '\t', 
		'?', '\x2', '\x2', '\xE1E', '\xE20', '\a', '\x8C', '\x2', '\x2', '\xE1F', 
		'\xE21', '\x5', '\x260', '\x131', '\x2', '\xE20', '\xE1F', '\x3', '\x2', 
		'\x2', '\x2', '\xE20', '\xE21', '\x3', '\x2', '\x2', '\x2', '\xE21', '\xE23', 
		'\x3', '\x2', '\x2', '\x2', '\xE22', '\xE04', '\x3', '\x2', '\x2', '\x2', 
		'\xE22', '\xE0D', '\x3', '\x2', '\x2', '\x2', '\xE22', '\xE18', '\x3', 
		'\x2', '\x2', '\x2', '\xE22', '\xE1B', '\x3', '\x2', '\x2', '\x2', '\xE22', 
		'\xE1C', '\x3', '\x2', '\x2', '\x2', '\xE22', '\xE1E', '\x3', '\x2', '\x2', 
		'\x2', '\xE23', '\xE24', '\x3', '\x2', '\x2', '\x2', '\xE24', '\xE25', 
		'\a', '\xD2', '\x2', '\x2', '\xE25', '\xE26', '\a', 'H', '\x2', '\x2', 
		'\xE26', '\x253', '\x3', '\x2', '\x2', '\x2', '\xE27', '\xE3C', '\a', 
		'l', '\x2', '\x2', '\xE28', '\xE29', '\x5', '\x256', '\x12C', '\x2', '\xE29', 
		'\xE2A', '\a', '\xE8', '\x2', '\x2', '\xE2A', '\xE3D', '\x3', '\x2', '\x2', 
		'\x2', '\xE2B', '\xE2D', '\a', '%', '\x2', '\x2', '\xE2C', '\xE2B', '\x3', 
		'\x2', '\x2', '\x2', '\xE2C', '\xE2D', '\x3', '\x2', '\x2', '\x2', '\xE2D', 
		'\xE3A', '\x3', '\x2', '\x2', '\x2', '\xE2E', '\xE2F', '\x5', '\x258', 
		'\x12D', '\x2', '\xE2F', '\xE30', '\x5', '\x264', '\x133', '\x2', '\xE30', 
		'\xE3B', '\x3', '\x2', '\x2', '\x2', '\xE31', '\xE33', '\a', '\x13F', 
		'\x2', '\x2', '\xE32', '\xE34', '\a', 'K', '\x2', '\x2', '\xE33', '\xE32', 
		'\x3', '\x2', '\x2', '\x2', '\xE33', '\xE34', '\x3', '\x2', '\x2', '\x2', 
		'\xE34', '\xE36', '\x3', '\x2', '\x2', '\x2', '\xE35', '\xE31', '\x3', 
		'\x2', '\x2', '\x2', '\xE35', '\xE36', '\x3', '\x2', '\x2', '\x2', '\xE36', 
		'\xE37', '\x3', '\x2', '\x2', '\x2', '\xE37', '\xE38', '\x5', '\x170', 
		'\xB9', '\x2', '\xE38', '\xE39', '\x5', '\x262', '\x132', '\x2', '\xE39', 
		'\xE3B', '\x3', '\x2', '\x2', '\x2', '\xE3A', '\xE2E', '\x3', '\x2', '\x2', 
		'\x2', '\xE3A', '\xE35', '\x3', '\x2', '\x2', '\x2', '\xE3B', '\xE3D', 
		'\x3', '\x2', '\x2', '\x2', '\xE3C', '\xE28', '\x3', '\x2', '\x2', '\x2', 
		'\xE3C', '\xE2C', '\x3', '\x2', '\x2', '\x2', '\xE3D', '\x255', '\x3', 
		'\x2', '\x2', '\x2', '\xE3E', '\xE3F', '\t', '@', '\x2', '\x2', '\xE3F', 
		'\x257', '\x3', '\x2', '\x2', '\x2', '\xE40', '\xE41', '\t', '%', '\x2', 
		'\x2', '\xE41', '\x259', '\x3', '\x2', '\x2', '\x2', '\xE42', '\xE43', 
		'\t', '\x41', '\x2', '\x2', '\xE43', '\x25B', '\x3', '\x2', '\x2', '\x2', 
		'\xE44', '\xE45', '\t', '\x42', '\x2', '\x2', '\xE45', '\x25D', '\x3', 
		'\x2', '\x2', '\x2', '\xE46', '\xE47', '\t', '\x43', '\x2', '\x2', '\xE47', 
		'\x25F', '\x3', '\x2', '\x2', '\x2', '\xE48', '\xE4B', '\a', '\xB0', '\x2', 
		'\x2', '\xE49', '\xE4C', '\a', '\x12B', '\x2', '\x2', '\xE4A', '\xE4C', 
		'\x5', '\x1E0', '\xF1', '\x2', '\xE4B', '\xE49', '\x3', '\x2', '\x2', 
		'\x2', '\xE4B', '\xE4A', '\x3', '\x2', '\x2', '\x2', '\xE4C', '\xE4D', 
		'\x3', '\x2', '\x2', '\x2', '\xE4D', '\xE4E', '\a', '\x109', '\x2', '\x2', 
		'\xE4E', '\x261', '\x3', '\x2', '\x2', '\x2', '\xE4F', '\xE50', '\x5', 
		'\x268', '\x135', '\x2', '\xE50', '\x263', '\x3', '\x2', '\x2', '\x2', 
		'\xE51', '\xE52', '\x5', '\x268', '\x135', '\x2', '\xE52', '\x265', '\x3', 
		'\x2', '\x2', '\x2', '\xE53', '\xE54', '\x5', '\x268', '\x135', '\x2', 
		'\xE54', '\x267', '\x3', '\x2', '\x2', '\x2', '\xE55', '\xE5A', '\x5', 
		'\x26A', '\x136', '\x2', '\xE56', '\xE57', '\a', '\x32', '\x2', '\x2', 
		'\xE57', '\xE59', '\x5', '\x26A', '\x136', '\x2', '\xE58', '\xE56', '\x3', 
		'\x2', '\x2', '\x2', '\xE59', '\xE5C', '\x3', '\x2', '\x2', '\x2', '\xE5A', 
		'\xE58', '\x3', '\x2', '\x2', '\x2', '\xE5A', '\xE5B', '\x3', '\x2', '\x2', 
		'\x2', '\xE5B', '\x269', '\x3', '\x2', '\x2', '\x2', '\xE5C', '\xE5A', 
		'\x3', '\x2', '\x2', '\x2', '\xE5D', '\xE5F', '\x5', '\x2F6', '\x17C', 
		'\x2', '\xE5E', '\xE60', '\x5', '\x26C', '\x137', '\x2', '\xE5F', '\xE5E', 
		'\x3', '\x2', '\x2', '\x2', '\xE5F', '\xE60', '\x3', '\x2', '\x2', '\x2', 
		'\xE60', '\xE63', '\x3', '\x2', '\x2', '\x2', '\xE61', '\xE63', '\x5', 
		'\x26C', '\x137', '\x2', '\xE62', '\xE5D', '\x3', '\x2', '\x2', '\x2', 
		'\xE62', '\xE61', '\x3', '\x2', '\x2', '\x2', '\xE63', '\x26B', '\x3', 
		'\x2', '\x2', '\x2', '\xE64', '\xE66', '\x5', '\x26E', '\x138', '\x2', 
		'\xE65', '\xE67', '\x5', '\x26C', '\x137', '\x2', '\xE66', '\xE65', '\x3', 
		'\x2', '\x2', '\x2', '\xE66', '\xE67', '\x3', '\x2', '\x2', '\x2', '\xE67', 
		'\x26D', '\x3', '\x2', '\x2', '\x2', '\xE68', '\xE6A', '\a', 'V', '\x2', 
		'\x2', '\xE69', '\xE6B', '\x5', '\x2F6', '\x17C', '\x2', '\xE6A', '\xE69', 
		'\x3', '\x2', '\x2', '\x2', '\xE6A', '\xE6B', '\x3', '\x2', '\x2', '\x2', 
		'\xE6B', '\xE70', '\x3', '\x2', '\x2', '\x2', '\xE6C', '\xE70', '\a', 
		'\xED', '\x2', '\x2', '\xE6D', '\xE70', '\a', '\x12B', '\x2', '\x2', '\xE6E', 
		'\xE70', '\x5', '\x2F8', '\x17D', '\x2', '\xE6F', '\xE68', '\x3', '\x2', 
		'\x2', '\x2', '\xE6F', '\xE6C', '\x3', '\x2', '\x2', '\x2', '\xE6F', '\xE6D', 
		'\x3', '\x2', '\x2', '\x2', '\xE6F', '\xE6E', '\x3', '\x2', '\x2', '\x2', 
		'\xE70', '\x26F', '\x3', '\x2', '\x2', '\x2', '\xE71', '\xE76', '\a', 
		'\x133', '\x2', '\x2', '\xE72', '\xE76', '\a', 'L', '\x2', '\x2', '\xE73', 
		'\xE74', '\t', '\x44', '\x2', '\x2', '\xE74', '\xE76', '\x5', '\x274', 
		'\x13B', '\x2', '\xE75', '\xE71', '\x3', '\x2', '\x2', '\x2', '\xE75', 
		'\xE72', '\x3', '\x2', '\x2', '\x2', '\xE75', '\xE73', '\x3', '\x2', '\x2', 
		'\x2', '\xE76', '\xE77', '\x3', '\x2', '\x2', '\x2', '\xE77', '\xE78', 
		'\a', '\xD2', '\x2', '\x2', '\xE78', '\xE79', '\x5', '\x284', '\x143', 
		'\x2', '\xE79', '\xE7A', '\x5', '\x278', '\x13D', '\x2', '\xE7A', '\x271', 
		'\x3', '\x2', '\x2', '\x2', '\xE7B', '\xE7E', '\a', '\x12B', '\x2', '\x2', 
		'\xE7C', '\xE7E', '\x5', '\x276', '\x13C', '\x2', '\xE7D', '\xE7B', '\x3', 
		'\x2', '\x2', '\x2', '\xE7D', '\xE7C', '\x3', '\x2', '\x2', '\x2', '\xE7E', 
		'\x273', '\x3', '\x2', '\x2', '\x2', '\xE7F', '\xE82', '\a', '\xA7', '\x2', 
		'\x2', '\xE80', '\xE83', '\a', '\x12B', '\x2', '\x2', '\xE81', '\xE83', 
		'\x5', '\x276', '\x13C', '\x2', '\xE82', '\xE80', '\x3', '\x2', '\x2', 
		'\x2', '\xE82', '\xE81', '\x3', '\x2', '\x2', '\x2', '\xE83', '\xE84', 
		'\x3', '\x2', '\x2', '\x2', '\xE84', '\xE85', '\a', '\xF0', '\x2', '\x2', 
		'\xE85', '\x275', '\x3', '\x2', '\x2', '\x2', '\xE86', '\xE8B', '\x5', 
		'\x2F4', '\x17B', '\x2', '\xE87', '\xE88', '\a', '\x32', '\x2', '\x2', 
		'\xE88', '\xE8A', '\x5', '\x2F4', '\x17B', '\x2', '\xE89', '\xE87', '\x3', 
		'\x2', '\x2', '\x2', '\xE8A', '\xE8D', '\x3', '\x2', '\x2', '\x2', '\xE8B', 
		'\xE89', '\x3', '\x2', '\x2', '\x2', '\xE8B', '\xE8C', '\x3', '\x2', '\x2', 
		'\x2', '\xE8C', '\x277', '\x3', '\x2', '\x2', '\x2', '\xE8D', '\xE8B', 
		'\x3', '\x2', '\x2', '\x2', '\xE8E', '\xE91', '\x5', '\x27A', '\x13E', 
		'\x2', '\xE8F', '\xE92', '\a', '\x12B', '\x2', '\x2', '\xE90', '\xE92', 
		'\x5', '\x276', '\x13C', '\x2', '\xE91', '\xE8F', '\x3', '\x2', '\x2', 
		'\x2', '\xE91', '\xE90', '\x3', '\x2', '\x2', '\x2', '\xE92', '\xEE0', 
		'\x3', '\x2', '\x2', '\x2', '\xE93', '\xEDD', '\a', 'y', '\x2', '\x2', 
		'\xE94', '\xE96', '\a', '\xB0', '\x2', '\x2', '\xE95', '\xE97', '\x5', 
		'\x130', '\x99', '\x2', '\xE96', '\xE95', '\x3', '\x2', '\x2', '\x2', 
		'\xE96', '\xE97', '\x3', '\x2', '\x2', '\x2', '\xE97', '\xEA1', '\x3', 
		'\x2', '\x2', '\x2', '\xE98', '\xE99', '\a', '\x30', '\x2', '\x2', '\xE99', 
		'\xE9E', '\x5', '\x2F4', '\x17B', '\x2', '\xE9A', '\xE9B', '\a', '!', 
		'\x2', '\x2', '\xE9B', '\xE9D', '\x5', '\x2F4', '\x17B', '\x2', '\xE9C', 
		'\xE9A', '\x3', '\x2', '\x2', '\x2', '\xE9D', '\xEA0', '\x3', '\x2', '\x2', 
		'\x2', '\xE9E', '\xE9C', '\x3', '\x2', '\x2', '\x2', '\xE9E', '\xE9F', 
		'\x3', '\x2', '\x2', '\x2', '\xE9F', '\xEA2', '\x3', '\x2', '\x2', '\x2', 
		'\xEA0', '\xE9E', '\x3', '\x2', '\x2', '\x2', '\xEA1', '\xE98', '\x3', 
		'\x2', '\x2', '\x2', '\xEA1', '\xEA2', '\x3', '\x2', '\x2', '\x2', '\xEA2', 
		'\xEAD', '\x3', '\x2', '\x2', '\x2', '\xEA3', '\xEA4', '\a', '\x109', 
		'\x2', '\x2', '\xEA4', '\xEA5', '\a', '\x14A', '\x2', '\x2', '\xEA5', 
		'\xEAE', '\x5', '\xBC', '_', '\x2', '\xEA6', '\xEA7', '\a', '\x14A', '\x2', 
		'\x2', '\xEA7', '\xEAA', '\x5', '\xBC', '_', '\x2', '\xEA8', '\xEAA', 
		'\x5', '\x2EC', '\x177', '\x2', '\xEA9', '\xEA6', '\x3', '\x2', '\x2', 
		'\x2', '\xEA9', '\xEA8', '\x3', '\x2', '\x2', '\x2', '\xEAA', '\xEAB', 
		'\x3', '\x2', '\x2', '\x2', '\xEAB', '\xEAC', '\a', '\x109', '\x2', '\x2', 
		'\xEAC', '\xEAE', '\x3', '\x2', '\x2', '\x2', '\xEAD', '\xEA3', '\x3', 
		'\x2', '\x2', '\x2', '\xEAD', '\xEA9', '\x3', '\x2', '\x2', '\x2', '\xEAE', 
		'\xEDE', '\x3', '\x2', '\x2', '\x2', '\xEAF', '\xEB0', '\a', '\xB0', '\x2', 
		'\x2', '\xEB0', '\xEB2', '\a', '\x109', '\x2', '\x2', '\xEB1', '\xEB3', 
		'\x5', '\xA6', 'T', '\x2', '\xEB2', '\xEB1', '\x3', '\x2', '\x2', '\x2', 
		'\xEB2', '\xEB3', '\x3', '\x2', '\x2', '\x2', '\xEB3', '\xEB4', '\x3', 
		'\x2', '\x2', '\x2', '\xEB4', '\xEB5', '\x5', '\xA8', 'U', '\x2', '\xEB5', 
		'\xEB7', '\a', '\xA6', '\x2', '\x2', '\xEB6', '\xEB8', '\x5', '\x130', 
		'\x99', '\x2', '\xEB7', '\xEB6', '\x3', '\x2', '\x2', '\x2', '\xEB7', 
		'\xEB8', '\x3', '\x2', '\x2', '\x2', '\xEB8', '\xEC2', '\x3', '\x2', '\x2', 
		'\x2', '\xEB9', '\xEBA', '\a', '\x30', '\x2', '\x2', '\xEBA', '\xEBF', 
		'\x5', '\x2F4', '\x17B', '\x2', '\xEBB', '\xEBC', '\a', '!', '\x2', '\x2', 
		'\xEBC', '\xEBE', '\x5', '\x2F4', '\x17B', '\x2', '\xEBD', '\xEBB', '\x3', 
		'\x2', '\x2', '\x2', '\xEBE', '\xEC1', '\x3', '\x2', '\x2', '\x2', '\xEBF', 
		'\xEBD', '\x3', '\x2', '\x2', '\x2', '\xEBF', '\xEC0', '\x3', '\x2', '\x2', 
		'\x2', '\xEC0', '\xEC3', '\x3', '\x2', '\x2', '\x2', '\xEC1', '\xEBF', 
		'\x3', '\x2', '\x2', '\x2', '\xEC2', '\xEB9', '\x3', '\x2', '\x2', '\x2', 
		'\xEC2', '\xEC3', '\x3', '\x2', '\x2', '\x2', '\xEC3', '\xEDB', '\x3', 
		'\x2', '\x2', '\x2', '\xEC4', '\xEC5', '\a', '\xEF', '\x2', '\x2', '\xEC5', 
		'\xEC7', '\x5', '\xA8', 'U', '\x2', '\xEC6', '\xEC8', '\x5', '\xAA', 'V', 
		'\x2', '\xEC7', '\xEC6', '\x3', '\x2', '\x2', '\x2', '\xEC7', '\xEC8', 
		'\x3', '\x2', '\x2', '\x2', '\xEC8', '\xEC9', '\x3', '\x2', '\x2', '\x2', 
		'\xEC9', '\xECA', '\a', '\xB0', '\x2', '\x2', '\xECA', '\xECB', '\a', 
		'\x109', '\x2', '\x2', '\xECB', '\xECC', '\a', '\x14A', '\x2', '\x2', 
		'\xECC', '\xECD', '\x5', '\xBC', '_', '\x2', '\xECD', '\xEDC', '\x3', 
		'\x2', '\x2', '\x2', '\xECE', '\xECF', '\a', '\x14A', '\x2', '\x2', '\xECF', 
		'\xED2', '\x5', '\xBC', '_', '\x2', '\xED0', '\xED2', '\x5', '\x2EC', 
		'\x177', '\x2', '\xED1', '\xECE', '\x3', '\x2', '\x2', '\x2', '\xED1', 
		'\xED0', '\x3', '\x2', '\x2', '\x2', '\xED2', '\xED3', '\x3', '\x2', '\x2', 
		'\x2', '\xED3', '\xED4', '\a', '\xEF', '\x2', '\x2', '\xED4', '\xED6', 
		'\x5', '\xA8', 'U', '\x2', '\xED5', '\xED7', '\x5', '\xAA', 'V', '\x2', 
		'\xED6', '\xED5', '\x3', '\x2', '\x2', '\x2', '\xED6', '\xED7', '\x3', 
		'\x2', '\x2', '\x2', '\xED7', '\xED8', '\x3', '\x2', '\x2', '\x2', '\xED8', 
		'\xED9', '\a', '\xB0', '\x2', '\x2', '\xED9', '\xEDA', '\a', '\x109', 
		'\x2', '\x2', '\xEDA', '\xEDC', '\x3', '\x2', '\x2', '\x2', '\xEDB', '\xEC4', 
		'\x3', '\x2', '\x2', '\x2', '\xEDB', '\xED1', '\x3', '\x2', '\x2', '\x2', 
		'\xEDC', '\xEDE', '\x3', '\x2', '\x2', '\x2', '\xEDD', '\xE94', '\x3', 
		'\x2', '\x2', '\x2', '\xEDD', '\xEAF', '\x3', '\x2', '\x2', '\x2', '\xEDE', 
		'\xEE0', '\x3', '\x2', '\x2', '\x2', '\xEDF', '\xE8E', '\x3', '\x2', '\x2', 
		'\x2', '\xEDF', '\xE93', '\x3', '\x2', '\x2', '\x2', '\xEDF', '\xEE0', 
		'\x3', '\x2', '\x2', '\x2', '\xEE0', '\x279', '\x3', '\x2', '\x2', '\x2', 
		'\xEE1', '\xEE5', '\x5', '\x27C', '\x13F', '\x2', '\xEE2', '\xEE5', '\x5', 
		'\x280', '\x141', '\x2', '\xEE3', '\xEE5', '\x5', '\x27E', '\x140', '\x2', 
		'\xEE4', '\xEE1', '\x3', '\x2', '\x2', '\x2', '\xEE4', '\xEE2', '\x3', 
		'\x2', '\x2', '\x2', '\xEE4', '\xEE3', '\x3', '\x2', '\x2', '\x2', '\xEE5', 
		'\x27B', '\x3', '\x2', '\x2', '\x2', '\xEE6', '\xEE7', '\t', '\x45', '\x2', 
		'\x2', '\xEE7', '\x27D', '\x3', '\x2', '\x2', '\x2', '\xEE8', '\xEE9', 
		'\t', '\x46', '\x2', '\x2', '\xEE9', '\x27F', '\x3', '\x2', '\x2', '\x2', 
		'\xEEA', '\xEEB', '\t', 'G', '\x2', '\x2', '\xEEB', '\x281', '\x3', '\x2', 
		'\x2', '\x2', '\xEEC', '\xEED', '\a', '\x89', '\x2', '\x2', '\xEED', '\xEF4', 
		'\a', '\x44', '\x2', '\x2', '\xEEE', '\xEF1', '\t', '.', '\x2', '\x2', 
		'\xEEF', '\xEF2', '\a', '\x12B', '\x2', '\x2', '\xEF0', '\xEF2', '\x5', 
		'\x2D8', '\x16D', '\x2', '\xEF1', '\xEEF', '\x3', '\x2', '\x2', '\x2', 
		'\xEF1', '\xEF0', '\x3', '\x2', '\x2', '\x2', '\xEF2', '\xEF4', '\x3', 
		'\x2', '\x2', '\x2', '\xEF3', '\xEEC', '\x3', '\x2', '\x2', '\x2', '\xEF3', 
		'\xEEE', '\x3', '\x2', '\x2', '\x2', '\xEF4', '\x283', '\x3', '\x2', '\x2', 
		'\x2', '\xEF5', '\xEF6', '\a', '\x89', '\x2', '\x2', '\xEF6', '\xEFD', 
		'\a', '\x82', '\x2', '\x2', '\xEF7', '\xEFA', '\t', '\x38', '\x2', '\x2', 
		'\xEF8', '\xEFB', '\a', '\x12B', '\x2', '\x2', '\xEF9', '\xEFB', '\x5', 
		'\x2D8', '\x16D', '\x2', '\xEFA', '\xEF8', '\x3', '\x2', '\x2', '\x2', 
		'\xEFA', '\xEF9', '\x3', '\x2', '\x2', '\x2', '\xEFB', '\xEFD', '\x3', 
		'\x2', '\x2', '\x2', '\xEFC', '\xEF5', '\x3', '\x2', '\x2', '\x2', '\xEFC', 
		'\xEF7', '\x3', '\x2', '\x2', '\x2', '\xEFD', '\x285', '\x3', '\x2', '\x2', 
		'\x2', '\xEFE', '\xEFF', '\a', '\x35', '\x2', '\x2', '\xEFF', '\xF00', 
		'\a', '\x44', '\x2', '\x2', '\xF00', '\xF04', '\x5', '\x2DA', '\x16E', 
		'\x2', '\xF01', '\xF02', '\a', '\x8B', '\x2', '\x2', '\xF02', '\xF03', 
		'\a', '\xCB', '\x2', '\x2', '\xF03', '\xF05', '\a', 'o', '\x2', '\x2', 
		'\xF04', '\xF01', '\x3', '\x2', '\x2', '\x2', '\xF04', '\xF05', '\x3', 
		'\x2', '\x2', '\x2', '\xF05', '\xF0A', '\x3', '\x2', '\x2', '\x2', '\xF06', 
		'\xF08', '\a', '\x114', '\x2', '\x2', '\xF07', '\xF06', '\x3', '\x2', 
		'\x2', '\x2', '\xF07', '\xF08', '\x3', '\x2', '\x2', '\x2', '\xF08', '\xF09', 
		'\x3', '\x2', '\x2', '\x2', '\xF09', '\xF0B', '\x5', '\x29C', '\x14F', 
		'\x2', '\xF0A', '\xF07', '\x3', '\x2', '\x2', '\x2', '\xF0A', '\xF0B', 
		'\x3', '\x2', '\x2', '\x2', '\xF0B', '\xF0D', '\x3', '\x2', '\x2', '\x2', 
		'\xF0C', '\xF0E', '\x5', '\x154', '\xAB', '\x2', '\xF0D', '\xF0C', '\x3', 
		'\x2', '\x2', '\x2', '\xF0D', '\xF0E', '\x3', '\x2', '\x2', '\x2', '\xF0E', 
		'\xF10', '\x3', '\x2', '\x2', '\x2', '\xF0F', '\xF11', '\x5', '\x2B4', 
		'\x15B', '\x2', '\xF10', '\xF0F', '\x3', '\x2', '\x2', '\x2', '\xF10', 
		'\xF11', '\x3', '\x2', '\x2', '\x2', '\xF11', '\x287', '\x3', '\x2', '\x2', 
		'\x2', '\xF12', '\xF13', '\a', '\x44', '\x2', '\x2', '\xF13', '\xF17', 
		'\x5', '\x2DA', '\x16E', '\x2', '\xF14', '\xF15', '\a', '\x8B', '\x2', 
		'\x2', '\xF15', '\xF16', '\a', '\xCB', '\x2', '\x2', '\xF16', '\xF18', 
		'\a', 'o', '\x2', '\x2', '\xF17', '\xF14', '\x3', '\x2', '\x2', '\x2', 
		'\xF17', '\xF18', '\x3', '\x2', '\x2', '\x2', '\xF18', '\xF1D', '\x3', 
		'\x2', '\x2', '\x2', '\xF19', '\xF1B', '\a', '\x114', '\x2', '\x2', '\xF1A', 
		'\xF19', '\x3', '\x2', '\x2', '\x2', '\xF1A', '\xF1B', '\x3', '\x2', '\x2', 
		'\x2', '\xF1B', '\xF1C', '\x3', '\x2', '\x2', '\x2', '\xF1C', '\xF1E', 
		'\x5', '\x29C', '\x14F', '\x2', '\xF1D', '\xF1A', '\x3', '\x2', '\x2', 
		'\x2', '\xF1D', '\xF1E', '\x3', '\x2', '\x2', '\x2', '\xF1E', '\xF21', 
		'\x3', '\x2', '\x2', '\x2', '\xF1F', '\xF22', '\x5', '\x290', '\x149', 
		'\x2', '\xF20', '\xF22', '\x5', '\x28A', '\x146', '\x2', '\xF21', '\xF1F', 
		'\x3', '\x2', '\x2', '\x2', '\xF21', '\xF20', '\x3', '\x2', '\x2', '\x2', 
		'\xF21', '\xF22', '\x3', '\x2', '\x2', '\x2', '\xF22', '\xF24', '\x3', 
		'\x2', '\x2', '\x2', '\xF23', '\xF25', '\x5', '\x154', '\xAB', '\x2', 
		'\xF24', '\xF23', '\x3', '\x2', '\x2', '\x2', '\xF24', '\xF25', '\x3', 
		'\x2', '\x2', '\x2', '\xF25', '\xF27', '\x3', '\x2', '\x2', '\x2', '\xF26', 
		'\xF28', '\x5', '\x2B4', '\x15B', '\x2', '\xF27', '\xF26', '\x3', '\x2', 
		'\x2', '\x2', '\xF27', '\xF28', '\x3', '\x2', '\x2', '\x2', '\xF28', '\x289', 
		'\x3', '\x2', '\x2', '\x2', '\xF29', '\xF2B', '\a', '\x114', '\x2', '\x2', 
		'\xF2A', '\xF29', '\x3', '\x2', '\x2', '\x2', '\xF2A', '\xF2B', '\x3', 
		'\x2', '\x2', '\x2', '\xF2B', '\xF2C', '\x3', '\x2', '\x2', '\x2', '\xF2C', 
		'\xF2E', '\x5', '\x28C', '\x147', '\x2', '\xF2D', '\xF2A', '\x3', '\x2', 
		'\x2', '\x2', '\xF2D', '\xF2E', '\x3', '\x2', '\x2', '\x2', '\xF2E', '\xF30', 
		'\x3', '\x2', '\x2', '\x2', '\xF2F', '\xF31', '\a', '\x114', '\x2', '\x2', 
		'\xF30', '\xF2F', '\x3', '\x2', '\x2', '\x2', '\xF30', '\xF31', '\x3', 
		'\x2', '\x2', '\x2', '\xF31', '\xF32', '\x3', '\x2', '\x2', '\x2', '\xF32', 
		'\xF33', '\x5', '\x28E', '\x148', '\x2', '\xF33', '\x28B', '\x3', '\x2', 
		'\x2', '\x2', '\xF34', '\xF35', '\a', '\x82', '\x2', '\x2', '\xF35', '\xF36', 
		'\a', '\x117', '\x2', '\x2', '\xF36', '\xF38', '\a', '\xA7', '\x2', '\x2', 
		'\xF37', '\xF39', '\x5', '\x290', '\x149', '\x2', '\xF38', '\xF37', '\x3', 
		'\x2', '\x2', '\x2', '\xF38', '\xF39', '\x3', '\x2', '\x2', '\x2', '\xF39', 
		'\xF3A', '\x3', '\x2', '\x2', '\x2', '\xF3A', '\xF3B', '\a', '\xF0', '\x2', 
		'\x2', '\xF3B', '\x28D', '\x3', '\x2', '\x2', '\x2', '\xF3C', '\xF3D', 
		'\a', '\xEA', '\x2', '\x2', '\xF3D', '\xF3E', '\t', 'H', '\x2', '\x2', 
		'\xF3E', '\xF3F', '\a', '\xA7', '\x2', '\x2', '\xF3F', '\xF40', '\a', 
		'=', '\x2', '\x2', '\xF40', '\xF48', '\a', '\a', '\x2', '\x2', '\xF41', 
		'\xF43', '\a', '\x114', '\x2', '\x2', '\xF42', '\xF41', '\x3', '\x2', 
		'\x2', '\x2', '\xF42', '\xF43', '\x3', '\x2', '\x2', '\x2', '\xF43', '\xF44', 
		'\x3', '\x2', '\x2', '\x2', '\xF44', '\xF45', '\a', '\x12F', '\x2', '\x2', 
		'\xF45', '\xF46', '\x5', '\x2E8', '\x175', '\x2', '\xF46', '\xF47', '\t', 
		'I', '\x2', '\x2', '\xF47', '\xF49', '\x3', '\x2', '\x2', '\x2', '\xF48', 
		'\xF42', '\x3', '\x2', '\x2', '\x2', '\xF48', '\xF49', '\x3', '\x2', '\x2', 
		'\x2', '\xF49', '\xF4A', '\x3', '\x2', '\x2', '\x2', '\xF4A', '\xF4B', 
		'\a', '\xF0', '\x2', '\x2', '\xF4B', '\x28F', '\x3', '\x2', '\x2', '\x2', 
		'\xF4C', '\xF4E', '\a', '\x114', '\x2', '\x2', '\xF4D', '\xF4C', '\x3', 
		'\x2', '\x2', '\x2', '\xF4D', '\xF4E', '\x3', '\x2', '\x2', '\x2', '\xF4E', 
		'\xF4F', '\x3', '\x2', '\x2', '\x2', '\xF4F', '\xF52', '\a', '\x12F', 
		'\x2', '\x2', '\xF50', '\xF53', '\x5', '\x292', '\x14A', '\x2', '\xF51', 
		'\xF53', '\x5', '\x296', '\x14C', '\x2', '\xF52', '\xF50', '\x3', '\x2', 
		'\x2', '\x2', '\xF52', '\xF51', '\x3', '\x2', '\x2', '\x2', '\xF53', '\xF54', 
		'\x3', '\x2', '\x2', '\x2', '\xF54', '\xF52', '\x3', '\x2', '\x2', '\x2', 
		'\xF54', '\xF55', '\x3', '\x2', '\x2', '\x2', '\xF55', '\x291', '\x3', 
		'\x2', '\x2', '\x2', '\xF56', '\xF57', '\x5', '\x2E8', '\x175', '\x2', 
		'\xF57', '\xF58', '\x5', '\x294', '\x14B', '\x2', '\xF58', '\x293', '\x3', 
		'\x2', '\x2', '\x2', '\xF59', '\xF5A', '\t', 'J', '\x2', '\x2', '\xF5A', 
		'\x295', '\x3', '\x2', '\x2', '\x2', '\xF5B', '\xF5C', '\x5', '\x2E8', 
		'\x175', '\x2', '\xF5C', '\xF5D', '\x5', '\x298', '\x14D', '\x2', '\xF5D', 
		'\x297', '\x3', '\x2', '\x2', '\x2', '\xF5E', '\xF5F', '\t', 'K', '\x2', 
		'\x2', '\xF5F', '\x299', '\x3', '\x2', '\x2', '\x2', '\xF60', '\xF61', 
		'\t', 'I', '\x2', '\x2', '\xF61', '\x29B', '\x3', '\x2', '\x2', '\x2', 
		'\xF62', '\xF63', '\a', 'J', '\x2', '\x2', '\xF63', '\xF64', '\a', '\xA5', 
		'\x2', '\x2', '\xF64', '\xF65', '\a', '\x42', '\x2', '\x2', '\xF65', '\xF66', 
		'\a', '\a', '\x2', '\x2', '\xF66', '\x29D', '\x3', '\x2', '\x2', '\x2', 
		'\xF67', '\xF69', '\a', '\x35', '\x2', '\x2', '\xF68', '\xF67', '\x3', 
		'\x2', '\x2', '\x2', '\xF68', '\xF69', '\x3', '\x2', '\x2', '\x2', '\xF69', 
		'\xF6A', '\x3', '\x2', '\x2', '\x2', '\xF6A', '\xF6B', '\a', '\x44', '\x2', 
		'\x2', '\xF6B', '\xF6E', '\x5', '\x2DA', '\x16E', '\x2', '\xF6C', '\xF6D', 
		'\a', '\x8B', '\x2', '\x2', '\xF6D', '\xF6F', '\a', 'o', '\x2', '\x2', 
		'\xF6E', '\xF6C', '\x3', '\x2', '\x2', '\x2', '\xF6E', '\xF6F', '\x3', 
		'\x2', '\x2', '\x2', '\xF6F', '\xF71', '\x3', '\x2', '\x2', '\x2', '\xF70', 
		'\xF72', '\x5', '\x2A0', '\x151', '\x2', '\xF71', '\xF70', '\x3', '\x2', 
		'\x2', '\x2', '\xF71', '\xF72', '\x3', '\x2', '\x2', '\x2', '\xF72', '\xF75', 
		'\x3', '\x2', '\x2', '\x2', '\xF73', '\xF74', '\t', 'L', '\x2', '\x2', 
		'\xF74', '\xF76', '\a', '\x43', '\x2', '\x2', '\xF75', '\xF73', '\x3', 
		'\x2', '\x2', '\x2', '\xF75', '\xF76', '\x3', '\x2', '\x2', '\x2', '\xF76', 
		'\xF78', '\x3', '\x2', '\x2', '\x2', '\xF77', '\xF79', '\x5', '\x2B4', 
		'\x15B', '\x2', '\xF78', '\xF77', '\x3', '\x2', '\x2', '\x2', '\xF78', 
		'\xF79', '\x3', '\x2', '\x2', '\x2', '\xF79', '\x29F', '\x3', '\x2', '\x2', 
		'\x2', '\xF7A', '\xF7E', '\a', '\x101', '\x2', '\x2', '\xF7B', '\xF7C', 
		'\a', '+', '\x2', '\x2', '\xF7C', '\xF7E', '\t', 'M', '\x2', '\x2', '\xF7D', 
		'\xF7A', '\x3', '\x2', '\x2', '\x2', '\xF7D', '\xF7B', '\x3', '\x2', '\x2', 
		'\x2', '\xF7E', '\x2A1', '\x3', '\x2', '\x2', '\x2', '\xF7F', '\xF80', 
		'\a', '\x44', '\x2', '\x2', '\xF80', '\xF83', '\x5', '\x2DA', '\x16E', 
		'\x2', '\xF81', '\xF82', '\a', '\x8B', '\x2', '\x2', '\xF82', '\xF84', 
		'\a', 'o', '\x2', '\x2', '\xF83', '\xF81', '\x3', '\x2', '\x2', '\x2', 
		'\xF83', '\xF84', '\x3', '\x2', '\x2', '\x2', '\xF84', '\xF9A', '\x3', 
		'\x2', '\x2', '\x2', '\xF85', '\xF8D', '\a', '\x114', '\x2', '\x2', '\xF86', 
		'\xF8E', '\x5', '\x2A4', '\x153', '\x2', '\xF87', '\xF8E', '\x5', '\x2A6', 
		'\x154', '\x2', '\xF88', '\xF8E', '\x5', '\x2AE', '\x158', '\x2', '\xF89', 
		'\xF8E', '\x5', '\x2AA', '\x156', '\x2', '\xF8A', '\xF8E', '\x5', '\x2AC', 
		'\x157', '\x2', '\xF8B', '\xF8E', '\x5', '\x2A8', '\x155', '\x2', '\xF8C', 
		'\xF8E', '\x5', '\x29C', '\x14F', '\x2', '\xF8D', '\xF86', '\x3', '\x2', 
		'\x2', '\x2', '\xF8D', '\xF87', '\x3', '\x2', '\x2', '\x2', '\xF8D', '\xF88', 
		'\x3', '\x2', '\x2', '\x2', '\xF8D', '\xF89', '\x3', '\x2', '\x2', '\x2', 
		'\xF8D', '\xF8A', '\x3', '\x2', '\x2', '\x2', '\xF8D', '\xF8B', '\x3', 
		'\x2', '\x2', '\x2', '\xF8D', '\xF8C', '\x3', '\x2', '\x2', '\x2', '\xF8E', 
		'\xF90', '\x3', '\x2', '\x2', '\x2', '\xF8F', '\xF85', '\x3', '\x2', '\x2', 
		'\x2', '\xF90', '\xF91', '\x3', '\x2', '\x2', '\x2', '\xF91', '\xF8F', 
		'\x3', '\x2', '\x2', '\x2', '\xF91', '\xF92', '\x3', '\x2', '\x2', '\x2', 
		'\xF92', '\xF9B', '\x3', '\x2', '\x2', '\x2', '\xF93', '\xF94', '\a', 
		'\xF9', '\x2', '\x2', '\xF94', '\xF95', '\a', '\xD6', '\x2', '\x2', '\xF95', 
		'\xF97', '\x5', '\x2F4', '\x17B', '\x2', '\xF96', '\xF93', '\x3', '\x2', 
		'\x2', '\x2', '\xF97', '\xF98', '\x3', '\x2', '\x2', '\x2', '\xF98', '\xF96', 
		'\x3', '\x2', '\x2', '\x2', '\xF98', '\xF99', '\x3', '\x2', '\x2', '\x2', 
		'\xF99', '\xF9B', '\x3', '\x2', '\x2', '\x2', '\xF9A', '\xF8F', '\x3', 
		'\x2', '\x2', '\x2', '\xF9A', '\xF96', '\x3', '\x2', '\x2', '\x2', '\xF9B', 
		'\xF9D', '\x3', '\x2', '\x2', '\x2', '\xF9C', '\xF9E', '\x5', '\x2B4', 
		'\x15B', '\x2', '\xF9D', '\xF9C', '\x3', '\x2', '\x2', '\x2', '\xF9D', 
		'\xF9E', '\x3', '\x2', '\x2', '\x2', '\xF9E', '\x2A3', '\x3', '\x2', '\x2', 
		'\x2', '\xF9F', '\xFA0', '\a', '\r', '\x2', '\x2', '\xFA0', '\xFA1', '\a', 
		'\xF1', '\x2', '\x2', '\xFA1', '\xFA2', '\t', 'N', '\x2', '\x2', '\xFA2', 
		'\x2A5', '\x3', '\x2', '\x2', '\x2', '\xFA3', '\xFA6', '\a', '\x12F', 
		'\x2', '\x2', '\xFA4', '\xFA7', '\x5', '\x292', '\x14A', '\x2', '\xFA5', 
		'\xFA7', '\x5', '\x296', '\x14C', '\x2', '\xFA6', '\xFA4', '\x3', '\x2', 
		'\x2', '\x2', '\xFA6', '\xFA5', '\x3', '\x2', '\x2', '\x2', '\xFA7', '\xFA8', 
		'\x3', '\x2', '\x2', '\x2', '\xFA8', '\xFA6', '\x3', '\x2', '\x2', '\x2', 
		'\xFA8', '\xFA9', '\x3', '\x2', '\x2', '\x2', '\xFA9', '\x2A7', '\x3', 
		'\x2', '\x2', '\x2', '\xFAA', '\xFAB', '\a', '\xD6', '\x2', '\x2', '\xFAB', 
		'\xFAC', '\x5', '\x2F4', '\x17B', '\x2', '\xFAC', '\xFAD', '\x5', '\xBC', 
		'_', '\x2', '\xFAD', '\x2A9', '\x3', '\x2', '\x2', '\x2', '\xFAE', '\xFAF', 
		'\a', '\x82', '\x2', '\x2', '\xFAF', '\xFB0', '\a', '\x117', '\x2', '\x2', 
		'\xFB0', '\xFB1', '\a', '\xA7', '\x2', '\x2', '\xFB1', '\xFB2', '\a', 
		'\x114', '\x2', '\x2', '\xFB2', '\xFB3', '\x5', '\x2A6', '\x154', '\x2', 
		'\xFB3', '\xFB4', '\a', '\xF0', '\x2', '\x2', '\xFB4', '\x2AB', '\x3', 
		'\x2', '\x2', '\x2', '\xFB5', '\xFB6', '\a', '\xEA', '\x2', '\x2', '\xFB6', 
		'\xFB7', '\t', 'H', '\x2', '\x2', '\xFB7', '\xFB8', '\a', '\xA7', '\x2', 
		'\x2', '\xFB8', '\xFB9', '\a', '\x114', '\x2', '\x2', '\xFB9', '\xFBA', 
		'\x5', '\x2AE', '\x158', '\x2', '\xFBA', '\xFBB', '\a', '\xF0', '\x2', 
		'\x2', '\xFBB', '\x2AD', '\x3', '\x2', '\x2', '\x2', '\xFBC', '\xFBD', 
		'\a', '\x12F', '\x2', '\x2', '\xFBD', '\xFBE', '\x5', '\x2E8', '\x175', 
		'\x2', '\xFBE', '\xFBF', '\x5', '\x29A', '\x14E', '\x2', '\xFBF', '\x2AF', 
		'\x3', '\x2', '\x2', '\x2', '\xFC0', '\xFC1', '\a', '\x11F', '\x2', '\x2', 
		'\xFC1', '\xFC2', '\a', '\x44', '\x2', '\x2', '\xFC2', '\xFC4', '\x5', 
		'\x2DA', '\x16E', '\x2', '\xFC3', '\xFC5', '\x5', '\x2B4', '\x15B', '\x2', 
		'\xFC4', '\xFC3', '\x3', '\x2', '\x2', '\x2', '\xFC4', '\xFC5', '\x3', 
		'\x2', '\x2', '\x2', '\xFC5', '\x2B1', '\x3', '\x2', '\x2', '\x2', '\xFC6', 
		'\xFC7', '\a', '\x122', '\x2', '\x2', '\xFC7', '\xFC8', '\a', '\x44', 
		'\x2', '\x2', '\xFC8', '\xFCA', '\x5', '\x2DA', '\x16E', '\x2', '\xFC9', 
		'\xFCB', '\x5', '\x2B4', '\x15B', '\x2', '\xFCA', '\xFC9', '\x3', '\x2', 
		'\x2', '\x2', '\xFCA', '\xFCB', '\x3', '\x2', '\x2', '\x2', '\xFCB', '\x2B3', 
		'\x3', '\x2', '\x2', '\x2', '\xFCC', '\xFD1', '\a', '\x148', '\x2', '\x2', 
		'\xFCD', '\xFCF', '\a', '\a', '\x2', '\x2', '\xFCE', '\xFD0', '\x5', '\x2B6', 
		'\x15C', '\x2', '\xFCF', '\xFCE', '\x3', '\x2', '\x2', '\x2', '\xFCF', 
		'\xFD0', '\x3', '\x2', '\x2', '\x2', '\xFD0', '\xFD2', '\x3', '\x2', '\x2', 
		'\x2', '\xFD1', '\xFCD', '\x3', '\x2', '\x2', '\x2', '\xFD1', '\xFD2', 
		'\x3', '\x2', '\x2', '\x2', '\xFD2', '\xFD5', '\x3', '\x2', '\x2', '\x2', 
		'\xFD3', '\xFD5', '\a', '\xCD', '\x2', '\x2', '\xFD4', '\xFCC', '\x3', 
		'\x2', '\x2', '\x2', '\xFD4', '\xFD3', '\x3', '\x2', '\x2', '\x2', '\xFD5', 
		'\x2B5', '\x3', '\x2', '\x2', '\x2', '\xFD6', '\xFD7', '\t', 'O', '\x2', 
		'\x2', '\xFD7', '\x2B7', '\x3', '\x2', '\x2', '\x2', '\xFD8', '\xFD9', 
		'\t', 'P', '\x2', '\x2', '\xFD9', '\xFDB', '\a', '\x44', '\x2', '\x2', 
		'\xFDA', '\xFDC', '\x5', '\x14A', '\xA6', '\x2', '\xFDB', '\xFDA', '\x3', 
		'\x2', '\x2', '\x2', '\xFDB', '\xFDC', '\x3', '\x2', '\x2', '\x2', '\xFDC', 
		'\xFE5', '\x3', '\x2', '\x2', '\x2', '\xFDD', '\xFDF', '\t', '.', '\x2', 
		'\x2', '\xFDE', '\xFE0', '\x5', '\x2DA', '\x16E', '\x2', '\xFDF', '\xFDE', 
		'\x3', '\x2', '\x2', '\x2', '\xFDF', '\xFE0', '\x3', '\x2', '\x2', '\x2', 
		'\xFE0', '\xFE2', '\x3', '\x2', '\x2', '\x2', '\xFE1', '\xFE3', '\x5', 
		'\x14A', '\xA6', '\x2', '\xFE2', '\xFE1', '\x3', '\x2', '\x2', '\x2', 
		'\xFE2', '\xFE3', '\x3', '\x2', '\x2', '\x2', '\xFE3', '\xFE5', '\x3', 
		'\x2', '\x2', '\x2', '\xFE4', '\xFD8', '\x3', '\x2', '\x2', '\x2', '\xFE4', 
		'\xFDD', '\x3', '\x2', '\x2', '\x2', '\xFE5', '\x2B9', '\x3', '\x2', '\x2', 
		'\x2', '\xFE6', '\xFE7', '\x5', '\x2DA', '\x16E', '\x2', '\xFE7', '\x2BB', 
		'\x3', '\x2', '\x2', '\x2', '\xFE8', '\xFE9', '\x5', '\x2DA', '\x16E', 
		'\x2', '\xFE9', '\x2BD', '\x3', '\x2', '\x2', '\x2', '\xFEA', '\xFEB', 
		'\a', '\x12', '\x2', '\x2', '\xFEB', '\xFEF', '\x5', '\x2BA', '\x15E', 
		'\x2', '\xFEC', '\xFED', '\a', '\x8B', '\x2', '\x2', '\xFED', '\xFEE', 
		'\a', '\xCB', '\x2', '\x2', '\xFEE', '\xFF0', '\a', 'o', '\x2', '\x2', 
		'\xFEF', '\xFEC', '\x3', '\x2', '\x2', '\x2', '\xFEF', '\xFF0', '\x3', 
		'\x2', '\x2', '\x2', '\xFF0', '\xFF1', '\x3', '\x2', '\x2', '\x2', '\xFF1', 
		'\xFF2', '\a', 'y', '\x2', '\x2', '\xFF2', '\xFF3', '\a', '\x44', '\x2', 
		'\x2', '\xFF3', '\xFFE', '\x5', '\x2BC', '\x15F', '\x2', '\xFF4', '\xFF5', 
		'\a', '\x1F', '\x2', '\x2', '\xFF5', '\xFF6', '\x5', '\x2E6', '\x174', 
		'\x2', '\xFF6', '\xFF9', '\x5', '\x2C0', '\x161', '\x2', '\xFF7', '\xFF8', 
		'\a', 'Z', '\x2', '\x2', '\xFF8', '\xFFA', '\x5', '\x2EA', '\x176', '\x2', 
		'\xFF9', '\xFF7', '\x3', '\x2', '\x2', '\x2', '\xFF9', '\xFFA', '\x3', 
		'\x2', '\x2', '\x2', '\xFFA', '\xFFC', '\x3', '\x2', '\x2', '\x2', '\xFFB', 
		'\xFFD', '\x5', '\x29C', '\x14F', '\x2', '\xFFC', '\xFFB', '\x3', '\x2', 
		'\x2', '\x2', '\xFFC', '\xFFD', '\x3', '\x2', '\x2', '\x2', '\xFFD', '\xFFF', 
		'\x3', '\x2', '\x2', '\x2', '\xFFE', '\xFF4', '\x3', '\x2', '\x2', '\x2', 
		'\xFFE', '\xFFF', '\x3', '\x2', '\x2', '\x2', '\xFFF', '\x1002', '\x3', 
		'\x2', '\x2', '\x2', '\x1000', '\x1001', '\a', '\xE9', '\x2', '\x2', '\x1001', 
		'\x1003', '\x5', '\x2EA', '\x176', '\x2', '\x1002', '\x1000', '\x3', '\x2', 
		'\x2', '\x2', '\x1002', '\x1003', '\x3', '\x2', '\x2', '\x2', '\x1003', 
		'\x2BF', '\x3', '\x2', '\x2', '\x2', '\x1004', '\x1005', '\a', '\x13F', 
		'\x2', '\x2', '\x1005', '\x1006', '\x5', '\x2D4', '\x16B', '\x2', '\x1006', 
		'\x1007', '\a', '\xD9', '\x2', '\x2', '\x1007', '\x1008', '\x5', '\x212', 
		'\x10A', '\x2', '\x1008', '\x100D', '\x3', '\x2', '\x2', '\x2', '\x1009', 
		'\x100A', '\a', '\xD1', '\x2', '\x2', '\x100A', '\x100B', '\a', '?', '\x2', 
		'\x2', '\x100B', '\x100D', '\a', '{', '\x2', '\x2', '\x100C', '\x1004', 
		'\x3', '\x2', '\x2', '\x2', '\x100C', '\x1009', '\x3', '\x2', '\x2', '\x2', 
		'\x100D', '\x2C1', '\x3', '\x2', '\x2', '\x2', '\x100E', '\x100F', '\a', 
		'\x12', '\x2', '\x2', '\x100F', '\x1012', '\x5', '\x2BA', '\x15E', '\x2', 
		'\x1010', '\x1011', '\a', '\x8B', '\x2', '\x2', '\x1011', '\x1013', '\a', 
		'o', '\x2', '\x2', '\x1012', '\x1010', '\x3', '\x2', '\x2', '\x2', '\x1012', 
		'\x1013', '\x3', '\x2', '\x2', '\x2', '\x1013', '\x1014', '\x3', '\x2', 
		'\x2', '\x2', '\x1014', '\x1015', '\a', 'y', '\x2', '\x2', '\x1015', '\x1016', 
		'\a', '\x44', '\x2', '\x2', '\x1016', '\x2C3', '\x3', '\x2', '\x2', '\x2', 
		'\x1017', '\x1018', '\a', '\x12', '\x2', '\x2', '\x1018', '\x101B', '\x5', 
		'\x2BA', '\x15E', '\x2', '\x1019', '\x101A', '\a', '\x8B', '\x2', '\x2', 
		'\x101A', '\x101C', '\a', 'o', '\x2', '\x2', '\x101B', '\x1019', '\x3', 
		'\x2', '\x2', '\x2', '\x101B', '\x101C', '\x3', '\x2', '\x2', '\x2', '\x101C', 
		'\x101D', '\x3', '\x2', '\x2', '\x2', '\x101D', '\x101E', '\a', '\x114', 
		'\x2', '\x2', '\x101E', '\x1025', '\a', '\x44', '\x2', '\x2', '\x101F', 
		'\x1026', '\x5', '\x2C6', '\x164', '\x2', '\x1020', '\x1026', '\x5', '\x2C8', 
		'\x165', '\x2', '\x1021', '\x1026', '\x5', '\x2CA', '\x166', '\x2', '\x1022', 
		'\x1026', '\x5', '\x2CC', '\x167', '\x2', '\x1023', '\x1026', '\x5', '\x2CE', 
		'\x168', '\x2', '\x1024', '\x1026', '\x5', '\x29C', '\x14F', '\x2', '\x1025', 
		'\x101F', '\x3', '\x2', '\x2', '\x2', '\x1025', '\x1020', '\x3', '\x2', 
		'\x2', '\x2', '\x1025', '\x1021', '\x3', '\x2', '\x2', '\x2', '\x1025', 
		'\x1022', '\x3', '\x2', '\x2', '\x2', '\x1025', '\x1023', '\x3', '\x2', 
		'\x2', '\x2', '\x1025', '\x1024', '\x3', '\x2', '\x2', '\x2', '\x1026', 
		'\x1027', '\x3', '\x2', '\x2', '\x2', '\x1027', '\x1025', '\x3', '\x2', 
		'\x2', '\x2', '\x1027', '\x1028', '\x3', '\x2', '\x2', '\x2', '\x1028', 
		'\x2C5', '\x3', '\x2', '\x2', '\x2', '\x1029', '\x102A', '\a', '\x126', 
		'\x2', '\x2', '\x102A', '\x102D', '\x5', '\x2BC', '\x15F', '\x2', '\x102B', 
		'\x102C', '\a', '\x1F', '\x2', '\x2', '\x102C', '\x102E', '\x5', '\x2E6', 
		'\x174', '\x2', '\x102D', '\x102B', '\x3', '\x2', '\x2', '\x2', '\x102D', 
		'\x102E', '\x3', '\x2', '\x2', '\x2', '\x102E', '\x2C7', '\x3', '\x2', 
		'\x2', '\x2', '\x102F', '\x1030', '\a', '\x13F', '\x2', '\x2', '\x1030', 
		'\x1031', '\x5', '\x2D4', '\x16B', '\x2', '\x1031', '\x2C9', '\x3', '\x2', 
		'\x2', '\x2', '\x1032', '\x1033', '\a', '\xD9', '\x2', '\x2', '\x1033', 
		'\x1034', '\x5', '\x212', '\x10A', '\x2', '\x1034', '\x2CB', '\x3', '\x2', 
		'\x2', '\x2', '\x1035', '\x1036', '\a', 'Z', '\x2', '\x2', '\x1036', '\x1037', 
		'\x5', '\x2EA', '\x176', '\x2', '\x1037', '\x2CD', '\x3', '\x2', '\x2', 
		'\x2', '\x1038', '\x1039', '\a', '\xE9', '\x2', '\x2', '\x1039', '\x103A', 
		'\x5', '\x2EA', '\x176', '\x2', '\x103A', '\x2CF', '\x3', '\x2', '\x2', 
		'\x2', '\x103B', '\x103D', '\t', 'M', '\x2', '\x2', '\x103C', '\x103E', 
		'\x5', '\x2BA', '\x15E', '\x2', '\x103D', '\x103C', '\x3', '\x2', '\x2', 
		'\x2', '\x103D', '\x103E', '\x3', '\x2', '\x2', '\x2', '\x103E', '\x103F', 
		'\x3', '\x2', '\x2', '\x2', '\x103F', '\x1040', '\a', 'y', '\x2', '\x2', 
		'\x1040', '\x1042', '\t', '.', '\x2', '\x2', '\x1041', '\x1043', '\x5', 
		'\x14A', '\xA6', '\x2', '\x1042', '\x1041', '\x3', '\x2', '\x2', '\x2', 
		'\x1042', '\x1043', '\x3', '\x2', '\x2', '\x2', '\x1043', '\x2D1', '\x3', 
		'\x2', '\x2', '\x2', '\x1044', '\x1047', '\x5', '\x2F4', '\x17B', '\x2', 
		'\x1045', '\x1047', '\x5', '\x124', '\x93', '\x2', '\x1046', '\x1044', 
		'\x3', '\x2', '\x2', '\x2', '\x1046', '\x1045', '\x3', '\x2', '\x2', '\x2', 
		'\x1047', '\x2D3', '\x3', '\x2', '\x2', '\x2', '\x1048', '\x104B', '\x5', 
		'\x2F4', '\x17B', '\x2', '\x1049', '\x104B', '\x5', '\x124', '\x93', '\x2', 
		'\x104A', '\x1048', '\x3', '\x2', '\x2', '\x2', '\x104A', '\x1049', '\x3', 
		'\x2', '\x2', '\x2', '\x104B', '\x2D5', '\x3', '\x2', '\x2', '\x2', '\x104C', 
		'\x1051', '\x5', '\x2D4', '\x16B', '\x2', '\x104D', '\x104E', '\a', '\x32', 
		'\x2', '\x2', '\x104E', '\x1050', '\x5', '\x2D4', '\x16B', '\x2', '\x104F', 
		'\x104D', '\x3', '\x2', '\x2', '\x2', '\x1050', '\x1053', '\x3', '\x2', 
		'\x2', '\x2', '\x1051', '\x104F', '\x3', '\x2', '\x2', '\x2', '\x1051', 
		'\x1052', '\x3', '\x2', '\x2', '\x2', '\x1052', '\x2D7', '\x3', '\x2', 
		'\x2', '\x2', '\x1053', '\x1051', '\x3', '\x2', '\x2', '\x2', '\x1054', 
		'\x1059', '\x5', '\x2DA', '\x16E', '\x2', '\x1055', '\x1056', '\a', '\x32', 
		'\x2', '\x2', '\x1056', '\x1058', '\x5', '\x2DA', '\x16E', '\x2', '\x1057', 
		'\x1055', '\x3', '\x2', '\x2', '\x2', '\x1058', '\x105B', '\x3', '\x2', 
		'\x2', '\x2', '\x1059', '\x1057', '\x3', '\x2', '\x2', '\x2', '\x1059', 
		'\x105A', '\x3', '\x2', '\x2', '\x2', '\x105A', '\x2D9', '\x3', '\x2', 
		'\x2', '\x2', '\x105B', '\x1059', '\x3', '\x2', '\x2', '\x2', '\x105C', 
		'\x105F', '\x5', '\x2DC', '\x16F', '\x2', '\x105D', '\x105F', '\x5', '\x124', 
		'\x93', '\x2', '\x105E', '\x105C', '\x3', '\x2', '\x2', '\x2', '\x105E', 
		'\x105D', '\x3', '\x2', '\x2', '\x2', '\x105F', '\x2DB', '\x3', '\x2', 
		'\x2', '\x2', '\x1060', '\x1065', '\x5', '\x2F4', '\x17B', '\x2', '\x1061', 
		'\x1062', '\a', 'V', '\x2', '\x2', '\x1062', '\x1064', '\x5', '\x2F4', 
		'\x17B', '\x2', '\x1063', '\x1061', '\x3', '\x2', '\x2', '\x2', '\x1064', 
		'\x1067', '\x3', '\x2', '\x2', '\x2', '\x1065', '\x1063', '\x3', '\x2', 
		'\x2', '\x2', '\x1065', '\x1066', '\x3', '\x2', '\x2', '\x2', '\x1066', 
		'\x2DD', '\x3', '\x2', '\x2', '\x2', '\x1067', '\x1065', '\x3', '\x2', 
		'\x2', '\x2', '\x1068', '\x1071', '\a', '\xA6', '\x2', '\x2', '\x1069', 
		'\x106E', '\x5', '\x2E2', '\x172', '\x2', '\x106A', '\x106B', '\a', '\x32', 
		'\x2', '\x2', '\x106B', '\x106D', '\x5', '\x2E2', '\x172', '\x2', '\x106C', 
		'\x106A', '\x3', '\x2', '\x2', '\x2', '\x106D', '\x1070', '\x3', '\x2', 
		'\x2', '\x2', '\x106E', '\x106C', '\x3', '\x2', '\x2', '\x2', '\x106E', 
		'\x106F', '\x3', '\x2', '\x2', '\x2', '\x106F', '\x1072', '\x3', '\x2', 
		'\x2', '\x2', '\x1070', '\x106E', '\x3', '\x2', '\x2', '\x2', '\x1071', 
		'\x1069', '\x3', '\x2', '\x2', '\x2', '\x1071', '\x1072', '\x3', '\x2', 
		'\x2', '\x2', '\x1072', '\x1073', '\x3', '\x2', '\x2', '\x2', '\x1073', 
		'\x1074', '\a', '\xEF', '\x2', '\x2', '\x1074', '\x2DF', '\x3', '\x2', 
		'\x2', '\x2', '\x1075', '\x1078', '\x5', '\x2E2', '\x172', '\x2', '\x1076', 
		'\x1077', '\a', '\x32', '\x2', '\x2', '\x1077', '\x1079', '\x5', '\x2E2', 
		'\x172', '\x2', '\x1078', '\x1076', '\x3', '\x2', '\x2', '\x2', '\x1079', 
		'\x107A', '\x3', '\x2', '\x2', '\x2', '\x107A', '\x1078', '\x3', '\x2', 
		'\x2', '\x2', '\x107A', '\x107B', '\x3', '\x2', '\x2', '\x2', '\x107B', 
		'\x2E1', '\x3', '\x2', '\x2', '\x2', '\x107C', '\x107D', '\t', 'Q', '\x2', 
		'\x2', '\x107D', '\x2E3', '\x3', '\x2', '\x2', '\x2', '\x107E', '\x1081', 
		'\x5', '\x2E2', '\x172', '\x2', '\x107F', '\x1081', '\x5', '\x124', '\x93', 
		'\x2', '\x1080', '\x107E', '\x3', '\x2', '\x2', '\x2', '\x1080', '\x107F', 
		'\x3', '\x2', '\x2', '\x2', '\x1081', '\x2E5', '\x3', '\x2', '\x2', '\x2', 
		'\x1082', '\x1085', '\x5', '\x2E2', '\x172', '\x2', '\x1083', '\x1085', 
		'\x5', '\x124', '\x93', '\x2', '\x1084', '\x1082', '\x3', '\x2', '\x2', 
		'\x2', '\x1084', '\x1083', '\x3', '\x2', '\x2', '\x2', '\x1085', '\x2E7', 
		'\x3', '\x2', '\x2', '\x2', '\x1086', '\x1089', '\a', '\a', '\x2', '\x2', 
		'\x1087', '\x1089', '\x5', '\x124', '\x93', '\x2', '\x1088', '\x1086', 
		'\x3', '\x2', '\x2', '\x2', '\x1088', '\x1087', '\x3', '\x2', '\x2', '\x2', 
		'\x1089', '\x2E9', '\x3', '\x2', '\x2', '\x2', '\x108A', '\x108D', '\x5', 
		'\x2EC', '\x177', '\x2', '\x108B', '\x108D', '\x5', '\x124', '\x93', '\x2', 
		'\x108C', '\x108A', '\x3', '\x2', '\x2', '\x2', '\x108C', '\x108B', '\x3', 
		'\x2', '\x2', '\x2', '\x108D', '\x2EB', '\x3', '\x2', '\x2', '\x2', '\x108E', 
		'\x109C', '\a', '\xA7', '\x2', '\x2', '\x108F', '\x1090', '\x5', '\x122', 
		'\x92', '\x2', '\x1090', '\x1091', '\a', '\x30', '\x2', '\x2', '\x1091', 
		'\x1099', '\x5', '\xBC', '_', '\x2', '\x1092', '\x1093', '\a', '\x32', 
		'\x2', '\x2', '\x1093', '\x1094', '\x5', '\x122', '\x92', '\x2', '\x1094', 
		'\x1095', '\a', '\x30', '\x2', '\x2', '\x1095', '\x1096', '\x5', '\xBC', 
		'_', '\x2', '\x1096', '\x1098', '\x3', '\x2', '\x2', '\x2', '\x1097', 
		'\x1092', '\x3', '\x2', '\x2', '\x2', '\x1098', '\x109B', '\x3', '\x2', 
		'\x2', '\x2', '\x1099', '\x1097', '\x3', '\x2', '\x2', '\x2', '\x1099', 
		'\x109A', '\x3', '\x2', '\x2', '\x2', '\x109A', '\x109D', '\x3', '\x2', 
		'\x2', '\x2', '\x109B', '\x1099', '\x3', '\x2', '\x2', '\x2', '\x109C', 
		'\x108F', '\x3', '\x2', '\x2', '\x2', '\x109C', '\x109D', '\x3', '\x2', 
		'\x2', '\x2', '\x109D', '\x109E', '\x3', '\x2', '\x2', '\x2', '\x109E', 
		'\x109F', '\a', '\xF0', '\x2', '\x2', '\x109F', '\x2ED', '\x3', '\x2', 
		'\x2', '\x2', '\x10A0', '\x10A3', '\x5', '\x2F0', '\x179', '\x2', '\x10A1', 
		'\x10A3', '\x5', '\x2F2', '\x17A', '\x2', '\x10A2', '\x10A0', '\x3', '\x2', 
		'\x2', '\x2', '\x10A2', '\x10A1', '\x3', '\x2', '\x2', '\x2', '\x10A3', 
		'\x2EF', '\x3', '\x2', '\x2', '\x2', '\x10A4', '\x10A5', '\x5', '\x2F6', 
		'\x17C', '\x2', '\x10A5', '\x2F1', '\x3', '\x2', '\x2', '\x2', '\x10A6', 
		'\x10A7', '\x5', '\x2F8', '\x17D', '\x2', '\x10A7', '\x2F3', '\x3', '\x2', 
		'\x2', '\x2', '\x10A8', '\x10AB', '\x5', '\x2F6', '\x17C', '\x2', '\x10A9', 
		'\x10AB', '\x5', '\x2F8', '\x17D', '\x2', '\x10AA', '\x10A8', '\x3', '\x2', 
		'\x2', '\x2', '\x10AA', '\x10A9', '\x3', '\x2', '\x2', '\x2', '\x10AB', 
		'\x2F5', '\x3', '\x2', '\x2', '\x2', '\x10AC', '\x10AD', '\a', '\f', '\x2', 
		'\x2', '\x10AD', '\x2F7', '\x3', '\x2', '\x2', '\x2', '\x10AE', '\x10AF', 
		'\x5', '\x2FA', '\x17E', '\x2', '\x10AF', '\x2F9', '\x3', '\x2', '\x2', 
		'\x2', '\x10B0', '\x10B1', '\t', 'R', '\x2', '\x2', '\x10B1', '\x2FB', 
		'\x3', '\x2', '\x2', '\x2', '\x10B2', '\x10B3', '\a', '\x2', '\x2', '\x3', 
		'\x10B3', '\x2FD', '\x3', '\x2', '\x2', '\x2', '\x21E', '\x303', '\x307', 
		'\x30D', '\x314', '\x319', '\x31E', '\x323', '\x329', '\x32C', '\x339', 
		'\x33C', '\x342', '\x357', '\x35B', '\x365', '\x36D', '\x371', '\x374', 
		'\x377', '\x37C', '\x380', '\x386', '\x38C', '\x399', '\x3A8', '\x3B6', 
		'\x3CF', '\x3D7', '\x3E2', '\x3E5', '\x3ED', '\x3F1', '\x3F5', '\x3FB', 
		'\x3FF', '\x404', '\x407', '\x40C', '\x40F', '\x411', '\x41B', '\x41E', 
		'\x42D', '\x434', '\x43D', '\x44C', '\x454', '\x45E', '\x461', '\x464', 
		'\x46D', '\x471', '\x473', '\x475', '\x47F', '\x485', '\x48D', '\x498', 
		'\x49D', '\x4A1', '\x4A7', '\x4B0', '\x4B3', '\x4B9', '\x4BC', '\x4C2', 
		'\x4C4', '\x4CF', '\x4D3', '\x4D8', '\x4DB', '\x4E7', '\x4EA', '\x4EE', 
		'\x4F1', '\x4F8', '\x500', '\x506', '\x509', '\x510', '\x518', '\x520', 
		'\x524', '\x529', '\x52D', '\x537', '\x53D', '\x541', '\x543', '\x548', 
		'\x54D', '\x551', '\x554', '\x558', '\x55C', '\x55F', '\x565', '\x567', 
		'\x56B', '\x577', '\x580', '\x583', '\x586', '\x58A', '\x58D', '\x596', 
		'\x599', '\x59C', '\x59F', '\x5A5', '\x5A9', '\x5AD', '\x5AF', '\x5B4', 
		'\x5B8', '\x5BA', '\x5C4', '\x5D8', '\x5DB', '\x5E5', '\x5E8', '\x5EB', 
		'\x5EE', '\x5F2', '\x5F5', '\x5F9', '\x5FC', '\x606', '\x60A', '\x60E', 
		'\x612', '\x61C', '\x620', '\x623', '\x62B', '\x630', '\x638', '\x63E', 
		'\x64A', '\x652', '\x65D', '\x665', '\x66D', '\x673', '\x67D', '\x682', 
		'\x68B', '\x690', '\x695', '\x699', '\x69E', '\x6A1', '\x6A5', '\x6AE', 
		'\x6B6', '\x6BE', '\x6C4', '\x6CA', '\x6D4', '\x6D8', '\x6DB', '\x6E8', 
		'\x706', '\x711', '\x717', '\x71B', '\x729', '\x72D', '\x737', '\x741', 
		'\x749', '\x74F', '\x751', '\x759', '\x75E', '\x773', '\x78B', '\x797', 
		'\x7A0', '\x7C4', '\x7C7', '\x7CA', '\x7DE', '\x7E1', '\x7ED', '\x7F8', 
		'\x7FC', '\x7FE', '\x806', '\x80A', '\x80C', '\x816', '\x81B', '\x825', 
		'\x828', '\x835', '\x83A', '\x841', '\x844', '\x852', '\x85C', '\x864', 
		'\x869', '\x86E', '\x879', '\x88A', '\x891', '\x8A2', '\x8A8', '\x8C0', 
		'\x8C7', '\x8C9', '\x8CE', '\x8D2', '\x8D6', '\x8E4', '\x8E7', '\x8EA', 
		'\x8F9', '\x8FE', '\x907', '\x910', '\x91A', '\x92E', '\x932', '\x935', 
		'\x93A', '\x949', '\x94C', '\x94F', '\x952', '\x955', '\x958', '\x962', 
		'\x96C', '\x96F', '\x977', '\x97A', '\x97D', '\x981', '\x987', '\x98C', 
		'\x992', '\x995', '\x999', '\x99D', '\x9A5', '\x9A9', '\x9AC', '\x9B2', 
		'\x9B5', '\x9B9', '\x9BC', '\x9BF', '\x9C2', '\x9C6', '\x9C9', '\x9CC', 
		'\x9D5', '\x9D7', '\x9DE', '\x9E6', '\x9E9', '\x9F1', '\x9F5', '\x9F7', 
		'\x9FA', '\x9FE', '\xA08', '\xA11', '\xA18', '\xA1D', '\xA22', '\xA26', 
		'\xA2D', '\xA35', '\xA3D', '\xA47', '\xA4D', '\xA63', '\xA66', '\xA6B', 
		'\xA70', '\xA75', '\xA78', '\xA7D', '\xA82', '\xA8A', '\xA94', '\xA9C', 
		'\xAA7', '\xAAD', '\xAB3', '\xAB8', '\xABD', '\xAC4', '\xACF', '\xAD7', 
		'\xADD', '\xAE3', '\xAEC', '\xAF6', '\xB00', '\xB04', '\xB0A', '\xB13', 
		'\xB1B', '\xB21', '\xB27', '\xB2B', '\xB2F', '\xB33', '\xB37', '\xB3C', 
		'\xB40', '\xB44', '\xB47', '\xB4B', '\xB52', '\xB5A', '\xB62', '\xB66', 
		'\xB68', '\xB70', '\xB75', '\xB79', '\xB84', '\xB96', '\xB9A', '\xBA8', 
		'\xBAB', '\xBB1', '\xBB5', '\xBB9', '\xBC1', '\xBC6', '\xBCA', '\xBD0', 
		'\xBD4', '\xBDD', '\xBE1', '\xBE9', '\xBEC', '\xBF5', '\xC01', '\xC12', 
		'\xC15', '\xC19', '\xC24', '\xC2B', '\xC32', '\xC38', '\xC3E', '\xC44', 
		'\xC4A', '\xC4F', '\xC52', '\xC61', '\xC6A', '\xC6E', '\xC74', '\xC7A', 
		'\xC8C', '\xC94', '\xC97', '\xC9B', '\xCA5', '\xCA9', '\xCAE', '\xCB3', 
		'\xCB6', '\xCBB', '\xCBE', '\xCC5', '\xCC9', '\xCD6', '\xCDE', '\xCE7', 
		'\xCEC', '\xCEF', '\xCF4', '\xCF9', '\xCFC', '\xD00', '\xD03', '\xD09', 
		'\xD0C', '\xD10', '\xD14', '\xD17', '\xD1B', '\xD2C', '\xD30', '\xD36', 
		'\xD3F', '\xD44', '\xD47', '\xD56', '\xD5D', '\xD61', '\xD67', '\xD6D', 
		'\xD73', '\xD78', '\xD7D', '\xD86', '\xD8E', '\xD95', '\xD97', '\xDA5', 
		'\xDA9', '\xDB1', '\xDB7', '\xDBA', '\xDC2', '\xDD1', '\xDDE', '\xDE7', 
		'\xDEF', '\xDF2', '\xDF6', '\xDFA', '\xDFD', '\xDFF', '\xE07', '\xE0B', 
		'\xE11', '\xE18', '\xE20', '\xE22', '\xE2C', '\xE33', '\xE35', '\xE3A', 
		'\xE3C', '\xE4B', '\xE5A', '\xE5F', '\xE62', '\xE66', '\xE6A', '\xE6F', 
		'\xE75', '\xE7D', '\xE82', '\xE8B', '\xE91', '\xE96', '\xE9E', '\xEA1', 
		'\xEA9', '\xEAD', '\xEB2', '\xEB7', '\xEBF', '\xEC2', '\xEC7', '\xED1', 
		'\xED6', '\xEDB', '\xEDD', '\xEDF', '\xEE4', '\xEF1', '\xEF3', '\xEFA', 
		'\xEFC', '\xF04', '\xF07', '\xF0A', '\xF0D', '\xF10', '\xF17', '\xF1A', 
		'\xF1D', '\xF21', '\xF24', '\xF27', '\xF2A', '\xF2D', '\xF30', '\xF38', 
		'\xF42', '\xF48', '\xF4D', '\xF52', '\xF54', '\xF68', '\xF6E', '\xF71', 
		'\xF75', '\xF78', '\xF7D', '\xF83', '\xF8D', '\xF91', '\xF98', '\xF9A', 
		'\xF9D', '\xFA6', '\xFA8', '\xFC4', '\xFCA', '\xFCF', '\xFD1', '\xFD4', 
		'\xFDB', '\xFDF', '\xFE2', '\xFE4', '\xFEF', '\xFF9', '\xFFC', '\xFFE', 
		'\x1002', '\x100C', '\x1012', '\x101B', '\x1025', '\x1027', '\x102D', 
		'\x103D', '\x1042', '\x1046', '\x104A', '\x1051', '\x1059', '\x105E', 
		'\x1065', '\x106E', '\x1071', '\x107A', '\x1080', '\x1084', '\x1088', 
		'\x108C', '\x1099', '\x109C', '\x10A2', '\x10AA',
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
