using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System;
using System.Collections.Generic;
using System.Linq;
using static CypherParser;

namespace Cypher
{
    public class CypherVisitor : CypherParserBaseVisitor<ASTNode>
    {
        /// <summary>
        /// This represents the set of operations that are currently not supported in SEE.
        /// </summary>
        private readonly Dictionary<Type, string> NotSupportedContexts = new Dictionary<Type, string>
        {
            // Database commands
            { typeof(CypherParser.CommandContext), "COMMAND" },
            { typeof(CypherParser.PrivilegeContext), "PRIVILEGE" },
            // Clauses
            { typeof(CypherParser.UseClauseContext), "USE" },
            { typeof(CypherParser.FinishClauseContext), "FINISH" },
            { typeof(CypherParser.CreateClauseContext), "CREATE" },
            { typeof(CypherParser.InsertClauseContext), "INSERT" },
            { typeof(CypherParser.DeleteClauseContext), "DELETE" },
            { typeof(CypherParser.SetClauseContext), "SET" },
            { typeof(CypherParser.RemoveClauseContext), "REMOVE" },
            { typeof(CypherParser.MergeActionContext), "MERGE" },
            { typeof(CypherParser.UnwindClauseContext), "UNWIND" },
            { typeof(CypherParser.LetClauseContext), "LET" },
            { typeof(CypherParser.CallClauseContext), "CALL" },
            { typeof(CypherParser.SubqueryClauseContext), "SUBQUERY" },
            { typeof(CypherParser.LoadCSVClauseContext), "LOAD CSV" },
            { typeof(CypherParser.ForeachClauseContext), "FOR EACH" },
            // Expressions
            { typeof(CypherParser.CollectExpressionContext), "COLLECT" },
            { typeof(CypherParser.DropAliasContext), "DROP" },
            { typeof(CypherParser.FunctionInvocationContext), "FUNCTION INVOCATION" },
            // MATCH
            { typeof(CypherParser.HintContext), "HINT" },
            { typeof(CypherParser.MatchModeContext), "MATCH MODE" },
            // WITH
            { typeof(CypherParser.WithClauseContext), "WITH" },
            // PATTERN
            { typeof(CypherParser.ShortestPathExpressionContext), "SHORTEST PATH" },
            { typeof(CypherParser.SelectorContext), "SELECTOR" },
            { typeof(CypherParser.QuantifierContext), "QUANTIFIER" },
            { typeof(CypherParser.ParenthesizedPathContext), "SELECTOR" },
            // LabelExpressions
            { typeof(CypherParser.AnyLabelContext), "ANY LABEL" },
            { typeof(CypherParser.DynamicAnyAllExpressionContext), "DYNAMIC LABEL" },
            { typeof(CypherParser.ParenthesizedLabelExpressionContext), "PARENTHESIZED LABEL" },
        };

        /// <summary>
        /// Root node of the typed tree.
        /// </summary>
        public ASTRoot Root;

        /// <summary>
        /// Constructor for the Visitor.
        /// </summary>
        public CypherVisitor()
        {
            Root = new ASTRoot();
        }

        /// <summary>
        /// Start the traversal of the tree.
        /// </summary>
        /// <param name="tree">Tree generated by the parser.</param>
        /// <returns>The IParseTree-subtree of tree.</returns>
        /// <exception cref="NotSupportedException">Throws Exception on not supported commands.</exception>
        public override ASTNode Visit(IParseTree tree)
        {
            if (NotSupportedContexts.TryGetValue(tree.GetType(), out string name))
            {
                throw new NotSupportedException($"{name} is currently not supported.");
            }
            return base.Visit(tree);
        }

        /// <summary>
        /// Returns the typed tree to the caller.
        /// </summary>
        /// <param name="context">Call context.</param>
        /// <returns>ASTRoot node to build a search.</returns>
        public override ASTNode VisitStatements([NotNull] StatementsContext context)
        {
            base.VisitStatements(context);
            return Root;
        }

#region TOP_LEVEL_QUERY

        public override ASTNode VisitUnion([NotNull] CypherParser.UnionContext context)
        {
            if (context.ChildCount > 1)
            {
                throw new NotSupportedException($"UNION is currently not supported.");
            }
            return base.VisitUnion(context);
        }

        public override ASTNode VisitSingleQuery([NotNull] SingleQueryContext context)
        {
            if (context.clause().Length == 0)
                throw new NotSupportedException("Block form of SingleQuery is not supported.");

            if (context.useClause() != null)
                throw new NotSupportedException("USE is currently not supported.");

            if (context.nextStatement() != null)
                throw new NotSupportedException("NEXT STATEMENT is currently not supported.");

            // There must be exactly one MATCH clause
            var matchClauses = context.clause().Where(c => c.matchClause() != null).ToList();
            if (matchClauses.Count != 1)
                throw new NotSupportedException("There must be exactly one MATCH clause.");

            // There must be exactly one RETURN clause
            var returnClauses = context.clause().Where(c => c.returnClause() != null).ToList();
            if (returnClauses.Count != 1)
                throw new NotSupportedException("There must be exactly one RETURN clause.");

            // gezielt verarbeiten
            Root.Match = (MatchASTNode)VisitMatchClause(matchClauses[0].matchClause());
            Root.Return = (ReturnASTNode)VisitReturnClause(returnClauses[0].returnClause());

            return Root;
        }

#endregion

#region RETURN
        public override ASTNode VisitReturnBody([NotNull] ReturnBodyContext context)
        {
            if(context.skip() != null)
            {
                throw new NotSupportedException("Skip is currently not supported");
            }
            ReturnASTNode returnNode = new ReturnASTNode();
            if (context.DISTINCT() != null)
            {
                returnNode.DISTINCT = true;
            }
            var list = (ReturnItemsASTNode)VisitReturnItems(context.returnItems());
            returnNode.ReturnItems = list.ReturnItems;
            returnNode.ANYTHING = list.ANYTHING;
            if(context.orderBy() != null)
            {
                OrderASTNode order = new OrderASTNode();
                foreach (var item in context.orderBy().orderItem())
                {
                    var ascdesc = item.descToken() == null ? "ASC" : "DESC";
                    order.OrderList.Add(((ExpressionASTNode)VisitExpression(item.expression()), ascdesc));
                }
                returnNode.Order = order;
            }
            if(context.limit() != null)
            {
                var expr = (ExpressionASTNode)VisitExpression(context.limit().expression());
                if (expr.Type == "Numeric")
                {
                    returnNode.Limit = int.Parse(expr.Value);
                }
                else
                {
                    throw new NotSupportedException("Only integer literals are supported in LIMIT.");
                }
            }
            return returnNode;
        }


        public override ASTNode VisitReturnItems([NotNull] ReturnItemsContext context)
        {
            ReturnItemsASTNode returnList = new ReturnItemsASTNode();
            if (context.TIMES() != null)
            {
                if (context.returnItem().Length > 0)
                    throw new NotSupportedException("RETURN * combined with explicit items is not supported.");

                return new ReturnItemsASTNode { ANYTHING = true };
            }
            foreach (var child in context.returnItem())
            {
                string alias = child.AS() == null ? null : child.AS().GetText();
                ExpressionASTNode returnExpression = (ExpressionASTNode)VisitExpression(child.expression());
                ReturnItemASTNode returnItem = new ReturnItemASTNode(alias, returnExpression);
                returnList.ReturnItems.Add(returnItem);
            }
            return returnList;
        }
#endregion

#region NODEPATTERNS
        /// <summary>
        /// Collects Nodes into the MatchASTNode.
        /// </summary>
        /// <param name="context">Current Subtree.</param>
        /// <returns>A NodeASTNode.</returns>
        /// <exception cref="NotSupportedException">On not supported Operations.</exception>
        public override ASTNode VisitNodePattern([NotNull] CypherParser.NodePatternContext context)
        {
            // WHERE
            if (context.expression() != null)
            {
                throw new NotSupportedException("WHERE within node pattern is currently not supported.");
            }

            NodeASTNode node = new NodeASTNode();

            // Variable
            if (context.variable() is CypherParser.VariableContext varCtx)
            {
                node.Variable = varCtx.GetText();
            }

            // Labels
            if (context.labelExpression() is CypherParser.LabelExpressionContext labelCtx)
            {
                node.Label = labelCtx.GetText();
            }

            // Properties
            if (context.properties() != null)
            {
                var map = (MapASTNode)VisitProperties(context.properties());
                node.Properties = map.Map;
            }
            return node;
        }

        /// <summary>
        /// Visit a property node.
        /// </summary>
        /// <param name="context">Current Subtree.</param>
        /// <returns>A MapASTNode.</returns>
        /// <exception cref="NotSupportedException">Parameters are used, which are not existent in SEE.</exception>
        public override ASTNode VisitProperties([NotNull] PropertiesContext context)
        {
            if (context.parameter() != null)
            {
                throw new NotSupportedException("PARAMETERS do not make any sense in current SEE set.");
            }
            return VisitMap(context.map());
        }

        /// <summary>
        /// Visit a Map of properties.
        /// </summary>
        /// <param name="context"></param>
        /// <returns>A MapASTNode.</returns>
        /// <exception cref="InvalidOperationException">If the expression is null.</exception>
        /// <exception cref="NotSupportedException"></exception>
        public override ASTNode VisitMap([NotNull] MapContext context)
        {
            MapASTNode map = new MapASTNode();
            var children = context.children;

            // look for key
            for (int i = 0; i < children.Count; i++)
            {
                if (children[i] is PropertyKeyNameContext keyCtx)
                {
                    var key = keyCtx.GetText();

                    // look for value
                    ExpressionContext exprCtx = null;
                    for (int j = i + 1; j < children.Count; j++)
                    {
                        if (children[j] is ExpressionContext ectx)
                        {
                            exprCtx = ectx;
                            break;
                        }
                    }

                    if (exprCtx == null)
                    {
                        throw new InvalidOperationException($"Missing expression for '{key}'");
                    }

                    var value = (ExpressionASTNode)VisitExpression(exprCtx);
                    try
                    {
                        map.Map.Add(key, value);
                    }
                    catch
                    {
                        throw new NotSupportedException("Multiple usage of the same key.");
                    }
                }
            }

            return map;
        }

#endregion

#region MATCH

        public override ASTNode VisitMatchClause([NotNull] CypherParser.MatchClauseContext context)
        {
            MatchASTNode match = new MatchASTNode();
            var plNode = ((PatternListASTNode)VisitPatternList(context.patternList()));
            match.SetPatternList(plNode.PatternsList);
            if(context.whereClause() != null)
            {
                match.Where = (ExpressionASTNode)VisitWhereClause(context.whereClause());
            }
            return match;
        }

        public override ASTNode VisitPatternList([NotNull] PatternListContext context)
        {
            PatternListASTNode list = new PatternListASTNode();
            foreach (var pattern in context.pattern())
            {
                if(pattern.variable() != null && pattern.selector() != null)
                {
                    throw new NotSupportedException("Pattern VARIABLES and SELECTORS are currently not supported.");
                }
                list.PatternsList.Add((PatternASTNode)VisitAnonymousPattern(pattern.anonymousPattern()));
            }
            return list;
        }

        public override ASTNode VisitAnonymousPattern([NotNull] AnonymousPatternContext context)
        {
            if(context.shortestPathPattern() != null)
            {
                throw new NotSupportedException("SHORTEST PATH PATTERNS are currently not supported.");
            }
            return VisitPatternElement(context.patternElement());
        }

        public override ASTNode VisitPatternElement([NotNull] PatternElementContext context)
        {
            // Prüfen auf parenthesizedPath
            if (context.parenthesizedPath().Length > 0)
            {
                throw new NotSupportedException("Parenthesized paths are not supported.");
            }
            PatternASTNode pattern = new PatternASTNode();
            RelationshipASTNode rel = null;
            foreach (var element in context.children)
            {
                // add Node to List of patterns
                if (element is NodePatternContext npc)
                {
                    pattern.AddPattern((NodeASTNode)VisitNodePattern(npc));
                    if (rel != null)
                    {
                        if (!(rel.Left ^ rel.Right))
                        {
                            rel.From = (NodeASTNode)pattern.Pattern[pattern.Pattern.Count - 2];
                            rel.To = (NodeASTNode)pattern.Pattern[pattern.Pattern.Count - 1];
                            rel.Undirected = true;
                            pattern.AddPattern(rel.GetEdge());
                        }
                        else
                        { 
                            if (rel.Left) // check left directed
                            {
                                rel.From = (NodeASTNode)pattern.Pattern[pattern.Pattern.Count - 2];
                                rel.To = (NodeASTNode)pattern.Pattern[pattern.Pattern.Count - 1];
                                pattern.AddPattern(rel.GetEdge());
                            }
                            if (rel.Right) // check right directed or BOTH (no else) directed
                            {
                                rel.From = (NodeASTNode)pattern.Pattern[pattern.Pattern.Count - 1];
                                rel.To = (NodeASTNode)pattern.Pattern[pattern.Pattern.Count - 2];
                                pattern.AddPattern(rel.GetEdge());
                            }
                        }
                        rel = null;
                    }
                    continue;
                }
                if (element is RelationshipPatternContext rpc)
                {
                    rel = (RelationshipASTNode)VisitRelationshipPattern(rpc);
                }
            }
            return pattern;
        }

        public override ASTNode VisitRelationshipPattern([NotNull] RelationshipPatternContext context)
        {
            // WHERE
            if (context.expression() != null || context.pathLength() != null)
            {
                throw new NotSupportedException("WHERE adn PATH LENGTH within relationship pattern are currently not supported.");
            }
            RelationshipASTNode rel = new RelationshipASTNode();
            if (context.leftArrow() != null) rel.Left = true;
            if (context.rightArrow() != null) rel.Right = true;
            if (context.variable() != null) rel.Variable = ((StringASTNode)Visit(context.variable())).Value;
            if (context.properties() != null)
            {
                MapASTNode map = (MapASTNode)VisitProperties(context.properties());
                rel.Properties = map.Map;
            }
            return rel;
        }

        public override ASTNode VisitWhereClause([NotNull] WhereClauseContext context)
        {
            ExpressionASTNode exp = null;
            if(context.expression() != null)
            {
                exp = (ExpressionASTNode)VisitExpression(context.expression());
            }
            return exp;
        }

#endregion

#region Expressions

        public override ASTNode VisitExpression([NotNull] ExpressionContext context)
        {
            return BuildBinaryExpression(context);
        }

        public override ASTNode VisitExpression11([NotNull] Expression11Context context)
        {
            return BuildBinaryExpression(context);
        }

        public override ASTNode VisitExpression10([NotNull] Expression10Context context)
        {
            return BuildBinaryExpression(context);
        }

        private ASTNode BuildBinaryExpression(IParseTree context)
        {
            // if there is only one child there is no need to evaluate this later
            if (context.ChildCount == 1)
            {
                return Visit(context.GetChild(0));
            }

            // it there are more start building a binary tree of expression nodes
            // start with the left node
            ExpressionASTNode left = (ExpressionASTNode)Visit(context.GetChild(0));

            // build right nodes and append -> older nodes become leafs and inner nodes
            for (int i = 1; i < context.ChildCount; i += 2)
            {
                string op = context.GetChild(i).GetText();
                ExpressionASTNode right = (ExpressionASTNode)Visit(context.GetChild(i + 1));

                left = new ExpressionASTNode
                {
                    leftNode = left,
                    rightNode = right,
                    Operator = op
                };
            }
            // return the (youngest) root node
            return left;
        }

        public override ASTNode VisitExpression9([NotNull] Expression9Context context)
        {
            // if there is only one child there is no need to evaluate this later
            if (context.ChildCount == 1)
            {
                return VisitExpression8(context.expression8());
            } 
            else if (context.ChildCount > 2)
            {
                throw new NotSupportedException("More than one NOT does not make sense and slows the evaluation.");
            }
            ExpressionASTNode notNode = new ExpressionASTNode();
            notNode.leftNode = (ExpressionASTNode)VisitExpression8(context.expression8());
            notNode.Operator = "NOT";
            return notNode;
        }

        public override ASTNode VisitExpression8([NotNull] Expression8Context context)
        {
            return BuildBinaryExpression(context);
        }

        public override ASTNode VisitExpression7([NotNull] Expression7Context context)
        {
            // if there is only one child there is no need to evaluate this later
            if (context.ChildCount == 1)
            {
                return VisitExpression6(context.expression6());
            }
            var child = context.comparisonExpression6();
            ExpressionASTNode nullCompNode;
            if (child is NullComparisonContext || child is LabelComparisonContext)
            {
                nullCompNode = (ExpressionASTNode)Visit(child);
                nullCompNode.leftNode = (ExpressionASTNode)VisitExpression6(context.expression6());
            }
            else
            {
                throw new NotSupportedException("Only NULL and LABEL comparisons are supported at this point.");
            }
            return nullCompNode;
        }

        public override ASTNode VisitNullComparison([NotNull] NullComparisonContext context)
        {
            ExpressionASTNode compNode = new ExpressionASTNode();
            compNode.Operator = context.GetText();
            return compNode;
        }

        public override ASTNode VisitLabelComparison([NotNull] LabelComparisonContext context)
        {
            int idx = context.ChildCount > 1 ? 1 : 0;
            var node = (StringASTNode)Visit(context.GetChild(idx));
            ExpressionASTNode compNode = new ExpressionASTNode();
            compNode.Operator = context.GetText();
            compNode.Value = node.Value;
            return compNode;
        }

        // + - ||
        public override ASTNode VisitExpression6([NotNull] Expression6Context context)
        {
            if (context.ChildCount > 1)
            {
                throw new NotSupportedException("Arithmetic Operations within an expression are not supported.");
            }
            return VisitExpression5(context.expression5()[0]);
        }

        // * / %
        public override ASTNode VisitExpression5([NotNull] Expression5Context context)
        {
            if (context.ChildCount > 1)
            {
                throw new NotSupportedException("Arithmetic Operations within an expression are not supported.");
            }
            return VisitExpression4(context.expression4()[0]);
        }

        // x^y
        public override ASTNode VisitExpression4([NotNull] Expression4Context context)
        {
            if (context.ChildCount > 1)
            {
                throw new NotSupportedException("Arithmetic Operations within an expression are not supported.");
            }
            return VisitExpression3(context.expression3()[0]);
        }

        // signum
        public override ASTNode VisitExpression3([NotNull] Expression3Context context)
        {
            // if there is only one child there is no need to evaluate this later
            if (context.ChildCount == 1 || context.PLUS() != null)
            {
                return VisitExpression2(context.expression2());
            }
            ExpressionASTNode signNode = new ExpressionASTNode();
            signNode.Operator = "sign";
            signNode.Value = "-";
            signNode.leftNode = (ExpressionASTNode)VisitExpression2(context.expression2());
            return signNode;
        }

        public override ASTNode VisitExpression2([NotNull] Expression2Context context)
        {
            // if there is only one child there is no need to evaluate this later
            if (context.ChildCount == 1)
            {
                return VisitExpression1(context.expression1());
            }

            // SEE only supports one property
            var postfixes = context.postFix();
            if (postfixes.Count() != 1)
            {
                throw new NotSupportedException("Only one postfix is supported.");
            }

            // avoid index and ranges as see has none
            var pf = postfixes[0];
            if (!(pf is PropertyPostfixContext propCtx))
            {
                throw new NotSupportedException("Only property postfixes are supported (no index or range).");
            }

            string propertyName = propCtx.property().GetText();
            var propertyNode = new ExpressionASTNode
            {
                Operator = "propertyAccess",
                leftNode = (ExpressionASTNode)VisitExpression1(context.expression1()),
                Value = propertyName
            };

            return propertyNode;
        }


        public override ASTNode VisitPropertyPostfix([NotNull] PropertyPostfixContext context)
        {
            foreach (var child in context.children)
            {
                
            }
            return base.VisitPropertyPostfix(context);
        }

        public override ASTNode VisitExpression1([NotNull] Expression1Context context)
        {
            var child = context.GetChild(0);
            ExpressionASTNode leaf = new ExpressionASTNode();
            if (child is LiteralContext)
            {
                if (child is BooleanLiteralContext)
                {
                    leaf.Value = child.GetText();
                    leaf.Type = "Boolean";
                }
                else if (child is KeywordLiteralContext)
                {
                    leaf.Value = child.GetText();
                    if (leaf.Value != "NULL") throw new NotSupportedException("No Infinity or NaN literals at this point.");
                    leaf.Type = "Keyword";
                }
                else if (child is NummericLiteralContext)
                {
                    leaf.Value = child.GetText();
                    leaf.Type = "Numeric";
                }
                else if (child is VariableContext)
                {
                    leaf.Value = child.GetText();
                    leaf.Type = "String";
                }
                else if (child is StringLiteralContext)
                {
                    leaf.Value = child.GetText();
                    leaf.Type = "String";
                }
                else if (child is StringsLiteralContext)
                {
                    leaf.Value = child.GetText();
                    leaf.Type = "String";
                }
                else
                {
                    throw new NotSupportedException("Expressions only support 'Literal', 'Variable' or COUNT(*).");
                }
                
            }
            else if (child is VariableContext varCtx)
            {
                leaf.Type = "Variable";
                var name = (StringASTNode)Visit(varCtx);
                leaf.Value = name.Value;
            }
            else if (child is CountStarContext)
            {
                leaf.Type = "COUNT*";
            }
            else
            {
                throw new NotSupportedException("Expressions only support 'Literal', 'Variable' or COUNT(*).");
            }
            return leaf;
        }

#endregion

#region LABEL EXPRESSIONS

        public override ASTNode VisitLabelExpression4([NotNull] LabelExpression4Context context)
        {
            if (context.ChildCount > 1)
            {
                throw new NotSupportedException("SEE does not support multiple GraphElement labels.");
            }
            return VisitLabelExpression3(context.labelExpression3()[0]);
        }

        public override ASTNode VisitLabelExpression3([NotNull] LabelExpression3Context context)
        {
            if (context.ChildCount > 1)
            {
                throw new NotSupportedException("SEE does not support multiple GraphElement labels.");
            }
            return VisitLabelExpression2(context.labelExpression2()[0]);
        }

        public override ASTNode VisitLabelExpression2([NotNull] LabelExpression2Context context)
        {
            string name;
            bool negation = false;
            LabelASTNode label = new LabelASTNode();
            if (context.ChildCount > 2)
            {
                throw new NotSupportedException("More than one Exclamation mark does not make sense.");
            }
            else 
            {
                if (context.ChildCount == 2) negation = true;
                var snode = (StringASTNode)VisitChildren(context);
                name = snode.Value;
            }
            label.Name = name;
            label.NOT = negation;
            return label;
        }

        // LabelExpression1
        public override ASTNode VisitLabelName([NotNull] LabelNameContext context)
        {
            StringASTNode name = (StringASTNode)VisitChildren(context);
            return name; 
        }

#endregion

#region Strings
        public override ASTNode VisitUnescapedSymbolicNameString_([NotNull] CypherParser.UnescapedSymbolicNameString_Context context)
        {
            string name = context.GetChild(0).ToString();
            return new StringASTNode(name);
        }

        public override ASTNode VisitEscapedSymbolicVariableNameString([NotNull] CypherParser.EscapedSymbolicVariableNameStringContext context)
        {
            string name = context.GetChild(0).ToString();
            name = name.Substring(1, name.Length - 2);
            return new StringASTNode(name);
        }
#endregion

    }


}