using MoreLinq;
using SEE.DataModel;
using SEE.DataModel.DG;
using SEE.Tools.ReflexionAnalysis;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using DocumentMergingType = Assets.SEE.Tools.ReflexionAnalysis.AttractFunctions.Document.DocumentMergingType;

namespace Assets.SEE.Tools.ReflexionAnalysis.AttractFunctions
{
    /// <summary>
    /// This class implements the <see cref="AttractFunction"/> ADCAttract.
    /// It calculates attraction values for candidates by summing up the overlap
    /// of documents of allowed edges attached to a candidate to a document of the 
    /// corresponding allowing architecture dependencies. The documents of the 
    /// allowing edges are generated by merging the source code regions of the 
    /// source and target nodes given a <see cref="DocumentMergingType"/>. The 
    /// documents of the architecture dependencies are a union of all documents 
    /// of edges which are allowed through the rule of the architecture dependency.
    /// </summary>
    public class ADCAttract : LanguageAttract
    {
        /// <summary>
        /// This dictionary contains a document for architecture dependecies which cumulate 
        /// all words of the edges which are allowed through them.
        /// </summary>
        private Dictionary<string, Document> wordsPerArchEdge = new Dictionary<string, Document>();

        /// <summary>
        /// This dictionary contains for ids of implementation edges by which architecture dependency they are allowed by.
        /// </summary>
        private Dictionary<string, Edge> allowedByArchEdge = new Dictionary<string, Edge>();

        /// <summary>
        /// merging type used to merge documents for edges
        /// </summary>
        private DocumentMergingType MergingType { get; }

        /// <summary>
        /// This constructor initializes a new instance of <see cref="ADCAttract"/>.
        /// </summary>
        /// <param name="graph">Reflexion graph this attraction function is reading on.</param>
        /// <param name="candidateRecommendation">CandidateRecommendation object which uses and is used by the created attract function.</param>
        /// <param name="config">Configuration objects containing parameters to configure this attraction function</param>
        public ADCAttract(ReflexionGraph reflexionGraph, 
                          Recommendations candidateRecommendation, 
                          ADCAttractConfig config) : base(reflexionGraph, candidateRecommendation, config)
        {   
            this.MergingType = config.MergingType;
        }

        /// <summary>
        /// This method returns a formatted string, describing which words are contained
        /// in each architecture dependency.
        /// 
        /// Can be used for debug and logging purposes.
        /// 
        /// </summary>
        /// <returns>a formatted string representing the words of each architecture dependency</returns>
        public override string DumpTrainingData()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append($"Words per abstract dependency:{Environment.NewLine}");
            foreach (string edgeID in wordsPerArchEdge.Keys)
            {
                Edge edge = reflexionGraph.GetEdge(edgeID);
                if (edge != null)
                {
                    sb.Append($"{edge.Source.ID} -{edge.Type}-> {edge.Target.ID}"); 
                }
                else
                {
                    sb.Append(edgeID);
                }
                sb.Append($" :{Environment.NewLine}{wordsPerArchEdge[edgeID]}{Environment.NewLine}");
            }
            return sb.ToString();
        }

        /// <summary>
        /// This method calculates the attract value for a given candidate node and a given cluster node.
        /// The method sums up the overlap of neighboring edges that would be allowed when the candidate would be mapped 
        /// to the cluster. The overlap is calculated by comparing the document of the potentially allowed 
        /// edges to the documents of the architecture edges they are allowed by. The edges within the subtree 
        /// of the candidate are also considered.
        /// </summary>
        /// <param name="candidate">given candidate node</param>
        /// <param name="cluster">given cluster node</param>
        /// <returns>The attraction between the given nodes.</returns>
        public override double GetAttractionValue(Node candidate, Node cluster)
        {
            if (!candidate.Type.Equals(this.CandidateType))
            {
                return 0;
            }

            double attraction = 0;
            candidate.PostOrderDescendants().ForEach(d => attraction += GetAttractionValueLocal(candidate, descendant:d, cluster));

            return attraction;
        }

        /// <summary>
        /// This method calculates the local attract value for a given descendant of a candidate node and a given cluster node.
        /// The method sums up the overlap of neighboring edges of the descendant that would be allowed when the candidate would be mapped 
        /// to the cluster. The overlap is calculated by comparing the document of the potentially allowed 
        /// edges to the documents of the architecture edges they are allowed by.
        /// </summary>
        /// <param name="candidate">Candidate which is considered to be mapped. 
        /// This parameter is used to retrieve information from the edge state cache</param>
        /// <param name="descendant">Descendant within the subtree of the candidate. Can be the candidate as well.</param>
        /// <param name="cluster">Given cluster</param>
        /// <returns></returns>
        /// <exception cref="Exception">Throws if an edge is in state allowed or implicitly allowed 
        /// but no corresponding architecture dependency could be found.</exception>
        private double GetAttractionValueLocal(Node candidate, Node descendant, Node cluster)
        {
            List<Edge> implementationEdges = descendant.GetImplementationEdges();

            double attraction = 0;

            foreach (Edge edge in implementationEdges)
            {
                bool isDescendantSource = edge.Source.Equals(descendant);
                Node descendantNeighbor = isDescendantSource ? edge.Target : edge.Source;

                // Get the state of the current implementation edge if the candidate would be mapped to the cluster 
                State edgeState = this.edgeStateCache.GetFromCache(cluster,
                                                                   descendant,
                                                                   edge);

                if ((edgeState == State.Allowed || edgeState == State.ImplicitlyAllowed))
                {
                    Node neighborCluster = reflexionGraph.MapsTo(descendantNeighbor);
                    Node clusterSource = isDescendantSource ? cluster : neighborCluster;
                    Node clusterTarget = isDescendantSource ? neighborCluster : cluster;

                    Edge architectureEdge = this.AllowedBy(clusterSource, clusterTarget, edgeState, edge.Type);

                    if(architectureEdge == null) 
                    {
                        throw new Exception($"No specifying architecture dependency was found for the edge {edge.ID} in edgeState {edgeState}.");
                    }

                    if (this.wordsPerArchEdge.ContainsKey(architectureEdge.ID))
                    {
                        Document architectureEdgeDoc = this.wordsPerArchEdge[architectureEdge.ID];
                        Document mergedDocument = this.GetMergedTerms(edge.Source, edge.Target, MergingType);
                        double similarity = Document.OverlapCoefficient(mergedDocument, architectureEdgeDoc);
                        attraction += similarity;
                    }
                }
            }
            return attraction;
        }

        /// <summary>
        /// This method is called if a node was add or removed from a given cluster. 
        /// This method adds the cluster id id to the cluster ids to update.
        /// </summary>
        /// <param name="cluster">Cluster node from which the changedNode was add or removed.</param>
        /// <param name="changedNode">Candidate node which was add or removed from the cluster</param>
        /// <param name="changeType">given change type</param>
        public override void HandleChangedCandidate(Node cluster, Node changedNode, ChangeType changeType)
        {
            if(!HandlingRequired(changedNode.ID, changeType, updateHandling: true))
            {
                return;
            }

            this.AddClusterToUpdate(cluster.ID);
            this.AddClusterToUpdate(cluster.Incomings.Where(e => e.IsInArchitecture()).Select(e => e.Source.ID));
            this.AddClusterToUpdate(cluster.Outgoings.Where(e => e.IsInArchitecture()).Select(e => e.Target.ID));
            this.AddCandidatesToUpdate(changedNode.Incomings.Where(e => e.IsInImplementation()).Select(e => e.Source.ID));
            this.AddCandidatesToUpdate(changedNode.Outgoings.Where(e => e.IsInImplementation()).Select(e => e.Target.ID));

            if (changeType == ChangeType.Removal)
            {
                this.AddCandidateToUpdate(changedNode.ID);
            }
        }

        /// <summary>
        /// This operation merges the documents of the source and target node of the 
        /// given implementation edge, retrieves the architecture edges which allows 
        /// the implementation edge and adds the words of the merged document to the 
        /// document of the architecture edge. Words are only add if the given 
        /// implementation edge is in the state allowed or implicitlyAllowed.
        /// </summary>
        /// <param name="implEdge">given implementation edge</param>
        /// <exception cref="Exception">Throws if an edge is in state allowed or implicitly allowed 
        /// but no corresponding architecture dependency could be found.</exception>
        private void AddDocumentsToAllowingDependency(Edge implEdge)
        {
            State edgeState = implEdge.State();

            if ((edgeState == State.Allowed || edgeState == State.ImplicitlyAllowed) 
                 && !this.allowedByArchEdge.ContainsKey(implEdge.ID))
            {
                Node mapsToSource = this.reflexionGraph.MapsTo(implEdge.Source);
                Node mapsToTarget = this.reflexionGraph.MapsTo(implEdge.Target);

                Edge architectureEdge = AllowedBy(implEdge, edgeState);

                if(architectureEdge == null)
                {
                    throw new Exception($"No matching architecture edge was found for {mapsToSource.ID} -{implEdge.Type}-> {mapsToTarget.ID}." +
                                          $" Expected by implementation Edge {implEdge.ToShortString()} in edgeState {edgeState}");
                }

                this.FindNodesToUpdateOnChangedArchEdge(architectureEdge);

                this.allowedByArchEdge[implEdge.ID] = architectureEdge;

                Document mergedDocument = this.GetMergedTerms(implEdge.Source, implEdge.Target, MergingType);

                if (!wordsPerArchEdge.ContainsKey(architectureEdge.ID))
                {
                    wordsPerArchEdge.Add(architectureEdge.ID, mergedDocument.Clone());
                }
                else
                {
                    wordsPerArchEdge[architectureEdge.ID].AddWords(mergedDocument);
                }
            } 
        }

        /// <summary>
        /// Returns the architecture edge which is allowing a given implementation 
        /// edge considering a given type and expected or current state.
        /// </summary>
        /// <param name="edge">Given implementation edge</param>
        /// <param name="state">Expected or current state</param>
        /// <returns>Allowing architecture edge</returns>
        private Edge AllowedBy(Edge edge, State state)
        {
            Node sourceCluster = reflexionGraph.MapsTo(edge.Source);
            Node targetCluster = reflexionGraph.MapsTo(edge.Target);
            return AllowedBy(sourceCluster, targetCluster, state, edge.Type);
        }

        /// <summary>
        /// Returns the architecture edge which is between two given cluster regarding 
        /// a edge type. If the given state is implicitly allowed an artificial architecture
        /// edge is returned to avoid to depend on the lifecycle of implicit architecture dependencies 
        /// of the reflexion graph.
        /// 
        // TODO: wording of function name
        /// 
        /// </summary>
        /// <param name="sourceCluster">Cluster node which should be the source of the searched architecture edge</param>
        /// <param name="targetCluster">Cluster node which sould be the target of the searched architecture edge</param>
        /// <param name="state">expected or current state</param>
        /// <param name="type">type of allowed implementation edge</param>
        /// <returns></returns>
        /// <exception cref="Exception">if the given state is neither allowed or implicitlyAllowed</exception>
        private Edge AllowedBy(Node sourceCluster, Node targetCluster, State state, string type)
        {
            Edge architectureEdge = null;
            if (state == State.Allowed && !sourceCluster.ID.Equals(targetCluster.ID))
            {
                // TODO: Use type hierarchy in the future
                List<Edge> architectureEdges = sourceCluster.FromTo(targetCluster, null).Where(e => ReflexionGraph.IsSpecified(e)
                                                                                 || e.Source.ID.Equals(e.Target.ID)).ToList(); ;
                architectureEdge = architectureEdges.SingleOrDefault();
                return architectureEdge;
            }
            else if (state == State.ImplicitlyAllowed)
            {
                // special case for implicitly allowed edges: 
                // The architecture dependencies which are allowing implementation edges within the same 
                // cluster are not specified until there are already two connected nodes mapped to an 
                // architecture node. So if only one node 'a' is add to a Cluster A, the calculation for (A,b) for a second node 'b'
                // with the dependecy b->a could not compare b->a with A->A even A->A is assumed per definition. A->A will only be 
                // created after b was already add. We create a corresponding architecure edge ourself, so we do not have 
                // to depend on the lifecycle of artificial self loop architecture edges created by the reflexion analysis.
                architectureEdge = new Edge(sourceCluster, targetCluster, type);
                architectureEdge.SetToggle(ReflexionSubgraphs.Architecture.GetLabel());
            }
            else
            {
                throw new Exception($"State must be allowed or implicitly allowed to find allowing architecture dependency. given state={state} sourceCluster={sourceCluster.ID} targetCluster={targetCluster.ID}");
            }

            return architectureEdge;
        }

        /// <summary>
        /// This operation merges the documents of the source and target node of the 
        /// given implementation edge, retrieves the architecture edges which previously allowed
        /// the implementation edge and removes the words of the merged document from the 
        /// document of the architecture edge. To retrieve the previously allowing architecture edge
        /// the datastructure <see cref="allowedByArchEdge"/> is used. The given implementation 
        /// edge is removed from this datastructure after the call. 
        /// </summary>
        /// <param name="implEdge">Given implementation edge</param>
        private void DeleteDocumentsFromAllowingDependency(Edge implEdge)
        {
            if(this.allowedByArchEdge.ContainsKey(implEdge.ID))
            {
                Edge architectureEdge = this.allowedByArchEdge[implEdge.ID];

                this.allowedByArchEdge.Remove(implEdge.ID);

                Document mergedDocument = this.GetMergedTerms(implEdge.Source, implEdge.Target, MergingType);

                if (wordsPerArchEdge.ContainsKey(architectureEdge.ID))
                {
                    wordsPerArchEdge[architectureEdge.ID].RemoveWords(mergedDocument);
                }

                if (architectureEdge != null)
                {
                    FindNodesToUpdateOnChangedArchEdge(architectureEdge);
                }
                else
                {
                    UnityEngine.Debug.LogWarning($"Architecture edge {architectureEdge.ID} is no longer contained within the graph. Attraction values may not be updated completely.");
                }
            }
        }

        /// <summary>
        /// Finds the nodes to update when the words of an arch edge changes.
        /// </summary>
        /// <param name="edge">given edge</param>
        /// <exception cref="Exception">Throws Exception if the given edge is not part of the architecture</exception>
        public void FindNodesToUpdateOnChangedArchEdge(Edge edge)
        {
            if(!edge.IsInArchitecture())
            {
                throw new Exception($"Given edge is not part of the architecture. {edge.ToShortString()}");
            }

            Node ClusterSource = edge.Source;
            Node ClusterTarget = edge.Target;

            this.AddClusterToUpdate(edge.Source.ID);
            this.AddClusterToUpdate(edge.Target.ID);

            this.AddAllCandidatesToUpdate();
        }

        /// <summary>
        /// Returns wether there is data saved in this object for architecture dependencies.
        /// </summary>
        /// <returns>Returns true if no words are contained within the documents of the architecture dependencies.
        /// False otherwise.</returns>
        public override bool EmptyTrainingData()
        {
            foreach (string id in wordsPerArchEdge.Keys)
            {
                if (wordsPerArchEdge[id].WordCount > 0)
                {
                    return false;
                }
            }
            return true;
        }

        /// <summary>
        /// Resets this attract function object.
        /// All caches and data structures will be cleared.
        /// </summary>
        public override void Reset()
        {
            this.edgeStateCache.ClearCache();
            this.ClearDocumentCache();
            this.wordsPerArchEdge.Clear();
            this.allowedByArchEdge.Clear();
        }

        /// <summary>
        /// Handles a cluster node which was add. 
        /// Forwards the call to the base class.
        /// </summary>
        /// <param name="cluster">given cluster node</param>
        public override void HandleAddCluster(Node cluster)
        {
            base.HandleAddCluster(cluster);
            this.AddAllCandidatesToUpdate();
        }

        /// <summary>
        /// Handles a cluster node which was removed. 
        /// Forwards the call to the base class.
        /// </summary>
        /// <param name="cluster">given cluster node</param>
        public override void HandleRemovedCluster(Node cluster)
        {
            base.HandleRemovedCluster(cluster);
        }

        /// <summary>
        /// Handles a architecture edge which was add. 
        /// Forwards the call to the base class.
        /// </summary>
        /// <param name="cluster">given cluster node</param>
        public override void HandleAddArchEdge(Edge archEdge)
        {
            base.HandleAddArchEdge(archEdge);
            this.AddAllCandidatesToUpdate();
        }

        /// <summary>
        /// Handles a architecture edge which was removed.
        /// 
        /// Add the source node and the target cluster node 
        /// to cluster to update if they are considered to be cluster.
        /// 
        /// Removed the edge from the datastructures <see cref="allowedByArchEdge"/>
        /// and <see cref="wordsPerArchEdge"/>.
        /// 
        /// </summary>
        /// <param name="archEdge">Given architecture edge</param>
        public override void HandleRemovedArchEdge(Edge archEdge)
        {
            base.HandleRemovedArchEdge(archEdge);

            if (reflexionGraph.ContainsNode(archEdge.Source) 
                && this.CandidateRecommendation.IsCluster(archEdge.Source))
            {
                this.AddClusterToUpdate(archEdge.Source.ID);
            }

            if (reflexionGraph.ContainsNode(archEdge.Target) 
                && this.CandidateRecommendation.IsCluster(archEdge.Target))
            {
                this.AddClusterToUpdate(archEdge.Target.ID);
            }

            if (this.wordsPerArchEdge.ContainsKey(archEdge.ID))
            {
                this.wordsPerArchEdge.Remove(archEdge.ID); 
            }

            IList<string> keysToDelete = new List<string>();

            foreach (string implEdgeId in this.allowedByArchEdge.Keys)
            {
                if (this.allowedByArchEdge[implEdgeId].ID.Equals(archEdge.ID))
                {
                    keysToDelete.Add(implEdgeId);
                }
            }

            foreach (string key in keysToDelete)
            {
                this.allowedByArchEdge.Remove(key);
            }
            this.AddAllCandidatesToUpdate();
        }

        /// <summary>
        /// This method is called if the state of an edge changes.
        /// 
        /// If the edge is in implementation and changes from a different 
        /// state to Allowed or ImplicitlyAllowed the document of the implementation 
        /// edge will be generated and add.
        /// 
        /// If the edge is in implementation and changes from a Allowed or Implicitly Allowed 
        /// to a different state the document of the implementation 
        /// edge will be removed.
        /// 
        /// </summary>
        /// <param name="edgeChange"></param>
        public override void HandleChangedState(EdgeChange edgeChange)
        {
            if ((edgeChange.NewState == State.Allowed || edgeChange.NewState == State.ImplicitlyAllowed)
                && edgeChange.OldState != State.Allowed 
                && edgeChange.OldState != State.ImplicitlyAllowed
                && edgeChange.Edge.IsInImplementation())
            {
                AddDocumentsToAllowingDependency(edgeChange.Edge);
            }

            if ((edgeChange.OldState == State.Allowed || edgeChange.OldState == State.ImplicitlyAllowed)
                && edgeChange.NewState != State.Allowed 
                && edgeChange.NewState != State.ImplicitlyAllowed
                && edgeChange.Edge.IsInImplementation())
            {
                DeleteDocumentsFromAllowingDependency(edgeChange.Edge);
            }

            return;
        }
    }
}