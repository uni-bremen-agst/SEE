using System.Collections.Generic;
using SEE.DataModel;
using SEE.DataModel.DG;
using SEE.Game.City;
using SEE.GO;
using UnityEngine;

namespace SEE.Game
{
    /// <summary>
    /// This component is intended to provide interactions with a 
    /// code city representing a reflexion model. One can show/hide nodes 
    /// and edges in the architecture by user interactions.
    /// 
    /// Its only purpose was to create a video. Do not use this class.
    /// </summary>
    [ExecuteAlways]
    public class ArchitectureInteraction : MonoBehaviour
    {
        /// <summary>
        /// The code city to be manipulated by this component.
        /// </summary>
        [Tooltip("The code city to be manipulated by this component.")]
        public SEECity CodeCity;

        //------------------
        // Edge types 
        //------------------

        /// <summary>
        /// Edge types generated by the reflexion analysis.
        /// </summary>
        public static readonly HashSet<string> ReflexionEdgeTypes = new HashSet<string>()
        {
            "Absence",
            "Convergence",
            "Divergence",
        };

        /// <summary>
        /// Edge types representing implementation dependencies.
        /// </summary>
        public static readonly HashSet<string> ArchitectureEdgeTypes = new HashSet<string>()
        {
            "Source_Dependency",
        };

        public static readonly HashSet<string> AllEdgeTypes = new HashSet<string>();

        private HashSet<string> implementationEdgeTypes = new HashSet<string>();
        /// <summary>
        /// All edge types in the graph that are neither reflexion edges 
        /// nor architecture dependencies.
        /// </summary>
        public HashSet<string> ImplementationEdgeTypes
        {
            get
            {
                if (implementationEdgeTypes.Count == 0)
                {
                    implementationEdgeTypes = GetImplementationEdgeTypes();
                    foreach (string type in implementationEdgeTypes)
                    {
                        Debug.LogFormat("implementation edge type {0}\n", type);
                    }
                }
                return implementationEdgeTypes;
            }
        }

        /// <summary>
        /// Returns all edge types in the graph that are neither reflexion edges 
        /// nor architecture dependencies.
        /// </summary>
        /// <returns>all implementation edge types</returns>
        private HashSet<string> GetImplementationEdgeTypes()
        {
            HashSet<string> result = new HashSet<string>();
            foreach (GameObject go in GetAllEdges())
            {
                string type = GetGraphEdge(go).Type;
                if (!ReflexionEdgeTypes.Contains(type) && !ArchitectureEdgeTypes.Contains(type))
                {
                    result.Add(type);
                }
            }
            return result;
        }

        // -----------------------
        // Edge property defaults
        // -----------------------
        private static readonly Color implementationEdgesColorDefault = Color.black;
        private static readonly Color architectureEdgesColorDefault = Color.blue;
        private static readonly float implementationEdgeWidthDefault = 0.001f;
        private static readonly float architectureEdgeWidthDefault = 0.005f;
        private static readonly float reflexionEdgeWidthDefault = 0.005f;

        /// <summary>
        /// Resets the settings to their defaults. Called in editor mode when the
        /// user resets the component.
        /// </summary>
        private void Reset()
        {
            implementationEdgesVisible = false;
            implementationEdgesStartColor = Lighter(implementationEdgesColorDefault);
            implementationEdgesEndColor = implementationEdgesColorDefault;
            implementationEdgesWidth = implementationEdgeWidthDefault;

            architectureEdgesVisible = false;
            architectureEdgesStartColor = Lighter(architectureEdgesColorDefault);
            architectureEdgesEndColor = architectureEdgesColorDefault;
            architectureEdgesWidth = architectureEdgeWidthDefault;

            reflexionEdgesVisible = false;
            reflexionEdgesWidth = reflexionEdgeWidthDefault;

            architectureNodesVisible = true;
            implementationNodesVisible = false;
        }

        /// <summary>
        /// Assigns <see cref="CodeCity"/>.
        /// </summary>
        private void Awake()
        {
            if (!gameObject.TryGetComponent(out CodeCity))
            {
                Debug.LogError($"Game object {name} does not have a SEECity component.\n");
                enabled = false;
            }
            else
            {
                UpdateCity();
            }
        }

        // --------------------------------------------
        // Update
        // --------------------------------------------

        private void Update()
        {
            if (Input.GetKeyDown(KeyCode.F5))
            {
                ImplementationEdgesVisible = !ImplementationEdgesVisible;
                Debug.Log("F5 pressed.\n");
            }
            if (Input.GetKeyDown(KeyCode.F6))
            {
                ArchitectureEdgesVisible = !ArchitectureEdgesVisible;
            }
            if (Input.GetKeyDown(KeyCode.F7))
            {
                ReflexionEdgesVisible = !ReflexionEdgesVisible;
            }
            if (Input.GetKeyDown(KeyCode.F11))
            {
                ArchitectureNodesVisible = !ArchitectureNodesVisible;                
            }
            if (Input.GetKeyDown(KeyCode.F12))
            {
                ImplementationNodesVisible = !ImplementationNodesVisible;
            }
        }

        /// <summary>
        /// Sets the edge references of all edges in <see cref="CodeCity"/>
        /// and colors the nodes.
        /// </summary>
        public void UpdateCity()
        {
            if (CodeCity != null)
            {
                CodeCity.SetNodeEdgeRefs();
                GameObject root = GetCityRootNode();
                if (root != null)
                {
                    Debug.LogFormat("Root of {0} is {1}\n", CodeCity.name, root.name);
                    SetAllNodes(root);                    
                    SetAllEdges();
                }
            }
            else
            {
                Debug.LogErrorFormat("Code city is null in {0}.\n", name);
            }
        }

        /// <summary>
        /// Sets all attributes of all nodes.
        /// </summary>
        /// <param name="root">root node of the code city</param>
        private void SetAllNodes(GameObject root)
        {
            ColorNodes(root);
            SetNodeVisibility(ArchitectureNodes(), architectureNodesVisible);
            SetNodeVisibility(ImplementationNodes(), implementationNodesVisible);
        }

        /// <summary>
        /// Sets all attributes of all edges.
        /// </summary>
        private void SetAllEdges()
        {
            SetArchitectureEdges();
            SetImplementationEdges();
            SetReflexionEdges();
        }

        /// <summary>
        /// Returns the root node of <see cref="CodeCity"/>.
        /// </summary>
        /// <returns>root node of <see cref="CodeCity"/></returns>
        private GameObject GetCityRootNode()
        {
            return SceneQueries.GetCityRootNode(CodeCity.gameObject).gameObject;            
        }

        /// <summary>
        /// Colors architecture node with increasingly darker colors starting from white
        /// and implementation nodes with increasingly darker colors starting from yellow.
        /// The actual color used gets darker from nesting level to nesting level.
        /// Implementation leaf nodes keep their original color, however.
        /// </summary>
        /// <param name="root">the root of the node tree to be colored</param>
        private void ColorNodes(GameObject root)
        {
            ColorNodes(root, architectureNode: false, Color.yellow);
            ColorNodes(root, architectureNode: true, Color.white);
        }

        /// <summary>
        /// Colors all nodes in the node tree rooted by <paramref name="parent"/> using
        /// the given <paramref name="color"/> if and only if:
        ///   (1) if <paramref name="architectureNode"/> is true, the nodes are architecture nodes
        ///   or
        ///   (2) if <paramref name="architectureNode"/> is false, the nodes are implementation nodes.
        /// The color is increasingly darkened from level to level, that is, the deeper a node
        /// in the node tree, the darker its color originating from the initial given <paramref name="color"/>.
        /// 
        /// Note: The color of implementation leaf nodes is never changed.
        /// </summary>
        /// <param name="parent">root of the node tree to be colored</param>
        /// <param name="architectureNode">whether architecture nodes should be colored</param>
        /// <param name="color">the new color of the nodes</param>
        private void ColorNodes(GameObject parent, bool architectureNode, Color color)
        {
            // Is root a node at all? It may as well be an edge, for instance.
            if (parent.CompareTag(Tags.Node))
            {
                if (parent.TryGetComponent<NodeRef>(out NodeRef nodeRef) && nodeRef.Value != null)
                {
                    bool isArchitectureNode = IsArchitectureNode(parent);
                    Color childColor = color;

                    if (!isArchitectureNode && GetGraphNode(parent).IsLeaf())
                    {
                        // We are dealing with an implementation node that is a leaf.
                        // We will not change the color of implementation nodes that are leaves;
                        // neither do we need to traverse any children because there are none.
                    }
                    else
                    {
                        if ((architectureNode && isArchitectureNode) || (!architectureNode && !isArchitectureNode))
                        {
                            parent.SetColor(color);
                            childColor = Darker(color, 0.35f);
                        }
                        foreach (Transform child in parent.transform)
                        {
                            ColorNodes(child.gameObject, architectureNode, childColor);
                        }
                    }
                }
                else
                {
                    Debug.LogErrorFormat("Game object {0} has no valid node reference.\n", parent.name);
                }
            }
        }

        //-------------------
        // Edges in CodeCity
        //-------------------

        /// <summary>
        /// Returns all edges in the subtree rooted by <see cref="CodeCity"/>.
        /// </summary>
        /// <returns>all edges in the subtree rooted by <see cref="CodeCity"/></returns>
        private List<GameObject> GetAllEdges()
        {
            List<GameObject> edges = new List<GameObject>();
            GameObject root = GetCityRootNode();
            AddAllEdges(root, edges);
            return edges;
        }

        /// <summary>
        /// Adds all edges in the subtree rooted by <paramref name="root"/> to <paramref name="edges"/>.
        /// </summary>
        /// <param name="root">root of the subtree to be traversed</param>
        /// <param name="edges">where to add the found edges</param>
        private void AddAllEdges(GameObject root, List<GameObject> edges)
        {
            foreach (Transform child in root.transform)
            {
                GameObject childGO = child.gameObject;
                if (childGO.CompareTag(Tags.Edge))
                {
                    if (childGO.TryGetComponent(out EdgeRef edgeRef) && edgeRef.Value != null)
                    {
                        edges.Add(childGO);
                    }
                    else
                    {
                        Debug.LogErrorFormat("Edge {0} has no valid edge reference.\n", childGO.name);
                    }
                }
                else if (childGO.CompareTag(Tags.Node))
                {
                    AddAllEdges(childGO, edges);
                }
            }
        }

        /// <summary>
        /// Returns the graph edge represented by <paramref name="gameEdge"/> if there is any.
        /// Returns null if <paramref name="gameEdge"/> does not have a valid graph edge.
        /// </summary>
        /// <param name="gameEdge">game object representing an edge</param>
        /// <returns>graph edge represented or null</returns>
        private static Edge GetGraphEdge(GameObject gameEdge)
        {
            if (gameEdge.TryGetComponent(out EdgeRef edgeRef))
            {
                return edgeRef.Value;
            }
            else
            {
                Debug.LogError($"Edge {gameEdge.name} has no valid edge reference.\n");
                return null;
            }
        }

        //------------------
        // Nodes in CodeCity
        //------------------

        /// <summary>
        /// Returns all nodes in the subtree rooted by <see cref="CodeCity"/>.
        /// </summary>
        /// <returns>all nodes in the subtree rooted by <see cref="CodeCity"/></returns>
        private List<GameObject> GetAllNodes()
        {
            GameObject root = GetCityRootNode();
            List<GameObject> nodes = new List<GameObject>() { root };            
            AddAllNodes(root, nodes);
            return nodes;
        }

        /// <summary>
        /// Adds all nodes in the subtree rooted by <paramref name="root"/> to <paramref name="nodes"/>.
        /// </summary>
        /// <param name="root">root of the subtree to be traversed</param>
        /// <param name="nodes">where to add the found nodes</param>
        private void AddAllNodes(GameObject root, List<GameObject> nodes)
        {
            foreach (Transform child in root.transform)
            {
                GameObject childGO = child.gameObject;
                if (childGO.CompareTag(Tags.Node))
                {
                    if (childGO.TryGetComponent(out NodeRef nodeRef) && nodeRef.Value != null)
                    {
                        nodes.Add(childGO);
                    }
                    else
                    {
                        Debug.LogError($"Node {childGO.name} has no valid node reference.\n");
                    }
                }
                AddAllNodes(childGO, nodes);
            }
        }

        /// <summary>
        /// Returns the graph node represented by <paramref name="gameNode"/> if there is any.
        /// Returns null if <paramref name="gameNode"/> does not have a valid graph node.
        /// </summary>
        /// <param name="gameNode">game object representing a node</param>
        /// <returns>graph node represented or null</returns>
        private static Node GetGraphNode(GameObject gameNode)
        {
            if (gameNode.TryGetComponent(out NodeRef nodeRef))
            {
                return nodeRef.Value;
            }
            else
            {
                Debug.LogErrorFormat("Node {0} has no valid node reference.\n", gameNode.name);
                return null;
            }
        }

        //------------------------------------
        // Implementation edge type properties
        //------------------------------------

        private bool implementationEdgesVisible = false;
        /// <summary>
        /// Whether implementation edges are visible.
        /// </summary>
        public bool ImplementationEdgesVisible
        {
            get => implementationEdgesVisible;
            set
            {
                if (implementationEdgesVisible != value)
                {
                    implementationEdgesVisible = value;
                    SetEdgeVisiblity(ImplementationEdgeTypes, implementationEdgesVisible);
                }
            }
        }

        private Color implementationEdgesStartColor = Lighter(implementationEdgesColorDefault);
        /// <summary>
        /// Start color of implementation dependencies.
        /// </summary>
        public Color ImplementationEdgesStartColor
        {
            get => implementationEdgesStartColor;
            set
            {
                if (implementationEdgesStartColor != value)
                {
                    implementationEdgesStartColor = value;
                    SetImplementationEdges();
                }
            }
        }

        private Color implementationEdgesEndColor = implementationEdgesColorDefault;
        /// <summary>
        /// End color of implementation dependencies.
        /// </summary>
        public Color ImplementationEdgesEndColor
        {
            get => implementationEdgesEndColor;
            set
            {
                if (implementationEdgesEndColor != value)
                {
                    implementationEdgesEndColor = value;
                    SetImplementationEdges();
                }
            }
        }

        private float implementationEdgesWidth = implementationEdgeWidthDefault;
        /// <summary>
        /// The width of implementation dependencies.
        /// </summary>
        public float ImplementationEdgesWidth
        {
            get => implementationEdgesWidth;
            set
            {
                if (implementationEdgesWidth != value)
                {
                    implementationEdgesWidth = value;
                    SetImplementationEdges();
                }
            }
        }

        /// <summary>
        /// Sets all attributes of implementation edges.
        /// </summary>
        private void SetImplementationEdges()
        {
            SetLine(ImplementationEdgeTypes, implementationEdgesStartColor, implementationEdgesEndColor, implementationEdgesWidth);
            SetEdgeVisiblity(ImplementationEdgeTypes, implementationEdgesVisible);
        }

        //------------------------------------
        // Reflexion edge type properties
        //------------------------------------

        private bool reflexionEdgesVisible = false;
        /// <summary>
        /// Whether reflexion edges are visible.
        /// </summary>
        public bool ReflexionEdgesVisible
        {
            get => reflexionEdgesVisible;
            set
            {
                if (reflexionEdgesVisible != value)
                {
                    reflexionEdgesVisible = value;
                    SetEdgeVisiblity(ReflexionEdgeTypes, reflexionEdgesVisible);
                }
            }
        }

        private float reflexionEdgesWidth = reflexionEdgeWidthDefault;
        /// <summary>
        /// The width of reflexion edges.
        /// </summary>
        public float ReflexionEdgesWidth
        {
            get => reflexionEdgesWidth;
            set
            {
                if (reflexionEdgesWidth != value)
                {
                    reflexionEdgesWidth = value;
                    SetReflexionEdges();
                }
            }
        }

        /// <summary>
        /// Sets start and end color and width for the lines of all reflexion edges.
        /// Absences will be colored yellow, convergences will be colored green, and
        /// divergences will be colored red. Sets the visibility of the reflexion edges.
        /// </summary>
        private void SetReflexionEdges()
        {
            SetLine(new HashSet<string>() { "Absence" }, Color.yellow, Darker(Color.yellow), reflexionEdgesWidth);
            SetLine(new HashSet<string>() { "Convergence" }, Color.green, Darker(Color.green), reflexionEdgesWidth);
            SetLine(new HashSet<string>() { "Divergence" }, Color.red, Darker(Color.red), reflexionEdgesWidth);
            SetEdgeVisiblity(ReflexionEdgeTypes, reflexionEdgesVisible);
        }

        //------------------------------------
        // Architecture edge type properties
        //------------------------------------

        private bool architectureEdgesVisible = false;
        /// <summary>
        /// Whether architecture dependencies are visible.
        /// </summary>
        public bool ArchitectureEdgesVisible
        {
            get => architectureEdgesVisible;
            set
            {
                if (architectureEdgesVisible != value)
                {
                    architectureEdgesVisible = value;
                    SetEdgeVisiblity(ArchitectureEdgeTypes, architectureEdgesVisible);
                }
            }
        }

        private Color architectureEdgesStartColor = Lighter(Color.blue);
        /// <summary>
        /// Start color of architecture dependencies.
        /// </summary>
        public Color ArchitectureEdgesStartColor
        {
            get => architectureEdgesStartColor;
            set
            {
                if (architectureEdgesStartColor != value)
                {
                    architectureEdgesStartColor = value;
                    SetArchitectureEdges();
                }
            }
        }

        private Color architectureEdgesEndColor = Color.blue;
        /// <summary>
        /// End color of architecture dependencies.
        /// </summary>
        public Color ArchitectureEdgesEndColor
        {
            get => architectureEdgesEndColor;
            set
            {
                if (architectureEdgesEndColor != value)
                {
                    architectureEdgesEndColor = value;
                    SetArchitectureEdges();
                }
            }
        }

        private float architectureEdgesWidth = architectureEdgeWidthDefault;
        /// <summary>
        /// The width of architecture dependencies.
        /// </summary>
        public float ArchitectureEdgesWidth
        {
            get => architectureEdgesWidth;
            set
            {
                if (architectureEdgesWidth != value)
                {
                    architectureEdgesWidth = value;
                    SetArchitectureEdges();
                }
            }
        }

        /// <summary>
        /// Sets all attributes of all architecture edges.
        /// </summary>
        private void SetArchitectureEdges()
        {
            SetLine(ArchitectureEdgeTypes, architectureEdgesStartColor, architectureEdgesEndColor, architectureEdgesWidth);
            SetEdgeVisiblity(ArchitectureEdgeTypes, architectureEdgesVisible);
        }

        /// <summary>
        /// Set the visibility of all edges in the <see cref="CodeCity"/> that have
        /// any of the given <paramref name="edgeTypes"/> to <paramref name="show"/>.
        /// </summary>
        /// <param name="edgeTypes">relevant edge types for setting the visibility</param>
        /// <param name="show">new visibility</param>
        private void SetEdgeVisiblity(HashSet<string> edgeTypes, bool show)
        {
            foreach (GameObject go in GetAllEdges())
            {
                if (edgeTypes == AllEdgeTypes || edgeTypes.Contains(GetGraphEdge(go).Type))
                {
                    go.SetVisibility(show);
                }
            }
        }

        /// <summary>
        /// For every edge in <see cref="CodeCity"/> having a type included in the given
        /// <paramref name="edgeTypes"/>, the given line attributes will be set.
        /// </summary>
        /// <param name="edgeTypes">relevant edge types</param>
        /// <param name="startColor">starting color of the line</param>
        /// <param name="endColor">ending color of the line</param>
        /// <param name="width">width of the line</param>
        private void SetLine(HashSet<string> edgeTypes, Color startColor, Color endColor, float width)
        {
            foreach (GameObject go in GetAllEdges())
            {
                if (edgeTypes == AllEdgeTypes || edgeTypes.Contains(GetGraphEdge(go).Type))
                {
                    LineRenderer renderer = go.GetComponent<LineRenderer>();
                    if (renderer != null)
                    {
                        renderer.startColor = startColor;
                        renderer.endColor = endColor;
                        renderer.startWidth = width;
                        renderer.endWidth = width;
                    }
                }
            }
        }

        //------------------------------------
        // Architecture node type properties
        //------------------------------------

        private bool architectureNodesVisible = true;
        /// <summary>
        /// Whether architecture nodes are visible.
        /// </summary>
        public bool ArchitectureNodesVisible
        {
            get => architectureNodesVisible;
            set
            {
                if (architectureNodesVisible != value)
                {
                    architectureNodesVisible = value;
                    SetNodeVisibility(ArchitectureNodes(), architectureNodesVisible);
                }
            }
        }

        private bool implementationNodesVisible = false;
        /// <summary>
        /// Whether implementation nodes are visible.
        /// </summary>
        public bool ImplementationNodesVisible
        {
            get => implementationNodesVisible;
            set
            {
                if (implementationNodesVisible != value)
                {
                    implementationNodesVisible = value;
                    SetNodeVisibility(ImplementationNodes(), implementationNodesVisible);
                }
            }
        }

        /// <summary>
        /// Returns all architecture nodes in <see cref="CodeCity"/>.
        /// </summary>
        /// <returns>all architecture nodes</returns>
        private List<GameObject> ArchitectureNodes()
        {
            List<GameObject> result = new List<GameObject>();
            foreach (GameObject go in GetAllNodes())
            {
                if (IsArchitectureNode(go))
                {
                    result.Add(go);
                }
            }
            return result;
        }

        /// <summary>
        /// Returns true if <paramref name="go"/> is an architecture node (has
        /// type Cluster).
        /// </summary>
        /// <param name="go">game object representing a node</param>
        /// <returns>true if architecture node</returns>
        private static bool IsArchitectureNode(GameObject go)
        {
            return GetGraphNode(go).Type == "Cluster";
        }

        /// <summary>
        /// Returns all implementation nodes in the <see cref="CodeCity"/>.
        /// </summary>
        /// <returns>all implementation nodes</returns>
        private List<GameObject> ImplementationNodes()
        {
            List<GameObject> result = new List<GameObject>();
            foreach (GameObject go in GetAllNodes())
            {
                if (!IsArchitectureNode(go))
                {
                    result.Add(go);
                }
            }
            return result;
        }

        /// <summary>
        /// Sets the visibility of all <paramref name="nodes"/> to <paramref name="show"/>.
        /// </summary>
        /// <param name="nodes">game objects whose visibility is to be set</param>
        /// <param name="show">the new visibility</param>
        private static void SetNodeVisibility(ICollection<GameObject> nodes, bool show)
        {
            foreach (GameObject go in nodes)
            {
                go.SetVisibility(show, includingChildren: false);
            }
        }

        /// <summary>
        /// Returns given <paramref name="color"/> lightened by 50%.
        /// </summary>
        /// <param name="color">base color to be lightened</param>
        /// <returns>given <paramref name="color"/> lightened by 50%</returns>
        private static Color Lighter(Color color)
        {
            return Color.Lerp(color, Color.white, 0.5f); // To lighten by 50 %
        }

        /// <summary>
        /// Returns given <paramref name="color"/> darkened by <paramref name="degree"/>.
        /// 
        /// Precondition: 0 <= <paramref name="degree"/> <= 1
        /// </summary>
        /// <param name="color">base color to be darkened</param>
        /// <param name="degree">degree by which to darker the given <paramref name="color"/></param>
        /// <returns>given <paramref name="color"/> darkened by <paramref name="degree"/></returns>
        private static Color Darker(Color color, float degree = 0.5f)
        {
            return Color.Lerp(color, Color.black, degree);
        }
    }
}