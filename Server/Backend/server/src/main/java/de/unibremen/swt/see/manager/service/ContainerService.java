package de.unibremen.swt.see.manager.service;

import com.github.dockerjava.api.DockerClient;
import com.github.dockerjava.api.command.CreateContainerResponse;
import com.github.dockerjava.api.command.InspectContainerResponse;
import com.github.dockerjava.api.exception.ConflictException;
import com.github.dockerjava.api.exception.InternalServerErrorException;
import com.github.dockerjava.api.exception.NotFoundException;
import com.github.dockerjava.api.exception.NotModifiedException;
import com.github.dockerjava.api.model.ExposedPort;
import com.github.dockerjava.api.model.HostConfig;
import com.github.dockerjava.api.model.PortBinding;
import com.github.dockerjava.api.model.Ports;
import com.github.dockerjava.core.DefaultDockerClientConfig;
import com.github.dockerjava.core.DockerClientConfig;
import com.github.dockerjava.core.DockerClientImpl;
import com.github.dockerjava.transport.DockerHttpClient;
import com.github.dockerjava.zerodep.ZerodepDockerHttpClient;
import de.unibremen.swt.see.manager.model.Server;
import de.unibremen.swt.see.manager.model.ServerStatusType;
import jakarta.annotation.PostConstruct;
import java.io.IOException;
import java.net.URISyntaxException;
import java.time.Duration;
import java.util.function.Supplier;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * Service class for managing container-related operations.
 * <p>
 * This service provides high-level operations for container management,
 * including creating, retrieving, updating, and deleting containers. It
 * encapsulates the business logic and acts as an intermediary between the
 * controller layer and the data access layer.
 * <p>
 * Container instances are managed by the {@link ServerService}.
 *
 * @see ServerService
 */
@Service
@Transactional
@Slf4j
@RequiredArgsConstructor
public class ContainerService {

    /**
     * Used to spawn and control containers.
     */
    private DockerClient dockerClient;

    /**
     * The URI used to connect to the Docker instance.
     * <p>
     * Possible formats are usually either {@code tcp://host:port} or
     * {@code unix:///path/to.sock}.
     */
    @Value("${see.app.docker.host}")
    private String dockerHost;

    /**
     * Contains the domain name, or IP address, and port of this back-end
     * application server.
     */
    @Value("${see.app.backend.domain}")
    private String backendDomain;

    /**
     * The name of the container image that should be used to run game server
     * instances.
     */
    @Value("${see.app.docker.image.gameserver}")
    private String containerImageName;

    /**
     * The port that the game server exposes inside the container.
     * <p>
     * This port will be mapped to the server's external port on the container
     * host.
     */
    final static int CONTAINER_PORT = 7777;

    /**
     * Maximal retries after "broken pipe" errors.
     */
    final static int MAX_RETRIES = 3;

    /**
     * Private exception for the {@code retry} method, indicating that the
     * maximal number of retries has exceeded and the execution still failed.
     */
    private static class MaxRetriesExceededException extends RuntimeException {

        private final int maxAttempts;

        public MaxRetriesExceededException(int maxAttempts, Throwable cause) {
            super("Operation failed after " + maxAttempts + " attempts", cause);
            this.maxAttempts = maxAttempts;
        }

        public int getMaxAttempts() {
            return maxAttempts;
        }
    }

    /**
     * Does custom initialization after the service has been constructed.
     * <p>
     * The constructor is generated by Lombok via
     * {@code @RequiredArgsConstructor}. This method is used to do additional
     * initialization steps usually implemented in a constructor.
     * <p>
     * Initializes the {@code DockerClient}.
     *
     * @throws URISyntaxException if the Docker {@code URI} is malformed
     */
    @PostConstruct
    public void init() throws URISyntaxException {
        DockerClientConfig config = DefaultDockerClientConfig.createDefaultConfigBuilder()
                .withDockerHost(dockerHost)
                .build();

        DockerHttpClient httpClient = new ZerodepDockerHttpClient.Builder()
                .dockerHost(config.getDockerHost())
                .maxConnections(100)
                .connectionTimeout(Duration.ofSeconds(30))
                .responseTimeout(Duration.ofSeconds(45))
                //                .sslConfig(sslConfig)
                .build();

        this.dockerClient = DockerClientImpl.getInstance(config, httpClient);

        try {
            retry(dockerClient.pingCmd()::exec, MAX_RETRIES);
            log.info("Successfully connected to Docker at: {}", dockerHost);
        } catch (MaxRetriesExceededException e) {
            log.warn("Connection to Docker failed with URI: {}", dockerHost);
        }
    }

    /**
     * Starts a container for the given server.
     * <p>
     * A new container will be created if it does not exist.
     *
     * @param server the server configuration
     * @throws java.io.IOException if the uploaded files for given server cannot
     * be accessed
     * @throws NotModifiedException if the container is already running
     * @throws InternalServerErrorException e.g., if the port is already bound
     * @throws NotFoundException if the container gets deleted in the time
     * between existence check and start execution
     */
    public void startContainer(Server server) throws IOException, NotModifiedException, NotFoundException, InternalServerErrorException {
        final String containerName = "see-" + server.getId();
        String containerId = server.getContainerId();

        if (containerId == null || !containerExists(containerId)) {
            CreateContainerResponse containerResponse = createContainer(containerName, server.getContainerPort(), server.getId().toString(), server.getServerPassword());
            containerId = containerResponse.getId();
            log.info("Created new container: {}", containerName);
        }

        try {
            retry(dockerClient.startContainerCmd(containerId)::exec, MAX_RETRIES);
            log.info("Started container: {}", containerName);
        } catch (NotModifiedException e) {
            server.setStatus(ServerStatusType.ONLINE);
            throw e;
        }

        server.setContainerId(containerId);
        server.setStatus(ServerStatusType.ONLINE);
    }

    /**
     * Stops the container for the given server.
     *
     * @param server the server configuration
     * @throws NotFoundException if the container does not exist
     * @throws NotModifiedException if the container is already stopped
     */
    public void stopContainer(Server server) throws NotFoundException, NotModifiedException {
        // SEE server will (currently) not shutdown gracefully, anyway, so we
        // can simply kill it.
        try {
            retry(dockerClient.killContainerCmd(server.getContainerId())::exec, MAX_RETRIES);
        } catch (ConflictException e) {
            throw new NotModifiedException(e);
        }
    }

    /**
     * Deletes a container.
     *
     * @param server the server configuration
     * @throws NotFoundException if the container does not exist
     */
    public void deleteContainer(Server server) throws NotFoundException, NotModifiedException {
        String containerId = server.getContainerId();
        if (containerId == null) {
            return;
        }
        
        try {
            retry(dockerClient.killContainerCmd(containerId)::exec, MAX_RETRIES);
        } catch (NotModifiedException | ConflictException e) {
            // Server already stopped
        }
        retry(dockerClient.removeContainerCmd(containerId)
                .withRemoveVolumes(true).withForce(true)::exec,
                MAX_RETRIES);
    }

    /**
     * Checks if a container is running for given server.
     *
     * @param server the server configuration
     * @return {@code true} if a container is running for the server, else
     * {@code false}.
     */
    public boolean isRunning(Server server) {
        InspectContainerResponse containerInfo = getContainerInfo(server);
        return containerInfo != null && containerInfo.getState().getRunning();
    }

    /**
     * Checks if a container exists for given server.
     * <p>
     * Use {@link #isRunning(Server)} directly if you want to know if it exists
     * and running.
     *
     * @param server the server configuration
     * @return {@code true} if a container exists for the server, else
     * {@code false}.
     */
    public boolean hasContainer(Server server) {
        return getContainerInfo(server) != null;
    }

    /**
     * Gets the container information for given server.
     *
     * @param server the server configuration
     * @return the container info if a container exists, or {@code null}
     */
    private InspectContainerResponse getContainerInfo(Server server) {
        String containerId = server.getContainerId();
        if (containerId == null || containerId.isBlank()) {
            return null;
        }

        try {
            return retry(dockerClient.inspectContainerCmd(containerId)::exec, MAX_RETRIES);
        } catch (NotFoundException e) {
            return null;
        }
    }

    /**
     * Creates and starts a new SEE container.
     *
     * @param containerName the name that the container should be started under
     * for a SEE Code City
     * @param port the port number that should be exposed on the container host
     * @param serverId ID of the server that is handed over to the game server
     * @param password room password that is handed over to the game server
     * @return response metadata object
     */
    private CreateContainerResponse createContainer(
            final String containerName,
            final int port,
            final String serverId,
            final String password) {
        ExposedPort exposedPort = ExposedPort.udp(CONTAINER_PORT);
        PortBinding portBinding = new PortBinding(Ports.Binding.bindPort(port), exposedPort);

        return retry(dockerClient.createContainerCmd(containerImageName)
                .withName(containerName)
                .withHostConfig(HostConfig.newHostConfig()
                        .withPortBindings(portBinding)
                )
                .withExposedPorts(exposedPort)
                .withEnv(
                        "SEE_BACKEND_DOMAIN=" + backendDomain,
                        "SEE_SERVER_ID=" + serverId,
                        "SEE_SERVER_PASSWORD=" + password)::exec,
                 MAX_RETRIES);
    }

    /**
     * Checks if a container with given ID exists.
     *
     * @param containerId the ID of the container
     * @return {@code true} if the container exists, else {@code false}
     */
    private boolean containerExists(final String containerId) {
        if (containerId == null) {
            return false;
        }

        try {
            InspectContainerResponse containerResponse = retry(dockerClient.inspectContainerCmd(containerId)::exec, MAX_RETRIES);
            return containerResponse != null;
        } catch (NotFoundException e) {
            return false;
        }
    }

    /**
     * Retry mechanism for container calls that might fail due to a
     * {@code IOException} wrapped in a {@code RuntimeException} (broken pipe).
     *
     * @param <T> the type of the result returned by the operation
     * @param operation the operation to be executed and potentially retried
     * @param maxAttempts maximal retry attempts
     * @return return value of the operation
     * @throws MaxRetriesExceededException if the execution failed after
     * {@code maxAttempts} retries
     */
    private static <T> T retry(Supplier<T> operation, int maxAttempts) throws MaxRetriesExceededException {
        int attempts = 0;
        Throwable lastException = null;
        while (attempts < maxAttempts) {
            try {
                return operation.get();
            } catch (RuntimeException e) {
                if (!(e.getCause() instanceof IOException)) {
                    throw e;
                }
                attempts++;
                lastException = e;
                if (attempts >= maxAttempts || !(e.getCause() instanceof IOException)) {
                    throw e;
                }
                log.debug("Retrying after {} failed attempts...", attempts);
            }
        }
        throw new MaxRetriesExceededException(maxAttempts, lastException);
    }
}
