#!/usr/bin/env python3

# A script which takes in a unified diff expected to be generated by
# git diff -U0 | grep '^[+@]'
# and outputs any bad pattern matches. See documentation of
# BadPattern.to_comment() for details of the output format.
# Note that this script is only run on CI, not as part of the Git hooks,
# due to it being written in Python rather than as a shell script.

import sys
import re
import fileinput
from enum import Enum


class Level(str, Enum):
    """
    Severity level of a bad pattern, associated to a GitHub emoji.
    """

    INFO = ":information_source:"
    WARN = ":warning:"
    ERROR = ":x:"


# Extensions that a pattern will be applied to by default.
DEFAULT_EXTENSIONS = ("cs",)


class BadPattern:
    """
    A pattern within a file that must be avoided.
    """

    def __init__(
        self,
        regex,
        message,
        extensions=DEFAULT_EXTENSIONS,
        suggestion=None,
        level=Level.INFO,
    ):
        """
        Takes a compiled regular expression `regex` that is checked against
        every line within changed files having an extension contained in
        `extensions`, a `message` that shall be displayed to the user in case
        a match has been found, a regex substitution `suggestion` for a found
        bad pattern, and a severity `level`.
        """
        self.regex = regex
        self.message = message
        self.extensions = extensions
        self.suggestion = suggestion
        self.level = level

    def to_comment(self, filename: str, line_number: int, suggestion: str) -> str:
        """
        Turns this bad pattern match into a string containing the following
        components, separated by newlines:
        Filename of matched file, line number where match occurred,
        set level, set message, substituted suggestion (may be empty),
        set regular expression,
        """
        return (
            f"{filename}\n{line_number}\n{self.level.value}\n{self.message}\n"
            + f"{suggestion}\n{self.regex.pattern if self.regex is not None else '(No regex specified)'}"
        )


# Special case for missing newline at end of file, as this can't be detected on a per-line basis.
NO_NEWLINE_BAD_PATTERN = BadPattern(
    None,
    "Missing newline at end of file! Files should always end with a single newline character.",
    level=Level.ERROR,
    suggestion=r"\n",
)

# *** MODIFY BELOW TO ADD NEW BAD PATTERNS ***

BAD_PATTERNS = [
    BadPattern(
        re.compile(r"^(.*(?<!= )new \w*NetAction\w*\([^()]*\))([^.].*)$"),
        "Don't forget to call `.Execute()` on newly created net actions!",
        suggestion=r"\1.Execute()\2",
        level=Level.ERROR,
    ),
    BadPattern(
        re.compile(r"(^\s*ActionManifestFileRelativeFilePath: StreamingAssets)\/SteamVR\/actions\.json(\s*)$"),
        """Slashes were unnecessarily changed to forward slashes.
This happens on Linux systems automatically, but Windows systems will change this back.
We should just leave it as a backslash.""",
        suggestion=r"\1\SteamVR\actions.json\2",
        extensions=["asset"],
        level=Level.WARN
    ),
    BadPattern(
        re.compile(r"^\s*(\s|Object\.)Destroy\(.*$"),
        "Make sure to use `Destroyer.Destroy` (`Destroyer` class is in `SEE.Utils`) instead of `Object.Destroy`!",
        level=Level.WARN
    ),
    BadPattern(
        # For trailing whitespace
        re.compile(r"^(.*\S)?\s+$"),
        "Trailing whitespace detected! Please remove it.",
        level=Level.WARN,
        suggestion=r"\1"
    )
]

# *** MODIFY ABOVE TO ADD NEW BAD PATTERNS ***


def handle_added_line(line, filename, linenumber) -> int:
    """
    Handles a single added line within a diff hunk, checking it against
    any bad patterns, printing comments for any matches it finds.
    """
    extension = filename.rsplit(".", 1)[1] if "." in filename else ""
    occurrences = 0
    for pattern in BAD_PATTERNS:
        if extension in pattern.extensions and pattern.regex.match(line):
            # We found a bad pattern.
            occurrences += 1
            # Try getting suggestion, if one exists.
            if pattern.suggestion:
                suggestion = pattern.regex.sub(pattern.suggestion, line)
            else:
                suggestion = ""
            print(pattern.to_comment(filename, linenumber, suggestion))
    return occurrences


def warn(message):
    """
    Prints a warning message to stderr.
    """
    print(f"::warning::{message}", file=sys.stderr)


def handle_missing_newline(filename: str, linenumber: int, last_line: str):
    """
    Handles a missing newline at the end of a file.
    :param filename: The name of the file.
    :param linenumber: The line number of the last line in the file.
    """
    print(NO_NEWLINE_BAD_PATTERN.to_comment(filename, linenumber, f"{last_line[1:] if last_line is not None else ''}\\n"))


def main():
    occurrences = 0
    with fileinput.input() as diff:
        filename = None
        diff_line = 0  # Current line number within a diff hunk.
        last_line = None  # Last line read.
        hunk_indicator = re.compile(r"^@@ -\d+(?:,\d+)? \+(\d+)(?:,(\d+))? @@.*$")
        missing_newline_at_eof = False
        while line := diff.readline().rstrip('\n\r'):
            if line.startswith("+++"):
                # New file here.

                if missing_newline_at_eof:
                    handle_missing_newline(filename, diff_line-1, last_line)
                    missing_newline_at_eof = False

                filename = line.split("/", 1)[1]
            elif line.startswith("@@"):
                # New diff hunk here.

                if missing_newline_at_eof:
                    handle_missing_newline(filename, diff_line, last_line)
                    missing_newline_at_eof = False

                m = hunk_indicator.match(line)
                if not m:
                    warn(f"Invalid unified diff hunk in {filename}: {line}")
                    # Nonetheless, this is not a fatal error, so we can continue.
                    continue
                diff_line = int(m.group(1))  # Next line is starting line indicated by this line range
            elif line.startswith("+"):
                # This is an actual added line within the hunk denoted by start_line.
                assert filename is not None
                # We skip the leading "+" character.
                occurrences += handle_added_line(line[1:], filename, diff_line)
                diff_line += 1
                last_line = line
                # We need to reset this flag. There were still added lines after the missing newline warning,
                # so it applied to the version of the file before it was changed and can be ignored.
                missing_newline_at_eof = False
            elif line.startswith(" "):
                # Lines starting with ' ' are just for context.
                diff_line += 1
                last_line = line
            # \ no newline at end of file
            elif line.startswith("\\ No newline at end of file"):
                # We can't report this immediately, as this string may occur twice.
                # Instead, we will report this once the next file / hunk starts.
                missing_newline_at_eof = True
            elif line != "" and line[0] not in ("-", "d", "i"):
                # We ignore empty lines, removed lines, and diff metadata lines (starting with "diff" or "index").
                warn(f'Unrecognized unified diff line indicator for line "{line}", skipping.')

        if missing_newline_at_eof:
            handle_missing_newline(filename, diff_line, last_line)

    sys.exit(min(occurrences, 255))


if __name__ == "__main__":
    main()
